diff --git a/arch/mips/Kbuild.platforms b/arch/mips/Kbuild.platforms
index a13c4cf6e..0ee0abb31 100644
--- a/arch/mips/Kbuild.platforms
+++ b/arch/mips/Kbuild.platforms
@@ -38,6 +38,7 @@ platform-$(CONFIG_SNI_RM)		+= sni/
 platform-$(CONFIG_MACH_TX39XX)		+= txx9/
 platform-$(CONFIG_MACH_TX49XX)		+= txx9/
 platform-$(CONFIG_MACH_VR41XX)		+= vr41xx/
+platform-$(CONFIG_TC3262)		+= tc3162/
 
 # include the platform specific files
 include $(patsubst %, $(srctree)/arch/mips/%/Platform, $(platform-y))
diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 8f328298f..d085c11f2 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -620,6 +620,31 @@ config RALINK
 	select ARCH_HAS_RESET_CONTROLLER
 	select RESET_CONTROLLER
 
+config MIPS_TC3262
+	bool "TrendChip's TC3262 Board"
+	select CPU_MIPSR2_IRQ_VI
+	select CPU_MIPSR2_IRQ_EI
+	select NO_EXCEPT_FILL
+	select BOOT_RAW
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	# select HW_HAS_PCI
+	# select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_CPU_MIPS64_R1
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_MULTITHREADING
+	# select TC3162_IMEM
+	# select TC3162_DMEM
+	help
+	  Support for TrendChip's TC3262 based board.
+
 config SGI_IP22
 	bool "SGI IP22 (Indy/Indigo2)"
 	select ARC_MEMORY
diff --git a/arch/mips/include/asm/cpu.h b/arch/mips/include/asm/cpu.h
index 388a82f28..311c776fb 100644
--- a/arch/mips/include/asm/cpu.h
+++ b/arch/mips/include/asm/cpu.h
@@ -96,6 +96,8 @@
 #define PRID_IMP_LOONGSON_64C	0x6300  /* Classic Loongson-2 and Loongson-3 */
 #define PRID_IMP_LOONGSON_64G	0xc000  /* Generic Loongson-2 and Loongson-3 */
 
+#define PRID_IMP_TC3162		0xcd00
+
 #define PRID_IMP_UNKNOWN	0xff00
 
 /*
diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index 4ddc12e44..61fc31cc8 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -133,6 +133,26 @@
  */
 #define CP0_TX39_CACHE	$7
 
+/*
+ * TrendChip cache control register
+ */
+#define CP0_CCTL 		$20		/* Lexra Cache Control Register */
+
+/*
+ * Lexra Cache Control Register fields
+ */
+#define CCTL_DINVAL	   	0x00000001
+#define CCTL_IINVAL		0x00000002
+#define CCTL_ILOCK		0x0000000c
+#define CCTL_IRAMFILL4 	0x00000010
+#define CCTL_IRAMOFF	0x00000020
+
+#define CCTL_IMEMFILL4 	0x00000010
+#define CCTL_IMEMOFF	0x00000020
+#define CCTL_DWB		0x00000100
+#define CCTL_DWBINVAL	0x00000200
+#define CCTL_DMEMON 	0x00000400
+#define CCTL_DMEMOFF 	0x00000800
 
 /* Generic EntryLo bit definitions */
 #define ENTRYLO_G		(_ULCAST_(1) << 0)
@@ -1645,6 +1665,10 @@ do {									\
 	: "Jr" (value), "i" (sel));					\
 } while (0)
 
+/* TrendChip cache control register */
+#define read_c0_cctl()		__read_32bit_c0_register($20, 0)
+#define write_c0_cctl(val)	__write_32bit_c0_register($20, 0, val)
+
 #define read_c0_index()		__read_32bit_c0_register($0, 0)
 #define write_c0_index(val)	__write_32bit_c0_register($0, 0, val)
 
@@ -1902,6 +1926,9 @@ do {									\
 #define read_c0_taglo()		__read_32bit_c0_register($28, 0)
 #define write_c0_taglo(val)	__write_32bit_c0_register($28, 0, val)
 
+#define read_c0_idatalo()		__read_32bit_c0_register($28, 1)
+#define write_c0_idatalo(val)	__write_32bit_c0_register($28, 1, val)
+
 #define read_c0_dtaglo()	__read_32bit_c0_register($28, 2)
 #define write_c0_dtaglo(val)	__write_32bit_c0_register($28, 2, val)
 
@@ -1914,6 +1941,9 @@ do {									\
 #define read_c0_taghi()		__read_32bit_c0_register($29, 0)
 #define write_c0_taghi(val)	__write_32bit_c0_register($29, 0, val)
 
+#define read_c0_idatahi()		__read_32bit_c0_register($29, 1)
+#define write_c0_idatahi(val)	__write_32bit_c0_register($29, 1, val)
+
 #define read_c0_errorepc()	__read_ulong_c0_register($30, 0)
 #define write_c0_errorepc(val)	__write_ulong_c0_register($30, 0, val)
 
diff --git a/arch/mips/include/asm/pgtable-32.h b/arch/mips/include/asm/pgtable-32.h
index a950fc1dd..7a8c25b25 100644
--- a/arch/mips/include/asm/pgtable-32.h
+++ b/arch/mips/include/asm/pgtable-32.h
@@ -206,7 +206,7 @@ static inline pte_t pfn_pte(unsigned long pfn, pgprot_t prot)
 
 #else
 
-#if defined(CONFIG_XPA)
+#if defined(CONFIG_XPA) || defined(CONFIG_CPU_TC3162)
 
 /* Swap entries must have VALID and GLOBAL bits cleared. */
 #define __swp_type(x)			(((x).val >> 4) & 0x1f)
diff --git a/arch/mips/include/asm/tc3162/cpu-feature-overrides.h b/arch/mips/include/asm/tc3162/cpu-feature-overrides.h
new file mode 100644
index 000000000..16b5c2729
--- /dev/null
+++ b/arch/mips/include/asm/tc3162/cpu-feature-overrides.h
@@ -0,0 +1,68 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003, 2004 Chris Dearman
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
+ */
+#ifndef __ASM_MACH_RALINK_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_RALINK_CPU_FEATURE_OVERRIDES_H
+
+
+/*
+ * CPU feature overrides for MIPS boards
+ */
+#ifdef CONFIG_CPU_MIPS32
+#define cpu_has_tlb		1
+#define cpu_has_4kex		1
+#define cpu_has_4k_cache	1
+/* #define cpu_has_fpu		? */
+/* #define cpu_has_32fpr	? */
+#define cpu_has_counter		1
+/* #define cpu_has_watch	? */
+#define cpu_has_divec		1
+#define cpu_has_vce		0
+/* #define cpu_has_cache_cdex_p	? */
+/* #define cpu_has_cache_cdex_s	? */
+/* #define cpu_has_prefetch	? */
+#define cpu_has_mcheck		1
+/* #define cpu_has_ejtag	? */
+#define cpu_has_llsc		1
+/* #define cpu_has_vtag_icache	? */
+/* #define cpu_has_dc_aliases	? */
+/* #define cpu_has_ic_fills_f_dc ? */
+#define cpu_has_nofpuex		0
+/* #define cpu_has_64bits	? */
+/* #define cpu_has_64bit_zero_reg ? */
+/* #define cpu_has_inclusive_pcaches ? */
+#define cpu_icache_snoops_remote_store 1
+#endif
+
+#ifdef CONFIG_CPU_MIPS64
+#define cpu_has_tlb		1
+#define cpu_has_4kex		1
+#define cpu_has_4k_cache	1
+/* #define cpu_has_fpu		? */
+/* #define cpu_has_32fpr	? */
+#define cpu_has_counter		1
+/* #define cpu_has_watch	? */
+#define cpu_has_divec		1
+#define cpu_has_vce		0
+/* #define cpu_has_cache_cdex_p	? */
+/* #define cpu_has_cache_cdex_s	? */
+/* #define cpu_has_prefetch	? */
+#define cpu_has_mcheck		1
+/* #define cpu_has_ejtag	? */
+#define cpu_has_llsc		1
+/* #define cpu_has_vtag_icache	? */
+/* #define cpu_has_dc_aliases	? */
+/* #define cpu_has_ic_fills_f_dc ? */
+#define cpu_has_nofpuex		0
+/* #define cpu_has_64bits	? */
+/* #define cpu_has_64bit_zero_reg ? */
+/* #define cpu_has_inclusive_pcaches ? */
+#define cpu_icache_snoops_remote_store 1
+#endif
+
+#endif /* __ASM_MACH_MIPS_CPU_FEATURE_OVERRIDES_H */
diff --git a/arch/mips/include/asm/tc3162/int_source.h b/arch/mips/include/asm/tc3162/int_source.h
new file mode 100644
index 000000000..7b32e909f
--- /dev/null
+++ b/arch/mips/include/asm/tc3162/int_source.h
@@ -0,0 +1,101 @@
+/************************************************************************
+ *
+ *	Copyright (C) 2006 Trendchip Technologies, Corp.
+ *	All Rights Reserved.
+ *
+ * Trendchip Confidential; Need to Know only.
+ * Protected as an unpublished work.
+ *
+ * The computer program listings, specifications and documentation
+ * herein are the property of Trendchip Technologies, Co. and shall
+ * not be reproduced, copied, disclosed, or used in whole or in part
+ * for any reason without the prior express written permission of
+ * Trendchip Technologeis, Co.
+ *
+ *************************************************************************/
+
+#ifndef _INT_SOURCE_H_
+#define _INT_SOURCE_H_
+
+enum
+interrupt_source
+	{
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		DUMMY_INT,
+#endif
+		UART_INT,		//0 	IPL10
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		PTM_B0_INT,		//1
+		SI_SWINT1_INT0,	//2
+		SI_SWINT1_INT1,	//3
+#else
+		RTC_ALARM_INT,	//1 	IPL29
+		RTC_TICK_INT,	//2 	IPL31
+		RESERVED0,		//3 	IPL30
+#endif
+		TIMER0_INT, 	//4 	IPL1
+		TIMER1_INT, 	//5 	IPL5
+		TIMER2_INT, 	//6 	IPL6
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		SI_SWINT_INT0, 	//7
+		SI_SWINT_INT1, 	//8
+#else
+		TIMER3_INT, 	//7 	IPL7
+		TIMER4_INT, 	//8 	IPL8
+#endif
+		TIMER5_INT, 	//9 	IPL9
+		GPIO_INT,		//10	IPL11
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		RESERVED1,		//11	IPL20
+		SI_PC1_INT, 	//12
+		SI_PC_INT, 		//13
+#else
+		PCIE_A_INT,		//11	IPL20
+		PCIE_SERR_INT,	//12	IPL21
+		RESERVED3,		//13	IPL22
+#endif
+		APB_DMA0_INT,	//14	IPL12
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		MAC1_INT,		//15	IPL13
+#else
+		APB_DMA1_INT,	//15	IPL13
+#endif
+		HSUART_INT,		//16	IPL23
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+
+		PTM_B1_INT,		//17
+#else
+		RESERVED5,		//17	IPL24
+#endif
+		DYINGGASP_INT,	//18	IPL25
+		DMT_INT,		//19	IPL26
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		USB20_INT,
+#else
+		ARBITER_ERR_INT,//20	IPL0
+#endif
+		MAC_INT,		//21	IPL3
+		SAR_INT,		//22	IPL2
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		USB11_INT,
+#else
+		USB_INT,		//23	IPL14
+#endif
+		PCI_A_INT,		//24
+		PCI_B_INT,		//25
+//		  RESERVED8,	  //24	  IPL27
+//		  RESERVED9,	  //25	  IPL28
+		XSLV0_INT,		//26	IPL15
+		XSLV1_INT,		//27	IPL16
+		XSLV2_INT,		//28	IPL17
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		SI_TIMER1_INT,	//29
+		SI_TIMER_INT,	//30
+#else
+		XAPB0_INT,		//29	IPL18
+		XAPB1_INT,		//30	IPL19
+#endif
+		SWR_INT 		//31	IPL4
+	};
+
+#endif /* _INT_SOURCE_H_ */
diff --git a/arch/mips/include/asm/tc3162/irq.h b/arch/mips/include/asm/tc3162/irq.h
new file mode 100644
index 000000000..2768f1afe
--- /dev/null
+++ b/arch/mips/include/asm/tc3162/irq.h
@@ -0,0 +1,13 @@
+#ifndef __ASM_MACH_MIPS_IRQ_H
+#define __ASM_MACH_MIPS_IRQ_H
+
+
+#ifdef CONFIG_MIPS_TC3262
+#define NR_IRQS 64
+#else
+#define NR_IRQS 32
+#endif
+
+#include_next <irq.h>
+
+#endif /* __ASM_MACH_MIPS_IRQ_H */
diff --git a/arch/mips/include/asm/tc3162/tc3162.h b/arch/mips/include/asm/tc3162/tc3162.h
new file mode 100644
index 000000000..810d008d7
--- /dev/null
+++ b/arch/mips/include/asm/tc3162/tc3162.h
@@ -0,0 +1,1329 @@
+/*
+** $Id: tc3162.h,v 1.7 2011/01/07 06:05:58 pork Exp $
+*/
+/************************************************************************
+ *
+ *	Copyright (C) 2006 Trendchip Technologies, Corp.
+ *	All Rights Reserved.
+ *
+ * Trendchip Confidential; Need to Know only.
+ * Protected as an unpublished work.
+ *
+ * The computer program listings, specifications and documentation
+ * herein are the property of Trendchip Technologies, Co. and shall
+ * not be reproduced, copied, disclosed, or used in whole or in part
+ * for any reason without the prior express written permission of
+ * Trendchip Technologeis, Co.
+ *
+ *************************************************************************/
+/*
+** $Log: tc3162.h,v $
+** Revision 1.7  2011/01/07 06:05:58  pork
+** add the definition of INT!16,INT32,SINT15,SINT7
+**
+** Revision 1.6  2010/09/20 07:08:02  shnwind
+** decrease nf_conntrack buffer size
+**
+** Revision 1.5  2010/09/03 16:43:07  here
+** [Ehance] TC3182 GMAC Driver is support TC-Console & WAN2LAN function & update the tc3182 dmt version (3.12.8.83)
+**
+** Revision 1.4  2010/09/02 07:04:50  here
+** [Ehance] Support TC3162U/TC3182 Auto-Bench
+**
+** Revision 1.3  2010/08/30 07:53:02  lino
+** add power saving mode kernel module support
+**
+** Revision 1.2  2010/06/05 05:40:29  lino
+** add tc3182 asic board support
+**
+** Revision 1.1.1.1  2010/04/09 09:39:21  feiyan
+** New TC Linux Make Flow Trunk
+**
+** Revision 1.4  2010/01/14 10:56:42  shnwind
+** recommit
+**
+** Revision 1.3  2010/01/14 08:00:10  shnwind
+** add TC3182 support
+**
+** Revision 1.2  2010/01/10 15:27:26  here
+** [Ehancement]TC3162U MAC EEE is operated at 100M-FD, SAR interface is accroding the SAR_CLK to calculate atm rate.
+**
+** Revision 1.1.1.1  2009/12/17 01:42:47  josephxu
+** 20091217, from Hinchu ,with VoIP
+**
+** Revision 1.2  2006/07/06 07:24:57  lino
+** update copyright year
+**
+** Revision 1.1.1.1  2005/11/02 05:45:38  lino
+** no message
+**
+** Revision 1.5  2005/09/27 08:01:38  bread.hsu
+** adding IMEM support for Tc3162L2
+**
+** Revision 1.4  2005/09/14 11:06:20  bread.hsu
+** new definition for TC3162L2
+**
+** Revision 1.3  2005/06/17 16:26:16  jasonlin
+** Remove redundant code to gain extra 100K bytes free memory.
+** Add "CODE_REDUCTION" definition to switch
+**
+** Revision 1.2  2005/06/14 10:02:01  jasonlin
+** Merge TC3162L2 source code into new main trunk
+**
+** Revision 1.1.1.1  2005/03/30 14:04:22  jasonlin
+** Import Linos source code
+**
+** Revision 1.4  2004/11/15 03:43:17  lino
+** rename ATM SAR max packet length register
+**
+** Revision 1.3  2004/09/01 13:15:47  lino
+** fixed when pc shutdown, system will reboot
+**
+** Revision 1.2  2004/08/27 12:16:37  lino
+** change SYS_HCLK to 96Mhz
+**
+** Revision 1.1  2004/07/02 08:03:04  lino
+** tc3160 and tc3162 code merge
+**
+*/
+
+#ifndef _TC3162_H_
+#define _TC3162_H_
+
+#ifdef CONFIG_MIPS_TC3262 
+#include "./tc3182_int_source.h"
+#else
+#include "./int_source.h" /*shnwind add*/
+#endif
+
+
+#ifndef INT32
+#define INT32
+typedef signed long int int32;    		/* 32-bit signed integer        */
+#endif
+
+#ifndef SINT31
+#define SINT31
+typedef signed long int sint31;        	/* 32-bit signed integer        */
+#endif
+
+#ifndef UINT32
+#define UINT32
+typedef unsigned long int uint32; 		/* 32-bit unsigned integer      */
+#endif
+
+#ifndef SINT15
+#define SINT15
+typedef signed short sint15;            /* 16-bit signed integer        */
+#endif
+
+#ifndef INT16
+#define INT16
+typedef signed short int int16;         /* 16-bit signed integer        */
+#endif
+
+#ifndef UINT16
+#define UINT16
+typedef unsigned short uint16;          /* 16-bit unsigned integer      */
+#endif
+
+#ifndef SINT7
+#define SINT7
+typedef signed char sint7;              /* 8-bit signed integer         */
+#endif
+
+
+#ifndef UINT8
+#define UINT8
+typedef unsigned char uint8;            /* 8-bit unsigned integer       */
+#endif
+
+#ifndef VPint
+#define VPint			*(volatile unsigned long int *)
+#endif
+#ifndef VPshort
+#define VPshort			*(volatile unsigned short *)
+#endif
+#ifndef VPchar
+#define VPchar			*(volatile unsigned char *)
+#endif
+#ifdef TCSUPPORT_MT7510_E1
+static inline unsigned long int regRead32(uint32 reg)	\
+{       						\
+	uint32 tmp;					\
+	tmp = VPint((reg & 0xf) + 0xbfb003a0);   	\
+	__asm__ __volatile("sync");			\
+	tmp = VPint(reg);				\
+	__asm__ __volatile("sync");			\
+        return tmp;             	           	\
+}
+static inline void regWrite32(uint32 reg, uint32 vlaue) \
+{                                                       \
+        VPint(reg) = vlaue;                             \
+	__asm__ __volatile("sync");			\
+}
+
+#else
+static inline uint32 regRead32(uint32 reg)		\
+{						  	\
+	return VPint(reg);			  	\
+}		
+static inline void regWrite32(uint32 reg, uint32 vlaue)	\
+{                                                	\
+        VPint(reg) = vlaue;                      	\
+}
+#endif
+static inline unsigned long int regReadPhy32(uint32 reg)	\
+{       						\
+	uint32 tmp;					\
+	tmp = VPint(reg);	  	\
+	tmp = VPint(reg);				\
+        return tmp;             	           	\
+}
+
+#ifdef CONFIG_CPU_TC3162
+#define TC3162L2		1
+#endif
+
+#define isTC3162L2P2 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)!=0)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L3P3 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==7)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L4P4 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==8)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L5P5E2 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==0xa)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L5P5E3 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==0xb)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L5P5 (isTC3162L5P5E2 || isTC3162L5P5E3)
+#define isTC3162U ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==0x10)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isRT63260 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==0x20)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+
+#define isTC3169 	(((regRead32(0xbfb00064)&0xffff0000))==0x00000000)
+#define isTC3182 	(((regRead32(0xbfb00064)&0xffff0000))==0x00010000)
+#define isRT65168 	(((regRead32(0xbfb00064)&0xffff0000))==0x00020000)
+#define isRT63165 	(((regRead32(0xbfb00064)&0xffff0000))==0x00030000)
+#define isRT63365 	(((regRead32(0xbfb00064)&0xffff0000))==0x00040000)
+#define isRT63368   (isRT63365 ? ((((regRead32(0xbfb0008c)>>8) & 0x3) == 0x3) ? 1 : 0): 0)
+#define isRT62806   (((gswPbusRead(0x7ffc))&0xffff0000)==0x28060000)
+
+#define isENP_MOD	(((regRead32(0xBFBF8214)&0x8)==0x8)?(((regRead32(0xBFBF8214)&0x20)==0x20)?1:0):(((regRead32(0xBFBF8214)&0x2)==0x2)?1:0))
+#define isENS_MOD	(((regRead32(0xBFBF8214)&0x8)==0x8)?((regRead32(0xBFBF8214)&0x40)==0x40):((regRead32(0xBFBF8214)&0x4)==0x4))
+#define isMT751020 	(((regRead32(0xbfb00064)&0xffff0000))==0x00050000)
+#define isMT7505 	(((regRead32(0xbfb00064)&0xffff0000))==0x00060000)
+#define isEN751221 	(((VPint(0xbfb00064)&0xffff0000))==0x00070000)
+#define isMT7510	(isMT751020 && ((regRead32(0xbfb000f8)&0x3)==0) && (isENP_MOD))
+#define isMT7511	(isMT751020 && ((regRead32(0xbfb000f8)&0x3)==0)&& (!isENP_MOD))
+#define isMT7520	(((regRead32(0xbfb000f8)&0x3)==0x2) && isMT751020 && (isENP_MOD) && (!isENS_MOD))
+#define isMT7520G	(((regRead32(0xbfb000f8)&0x3)==0x3) && isMT751020 && (isENP_MOD))
+#define isMT7525	(((regRead32(0xbfb000f8)&0x3)==0x2) && isMT751020 && (!isENP_MOD) && (!isENS_MOD))
+#define isMT7525G	(((regRead32(0xbfb000f8)&0x3)==0x3) && isMT751020 && (!isENP_MOD))
+#define isMT7520S       (((regRead32(0xbfb000f8)&0x3)==0x2) && isMT751020 && (isENS_MOD))
+#define isMT7520E2E3 ((regRead32(0xbfb00064) & 0xFF) <= 0x2 && (isMT7520 || isMT7520G || isMT7525 || isMT7525G || isMT7520S))
+#define isEPONFWID   (((regRead32(0xbfb00064) & 0xF) == 0x3) && ((regRead32(0xbfb5fffc) & 0xF) >= 0x1) && (isMT7520 || isMT7520G || isMT7525 || isMT7525G || isMT7520S))
+
+
+#define isEN751221FPGA      ((regRead32(CR_AHB_HWCONF)&(1<<29)) ? 0 : 1) //used for 7512/7521
+#define isGenernalFPGA          ((regRead32(CR_AHB_HWCONF)&(1<<31)) ? 1 : 0) //used for 63365/751020
+#define isFPGA              0 //(isEN751221 ? isEN751221FPGA : isGenernalFPGA )
+
+#define EFUSE_VERIFY_DATA0 (0xBFBF8214)
+#define EFUSE_PKG_MASK          (0x3F)
+#define EFUSE_REMARK_BIT        (1<<6)
+
+#define EFUSE_PKG_REMARK_SHITF 7
+
+#define EFUSE_EN7526F   (0x0)
+#define EFUSE_EN7521F   (0x10)
+#define EFUSE_EN7521S   (0x20)
+#define EFUSE_EN7512    (0x4)
+#define EFUSE_EN7526D   (0x1)
+#define EFUSE_EN7513    (0x5)
+#define EFUSE_EN7526G   (0x2)
+#define EFUSE_EN7521G   (0x12)
+#define EFUSE_EN7513G   (0x6)
+#define EFUSE_EN7586    (0xA)
+#define EFUSE_EN7586    (0xA)
+
+#define isEN7526F (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7526F): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7526F)))
+#define isEN7521F (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7521F): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7521F)))
+#define isEN7521S (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7521S): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7521S)))
+#define isEN7512 (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7512): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7512)))
+#define isEN7526D (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7526D): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7526D)))
+#define isEN7513 (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7513): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7513)))
+#define isEN7526G (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7526G): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7526G)))
+#define isEN7521G (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7521G): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7521G)))
+#define isEN7513G (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7513G): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7513G)))
+#define isEN7586 (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7586): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7586)))
+
+#define EFUSE_DDR3_BIT (1<<23)
+#define EFUSE_DDR3_REMARK_BIT (1<<24)
+#define EFUSE_IS_DDR3 ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        ((regRead32(EFUSE_VERIFY_DATA0)& EFUSE_DDR3_REMARK_BIT)): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)& EFUSE_DDR3_BIT)))
+
+#define REG_SAVE_INFO 0xBFB00284
+#define SET_DRAM_SIZE(x) regWrite32(REG_SAVE_INFO ,((regRead32(REG_SAVE_INFO)&(~0xfff)) | (x&0xfff)))
+#define GET_DRAM_SIZE   (regRead32(REG_SAVE_INFO)&0xfff)
+#define SET_SYS_CLK(x)  regWrite32(REG_SAVE_INFO ,((regRead32(REG_SAVE_INFO)&~0xfff000) | ((x&0xfff)<<12)))
+#define GET_SYS_CLK     ((regRead32(REG_SAVE_INFO)&0xfff000)>>12)
+
+
+
+
+#ifdef TCSUPPORT_MT7510_E1
+#define READ_E1(x) do{if (VPint(x) == 0)printk("Error Reg %x\n",x);}while(0)
+#endif
+
+#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520)
+#define JUDGE_SWITCH_SCENARIO_BY_751020_SUBMODEL
+#ifdef JUDGE_SWITCH_SCENARIO_BY_751020_SUBMODEL
+#define MT751020_SUBMODEL_REG   (0xbfb000f8)
+
+#define ExistExtMT7530		(isMT7520G || isMT7525G)
+#define DefaultUseExtMT7530	(isMT7520G || isMT7525G)
+#define LanPortIntMT7530	(isMT7510 || isMT7511 || isMT7520 || isMT7525)
+#define LanPortExtMT7530	(isMT7520G || isMT7525G)
+#endif
+#endif
+
+#define isMT7530	(((regRead32(0xbfb58000+0x7ffc)&0xffff0000))==0x75300000)
+//#define isMT7530FPGA	(((gswPbusRead(0x7ffc))&0xffff0000)==0x75300000)
+#define isMT7530ext	(((gswPbusRead(0x7ffc))&0xffff0000)==0x75300000)
+
+#ifdef TC3162L2
+#define RT63260_SYS_HCLK ((12*(((regRead32(0xbfb000b0))&0x1ff)+1)/(((regRead32(0xbfb000b0)>>9)&0x1f)+1))/5)
+#define TC3162U_SYS_HCLK (3*(((regRead32(0xbfb000b0)>>16)&0x1ff)+1)/(((regRead32(0xbfb000b0)>>25)&0x1f)+1))
+#define SYS_HCLK        (isRT63260 ? RT63260_SYS_HCLK : (isTC3162U ? TC3162U_SYS_HCLK : 133))
+#endif
+
+#ifdef CONFIG_MIPS_TC3262
+/* RT63165 ASIC */
+/* FPGA is 25Mhz, ASIC LQFP128 is 166.67Mhz, others are 200Mhz */
+#define	RT63165_SYS_HCLK       	(regRead32(0xbfb0008c)&(1<<31) ? 25 : (regRead32(0xbfb0008c)&(1<<9) ? (200) : (16667/100)))
+/* RT63365 ASIC */
+/* FPGA is 25/32Mhz 
+ * ASIC RT6856/RT63368: DDR(0): 233.33, DDR(1): 175, SDR: 140
+ *      RT6855/RT63365: DDR(0): 166.67, DDR(1): 125, SDR: 140 */
+#define	RT63365_SYS_HCLK       	(regRead32(0xbfb0008c)&(1<<31) ? (25) : (regRead32(0xbfb0008c)&(1<<9) ? (regRead32(0xbfb0008c)&(1<<25) ? (regRead32(0xbfb0008c)&(1<<26) ? (175) : (23333/100)) : (140)) : (regRead32(0xbfb0008c)&(1<<25) ? (regRead32(0xbfb0008c)&(1<<26) ? (125) : (16667/100)) : (140))))
+#define MT751020_CPU_CLK		(((regRead32(0xbfb0008c) >> 0x9) & 0x3) == 0x0) ? (750) : (((regRead32(0xbfb0008c) >> 0x9) & 0x3) == 0x1) ? (650) : (((regRead32(0xbfb0008c) >> 0x9) & 0x3) == 0x2) ? (500) : (250)
+#define	MT751020_SYS_HCLK		((regRead32(0xbfb0008c)&(1<<31)) ? (32) : ((((MT751020_CPU_CLK)* 100) / ((regRead32(0xbfb000f8) >> 0x3) & 0x7)) / 100))
+#define	MT7505_SYS_HCLK		((regRead32(0xbfb0008c)&(1<<31)) ? (32) : (135))  //MT7505 CPU clock is 540
+#define EN7512_SYS_HCLK         ((isFPGA) ? (32) : (GET_SYS_CLK)) //ASIC Clock need Check
+
+#define	SYS_HCLK		(isEN751221?EN7512_SYS_HCLK:(isMT7505? MT7505_SYS_HCLK:(isMT751020  ? MT751020_SYS_HCLK : (isRT63365 ? RT63365_SYS_HCLK : (isRT63165 ? RT63165_SYS_HCLK : (isRT65168 ? (1024/10) : (isTC3182 ? (1024/10) : (3*((VPint(0xbfb00058)>>16)+1)/(((VPint(0xbfb00058)&0x1f)+1)<<1)))))))))
+#endif
+
+#define	SAR_CLK	(SYS_HCLK)/(4.0)		//more accurate if 4.0 not 4
+
+/* define CPU timer clock, FPGA is 50Mhz, ASIC is 250Mhz */
+#define	CPUTMR_CLK		(isFPGA ? (50*1000000) : (isEN751221 ? (200*1000000) : (isMT7505 ? (100*1000000) : (isMT751020 ? (800*1000000/3) :(250*1000000)))))
+
+#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520)
+#define DSPRAM_BASE		0x9dff8000
+#else
+#define DSPRAM_BASE		0x9c000000
+#endif
+
+#define ENABLE          1
+#define DISABLE         0
+
+#define WAN2LAN_CH_ID	(1<<31)
+
+#define tc_inb(offset) 			(*(volatile unsigned char *)(offset))
+#define tc_inw(offset) 			(*(volatile unsigned short *)(offset))
+#define tc_inl(offset) 			(*(volatile unsigned long *)(offset))
+
+#define tc_outb(offset,val)    	(*(volatile unsigned char *)(offset) = val)
+#define tc_outw(offset,val)    	(*(volatile unsigned short *)(offset) = val)
+#define tc_outl(offset,val)    	(*(volatile unsigned long *)(offset) = val)
+
+#if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+#define IS_SPIFLASH		((~(VPint(0xBFA10114))) & 0x2)
+#define IS_NANDFLASH		(VPint(0xBFA10114) & 0x2)
+#else
+#if defined(TCSUPPORT_CPU_MT7505)
+#define IS_SPIFLASH		1
+#define IS_NANDFLASH	0
+#else
+#define IS_SPIFLASH				((regRead32(CR_AHB_SSR) & (1<<20)) || !(regRead32(CR_AHB_HWCONF) & 0x1))
+#define IS_NANDFLASH			(regRead32(CR_AHB_HWCONF) & 0x1)
+#endif
+#endif
+#define NF_CONNTRACK_BUF_SIZE 4096
+/*****************************
+ * RBUS CORE Module Registers *
+ *****************************/
+#define ARB_CFG     		0xBFA00008
+#define ROUND_ROBIN_ENABLE  (1<<30)
+#define ROUND_ROBIN_DISBALE  ~(1<<30)
+
+
+
+/*****************************
+ * DMC Module Registers *
+ *****************************/
+
+#define CR_DMC_BASE     	0xBFB20000
+#define CR_DMC_SRT      	(0x00 | CR_DMC_BASE)
+#define CR_DMC_STC      	(0x01 | CR_DMC_BASE)
+#define CR_DMC_SAMT      	(0x02 | CR_DMC_BASE)
+#define CR_DMC_SCR      	(0x03 | CR_DMC_BASE)
+
+/* RT63165 specific */
+/* DDR self refresh control register */
+#define CR_DMC_DDR_SR    	(0x18 | CR_DMC_BASE)
+/* DDR self refresh target count */
+#define CR_DMC_DDR_SR_CNT  	(0x1c | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG0    	(0x40 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG1    	(0x44 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG2    	(0x48 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG3    	(0x4c | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG4    	(0x50 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG8    	(0x60 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG9    	(0x64 | CR_DMC_BASE)
+
+#define CR_DMC_CTL0      	(0x70 | CR_DMC_BASE)
+#define CR_DMC_CTL1      	(0x74 | CR_DMC_BASE)
+#define CR_DMC_CTL2      	(0x78 | CR_DMC_BASE)
+#define CR_DMC_CTL3     	(0x7c | CR_DMC_BASE)
+#define CR_DMC_CTL4     	(0x80 | CR_DMC_BASE)
+
+#define CR_DMC_DCSR     	(0xb0 | CR_DMC_BASE)
+
+#define CR_DMC_ISPCFGR     	(0xc0 | CR_DMC_BASE)
+#define CR_DMC_DSPCFGR     	(0xc4 | CR_DMC_BASE)
+
+/* MT7510 */
+#define CR_DRAMC_CONF1		(0x04 | CR_DMC_BASE)
+#define CR_DRAMC_PADCTL4    (0xe4 | CR_DMC_BASE)
+
+/*****************************
+ * GDMA Module Registers *
+ *****************************/
+
+#define CR_GDMA_BASE     	0xBFB30000
+#define CR_GDMA_DCSA      	(0x00 | CR_GDMA_BASE)
+#define CR_GDMA_DCDA      	(0x04 | CR_GDMA_BASE)
+#define CR_GDMA_DCBT      	(0x08 | CR_GDMA_BASE)
+#define CR_GDMA_DCBL      	(0x0a | CR_GDMA_BASE)
+#define CR_GDMA_DCC      	(0x0c | CR_GDMA_BASE)
+#define CR_GDMA_DCS      	(0x0e | CR_GDMA_BASE)
+#define CR_GDMA_DCKSUM     	(0x10 | CR_GDMA_BASE)
+
+/*****************************
+ * SPI Module Registers *
+ *****************************/
+
+#define CR_SPI_BASE     	0xBFBC0000
+#define CR_SPI_CTL      	(0x00 | CR_SPI_BASE)
+#define CR_SPI_OPCODE      	(0x04 | CR_SPI_BASE)
+#define CR_SPI_DATA      	(0x08 | CR_SPI_BASE)
+
+/*****************************
+ * Ethernet Module Registers *
+ *****************************/
+
+#define CR_MAC_BASE     	0xBFB50000
+#define CR_MAC_ISR      	(0x00 | CR_MAC_BASE)// --- Interrupt Status Register ---
+#define CR_MAC_IMR      	(0x04 | CR_MAC_BASE)// --- Interrupt Mask Register ---
+#define CR_MAC_MADR  	   	(0x08 | CR_MAC_BASE)// --- MAC Address Register [47:32] ---
+#define CR_MAC_LADR     	(0x0c | CR_MAC_BASE)// --- MAC Address Register [31:0] ---
+#define CR_MAC_EEE		(0x10 | CR_MAC_BASE)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+// None
+#else
+  #define CR_MAC_MAHT0         (0x10 | CR_MAC_BASE)// --- MAC Hash Table Address Register [31:0] ---
+  #define CR_MAC_MAHT1         (0x14 | CR_MAC_BASE)// --- MAC Hash Table Address Register [31:0] ---
+#endif
+#define CR_MAC_TXPD     	(0x18 | CR_MAC_BASE)// --- Transmit Poll Demand Register ---
+#define CR_MAC_RXPD     	(0x1c | CR_MAC_BASE)// --- Receive Poll Demand Register ---
+#define CR_MAC_TXR_BADR 	(0x20 | CR_MAC_BASE)// --- Transmit Ring Base Address Register ---
+#define CR_MAC_RXR_BADR 	(0x24 | CR_MAC_BASE)// --- Receive Ring Base Address Register ---
+#define CR_MAC_ITC      	(0x28 | CR_MAC_BASE)// --- Interrupt Timer Control Register ---
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+  #define CR_MAC_TXR_SIZE  	   (0x2c | CR_MAC_BASE)// --- Transmit Ring Size Register ---
+  #define CR_MAC_RXR_SIZE      (0x30 | CR_MAC_BASE)// --- Receive Ring Size Register ---
+  #define CR_MAC_RXR_SWIDX     (0x34 | CR_MAC_BASE)// --- Receive Ring Software Index Register ---
+#else
+#define CR_MAC_APTC     	(0x2c | CR_MAC_BASE)// --- Automatic Polling Timer Control Register ---
+#define CR_MAC_DBLAC    	(0x30 | CR_MAC_BASE)// --- DMA Burst Length and Arbitration Control Register ---
+#endif
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+  #define CR_MAC_TXDESP_SIZE   (0x38 | CR_MAC_BASE)// --- Transmit Descriptor Size Register ---
+  #define CR_MAC_RXDESP_SIZE   (0x3c | CR_MAC_BASE)// --- Receive Descriptor Size Register ---
+#else
+  #define CR_MAC_TXDESCP_ADR   (0x38 | CR_MAC_BASE)// --- Current Transmit Descriptor Address Register ---
+  #define CR_MAC_RXDESCP_ADR   (0x3c | CR_MAC_BASE)// --- Current Receive Descriptor Address Register ---
+#endif
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+  #define CR_MAC_PRIORITY_CFG  (0x50 | CR_MAC_BASE)// --- Priority Configuration Register ---
+  #define CR_MAC_VLAN_CFG      (0x54 | CR_MAC_BASE)// --- VLAN Configuration Register ---
+  #define CR_MAC_TOS0_CFG      (0x58 | CR_MAC_BASE)// --- TOS 0 Configuration Register ---
+  #define CR_MAC_TOS1_CFG      (0x5c | CR_MAC_BASE)// --- TOS 1 Configuration Register ---
+  #define CR_MAC_TOS2_CFG      (0x60 | CR_MAC_BASE)// --- TOS 2 Configuration Register ---
+  #define CR_MAC_TOS3_CFG      (0x64 | CR_MAC_BASE)// --- TOS 3 Configuration Register ---
+  #define CR_MAC_TCP_CFG       (0x68 | CR_MAC_BASE)// --- TCP Configuration Register ---
+  #define CR_MAC_SWTAG_CFG     (0x6c | CR_MAC_BASE)// --- Software Tagging Configuration Register ---
+  #define CR_MAC_PMBL_CYC_NUM  (0x70 | CR_MAC_BASE)// --- Preamble Cycle Number Register ---
+  #define CR_MAC_FCTL_CYC_NUM  (0x74 | CR_MAC_BASE)// --- Flow Control Cycle Number Register ---
+  #define CR_MAC_JAM_CYC_NUM   (0x78 | CR_MAC_BASE)// --- JAM Cycle Number Register ---
+  #define CR_MAC_DEFER_VAL     (0x7c | CR_MAC_BASE)// --- Defer Value Register ---
+  #define CR_MAC_RANDOM_POLY   (0x80 | CR_MAC_BASE)// --- Random Polynomial Register ---
+#else
+// None
+#endif
+#define CR_MAC_MACCR    	(0x88 | CR_MAC_BASE)// --- MAC Control Register ---
+#define CR_MAC_MACSR    	(0x8c | CR_MAC_BASE)// --- MAC Status Register ---
+#define CR_MAC_PHYCR    	(0x90 | CR_MAC_BASE)// --- PHY Control Register ---
+#define CR_MAC_PHYWDATA 	(0x94 | CR_MAC_BASE)// --- PHY Write Data Register ---
+#define CR_MAC_FCR      	(0x98 | CR_MAC_BASE)// --- Flow Control Register ---
+#define CR_MAC_BPR      	(0x9c | CR_MAC_BASE)// --- Back Pressure Register ---
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define CR_MAC_DESP_IDX        (0xc4 | CR_MAC_BASE)// --- Current Tx/Rx Descriptor Index ---
+#endif
+#define CR_MAC_WOLCR    	(0xa0 | CR_MAC_BASE)// --- Wake-On-LAN Control Register ---
+#define CR_MAC_WOLSR    	(0xa4 | CR_MAC_BASE)// --- Wake-On-LAN Status Register ---
+#define CR_MAC_WFCRC    	(0xa8 | CR_MAC_BASE)// --- Wake-up Frame CRC Register ---
+#define CR_MAC_WFBM1    	(0xb0 | CR_MAC_BASE)// --- Wake-up Frame Byte Mask 1st Double Word Register ---
+#define CR_MAC_WFBM2    	(0xb4 | CR_MAC_BASE)// --- Wake-up Frame Byte Mask 2nd Double Word Register ---
+#define CR_MAC_WFBM3    	(0xb8 | CR_MAC_BASE)// --- Wake-up Frame Byte Mask 3rd Double Word Register ---
+#define CR_MAC_WFBM4    	(0xbc | CR_MAC_BASE)// --- Wake-up Frame Byte Mask 4th Double Word Register ---
+#define CR_MAC_DMA_FSM  	(0xc8 | CR_MAC_BASE)// --- DMA State Machine
+#define CR_MAC_TM       	(0xcc | CR_MAC_BASE)// --- Test Mode Register ---
+#define CR_MAC_XMPG_CNT 	(0xdc | CR_MAC_BASE)// --- XM and PG Counter Register ---
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define CR_MAC_RUNT_TLCC_CNT   (0xe0 | CR_MAC_BASE)// --- Receive Runt and Transmit Late Collision Packet Counter Register ---
+#define CR_MAC_RCRC_RLONG_CNT  (0xe4 | CR_MAC_BASE)// --- Receive CRC Error and Long Packet Counter Register ---
+#define CR_MAC_RLOSS_RCOL_CNT  (0xe8 | CR_MAC_BASE)// --- Receive Packet Loss and Receive Collision Counter Register ---
+#else
+#define CR_MAC_RUNT_LCOL_CNT 	(0xe0 | CR_MAC_BASE)// --- Runt and Late Collision Packet Counter Register ---
+#define CR_MAC_CRC_LONG_CNT   	(0xe4 | CR_MAC_BASE)// --- CRC and Long Packet Counter Register ---
+#define CR_MAC_LOSS_COL_CNT   	(0xe8 | CR_MAC_BASE)// --- Receive Packet Loss and Receive Collision Counter Register ---
+#endif
+#define CR_MAC_BROADCAST_CNT  	(0xec | CR_MAC_BASE)// --- Receive Broadcast Counter Register ---
+#define CR_MAC_MULTICAST_CNT  	(0xf0 | CR_MAC_BASE)// --- Receive Multicast Counter Register ---
+#define CR_MAC_RX_CNT   	(0xf4 | CR_MAC_BASE)// --- Receive Good Packet Counter Register ---
+#define CR_MAC_TX_CNT   	(0xf8 | CR_MAC_BASE)// --- Transmit Good Packet Counter Register ---
+
+/*************************
+ * UART Module Registers *
+ *************************/
+#ifdef __BIG_ENDIAN
+#define CR_UART_OFFSET		(0x03)
+#else
+#define CR_UART_OFFSET		(0x0)
+#endif
+
+#define	CR_UART_BASE    	0xBFBF0000
+#define	CR_UART_RBR     	(0x00+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_THR     	(0x00+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_IER     	(0x04+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_IIR     	(0x08+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_FCR     	(0x08+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_LCR     	(0x0c+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_MCR     	(0x10+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_LSR     	(0x14+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_MSR     	(0x18+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_SCR     	(0x1c+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_BRDL    	(0x00+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_BRDH    	(0x04+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_WORDA		(0x20+CR_UART_BASE+0x00)
+#define	CR_UART_HWORDA		(0x28+CR_UART_BASE+0x00)
+#define	CR_UART_MISCC		(0x24+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_XYD     	(0x2c+CR_UART_BASE)
+
+#define	UART_BRD_ACCESS		0x80
+#define	UART_XYD_Y          65000
+#define	UART_UCLK_115200    0
+#define	UART_UCLK_57600     1
+#define	UART_UCLK_38400     2
+#define	UART_UCLK_28800		3
+#define	UART_UCLK_19200		4
+#define	UART_UCLK_14400		5
+#define	UART_UCLK_9600		6
+#define	UART_UCLK_4800		7
+#define	UART_UCLK_2400		8
+#define	UART_UCLK_1200		9
+#define	UART_UCLK_600		10
+#define	UART_UCLK_300		11
+#define	UART_UCLK_110		12
+#define	UART_BRDL			0x03
+#define	UART_BRDH			0x00
+#define	UART_LCR			0x03
+#define	UART_FCR			0x0f
+#define	UART_WATERMARK		(0x0<<6)
+#define	UART_MCR			0x0
+#define	UART_MISCC			0x0
+//#define UART_IER			0x07
+//#define	UART_IER			0x05
+#define	UART_IER			0x01
+
+#define	IER_RECEIVED_DATA_INTERRUPT_ENABLE	0x01
+#define	IER_THRE_INTERRUPT_ENABLE			0x02
+#define	IER_LINE_STATUS_INTERRUPT_ENABLE	0x04
+
+#define	IIR_INDICATOR						VPchar(CR_UART_IIR)
+#define	IIR_RECEIVED_LINE_STATUS			0x06
+#define	IIR_RECEIVED_DATA_AVAILABLE			0x04
+#define IIR_RECEIVER_IDLE_TRIGGER			0x0C
+#define	IIR_TRANSMITTED_REGISTER_EMPTY		0x02
+#define	LSR_INDICATOR						VPchar(CR_UART_LSR)
+#define	LSR_RECEIVED_DATA_READY				0x01
+#define	LSR_OVERRUN							0x02
+#define	LSR_PARITY_ERROR					0x04
+#define	LSR_FRAME_ERROR						0x08
+#define	LSR_BREAK							0x10
+#define	LSR_THRE							0x20
+#define	LSR_THE								0x40
+#define	LSR_RFIFO_FLAG						0x80
+
+#define uartTxIntOn()		VPchar(CR_UART_IER) |= IER_THRE_INTERRUPT_ENABLE
+#define uartTxIntOff()		VPchar(CR_UART_IER) &= ~IER_THRE_INTERRUPT_ENABLE
+#define uartRxIntOn()		VPchar(CR_UART_IER) |= IER_RECEIVED_DATA_INTERRUPT_ENABLE
+#define	uartRxIntOff()		VPchar(CR_UART_IER) &= ~IER_RECEIVED_DATA_INTERRUPT_ENABLE
+
+/*************************
+ * UART2 Module Registers *
+ *************************/
+#ifdef TCSUPPORT_UART2
+#define	CR_UART2_BASE    	0xBFBF0300
+#define	CR_UART2_RBR     	(0x00+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_THR     	(0x00+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_IER     	(0x04+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_IIR     	(0x08+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_FCR     	(0x08+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_LCR     	(0x0c+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_MCR     	(0x10+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_LSR     	(0x14+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_MSR     	(0x18+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_SCR     	(0x1c+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_BRDL    	(0x00+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_BRDH    	(0x04+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_WORDA		(0x20+CR_UART2_BASE+0x00)
+#define	CR_UART2_HWORDA	    (0x28+CR_UART2_BASE+0x00)
+#define	CR_UART2_MISCC		(0x24+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_XYD     	(0x2c+CR_UART2_BASE)
+
+#define	IIR_INDICATOR2		VPchar(CR_UART2_IIR)
+#define	LSR_INDICATOR2		VPchar(CR_UART2_LSR)
+#endif
+
+/*************************
+ * HSUART Module Registers *
+ *************************/
+#define	CR_HSUART_BASE    	0xBFBF0300
+#define	CR_HSUART_RBR     	(0x00+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_THR     	(0x00+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_IER     	(0x04+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_IIR     	(0x08+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_FCR     	(0x08+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_LCR     	(0x0c+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_MCR     	(0x10+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_LSR     	(0x14+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_MSR     	(0x18+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_SCR     	(0x1c+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_BRDL    	(0x00+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_BRDH    	(0x04+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_WORDA		(0x20+CR_HSUART_BASE+0x00)
+#define	CR_HSUART_HWORDA	(0x28+CR_HSUART_BASE+0x00)
+#define	CR_HSUART_MISCC		(0x24+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_XYD     	(0x2c+CR_HSUART_BASE)
+
+/**********************************
+ * Interrupt Controller Registers *
+ **********************************/
+#define CR_INTC_BASE    0xBFB40000
+			// --- Interrupt Type Register ---
+#define CR_INTC_ITR     (CR_INTC_BASE+0x0000)
+			// --- Interrupt Mask Register ---
+#define CR_INTC_IMR     (CR_INTC_BASE+0x0004)
+			// --- Interrupt Pending Register ---
+#define CR_INTC_IPR     (CR_INTC_BASE+0x0008)
+			// --- Interrupt Set Register ---
+#define CR_INTC_ISR    	(CR_INTC_BASE+0x000c)
+			// --- Interrupt Priority Register 0 ---
+#define CR_INTC_IPR0    (CR_INTC_BASE+0x0010)
+			// --- Interrupt Priority Register 1 ---
+#define CR_INTC_IPR1    (CR_INTC_BASE+0x0014)
+			// --- Interrupt Priority Register 2 ---
+#define CR_INTC_IPR2    (CR_INTC_BASE+0x0018)
+			// --- Interrupt Priority Register 3 ---
+#define CR_INTC_IPR3    (CR_INTC_BASE+0x001c)
+			// --- Interrupt Priority Register 4 ---
+#define CR_INTC_IPR4    (CR_INTC_BASE+0x0020)
+			// --- Interrupt Priority Register 5 ---
+#define CR_INTC_IPR5    (CR_INTC_BASE+0x0024)
+			// --- Interrupt Priority Register 6 ---
+#define CR_INTC_IPR6    (CR_INTC_BASE+0x0028)
+			// --- Interrupt Priority Register 7 ---
+#define CR_INTC_IPR7    (CR_INTC_BASE+0x002c)
+			// --- Interrupt Vector egister ---
+#ifdef CONFIG_MIPS_TC3262
+			// --- Interrupt VPE and SRS Register 0 ---
+#define CR_INTC_IVSR0   (CR_INTC_BASE+0x0030)
+			// --- Interrupt VPE and SRS Register 1 ---
+#define CR_INTC_IVSR1   (CR_INTC_BASE+0x0034)
+			// --- Interrupt VPE and SRS Register 2 ---
+#define CR_INTC_IVSR2   (CR_INTC_BASE+0x0038)
+			// --- Interrupt VPE and SRS Register 3 ---
+#define CR_INTC_IVSR3   (CR_INTC_BASE+0x003c)
+			// --- Interrupt VPE and SRS Register 4 ---
+#define CR_INTC_IVSR4   (CR_INTC_BASE+0x0040)
+			// --- Interrupt VPE and SRS Register 5 ---
+#define CR_INTC_IVSR5   (CR_INTC_BASE+0x0044)
+			// --- Interrupt VPE and SRS Register 6 ---
+#define CR_INTC_IVSR6   (CR_INTC_BASE+0x0048)
+			// --- Interrupt VPE and SRS Register 7 ---
+#define CR_INTC_IVSR7   (CR_INTC_BASE+0x004c)
+			// --- Interrupt Vector egister ---
+#define CR_INTC_IVR     (CR_INTC_BASE+0x0050)
+
+/* RT63165 */
+			// --- Interrupt Mask Register ---
+#define CR_INTC_IMR_1   (CR_INTC_BASE+0x0050)
+			// --- Interrupt Pending Register ---
+#define CR_INTC_IPR_1   (CR_INTC_BASE+0x0054)
+			// --- Interrupt Priority Register 8 ---
+#define CR_INTC_IPSR8	(CR_INTC_BASE+0x0058)
+			// --- Interrupt Priority Register 9 ---
+#define CR_INTC_IPSR9	(CR_INTC_BASE+0x005c)
+			// --- Interrupt VPE and SRS Register 8 ---
+#define CR_INTC_IVSR8   (CR_INTC_BASE+0x0060)
+			// --- Interrupt VPE and SRS Register 9 ---
+#define CR_INTC_IVSR9   (CR_INTC_BASE+0x0064)
+
+/*MT7510*/
+#define CR_INTC_NMI0IMR0   (CR_INTC_BASE+0x0080)
+#define CR_INTC_NMI1IMR0   (CR_INTC_BASE+0x0088)
+
+
+
+
+#else
+			// --- Interrupt Vector egister ---
+#define CR_INTC_IVR     (CR_INTC_BASE+0x0030)
+#endif
+
+#if 0
+/*move this to the int_source.h because the definition of unsigned long int...etc has been defined in type.h.
+  The ralink driver uses type.h and needs this interrupt_source structure so move this interrupt_source structure
+	to int_source.h. shnwind */
+enum
+interrupt_source
+	{
+#ifdef CONFIG_MIPS_TC3262
+		DUMMY_INT,
+#endif
+		UART_INT,		//0 	IPL10
+		RTC_ALARM_INT,	//1 	IPL29
+#ifdef CONFIG_MIPS_TC3262
+		SI_SWINT1_INT0,	//2
+		SI_SWINT1_INT1,	//3
+#else
+		RTC_TICK_INT,	//2 	IPL31
+		RESERVED0,		//3 	IPL30
+#endif
+		TIMER0_INT, 	//4 	IPL1
+		TIMER1_INT, 	//5 	IPL5
+		TIMER2_INT, 	//6 	IPL6
+#ifdef CONFIG_MIPS_TC3262
+		SI_SWINT_INT0, 	//7
+		SI_SWINT_INT1, 	//8
+#else
+		TIMER3_INT, 	//7 	IPL7
+		TIMER4_INT, 	//8 	IPL8
+#endif
+		TIMER5_INT, 	//9 	IPL9
+		GPIO_INT,		//10	IPL11
+#ifdef CONFIG_MIPS_TC3262
+		RESERVED1,		//11	IPL20
+		SI_PC1_INT, 	//12
+		SI_PC_INT, 		//13
+#else
+		PCIE_A_INT,		//11	IPL20
+		PCIE_SERR_INT,	//12	IPL21
+		RESERVED3,		//13	IPL22
+#endif
+		APB_DMA0_INT,	//14	IPL12
+		APB_DMA1_INT,	//15	IPL13
+#ifdef CONFIG_MIPS_TC3262
+		HSUART_INT,		//16	IPL23
+#else
+		RESERVED4,		//16	IPL23
+#endif
+		RESERVED5,		//17	IPL24
+		DYINGGASP_INT,	//18	IPL25
+		DMT_INT,		//19	IPL26
+		ARBITER_ERR_INT,//20	IPL0
+		MAC_INT,		//21	IPL3
+		SAR_INT,		//22	IPL2
+		USB_INT,		//23	IPL14
+		PCI_A_INT,		//24
+		PCI_B_INT,		//25
+//		  RESERVED8,	  //24	  IPL27
+//		  RESERVED9,	  //25	  IPL28
+		XSLV0_INT,		//26	IPL15
+		XSLV1_INT,		//27	IPL16
+		XSLV2_INT,		//28	IPL17
+#ifdef CONFIG_MIPS_TC3262
+		SI_TIMER1_INT,	//29
+		SI_TIMER_INT,	//30
+#else
+		XAPB0_INT,		//29	IPL18
+		XAPB1_INT,		//30	IPL19
+#endif
+		SWR_INT 		//31	IPL4
+	};
+#endif
+
+enum
+interrupt_priority
+{
+		IPL0,	IPL1,	IPL2,	IPL3,	IPL4,
+		IPL5,	IPL6,	IPL7,	IPL8,	IPL9,
+		IPL10,	IPL11,	IPL12,	IPL13,	IPL14,
+		IPL15,	IPL16,	IPL17,	IPL18,	IPL19,
+		IPL20,	IPL21,	IPL22,	IPL23,	IPL24,
+		IPL25,	IPL26,	IPL27,	IPL28,	IPL29,
+		IPL30,	IPL31
+};
+
+/**************************
+ * Timer Module Registers *
+ **************************/
+#define CR_TIMER_BASE  		0xBFBF0100
+#define CR_TIMER_CTL    	(CR_TIMER_BASE + 0x00)
+#define CR_TIMER0_LDV   	(CR_TIMER_BASE + 0x04)
+#define CR_TIMER0_VLR    	(CR_TIMER_BASE + 0x08)
+#define CR_TIMER1_LDV       (CR_TIMER_BASE + 0x0C)
+#define CR_TIMER1_VLR       (CR_TIMER_BASE + 0x10)
+#define CR_TIMER2_LDV       (CR_TIMER_BASE + 0x14)
+#define CR_TIMER2_VLR       (CR_TIMER_BASE + 0x18)
+#define CR_TIMER3_LDV       (CR_TIMER_BASE + 0x1C)
+#define CR_TIMER3_VLR       (CR_TIMER_BASE + 0x20)
+#define CR_TIMER4_LDV       (CR_TIMER_BASE + 0x24)
+#define CR_TIMER4_VLR       (CR_TIMER_BASE + 0x28)
+#define CR_TIMER5_LDV       (CR_TIMER_BASE + 0x2C)
+#define CR_TIMER5_VLR       (CR_TIMER_BASE + 0x30)
+/* new watchdog design */
+#define CR_WDOG_THSLD       (CR_TIMER_BASE + 0x34)
+#define CR_WDOG_RLD         (CR_TIMER_BASE + 0x38)
+
+#define TIMER_ENABLE         1
+#define TIMER_DISABLE        0
+#define TIMER_TOGGLEMODE     1
+#define TIMER_INTERVALMODE   0
+#define TIMER_TICKENABLE     1
+#define TIMER_TICKDISABLE    0
+#define TIMER_WDENABLE       1
+#define TIMER_WDDISABLE      0
+#define TIMER_HALTENABLE     1
+#define TIMER_HALTDISABLE    0
+
+#define TIMERTICKS_1MS       1
+#define TIMERTICKS_10MS      10  // set timer ticks as 10 ms
+#define TIMERTICKS_100MS     100
+#define TIMERTICKS_1S        1000
+#define TIMERTICKS_10S       10000
+
+#define timerCtlSet(timer_no, timer_enable, timer_mode,timer_halt)	timer_Configure(timer_no, timer_enable, timer_mode, timer_halt)
+#define timerWdSet(tick_enable, watchdog_enable) timer_WatchDogConfigure(tick_enable,watchdog_enable)
+#define timerLdvSet(timer_no,val) *(volatile uint32 *)(CR_TIMER0_LDV+timer_no*0x08) = (val)
+#define timerVlrGet(timer_no,val) (val)=*(volatile uint32 *)(CR_TIMER0_VLR+timer_no*0x08)
+
+/**************************
+ * Timer Module Registers *
+ **************************/
+#define CR_CPUTMR_BASE 		0xBFBF0400
+#define CR_CPUTMR_CTL    	(CR_CPUTMR_BASE + 0x00)
+#define CR_CPUTMR_CMR0    	(CR_CPUTMR_BASE + 0x04)
+#define CR_CPUTMR_CNT0    	(CR_CPUTMR_BASE + 0x08)
+#define CR_CPUTMR_CMR1    	(CR_CPUTMR_BASE + 0x0c)
+#define CR_CPUTMR_CNT1    	(CR_CPUTMR_BASE + 0x10)
+
+/*************************
+ * GPIO Module Registers *
+ *************************/
+#define CR_GPIO_BASE       	0xBFBF0200
+#define CR_GPIO_CTRL	    (CR_GPIO_BASE + 0x00)
+#define CR_GPIO_DATA	    (CR_GPIO_BASE + 0x04)
+#define CR_GPIO_INTS      	(CR_GPIO_BASE + 0x08)
+#define CR_GPIO_EDET	    (CR_GPIO_BASE + 0x0C)
+#define CR_GPIO_LDET       	(CR_GPIO_BASE + 0x10)
+#define CR_GPIO_ODRAIN      (CR_GPIO_BASE + 0x14)
+#define CR_GPIO_CTRL1	    (CR_GPIO_BASE + 0x20)
+#ifdef TCSUPPORT_GPIO_ECM
+#define CR_SGPIO_DATA        (CR_GPIO_BASE + 0x24)
+#define CR_SGPIO_CDIV        (CR_GPIO_BASE + 0x28)
+#define CR_SGPIO_CDLY        (CR_GPIO_BASE + 0x2C)
+#define CR_SGPIO_MODE	    (CR_GPIO_BASE + 0x30)
+#define CR_GPIO_FLAMOD	    (CR_GPIO_BASE + 0x34)
+#define CR_GPIO_IMME	    (CR_GPIO_BASE + 0x38)
+#define CR_GPIO_FLAP0	    (CR_GPIO_BASE + 0x3C)
+#define CR_GPIO_FLAP1	    (CR_GPIO_BASE + 0x40)
+#define CR_GPIO_FLAP2 	    (CR_GPIO_BASE + 0x44)
+#define CR_GPIO_FLAP3	    (CR_GPIO_BASE + 0x48)
+#define CR_GPIO_FMAP0	    (CR_GPIO_BASE + 0x4C)
+#define CR_GPIO_FMAP1 	    (CR_GPIO_BASE + 0x50)
+#define CR_SGPIO_FMAP0	    (CR_GPIO_BASE + 0x54)
+#define CR_SGPIO_FMAP1	    (CR_GPIO_BASE + 0x58)
+#define CR_SGPIO_FMAP2	    (CR_GPIO_BASE + 0x5C)
+#define CR_GPIO_TYPE	    0xBFB000B0
+#endif
+/* MT7510 */
+#define CR_GPIO_CTRL2	    (CR_GPIO_BASE + 0x60)
+#define CR_GPIO_CTRL3	    (CR_GPIO_BASE + 0x64)
+#define CR_GPIO_FLAMOD_EXT	(CR_GPIO_BASE + 0x68)
+#define CR_GPIO_DATA1		(CR_GPIO_BASE + 0x70)
+#define CR_GPIO_ODRAIN1     (CR_GPIO_BASE + 0x78)
+
+#define GPIO_IN				0x0
+#define GPIO_OUT			0x1
+#define GPIO_ALT_IN			0x2
+#define GPIO_ALT_OUT		0x3
+
+#define GPIO_E_DIS			0x0
+#define GPIO_E_RISE			0x1
+#define GPIO_E_FALL			0x2
+#define GPIO_E_BOTH			0x3
+
+#define GPIO_L_DIS			0x0
+#define GPIO_L_HIGH			0x1
+#define GPIO_L_LOW			0x2
+#define GPIO_L_BOTH			0x3
+
+/*****************************
+ * Arbiter/Decoder Registers *
+ *****************************/
+#define CR_AHB_BASE       	0xBFB00000
+#define CR_AHB_AACS	    	(CR_AHB_BASE + 0x00)
+#define CR_AHB_ABEM      	(CR_AHB_BASE + 0x08)
+#define CR_AHB_ABEA		    (CR_AHB_BASE + 0x0C)
+#define CR_AHB_DMB0       	(CR_AHB_BASE + 0x10)
+#define CR_AHB_DMB1       	(CR_AHB_BASE + 0x14)
+#define CR_AHB_DMB2       	(CR_AHB_BASE + 0x18)
+#define CR_AHB_DMB3       	(CR_AHB_BASE + 0x1C)
+#define CR_AHB_SMB0       	(CR_AHB_BASE + 0x20)
+#define CR_AHB_SMB1       	(CR_AHB_BASE + 0x24)
+#define CR_AHB_SMB2       	(CR_AHB_BASE + 0x28)
+#define CR_AHB_SMB3       	(CR_AHB_BASE + 0x2C)
+#define CR_AHB_SMB4       	(CR_AHB_BASE + 0x30)
+#define CR_AHB_SMB5       	(CR_AHB_BASE + 0x34)
+
+/* RT63165 */
+#define CR_ERR_ADDR    		(CR_AHB_BASE + 0x3c)
+#define CR_PRATIR      		(CR_AHB_BASE + 0x58)
+#define CR_MON_TMR     		(CR_AHB_BASE + 0x60)
+
+/*MT7510*/
+#define CR_AHB_NMI_CONF		(CR_AHB_BASE + 0x50)
+
+#define CR_AHB_PMCR       	(CR_AHB_BASE + 0x80)
+#define CR_AHB_DMTCR       	(CR_AHB_BASE + 0x84)
+#define CR_AHB_PCIC	       	(CR_AHB_BASE + 0x88)
+#define CR_AHB_HWCONF       (CR_AHB_BASE + 0x8C)
+#define CR_AHB_SSR       	(CR_AHB_BASE + 0x90)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define CR_IMEM       	(CR_AHB_BASE + 0x9C)
+#define CR_DMEM       	(CR_AHB_BASE + 0xA0)
+#endif
+/* RT63365 */
+#define CR_CRCC_REG		(CR_AHB_BASE + 0xA0)
+#define CR_AHB_UHCR		(CR_AHB_BASE + 0xA8)
+#define CR_AHB_ABMR       	(CR_AHB_BASE + 0xB8)
+#define CR_CKGEN_CONF		(CR_AHB_BASE + 0xC0)
+#define CR_PSMCR       		(CR_AHB_BASE + 0xCC)
+#define CR_PSMDR       		(CR_AHB_BASE + 0xD0)
+#define CR_PSMMR       		(CR_AHB_BASE + 0xD0)
+
+/* RT63165 */
+#define CR_SRAM       		(CR_AHB_BASE + 0xF4)
+#define CR_AHB_HWCONF2      (CR_AHB_BASE + 0xF8)
+
+/* RT63365 */
+#define CR_AHB_CLK			(CR_AHB_BASE + 0x1c0)
+#define CR_CLK_CFG     		(CR_AHB_BASE + 0x82c)
+#define CR_RSTCTRL2    		(CR_AHB_BASE + 0x834)
+#define CR_GPIO_SHR			(CR_AHB_BASE + 0x860)			
+
+#define CR_BUSTIMEOUT_SWITCH     (CR_AHB_BASE + 0x92c)
+/*************************************************
+ * SRAM/FLASH/ROM Controller Operation Registers *
+ *************************************************/
+#define CR_SMC_BASE       	0xBFB10000
+#define CR_SMC_BCR0	    	(CR_SMC_BASE + 0x00)
+#define CR_SMC_BCR1	    	(CR_SMC_BASE + 0x04)
+#define CR_SMC_BCR2	    	(CR_SMC_BASE + 0x08)
+#define CR_SMC_BCR3	    	(CR_SMC_BASE + 0x0C)
+#define CR_SMC_BCR4	    	(CR_SMC_BASE + 0x10)
+#define CR_SMC_BCR5	    	(CR_SMC_BASE + 0x14)
+
+/************************************************
+ * System Control Uint                          *
+ ************************************************/
+ /* MT7510 */
+#define CR_SCU_BASE				0xbfb00000
+#define CR_DRAMC_HW_SREF_CONF	(0x44 | CR_SCU_BASE)
+#define CR_DRAMC_CONF			(0x74 | CR_SCU_BASE)
+
+/*****************************
+ * Clock Generator Registers *
+ *****************************/
+
+/****************************
+ * USB Module Registers *
+ ****************************/
+
+#define CR_USB_BASE     0xBFB70000
+
+        // --- System Control Register ---
+#define CR_USB_SYS_CTRL_REG           (0x00 | CR_USB_BASE)
+
+        // --- Device Control Register ---
+#define CR_USB_DEV_CTRL_REG           (0x04 | CR_USB_BASE)
+
+        // --- Interrupt Status Register ---
+#define CR_USB_INTR_STATUS_REG        (0x08 | CR_USB_BASE)
+
+        // --- Interrupt Mask Register ---
+#define CR_USB_INTR_MASK_REG          (0x0c | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode Control Register ---
+#define CR_USB_CTRL_ENDP_IO_CTRL_REG  (0x10 | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode OUT Transfer Data Register #00 ---
+#define CR_USB_CTRL_ENDP_IO_OUT_REG0  (0x18 | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode OUT Transfer Data Register #01 ---
+#define CR_USB_CTRL_ENDP_IO_OUT_REG1  (0x1c | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode IN Transfer Data Register #00 ---
+#define CR_USB_CTRL_ENDP_IO_IN_REG0   (0x20 | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode IN Transfer Data Register #01 ---
+#define CR_USB_CTRL_ENDP_IO_IN_REG1   (0x24 | CR_USB_BASE)
+
+        // --- Interrupt IN Endpoint Control Register ---
+#define CR_USB_INTR_IN_ENDP_CTRL_REG  (0x30 | CR_USB_BASE)
+
+        // --- Interrupt IN Endpoint IN Transfer Data Register #00 ---
+#define CR_USB_INTR_IN_ENDP_IN_REG0   (0x38 | CR_USB_BASE)
+
+        // --- Interrupt IN Endpoint IN Transfer Data Register #01 ---
+#define CR_USB_INTR_IN_ENDP_IN_REG1   (0x3c | CR_USB_BASE)
+
+        // --- Bulk/ISO OUT Descriptor Pointer Register ---
+#define CR_USB_BULKISO_OUT_DESCP_BASE_REG   (0x40 | CR_USB_BASE)
+
+        // --- Bulk/ISO IN Descriptor Pointer Register ---
+#define CR_USB_BULKISO_IN_DESCP_BASE_REG    (0x44 | CR_USB_BASE)
+
+        // --- Bulk/ISO IN/OUT Endpoint Number Register ---
+#define CR_USB_BULKISO_INOUT_ENDP_NUM_REG   (0x48 | CR_USB_BASE)
+
+        // --- Bulk/ISO Endpoint DMA Control Register ---
+#define CR_USB_BULKISO_ENDP_DMA_CTRL_REG    (0x4c | CR_USB_BASE)
+
+        // --- Bulk/ISO Endpoint DMA Configuration Register ---
+#define CR_USB_BULKISO_ENDP_DMA_CONF_REG    (0x50 | CR_USB_BASE)
+
+        // --- ISO Endpoint Transfer Delimiter Register #00 ---
+#define CR_USB_ISO_ENDP_DELIMITER_REG0      (0x58 | CR_USB_BASE)
+
+        // --- ISO Endpoint Transfer Delimiter Register #01 ---
+#define CR_USB_ISO_ENDP_DELIMITER_REG1      (0x5c | CR_USB_BASE)
+
+        // --- Vendor ID Register ---
+#define CR_USB_VENDOR_ID_REG                (0x68 | CR_USB_BASE)
+
+        // --- Product ID Register ---
+#define CR_USB_PRODUCT_ID_REG               (0x6c | CR_USB_BASE)
+
+/*************************
+ * HOST BRIDGE Registers *
+ * ***********************/
+#define HOST_BRIDGE_BASE 	0xBFB80000
+#define CR_CFG_ADDR_REG 	(HOST_BRIDGE_BASE+0x0020)
+#define CR_CFG_DATA_REG 	(HOST_BRIDGE_BASE+0x0024)
+/****************************
+ * ATM SAR Module Registers *
+ ****************************/
+#define TSCONTROL_BASE			0xBFB00000
+#define TSARM_REGISTER_BASE		(TSCONTROL_BASE + 0x00060000)
+
+/* ----- General configuration registers  ----- */
+
+/* ----- Reset And Identify register  ----- */
+#define TSARM_RAI				VPint(TSARM_REGISTER_BASE + 0x0000)
+/* ----- General Configuration register  ----- */
+#define TSARM_GFR				VPint(TSARM_REGISTER_BASE + 0x0004)
+/* ----- Traffic Scheduler Timer Base Counter register  ----- */
+#define TSARM_TSTBR				VPint(TSARM_REGISTER_BASE + 0x0008)
+/* ----- Receive Maximum Packet Length register  ----- */
+#define TSARM_RMPLR				VPint(TSARM_REGISTER_BASE + 0x000c)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+//Transmit Priority 0/1 Data Buffer Control and Status Register
+#define TSARM_TXDBCSR_P01		VPint(TSARM_REGISTER_BASE + 0x0010)
+#else
+/* ----- TX Data Buffer Control and Status register  ----- */
+#define TSARM_TXDBCSR			VPint(TSARM_REGISTER_BASE + 0x0010)
+#endif
+/* ----- TX OAM Buffer Control and Status register  ----- */
+#define TSARM_TXMBCSR			VPint(TSARM_REGISTER_BASE + 0x0014)
+/* ----- RX Data Buffer Control and Status register  ----- */
+#define TSARM_RXDBCSR			VPint(TSARM_REGISTER_BASE + 0x0018)
+/* ----- RX OAM Buffer Control and Status register  ----- */
+#define TSARM_RXMBCSR			VPint(TSARM_REGISTER_BASE + 0x001c)
+/* ----- Last IRQ Status register  ----- */
+#define TSARM_LIRQ				VPint(TSARM_REGISTER_BASE + 0x0020)
+/* ----- IRQ Queue Base Address register  ----- */
+#define TSARM_IRQBA				VPint(TSARM_REGISTER_BASE + 0x0024)
+/* ----- IRQ Queue Entry Length register  ----- */
+#define TSARM_IRQLEN			VPint(TSARM_REGISTER_BASE + 0x0028)
+/* ----- IRQ Head Indication register  ----- */
+#define TSARM_IRQH				VPint(TSARM_REGISTER_BASE + 0x002c)
+/* ----- Clear IRQ Entry register  ----- */
+#define TSARM_IRQC				VPint(TSARM_REGISTER_BASE + 0x0030)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+//Traffic Scheduler Line Rate Counter Register
+#define TSARM_TXSLRC			VPint(TSARM_REGISTER_BASE + 0x0034)
+//Transmit Priority 2/3 Data Buffer Control and Status Register
+#define TSARM_TXDBCSR_P23		VPint(TSARM_REGISTER_BASE + 0x0038)
+#endif
+
+/* ----- VC IRQ Mask register  ----- */
+#define TSARM_IRQM_BASE			(TSARM_REGISTER_BASE + 0x0040)
+#define TSARM_IRQM(vc)			VPint(TSARM_IRQM_BASE + (vc * 4))
+#define TSARM_IRQMCC			VPint(TSARM_IRQM_BASE + 0x0040)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_IRQ_QUE_THRE		VPint(TSARM_REGISTER_BASE + 0x0084)		//IRQ Queue Threshold Register
+#define TSARM_IRQ_TIMEOUT_CTRL 	VPint(TSARM_REGISTER_BASE + 0x0088)		//IRQ Timeout Control Register
+#endif
+
+/* ----- VC Configuration register  ----- */
+#define TSARM_VCCR_BASE			(TSARM_REGISTER_BASE + 0x0100)
+#define TSARM_VCCR(vc)			VPint(TSARM_VCCR_BASE + (vc * 4))
+#define TSARM_CCCR				VPint(TSARM_VCCR_BASE + 0x0040)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+/* ----- DMA WRR Configuration Register (DMA_WRR_WEIT) (for TC3162L4) ----- */
+#define TSARM_DMAWRRCR			VPint(TSARM_REGISTER_BASE + 0x0150)
+#endif
+/* ----- Transmit Buffer Descriptor register  ----- */
+#define TSARM_TXDCBDA_BASE		(TSARM_REGISTER_BASE + 0x0200)
+#define TSARM_TXDCBDA(vc)		VPint(TSARM_TXDCBDA_BASE + (vc * 4))
+#define TSARM_TXMCBDA_BASE		(TSARM_REGISTER_BASE + 0x0240)
+#define TSARM_TXMCBDA(vc)		VPint(TSARM_TXMCBDA_BASE + (vc * 4))
+
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_CC_TX_BD_BASE				VPint(TSARM_REGISTER_BASE + 0x0228)		//Control Channel Transmit BD Base Address 0x228
+#define TSARM_CC_TX_BD_MNG_BASE			VPint(TSARM_REGISTER_BASE + 0x0268)		//Control Channel Transmit BD Management Base
+#define TSARM_VC_TX_BD_PRIORITY01_BASE		(TSARM_REGISTER_BASE + 0x0280)
+#define TSARM_VC_TX_BD_PRIORITY01(vc)		VPint(TSARM_VC_TX_BD_PRIORITY01_BASE + vc * 4)		//VC0 Transmit BD Data Priority 0/1 Base 280
+#define TSARM_VC_TX_BD_PRIORITY23_BASE		(TSARM_REGISTER_BASE + 0x02c0)
+#define TSARM_VC_TX_BD_PRIORITY23(vc)		VPint(TSARM_VC_TX_BD_PRIORITY23_BASE + vc * 4)		//VC0 Transmit BD Data Priority 0/1 Base 280
+#else
+#define TSARM_TXCCBDA			VPint(TSARM_REGISTER_BASE + 0x0280)
+#endif
+
+/* ----- Receive Buffer Descriptor register  ----- */
+#define TSARM_RXDCBDA_BASE		(TSARM_REGISTER_BASE + 0x0300)
+#define TSARM_RXDCBDA(vc)		VPint(TSARM_RXDCBDA_BASE + (vc * 4))
+#define TSARM_RXMCBDA_BASE		(TSARM_REGISTER_BASE + 0x0340)
+#define TSARM_RXMCBDA(vc)		VPint(TSARM_RXMCBDA_BASE + (vc * 4))
+
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_CC_RX_BD_BASE			VPint(TSARM_REGISTER_BASE + 0x328)		//Control Channel Receive BD Base Address	0x328
+#define TSARM_CC_RX_BD_MNG_BASE		VPint(TSARM_REGISTER_BASE + 0x368)		//Control Channel Receive BD Management Base	0x368
+#define TSARM_VC_RX_DATA_BASE				(TSARM_REGISTER_BASE + 0x380)
+#define TSARM_VC_RX_DATA(vc)			VPint(TSARM_VC_RX_DATA_BASE + vc * 4)	//VC0 Receive BD Data Base	0x380
+#else
+#define TSARM_RXCCBDA			VPint(TSARM_REGISTER_BASE + 0x0380)
+#endif
+
+/* ----- Traffic Scheduler register  ----- */
+#define TSARM_PCR_BASE			(TSARM_REGISTER_BASE + 0x0400)
+#define TSARM_PCR(vc)			VPint(TSARM_PCR_BASE + (vc * 4))
+#define TSARM_SCR_BASE			(TSARM_REGISTER_BASE + 0x0440)
+#define TSARM_SCR(vc)			VPint(TSARM_SCR_BASE + (vc * 4))
+#define TSARM_MBSTP_BASE		(TSARM_REGISTER_BASE + 0x0480)
+#define TSARM_MBSTP(vc)			VPint(TSARM_MBSTP_BASE + (vc * 4))
+
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_MAX_FRAME_SIZE_BASE	(TSARM_REGISTER_BASE + 0x04c0)
+#define TSARM_MAX_FRAME_SIZE(vc)		VPint(TSARM_MAX_FRAME_SIZE_BASE + (vc * 4))
+/* define for TC3162L4 */
+#define TSARM_TRAFFIC_SHAPER_WEIGHT_BASE (TSARM_REGISTER_BASE + 0x0500)
+#define TSARM_TRAFFIC_SHAPER_WEIGHT(vc)     VPint(TSARM_TRAFFIC_SHAPER_WEIGHT_BASE + (vc * 4))
+#else
+/* ----- Receive Timeout register  ----- */
+#define TSARM_RTOCNT_BASE		(TSARM_REGISTER_BASE + 0x0500)
+#define TSARM_RTOCNT(vc)		VPint(TSARM_RTOCNT_BASE + (vc * 4))
+#endif
+
+/* ----- TX Statistic Counter register  ----- */
+#define TSARM_TDCNT_BASE		(TSARM_REGISTER_BASE + 0x0600)
+#define TSARM_TDCNT(vc)			VPint(TSARM_TDCNT_BASE + (vc * 4))
+#define TSARM_TDCNTCC			VPint(TSARM_TDCNT_BASE + 0x0040)
+
+/* ----- RX Statistic Counter register  ----- */
+#define TSARM_RDCNT_BASE		(TSARM_REGISTER_BASE + 0x0700)
+#define TSARM_RDCNT(vc)			VPint(TSARM_RDCNT_BASE + (vc * 4))
+#define TSARM_RDCNTCC			VPint(TSARM_RDCNT_BASE + 0x0040)
+#define TSARM_MISCNT			VPint(TSARM_RDCNT_BASE + 0x0044)
+
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_MPOA_GCR				VPint(TSARM_REGISTER_BASE + 0x0800)			//MPOA global control register
+#define TSARM_VC_MPOA_CTRL_BASE			(TSARM_REGISTER_BASE + 0x0810)			//VC0 ~9  MPOA Control register
+#define TSARM_VC_MPOA_CTRL(vc)			VPint(TSARM_VC_MPOA_CTRL_BASE + vc * 4)
+#define TSARM_MPOA_HFIV11				VPint(TSARM_REGISTER_BASE + 0x0850)			//MPOA header Field1 Insertion Value1
+#define TSARM_MPOA_HFIV12				VPint(TSARM_REGISTER_BASE + 0x0854)			//MPOA header Field1 Insertion Value2
+#define TSARM_MPOA_HFIV13				VPint(TSARM_REGISTER_BASE + 0x0858)			//MPOA header Field2 Insertion Value1
+#define TSARM_MPOA_HFIV21				VPint(TSARM_REGISTER_BASE + 0x0860)			//MPOA header Field2 Insertion Value2
+#define TSARM_MPOA_HFIV22				VPint(TSARM_REGISTER_BASE + 0x0864)			//MPOA header Field2 Insertion Value2
+#define TSARM_MPOA_HFIV23				VPint(TSARM_REGISTER_BASE + 0x0868)			//MPOA header Field2 Insertion Value2
+#define TSARM_MPOA_HFIV31				VPint(TSARM_REGISTER_BASE + 0x0870)			//MPOA header Field3 Insertion Value1
+#define TSARM_MPOA_HFIV32				VPint(TSARM_REGISTER_BASE + 0x0874)			//MPOA header Field3 Insertion Value2
+#define TSARM_MPOA_HFIV33				VPint(TSARM_REGISTER_BASE + 0x0878)			//MPOA header Field3 Insertion Value3
+#define TSARM_MPOA_HFIV41				VPint(TSARM_REGISTER_BASE + 0x0880)			//MPOA header Field4 Insertion Value1
+#define TSARM_MPOA_HFIV42				VPint(TSARM_REGISTER_BASE + 0x0884)			//MPOA header Field4 Insertion Value2
+#define TSARM_MPOA_HFIV43				VPint(TSARM_REGISTER_BASE + 0x0888)			//MPOA header Field4 Insertion Value2
+#endif
+
+/**************************
+ * USB Module Registers *
+ **************************/
+
+#define LA_DEBUG_TRIGGER(addr,val) VPint(0xbfc00000+addr) = val
+/**************************
+* USB 2.0 device Register *
+**************************/
+#define CR_USB20_BASE     0xBFB70000
+
+// --- System Control Register ---
+#define CR_USB20_SYS_CTRL_REG			(0x00 | CR_USB20_BASE)
+
+// --- Device Control Register ---
+#define CR_USB20_DEV_CTRL_REG			(0x04 | CR_USB20_BASE)
+
+// --- Interrupt Status Register ---
+#define CR_USB20_INTR_STATUS_REG		(0x0c | CR_USB20_BASE)
+
+// --- Interrupt ENABLE Register ---
+#define CR_USB20_INTR_ENABLE_REG          	(0x10 | CR_USB20_BASE)
+
+// --- Interrupt Timing Control Register ---
+#define CR_USB20_INTR_TIMING_CONTROL_REG	(0x14 | CR_USB20_BASE)
+
+// --- SETUP Receive Data Buffer Register ---
+#define CR_USB20_SETUP_BASE_REG          	(0x20 | CR_USB20_BASE)
+
+// --- Control OUT Receive Data Buffer Pointer Register ---
+#define CR_USB20_CONTROL_OUT_BASE_REG		(0x24 | CR_USB20_BASE)
+
+// --- Control IN Receive Data Buffer Pointer Register ---
+#define CR_USB20_CONTROL_IN_BASE_REG		(0x28 | CR_USB20_BASE)
+
+// --- Control IN Receive Data Buffer Pointer Register ---
+#define CR_USB20_CONTROL_CONF_REG		(0x2c | CR_USB20_BASE)
+
+// --- CONTROL Endpoint DMA Transfer Control Register ---
+#define CR_USB20R_CONTROL_EP_DMA_CTRL_REG	(0x30 | CR_USB20_BASE)
+
+// --- CONTROL Endpoint DMA Transfer Status Register ---
+#define CR_USB20_CONTROL_EP_DMA_STATUS_REG	(0x34 | CR_USB20_BASE)
+
+// --- INTERRUPT IN Transmit Data Buffer Pointer  Register ---
+#define CR_USB20_INTERRUPT_IN_BASE_REG		(0x38 | CR_USB20_BASE)
+
+// --- INTERRUPT IN Configuration   Register ---
+#define CR_USB20_INTERRUPT_IN_CONF_REG		(0x3c | CR_USB20_BASE)
+
+// --- INTERRUPT IN Endpoint DMA Transfer Control Register ---
+#define CR_USB20_INTERRUPT_IN_DMA_CTRL_REG	(0x40 | CR_USB20_BASE)
+
+// --- INTERRUPT IN Endpoint DMA Transfer Status Register ---
+#define CR_USB20_INTERRUPT_IN_EP_DMA_STATUS_REG	(0x44 | CR_USB20_BASE)
+
+// --- Bulk/Ctrl/Intr IN/OUT Underrun/Overrun Error Counter  Register ---
+#define CR_USB20_STATUS_COUNT_REG		(0x48 | CR_USB20_BASE)
+
+// --- BULK OUT Endpoint Transfer DMA Polling Demand Control Register ---
+#define CR_USB20_BULK_OUT_DMA_POLLING_REG	(0x60 | CR_USB20_BASE)
+
+// --- BULK IN Endpoint Transfer DMA Polling Demand Control Register ---
+#define CR_USB20_BULK_IN_DMA_POLLING_REG	(0x64 | CR_USB20_BASE)
+
+// --- Bulk OUT Endpoint Transfer Dscriptor Base Address Register ---
+#define CR_USB20_BULK_OUT_DESC_BASE_REG		(0x68 | CR_USB20_BASE)
+
+// --- Bulk IN Endpoint Transfer Dscriptor Base Address Register ---
+#define CR_USB20_BULK_IN_DESC_BASE_REG		(0x6c | CR_USB20_BASE)
+
+// --- Bulk OUT/IN Endpoint Transfer Dscriptor Rinf Size/Offset Register ---
+#define CR_USB20_BULK_DESC_SIZE_OFFSET_REG	(0x70 | CR_USB20_BASE)
+
+// --- Bulk OUT/IN Endpoint Configuration Register ---
+#define CR_USB20_BULK_EP_CONF_REG		(0x74 | CR_USB20_BASE)
+
+// --- Bulk OUT/IN Endpoint DMA Transfer Control Register ---
+#define CR_USB20_BULK_EP_DMA_CTRL_REG          	(0x78 | CR_USB20_BASE)
+
+// --- Bulk OUT/IN Endpoint DMA Transfer Status Register ---
+#define CR_USB20_BULK_EP_DMA_STATUS_REG         (0x7c | CR_USB20_BASE)
+
+// --- UDC Setup Command Address Register ---
+#define CR_USB20_UDC_SETUP_COMMAND_ADDR_REG	(0x80 | CR_USB20_BASE)
+
+// --- UDC Control Endpoint Information Register ---
+#define CR_USB20_UDC_CTRL_EP_INFO_REG          	(0x84 | CR_USB20_BASE)
+
+// --- UDC BULK IN Endpoint Information Register ---
+#define CR_USB20_UDC_BULK_IN_EP_INFO_REG    	(0x88 | CR_USB20_BASE)
+
+// --- UUDC BULK OUT Endpoint Information Register ---
+#define CR_USB20_UDC_BULK_OUT_EP_INFO_REG	(0x8c | CR_USB20_BASE)
+
+// --- UDC INTERRUPT IN Endpoint Information Register ---
+#define CR_USB20_UDC_INTERRUPT_IN_EP_INFO_REG	(0x90 | CR_USB20_BASE)
+
+#if 0
+#define TCSUPPORT_CPU_MT7510_FAKE
+
+#ifdef TCSUPPORT_CPU_MT7510
+#undef DEFAULT_USE_EXT_SWIC
+#endif
+#ifdef TCSUPPORT_CPU_MT7520
+#define DEFAULT_USE_EXT_SWIC
+#endif
+#if defined(TCSUPPORT_CPU_RT65168) || defined(TCSUPPORT_CPU_TC3182)	// for early MT7530 FPGA verification only
+#define DEFAULT_USE_EXT_SWIC
+#endif
+
+#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7520E) || defined(TCSUPPORT_CPU_MT751x20G25G) || defined(TCSUPPORT_CPU_MT7511G) || defined(TCSUPPORT_CPU_MT752025)
+//#define EXT_SWITCH_PHY_CONNECT_INT_MDIO
+
+#ifdef EXT_SWITCH_PHY_CONNECT_INT_MDIO
+#define EXT_SWITCH_PHY_ADDR_OFFSET	(0)
+#define INT_SWITCH_PHY_ADDR_OFFSET	(8)
+
+#endif	//EXT_SWITCH_PHY_CONNECT_INT_MDIO
+
+#endif
+#endif
+#endif /* _TC3162_H_ */
diff --git a/arch/mips/include/asm/tc3162/tc3182_int_source.h b/arch/mips/include/asm/tc3162/tc3182_int_source.h
new file mode 100644
index 000000000..2ae9a5672
--- /dev/null
+++ b/arch/mips/include/asm/tc3162/tc3182_int_source.h
@@ -0,0 +1,67 @@
+/************************************************************************
+ *
+ *	Copyright (C) 2006 Trendchip Technologies, Corp.
+ *	All Rights Reserved.
+ *
+ * Trendchip Confidential; Need to Know only.
+ * Protected as an unpublished work.
+ *
+ * The computer program listings, specifications and documentation
+ * herein are the property of Trendchip Technologies, Co. and shall
+ * not be reproduced, copied, disclosed, or used in whole or in part
+ * for any reason without the prior express written permission of
+ * Trendchip Technologeis, Co.
+ *
+ *************************************************************************/
+
+#ifndef _INT_SOURCE_H_
+#define _INT_SOURCE_H_
+
+enum
+interrupt_source
+	{
+		DUMMY_INT,
+		UART_INT,		//0 	IPL10
+		PTM_B0_INT,		//1
+		SI_SWINT1_INT0,	//2
+		SI_SWINT1_INT1,	//3
+		TIMER0_INT, 	//4 	IPL1
+		TIMER1_INT, 	//5 	IPL5
+		TIMER2_INT, 	//6 	IPL6
+		SI_SWINT_INT0, 	//7
+		SI_SWINT_INT1, 	//8
+		TIMER5_INT, 	//9 	IPL9
+		GPIO_INT,		//10	IPL11
+		RESERVED1,		//11	IPL20
+		SI_PC1_INT, 	//12
+		SI_PC_INT, 		//13
+		APB_DMA0_INT,	//14	IPL12
+		MAC1_INT,		//15	IPL13
+		HSUART_INT,		//16	IPL23
+#if !defined(CONFIG_MIPS_RT63365)
+		RESERVED2,		//17
+#else
+		IRQ_RT3XXX_USB,	//17	IPL24
+#endif
+		DYINGGASP_INT,	//18	IPL25
+		DMT_INT,		//19	IPL26
+		USB20_INT,		//20
+		MAC_INT,		//21	IPL3
+		SAR_INT,		//22	IPL2
+		USB11_INT,
+		PCIE_A_INT,		//24
+		PCIE_SERR_INT,		//25
+		PTM_B1_INT,		//26	IPL15
+		XSLV1_INT,		//27	IPL16
+		USB_INT,		//28	IPL17
+		SI_TIMER1_INT,	//29
+		SI_TIMER_INT,	//30
+		SWR_INT, 		//31	IPL4
+		BUS_TOUT_INT, 	//32
+		RESERVE_A_INT, 	//33
+		RESERVE_B_INT, 	//34
+		RESERVE_C_INT, 	//35
+		AUTO_MANUAL_INT 	//36
+	};
+
+#endif /* _INT_SOURCE_H_ */
diff --git a/arch/mips/include/asm/thread_info.h b/arch/mips/include/asm/thread_info.h
index ee26f9a45..83cee0776 100644
--- a/arch/mips/include/asm/thread_info.h
+++ b/arch/mips/include/asm/thread_info.h
@@ -79,8 +79,12 @@ static inline struct thread_info *current_thread_info(void)
 
 /* thread information allocation */
 #if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_32BIT)
+#if defined(CONFIG_CPU_TC3162) || defined(CONFIG_MIPS_TC3262)
+#define THREAD_SIZE_ORDER (2)
+#else
 #define THREAD_SIZE_ORDER (1)
 #endif
+#endif
 #if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_64BIT)
 #define THREAD_SIZE_ORDER (2)
 #endif
diff --git a/arch/mips/kernel/cpu-probe.c b/arch/mips/kernel/cpu-probe.c
index e2955f1f6..d391a2750 100644
--- a/arch/mips/kernel/cpu-probe.c
+++ b/arch/mips/kernel/cpu-probe.c
@@ -1388,6 +1388,13 @@ static inline void cpu_probe_legacy(struct cpuinfo_mips *c, unsigned int cpu)
 			c->options |= MIPS_CPU_FPU;
 		c->tlbsize = 64;
 		break;
+	case PRID_IMP_TC3162:
+		c->cputype = CPU_R3000;
+		c->isa_level = MIPS_CPU_ISA_I;
+		c->options = MIPS_CPU_TLB | MIPS_CPU_3K_CACHE |
+		             MIPS_CPU_NOFPUEX;
+		c->tlbsize = 32;
+		break;
 	case PRID_IMP_R4000:
 		if (read_c0_config() & CONF_SC) {
 			if ((c->processor_id & PRID_REV_MASK) >=
diff --git a/arch/mips/kernel/csrc-r4k.c b/arch/mips/kernel/csrc-r4k.c
index edc4afc08..61b82a024 100644
--- a/arch/mips/kernel/csrc-r4k.c
+++ b/arch/mips/kernel/csrc-r4k.c
@@ -17,7 +17,8 @@ static u64 c0_hpt_read(struct clocksource *cs)
 	return read_c0_count();
 }
 
-static struct clocksource clocksource_mips = {
+//static 
+struct clocksource clocksource_mips = {
 	.name		= "MIPS",
 	.read		= c0_hpt_read,
 	.mask		= CLOCKSOURCE_MASK(32),
diff --git a/arch/mips/kernel/entry.S b/arch/mips/kernel/entry.S
index 4b896f502..5827e4b08 100644
--- a/arch/mips/kernel/entry.S
+++ b/arch/mips/kernel/entry.S
@@ -101,7 +101,7 @@ restore_partial:		# restore partial frame
 	SAVE_AT
 	SAVE_TEMP
 	LONG_L	v0, PT_STATUS(sp)
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 	and	v0, ST0_IEP
 #else
 	and	v0, ST0_IE
diff --git a/arch/mips/kernel/genex.S b/arch/mips/kernel/genex.S
index bcce32a3d..d015f2f1d 100644
--- a/arch/mips/kernel/genex.S
+++ b/arch/mips/kernel/genex.S
@@ -163,7 +163,7 @@ NESTED(handle_int, PT_SIZE, sp)
 	.set	push
 	.set	noat
 	mfc0	k0, CP0_STATUS
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 	and	k0, ST0_IEP
 	bnez	k0, 1f
 
@@ -645,7 +645,7 @@ isrdhwr:
 	get_saved_sp	/* k1 := current_thread_info */
 	.set	noreorder
 	MFC0	k0, CP0_EPC
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 	ori	k1, _THREAD_MASK
 	xori	k1, _THREAD_MASK
 	LONG_L	v1, TI_TP_VALUE(k1)
diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 5bc3b0469..09d08bc20 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -18,6 +18,9 @@
 #include <asm/cpu-type.h>
 #include <asm/idle.h>
 #include <asm/mipsregs.h>
+#ifdef TCSUPPORT_CPU_EN7512
+#include <asm/tc3162/tc3162.h>
+#endif
 
 /*
  * Not all of the MIPS CPUs have the "wait" instruction available. Moreover,
@@ -67,6 +70,17 @@ void __cpuidle r4k_wait_irqoff(void)
 	local_irq_enable();
 }
 
+#ifdef TCSUPPORT_CPU_EN7512
+void cpu_wait_en7512(void)
+{
+	volatile unsigned int ram_access = 0;
+	int cnt;
+
+	for (cnt = 0; cnt < 100; cnt++)
+		ram_access = VPint(0xA0000000); /* DRAM access */
+}
+#endif
+
 /*
  * The RM7000 variant has to handle erratum 38.	 The workaround is to not
  * have any pending stores when the WAIT instruction is executed.
@@ -215,6 +229,11 @@ void __init check_wait(void)
 		cpu_wait = r4k_wait;
 		if (read_c0_config7() & MIPS_CONF7_WII)
 			cpu_wait = r4k_wait_irqoff;
+#ifdef TCSUPPORT_CPU_EN7512
+		if (isEN7512) {
+                    cpu_wait = cpu_wait_en7512;
+		}
+#endif
 		break;
 
 	case CPU_74K:
diff --git a/arch/mips/kernel/mips-mt-fpaff.c b/arch/mips/kernel/mips-mt-fpaff.c
index 1a08428ee..a072eb797 100644
--- a/arch/mips/kernel/mips-mt-fpaff.c
+++ b/arch/mips/kernel/mips-mt-fpaff.c
@@ -76,6 +76,28 @@ asmlinkage long mipsmt_sys_sched_setaffinity(pid_t pid, unsigned int len,
 	if (copy_from_user(&new_mask, user_mask_ptr, sizeof(new_mask)))
 		return -EFAULT;
 
+
+#ifdef CONFIG_MIPS_MT_SMP
+#ifndef CONFIG_MIPS_MT_SMTC
+	printk("\r\n\r\n%s new_mask origin value is %08x\r\n\r\n", __FUNCTION__, *new_mask);
+	if(*(unsigned long *)new_mask == 0x8)
+	{
+		*(unsigned long *)new_mask = 0x2;
+	}
+	else if(*(unsigned long *)new_mask == 0xf)
+	{
+		*(unsigned long *)new_mask = 0x3;
+	}
+	else
+	{
+		*(unsigned long *)new_mask = 0x1;
+	}
+	
+	printk("\r\n\r\n%s new_mask changed value is %08x\r\n\r\n", __FUNCTION__, *new_mask);
+#endif
+#endif
+
+
 	get_online_cpus();
 	rcu_read_lock();
 
diff --git a/arch/mips/kernel/mips-mt.c b/arch/mips/kernel/mips-mt.c
index d5f7362e8..9499ea448 100644
--- a/arch/mips/kernel/mips-mt.c
+++ b/arch/mips/kernel/mips-mt.c
@@ -119,11 +119,19 @@ void mips_mt_regdump(unsigned long mvpctl)
 	local_irq_restore(flags);
 }
 
+static int mt_opt_es;
 static int mt_opt_rpsctl = -1;
 static int mt_opt_nblsu = -1;
 static int mt_opt_forceconfig7;
 static int mt_opt_config7 = -1;
 
+static int __init es_set(char *str)
+{
+	get_option(&str, &mt_opt_es);
+	return 1;
+}
+__setup("es=", es_set);
+
 static int __init rpsctl_set(char *str)
 {
 	get_option(&str, &mt_opt_rpsctl);
@@ -161,6 +169,13 @@ void mips_mt_set_cpuoptions(void)
 	unsigned int oconfig7 = read_c0_config7();
 	unsigned int nconfig7 = oconfig7;
 
+        if (mt_opt_es >= 0) {
+		printk("34K sync es set to %d.\n", mt_opt_es);
+		if (mt_opt_es)
+			nconfig7 |= (1 << 8);
+		else
+			nconfig7 &= ~(1 << 8);
+	}
 	if (mt_opt_rpsctl >= 0) {
 		printk("34K return prediction stack override set to %d.\n",
 			mt_opt_rpsctl);
diff --git a/arch/mips/kernel/smp-mt.c b/arch/mips/kernel/smp-mt.c
index 5f04a0141..d584322aa 100644
--- a/arch/mips/kernel/smp-mt.c
+++ b/arch/mips/kernel/smp-mt.c
@@ -107,6 +107,10 @@ static void __init smvp_tc_init(unsigned int tc, unsigned int mvpconf0)
 
 static void vsmp_init_secondary(void)
 {
+#ifdef CONFIG_MIPS_TC3262
+	write_c0_status((read_c0_status() & ~ST0_IM ) |
+	                (STATUSF_IP0 | STATUSF_IP1));
+#else
 	/* This is Malta specific: IPI,performance and timer interrupts */
 	if (mips_gic_present())
 		change_c0_status(ST0_IM, STATUSF_IP2 | STATUSF_IP3 |
@@ -115,6 +119,7 @@ static void vsmp_init_secondary(void)
 	else
 		change_c0_status(ST0_IM, STATUSF_IP0 | STATUSF_IP1 |
 					 STATUSF_IP6 | STATUSF_IP7);
+#endif
 }
 
 static void vsmp_smp_finish(void)
diff --git a/arch/mips/kernel/vmlinux.lds.S b/arch/mips/kernel/vmlinux.lds.S
index f185a85a2..2621ac0d2 100644
--- a/arch/mips/kernel/vmlinux.lds.S
+++ b/arch/mips/kernel/vmlinux.lds.S
@@ -19,6 +19,10 @@
 
 #undef mips
 #define mips mips
+#if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+#undef CONFIG_IMEM_SIZE
+#define CONFIG_IMEM_SIZE 65536
+#endif
 OUTPUT_ARCH(mips)
 ENTRY(kernel_entry)
 PHDRS {
@@ -70,7 +74,21 @@ SECTIONS
 		*(.fixup)
 		*(.gnu.warning)
 	} :text = 0
+
+#ifdef CONFIG_TC3162_IMEM
+#ifdef CONFIG_CPU_TC3162
+  	. = ALIGN(16384);
+#else
+  	. = ALIGN(32768);
+#endif
+  	__imem = . ;
+  	.imem_text : { *(.imem_text) }
+  	_imem_end = .;
+  	_etext = (__imem + CONFIG_IMEM_SIZE) > . ? (__imem + CONFIG_IMEM_SIZE) : .;
+  	. = _etext;
+#else
 	_etext = .;	/* End of text section */
+#endif  
 
 	EXCEPTION_TABLE(16)
 
diff --git a/arch/mips/pci/Makefile b/arch/mips/pci/Makefile
index f3eecc065..8a5ee4b22 100644
--- a/arch/mips/pci/Makefile
+++ b/arch/mips/pci/Makefile
@@ -7,6 +7,18 @@ obj-y				+= pci.o
 obj-$(CONFIG_PCI_DRIVERS_LEGACY)+= pci-legacy.o
 obj-$(CONFIG_PCI_DRIVERS_GENERIC)+= pci-generic.o
 
+obj-$(CONFIG_MIPS_TC3162)	+= ops-tc3162.o pci-tc3162.o fixup-tc3162.o
+ifdef CONFIG_MIPS_TC3262 
+EXTRA_CFLAGS += -DPCIE_PCI_COEXIT
+endif
+obj-$(CONFIG_MIPS_TC3262)	+= ops-tc3162u.o pci-tc3162u.o fixup-tc3162u.o pcie-phy.o
+obj-$(CONFIG_MIPS_TC3262)       += ops-tc3162.o pci-tc3162.o fixup-tc3162.o pci-7512api.o
+ifdef CONFIG_MIPS_TC3162U
+EXTRA_CFLAGS += -DPCIE_PCI_COEXIT
+endif
+obj-$(CONFIG_MIPS_TC3162U)	+= ops-tc3162u.o pci-tc3162u.o fixup-tc3162u.o pcie-phy.o
+obj-$(CONFIG_MIPS_TC3162U)	+= ops-tc3162.o pci-tc3162.o fixup-tc3162.o
+
 #
 # PCI bus host bridge specific code
 #
diff --git a/arch/mips/tc3162/Makefile b/arch/mips/tc3162/Makefile
new file mode 100755
index 000000000..6ade19c7e
--- /dev/null
+++ b/arch/mips/tc3162/Makefile
@@ -0,0 +1,8 @@
+obj-y := \
+	prom.o \
+	setup.o \
+	irq.o
+obj-$(CONFIG_MIPS_TC3162)	+= time.o
+obj-$(CONFIG_MIPS_TC3162U)	+= time.o
+obj-$(CONFIG_MIPS_TC3262)	+= time2.o
+obj-$(CONFIG_MIPS_MT_SMP)	+= malta-smp.o
diff --git a/arch/mips/tc3162/Platform b/arch/mips/tc3162/Platform
new file mode 100755
index 000000000..4e5082249
--- /dev/null
+++ b/arch/mips/tc3162/Platform
@@ -0,0 +1,11 @@
+#
+# Ralink boards
+#
+platform-$(CONFIG_MIPS_TC3262)	+= ralink/ softfloat/
+cflags-$(CONFIG_MIPS_TC3262)	+= -I$(srctree)/arch/mips/include/asm/tc3162/
+ifneq ($(strip $(TCSUPPORT_FREE_BOOTBASE)),)
+load-$(CONFIG_MIPS_TC3262) += $(KERNEL_START_ADDR)
+else
+load-$(CONFIG_MIPS_TC3262)		+= 0xffffffff80020000
+endif
+all-$(CONFIG_MIPS_TC3262)		:= $(COMPRESSION_FNAME).bin
diff --git a/arch/mips/tc3162/irq.c b/arch/mips/tc3162/irq.c
new file mode 100644
index 000000000..5292d8e7a
--- /dev/null
+++ b/arch/mips/tc3162/irq.c
@@ -0,0 +1,494 @@
+
+
+
+
+
+/*
+ *  Interrupt service routines for Trendchip board
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/tc3162/tc3162.h>
+#include <linux/sched.h>
+
+#ifdef CONFIG_MIPS_TC3262
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/kernel_stat.h>
+#include <linux/kernel.h>
+#include <linux/random.h>
+#include <asm/mipsmtregs.h>
+#else
+#include <linux/io.h>
+#include <asm/irq_cpu.h>
+#endif
+
+#define ALLINTS (IE_SW0 | IE_SW1 | IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4 | IE_IRQ5)
+
+#ifdef CONFIG_MIPS_TC3262
+
+static DEFINE_SPINLOCK(tc3162_irq_lock);
+
+static inline void unmask_mips_mt_irq(unsigned int irq)
+{
+	unsigned int vpflags = dvpe();
+	int cpu_irq = 0;
+
+	if ((irq == SI_SWINT1_INT1) || (irq == SI_SWINT_INT1))  
+		cpu_irq = 1;
+
+	set_c0_status(0x100 << cpu_irq);
+	irq_enable_hazard();
+	evpe(vpflags);
+}
+
+static inline void mask_mips_mt_irq(unsigned int irq)
+{
+	unsigned int vpflags = dvpe();
+	int cpu_irq = 0;
+
+	if ((irq == SI_SWINT1_INT1) || (irq == SI_SWINT_INT1))  
+		cpu_irq = 1;
+
+	clear_c0_status(0x100 << cpu_irq);
+	irq_disable_hazard();
+	evpe(vpflags);
+}
+
+static unsigned int mips_mt_cpu_irq_startup(unsigned int irq)
+{
+	unsigned int vpflags = dvpe();
+	unsigned long int tmp;
+	int cpu_irq = 0;
+
+	if ((irq == SI_SWINT1_INT1) || (irq == SI_SWINT_INT1))  
+		cpu_irq = 1;
+#ifdef TCSUPPORT_MT7510_E1
+	READ_E1(CR_INTC_IMR);
+#endif
+	tmp = regRead32(CR_INTC_IMR);
+	tmp |= (1 << (irq-1));
+
+	if (irq == SI_SWINT_INT0){
+		tmp |= (1 << (SI_SWINT1_INT0-1));
+	}else if (irq == SI_SWINT_INT1){
+		tmp |= (1 << (SI_SWINT1_INT1-1));
+	}
+	regWrite32(CR_INTC_IMR, tmp);
+
+	clear_c0_cause(0x100 << cpu_irq);
+	evpe(vpflags);
+	unmask_mips_mt_irq(irq);
+
+	return 0;
+}
+
+/*
+ * While we ack the interrupt interrupts are disabled and thus we don't need
+ * to deal with concurrency issues.  Same for mips_cpu_irq_end.
+ */
+static void mips_mt_cpu_irq_ack(unsigned int irq)
+{
+	unsigned int vpflags = dvpe();
+	int cpu_irq = 0;
+
+	if ((irq == SI_SWINT1_INT1) || (irq == SI_SWINT_INT1))  
+		cpu_irq = 1;
+
+	clear_c0_cause(0x100 << cpu_irq);
+	evpe(vpflags);
+	mask_mips_mt_irq(irq);
+}
+
+static struct irq_chip mips_mt_cpu_irq_controller = {
+	.name		= "MIPS",
+	.startup	= mips_mt_cpu_irq_startup,
+	.ack		= mips_mt_cpu_irq_ack,
+	.mask		= mask_mips_mt_irq,
+	.mask_ack	= mips_mt_cpu_irq_ack,
+	.unmask		= unmask_mips_mt_irq,
+	.eoi		= unmask_mips_mt_irq,
+};
+
+#define __BUILD_IRQ_DISPATCH(irq_n) \
+static void __tc3262_irq_dispatch##irq_n(void) \
+{								\
+	do_IRQ(irq_n);				\
+}	
+
+#define __BUILD_IRQ_DISPATCH_FUNC(irq_n)  __tc3262_irq_dispatch##irq_n 
+
+/* pre-built 64 irq dispatch function */
+__BUILD_IRQ_DISPATCH(0)
+__BUILD_IRQ_DISPATCH(1)
+__BUILD_IRQ_DISPATCH(2)
+__BUILD_IRQ_DISPATCH(3)
+__BUILD_IRQ_DISPATCH(4)
+__BUILD_IRQ_DISPATCH(5)
+__BUILD_IRQ_DISPATCH(6)
+__BUILD_IRQ_DISPATCH(7)
+__BUILD_IRQ_DISPATCH(8)
+__BUILD_IRQ_DISPATCH(9)
+__BUILD_IRQ_DISPATCH(10)
+__BUILD_IRQ_DISPATCH(11)
+__BUILD_IRQ_DISPATCH(12)
+__BUILD_IRQ_DISPATCH(13)
+__BUILD_IRQ_DISPATCH(14)
+__BUILD_IRQ_DISPATCH(15)
+__BUILD_IRQ_DISPATCH(16)
+__BUILD_IRQ_DISPATCH(17)
+__BUILD_IRQ_DISPATCH(18)
+__BUILD_IRQ_DISPATCH(19)
+__BUILD_IRQ_DISPATCH(20)
+__BUILD_IRQ_DISPATCH(21)
+__BUILD_IRQ_DISPATCH(22)
+__BUILD_IRQ_DISPATCH(23)
+__BUILD_IRQ_DISPATCH(24)
+__BUILD_IRQ_DISPATCH(25)
+__BUILD_IRQ_DISPATCH(26)
+__BUILD_IRQ_DISPATCH(27)
+__BUILD_IRQ_DISPATCH(28)
+__BUILD_IRQ_DISPATCH(29)
+__BUILD_IRQ_DISPATCH(30)
+__BUILD_IRQ_DISPATCH(31)
+__BUILD_IRQ_DISPATCH(32)
+__BUILD_IRQ_DISPATCH(33)
+__BUILD_IRQ_DISPATCH(34)
+__BUILD_IRQ_DISPATCH(35)
+__BUILD_IRQ_DISPATCH(36)
+__BUILD_IRQ_DISPATCH(37)
+__BUILD_IRQ_DISPATCH(38)
+__BUILD_IRQ_DISPATCH(39)
+__BUILD_IRQ_DISPATCH(40)
+__BUILD_IRQ_DISPATCH(41)
+__BUILD_IRQ_DISPATCH(42)
+__BUILD_IRQ_DISPATCH(43)
+__BUILD_IRQ_DISPATCH(44)
+__BUILD_IRQ_DISPATCH(45)
+__BUILD_IRQ_DISPATCH(46)
+__BUILD_IRQ_DISPATCH(47)
+__BUILD_IRQ_DISPATCH(48)
+__BUILD_IRQ_DISPATCH(49)
+__BUILD_IRQ_DISPATCH(50)
+__BUILD_IRQ_DISPATCH(51)
+__BUILD_IRQ_DISPATCH(52)
+__BUILD_IRQ_DISPATCH(53)
+__BUILD_IRQ_DISPATCH(54)
+__BUILD_IRQ_DISPATCH(55)
+__BUILD_IRQ_DISPATCH(56)
+__BUILD_IRQ_DISPATCH(57)
+__BUILD_IRQ_DISPATCH(58)
+__BUILD_IRQ_DISPATCH(59)
+__BUILD_IRQ_DISPATCH(60)
+__BUILD_IRQ_DISPATCH(61)
+__BUILD_IRQ_DISPATCH(62)
+__BUILD_IRQ_DISPATCH(63)
+
+/* register pre-built 64 irq dispatch function */
+static void (*irq_dispatch_tab[])(void) =
+{
+__BUILD_IRQ_DISPATCH_FUNC(0),
+__BUILD_IRQ_DISPATCH_FUNC(1),
+__BUILD_IRQ_DISPATCH_FUNC(2),
+__BUILD_IRQ_DISPATCH_FUNC(3),
+__BUILD_IRQ_DISPATCH_FUNC(4),
+__BUILD_IRQ_DISPATCH_FUNC(5),
+__BUILD_IRQ_DISPATCH_FUNC(6),
+__BUILD_IRQ_DISPATCH_FUNC(7),
+__BUILD_IRQ_DISPATCH_FUNC(8),
+__BUILD_IRQ_DISPATCH_FUNC(9),
+__BUILD_IRQ_DISPATCH_FUNC(10),
+__BUILD_IRQ_DISPATCH_FUNC(11),
+__BUILD_IRQ_DISPATCH_FUNC(12),
+__BUILD_IRQ_DISPATCH_FUNC(13),
+__BUILD_IRQ_DISPATCH_FUNC(14),
+__BUILD_IRQ_DISPATCH_FUNC(15),
+__BUILD_IRQ_DISPATCH_FUNC(16),
+__BUILD_IRQ_DISPATCH_FUNC(17),
+__BUILD_IRQ_DISPATCH_FUNC(18),
+__BUILD_IRQ_DISPATCH_FUNC(19),
+__BUILD_IRQ_DISPATCH_FUNC(20),
+__BUILD_IRQ_DISPATCH_FUNC(21),
+__BUILD_IRQ_DISPATCH_FUNC(22),
+__BUILD_IRQ_DISPATCH_FUNC(23),
+__BUILD_IRQ_DISPATCH_FUNC(24),
+__BUILD_IRQ_DISPATCH_FUNC(25),
+__BUILD_IRQ_DISPATCH_FUNC(26),
+__BUILD_IRQ_DISPATCH_FUNC(27),
+__BUILD_IRQ_DISPATCH_FUNC(28),
+__BUILD_IRQ_DISPATCH_FUNC(29),
+__BUILD_IRQ_DISPATCH_FUNC(30),
+__BUILD_IRQ_DISPATCH_FUNC(31),
+__BUILD_IRQ_DISPATCH_FUNC(32),
+__BUILD_IRQ_DISPATCH_FUNC(33),
+__BUILD_IRQ_DISPATCH_FUNC(34),
+__BUILD_IRQ_DISPATCH_FUNC(35),
+__BUILD_IRQ_DISPATCH_FUNC(36),
+__BUILD_IRQ_DISPATCH_FUNC(37),
+__BUILD_IRQ_DISPATCH_FUNC(38),
+__BUILD_IRQ_DISPATCH_FUNC(39),
+__BUILD_IRQ_DISPATCH_FUNC(40),
+__BUILD_IRQ_DISPATCH_FUNC(41),
+__BUILD_IRQ_DISPATCH_FUNC(42),
+__BUILD_IRQ_DISPATCH_FUNC(43),
+__BUILD_IRQ_DISPATCH_FUNC(44),
+__BUILD_IRQ_DISPATCH_FUNC(45),
+__BUILD_IRQ_DISPATCH_FUNC(46),
+__BUILD_IRQ_DISPATCH_FUNC(47),
+__BUILD_IRQ_DISPATCH_FUNC(48),
+__BUILD_IRQ_DISPATCH_FUNC(49),
+__BUILD_IRQ_DISPATCH_FUNC(50),
+__BUILD_IRQ_DISPATCH_FUNC(51),
+__BUILD_IRQ_DISPATCH_FUNC(52),
+__BUILD_IRQ_DISPATCH_FUNC(53),
+__BUILD_IRQ_DISPATCH_FUNC(54),
+__BUILD_IRQ_DISPATCH_FUNC(55),
+__BUILD_IRQ_DISPATCH_FUNC(56),
+__BUILD_IRQ_DISPATCH_FUNC(57),
+__BUILD_IRQ_DISPATCH_FUNC(58),
+__BUILD_IRQ_DISPATCH_FUNC(59),
+__BUILD_IRQ_DISPATCH_FUNC(60),
+__BUILD_IRQ_DISPATCH_FUNC(61),
+__BUILD_IRQ_DISPATCH_FUNC(62),
+__BUILD_IRQ_DISPATCH_FUNC(63)
+};
+
+#endif
+
+__IMEM static inline void unmask_mips_irq(unsigned int irq)
+{
+#ifdef CONFIG_MIPS_TC3262
+	unsigned long flags;
+	unsigned long int tmp;
+	int cpu = smp_processor_id();
+
+	spin_lock_irqsave(&tc3162_irq_lock, flags);
+#ifdef CONFIG_MIPS_MT_SMTC
+	if (cpu_data[cpu].vpe_id != 0) {
+#else
+	if (cpu != 0) {
+#endif
+		if (irq == SI_TIMER_INT)
+			irq = SI_TIMER1_INT;
+	}
+
+	if (irq <= 32)
+	{
+#ifdef TCSUPPORT_MT7510_E1
+        	READ_E1(CR_INTC_IMR);
+#endif
+		tmp = regRead32(CR_INTC_IMR);
+		tmp |=  (1 << (irq-1));
+		regWrite32(CR_INTC_IMR, tmp);
+	}else
+	{
+#ifdef TCSUPPORT_MT7510_E1
+       		READ_E1(CR_INTC_IMR_1);
+#endif
+		tmp = regRead32(CR_INTC_IMR_1);
+		tmp |=  (1 << (irq-33));
+		regWrite32(CR_INTC_IMR_1, tmp);
+	}
+	spin_unlock_irqrestore(&tc3162_irq_lock, flags);
+#else
+	VPint(CR_INTC_IMR) |=  (1 << irq);
+#endif
+}
+
+__IMEM static inline void mask_mips_irq(unsigned int irq)
+{
+#ifdef CONFIG_MIPS_TC3262
+	unsigned long flags;
+	unsigned long int tmp;
+	int cpu = smp_processor_id();
+
+	spin_lock_irqsave(&tc3162_irq_lock, flags);
+#ifdef CONFIG_MIPS_MT_SMTC
+	if (cpu_data[cpu].vpe_id != 0) {
+#else
+	if (cpu != 0) {
+#endif
+		if (irq == SI_TIMER_INT)
+			irq = SI_TIMER1_INT;
+	}
+
+	if (irq <= 32){
+#ifdef TCSUPPORT_MT7510_E1
+        	READ_E1(CR_INTC_IMR);
+#endif
+		tmp = regRead32(CR_INTC_IMR);
+		tmp &= ~(1 << (irq-1));
+		regWrite32(CR_INTC_IMR, tmp);
+	}else{
+#ifdef TCSUPPORT_MT7510_E1
+        	READ_E1(CR_INTC_IMR_1);
+#endif
+		tmp = regRead32(CR_INTC_IMR_1);
+		tmp &= ~(1 << (irq-33));
+		regWrite32(CR_INTC_IMR_1, tmp);
+	}
+	spin_unlock_irqrestore(&tc3162_irq_lock, flags);
+#else
+	VPint(CR_INTC_IMR) &= ~(1 << irq);
+#endif
+}
+
+void tc3162_enable_irq(unsigned int irq)
+{
+#ifdef CONFIG_MIPS_TC3262
+	unsigned long flags;
+	unsigned long int tmp;
+
+	spin_lock_irqsave(&tc3162_irq_lock, flags);
+	if (irq <= 32){
+#ifdef TCSUPPORT_MT7510_E1
+        	READ_E1(CR_INTC_IMR);
+#endif
+		tmp = regRead32(CR_INTC_IMR);
+		tmp |=  (1 << (irq-1));
+		regWrite32(CR_INTC_IMR, tmp);
+	}else{
+#ifdef TCSUPPORT_MT7510_E1
+        	READ_E1(CR_INTC_IMR_1);
+#endif
+		tmp = regRead32(CR_INTC_IMR_1);
+		tmp |=  (1 << (irq-33));
+		regWrite32(CR_INTC_IMR_1, tmp);
+	}
+	spin_unlock_irqrestore(&tc3162_irq_lock, flags);
+#else
+	VPint(CR_INTC_IMR) |=  (1 << irq);
+#endif
+}
+EXPORT_SYMBOL(tc3162_enable_irq);
+
+void tc3162_disable_irq(unsigned int irq)
+{
+#ifdef CONFIG_MIPS_TC3262
+	unsigned long flags;
+	unsigned long int tmp;
+
+	spin_lock_irqsave(&tc3162_irq_lock, flags);
+	if (irq <= 32){
+#ifdef TCSUPPORT_MT7510_E1
+        	READ_E1(CR_INTC_IMR);
+#endif
+		tmp = regRead32(CR_INTC_IMR);
+		tmp &= ~(1 << (irq-1));
+		regWrite32(CR_INTC_IMR, tmp);
+	}else{
+#ifdef TCSUPPORT_MT7510_E1
+        	READ_E1(CR_INTC_IMR_1);
+#endif
+		tmp = regRead32(CR_INTC_IMR_1);
+		tmp &= ~(1 << (irq-33));
+		regWrite32(CR_INTC_IMR_1, tmp);
+	}
+	spin_unlock_irqrestore(&tc3162_irq_lock, flags);
+#else
+	VPint(CR_INTC_IMR) &= ~(1 << (irq-1));
+#endif
+}
+EXPORT_SYMBOL(tc3162_disable_irq);
+
+#ifdef CONFIG_MIPS_MT_SMP
+#ifndef CONFIG_MIPS_MT_SMTC
+extern int plat_set_irq_affinity(unsigned int irq,
+				  const struct cpumask *affinity);
+#endif
+#endif
+
+static struct irq_chip tc3162_irq_chip = {
+	.name		= "MIPS",
+	.ack		= mask_mips_irq,
+	.mask		= mask_mips_irq,
+	.mask_ack	= mask_mips_irq,
+	.unmask		= unmask_mips_irq,
+	.eoi		= unmask_mips_irq,
+#ifdef CONFIG_MIPS_MT_SMTC_IRQAFF 
+	.set_affinity	= plat_set_irq_affinity,
+#else
+#ifdef CONFIG_MIPS_MT_SMP
+#ifndef CONFIG_MIPS_MT_SMTC
+	.set_affinity	= plat_set_irq_affinity,
+#endif
+#endif
+#endif /* CONFIG_MIPS_MT_SMTC_IRQAFF */
+};
+
+extern void vsmp_int_init(void);
+
+void __init arch_init_irq(void)
+{
+	unsigned int i;
+
+	/* Disable all hardware interrupts */
+	clear_c0_status(ST0_IM);
+	clear_c0_cause(CAUSEF_IP);
+
+	/* Initialize IRQ action handlers */
+	for (i = 0; i < NR_IRQS; i++) {
+#ifdef CONFIG_MIPS_TC3262
+		//TCSUPPORT_CPU_MT7505
+		#if defined(CONFIG_MIPS_MT_SMP) || defined(CONFIG_MIPS_MT_SMTC)
+		/*
+	 	 * Only MT is using the software interrupts currently, so we just
+	 	 * leave them uninitialized for other processors.
+	 	 */
+		if (cpu_has_mipsmt) {
+			if ((i == SI_SWINT1_INT0) || (i == SI_SWINT1_INT1) ||
+				(i == SI_SWINT_INT0) || (i == SI_SWINT_INT1)) { 
+				set_irq_chip(i, &mips_mt_cpu_irq_controller);
+				continue;
+			}
+		}
+
+		if ((i == SI_TIMER_INT) || (i == SI_TIMER1_INT))
+			set_irq_chip_and_handler(i, &tc3162_irq_chip,
+					 handle_percpu_irq);
+		else
+		#endif
+			set_irq_chip_and_handler(i, &tc3162_irq_chip,
+					 handle_level_irq);
+#else
+		set_irq_chip_and_handler(i, &tc3162_irq_chip,
+					 handle_level_irq);
+#endif
+	}
+
+#ifdef CONFIG_MIPS_TC3262
+	if (cpu_has_veic || cpu_has_vint) {
+		write_c0_status((read_c0_status() & ~ST0_IM ) |
+			                (STATUSF_IP0 | STATUSF_IP1)); 
+
+		/* register irq dispatch functions */
+		for (i = 0; i < NR_IRQS; i++)
+			set_vi_handler(i, irq_dispatch_tab[i]);
+	} else {
+		change_c0_status(ST0_IM, ALLINTS);
+	}
+#else
+	/* Enable all interrupts */
+	change_c0_status(ST0_IM, ALLINTS);
+#endif
+#ifdef CONFIG_MIPS_MT_SMP
+	vsmp_int_init();
+#endif
+}
+
+__IMEM asmlinkage void plat_irq_dispatch(void)
+{
+#ifdef CONFIG_MIPS_TC3262
+	int irq = ((read_c0_cause() & ST0_IM) >> 10);
+
+	do_IRQ(irq);
+#else
+	do_IRQ(VPint(CR_INTC_IVR));
+#endif
+}
+
diff --git a/arch/mips/tc3162/malta-smp.c b/arch/mips/tc3162/malta-smp.c
new file mode 100644
index 000000000..af388ff1c
--- /dev/null
+++ b/arch/mips/tc3162/malta-smp.c
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2000, 2001, 2004 MIPS Technologies, Inc.
+ * Copyright (C) 2001 Ralf Baechle
+ * Copyright (C) 2010 PMC-Sierra, Inc.
+ *
+ *  VSMP support for MSP platforms . Derived from malta vsmp support.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/smp.h>
+#include <linux/interrupt.h>
+
+#include <asm/tc3162/tc3162.h>
+
+#ifdef CONFIG_MIPS_MT_SMP
+
+#define MIPS_CPU_IPI_RESCHED_IRQ 	SI_SWINT_INT0		/* SW int 0 for resched */
+#define MIPS_CPU_IPI_CALL_IRQ 		SI_SWINT_INT1		/* SW int 1 for call */
+
+
+static void ipi_resched_dispatch(void)
+{
+	//printk("ipi_resched_dispatch\n");
+	do_IRQ(MIPS_CPU_IPI_RESCHED_IRQ);
+}
+
+static void ipi_call_dispatch(void)
+{
+	//printk("ipi_call_dispatch\n");
+	do_IRQ(MIPS_CPU_IPI_CALL_IRQ);
+}
+
+static irqreturn_t ipi_resched_interrupt(int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ipi_call_interrupt(int irq, void *dev_id)
+{
+	smp_call_function_interrupt();
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction irq_resched = {
+	.handler	= ipi_resched_interrupt,
+	.flags		= IRQF_DISABLED | IRQF_PERCPU,
+	.name		= "IPI_resched"
+};
+
+static struct irqaction irq_call = {
+	.handler	= ipi_call_interrupt,
+	.flags		= IRQF_DISABLED | IRQF_PERCPU,
+	.name		= "IPI_call"
+};
+
+void __init arch_init_ipiirq(int irq, struct irqaction *action)
+{
+	setup_irq(irq, action);
+	set_irq_handler(irq, handle_percpu_irq);
+}
+
+void __init vsmp_int_init(void)
+{
+	//printk("vsmp_int_init\n");
+	set_vi_handler(MIPS_CPU_IPI_RESCHED_IRQ, ipi_resched_dispatch);
+	set_vi_handler(MIPS_CPU_IPI_CALL_IRQ, ipi_call_dispatch);
+	arch_init_ipiirq(MIPS_CPU_IPI_RESCHED_IRQ, &irq_resched);
+	arch_init_ipiirq(MIPS_CPU_IPI_CALL_IRQ, &irq_call);
+
+	VPint(CR_INTC_IMR) |=  (1 << (SI_SWINT1_INT0-1));
+   	VPint(CR_INTC_IMR) |=  (1 << (SI_SWINT1_INT1-1));
+}
+
+int plat_set_irq_affinity(unsigned int irq, const struct cpumask *affinity)
+{
+	cpumask_t tmask;
+	int cpu = 0;
+	//void smtc_set_irq_affinity(unsigned int irq, cpumask_t aff);
+	int irq_vpe0 = 0;
+	int irq_vpe1 = 0;
+	unsigned int offset1, offset2, tmp;
+
+#if 0
+	printk("\r\n\r\n%s affinity origin value is %08x\r\n\r\n", __FUNCTION__, *affinity);
+
+	if(*(unsigned long *)affinity == 0x8)
+	{
+		*(unsigned long *)affinity = 0x2;
+	}
+	else if(*(unsigned long *)affinity == 0xf)
+	{
+		*(unsigned long *)affinity = 0x3;
+	}
+	else
+	{
+		*(unsigned long *)affinity = 0x1;
+	}
+	
+	printk("\r\n\r\n%s affinity changed value is %08x\r\n\r\n", __FUNCTION__, *affinity);
+#endif
+
+	/*
+	 * On the legacy Malta development board, all I/O interrupts
+	 * are routed through the 8259 and combined in a single signal
+	 * to the CPU daughterboard, and on the CoreFPGA2/3 34K models,
+	 * that signal is brought to IP2 of both VPEs. To avoid racing
+	 * concurrent interrupt service events, IP2 is enabled only on
+	 * one VPE, by convention VPE0.  So long as no bits are ever
+	 * cleared in the affinity mask, there will never be any
+	 * interrupt forwarding.  But as soon as a program or operator
+	 * sets affinity for one of the related IRQs, we need to make
+	 * sure that we don't ever try to forward across the VPE boundry,
+	 * at least not until we engineer a system where the interrupt
+	 * _ack() or _end() function can somehow know that it corresponds
+	 * to an interrupt taken on another VPE, and perform the appropriate
+	 * restoration of Status.IM state using MFTR/MTTR instead of the
+	 * normal local behavior. We also ensure that no attempt will
+	 * be made to forward to an offline "CPU".
+	 */
+
+	cpumask_copy(&tmask, affinity);
+	for_each_cpu(cpu, affinity) {
+		printk("%s: cpu %d \r\n", __FUNCTION__, cpu);
+		if (!cpu_online(cpu))
+		{
+			cpu_clear(cpu, tmask);
+			printk("%s: cpu %d cpu_clear\r\n", __FUNCTION__, cpu);
+			
+		}
+		else {
+			printk("%s: cpu %d vpe_id %d \r\n", __FUNCTION__, cpu, cpu_data[cpu].vpe_id);
+#if 0			
+			if (cpu_data[cpu].vpe_id == 0)
+				irq_vpe0++;
+			else 
+				irq_vpe1++;
+#else
+			if(cpu == 0)
+				irq_vpe0++;
+			else 
+				irq_vpe1++;
+#endif
+		}
+
+	}
+	cpumask_copy(irq_desc[irq].affinity, &tmask);
+
+	printk("%s: irq_vpe0 %d irq_vpe1 %d \r\n", __FUNCTION__, irq_vpe0, irq_vpe1);
+	
+
+	/* change IRQ binding to VPE0 or VPE1 */
+	offset1= 32 - irq;
+	offset2 = ((irq - 1) % 4) * 8 + 4;
+	offset1 = (offset1 >> 2) << 2;
+	tmp = regRead32((CR_INTC_IVSR0 + offset1));
+	if (irq_vpe0 >= irq_vpe1)
+		tmp &= ~(1<<offset2);
+	else
+		tmp |= (1<<offset2);
+	regWrite32((CR_INTC_IVSR0 + offset1), tmp);
+	if (cpus_empty(tmask))
+		/*
+		 * We could restore a default mask here, but the
+		 * runtime code can anyway deal with the null set
+		 */
+		printk(KERN_WARNING
+			"IRQ affinity leaves no legal CPU for IRQ %d\n", irq);
+
+	/* Do any generic SMTC IRQ affinity setup */
+	//smtc_set_irq_affinity(irq, tmask);
+	printk("%s: irq num %d \r\n", __FUNCTION__, irq);
+	return 0;
+}
+
+#endif /* CONFIG_MIPS_MT_SMP */
+
diff --git a/arch/mips/tc3162/prom.c b/arch/mips/tc3162/prom.c
new file mode 100644
index 000000000..28047b556
--- /dev/null
+++ b/arch/mips/tc3162/prom.c
@@ -0,0 +1,505 @@
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+#include <linux/blkdev.h>
+
+#include <asm/mipsmtregs.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/time.h>
+#include <asm/tc3162/tc3162.h>
+#include <asm/traps.h>
+
+extern int __imem, __dmem;
+
+static void tc3162_component_setup(void)
+{
+	unsigned int controlReg;
+	unsigned long flags;
+
+	/* setup bus timeout value */
+	VPint(CR_AHB_AACS) = 0xffff;
+
+	/* reset hwnat */
+	if (isRT65168) {
+		/* table reset */
+		VPint(0xbfbe0024) = 0x0;
+		VPint(0xbfbe0024) = 0xffff;
+
+		/* hwnat swreset */
+		VPint(0xbfbe0000) = (1<<1);
+	}
+
+#ifdef CONFIG_CPU_TC3162
+#ifdef CONFIG_TC3162_IMEM
+	/* setup imem start address */
+	VPint(CR_IMEM) = CPHYSADDR(&__imem);
+
+	/* clear internal imem */
+	local_irq_save(flags);
+	controlReg = read_c0_cctl();
+	write_c0_cctl(controlReg & ~CCTL_IMEMOFF);
+	write_c0_cctl(controlReg | CCTL_IMEMOFF);
+	write_c0_cctl(controlReg);
+	local_irq_restore(flags);
+
+	/* refill internal imem */
+	local_irq_save(flags);
+	controlReg = read_c0_cctl();
+	write_c0_cctl(controlReg & ~CCTL_IMEMFILL4);
+	write_c0_cctl(controlReg | CCTL_IMEMFILL4);
+	write_c0_cctl(controlReg);
+	local_irq_restore(flags);
+
+	printk("Enable IMEM addr=%x\n", CPHYSADDR(&__imem));
+#endif
+
+#ifdef CONFIG_TC3162_DMEM
+	/* setup dmem start address */
+	VPint(CR_DMEM) = CPHYSADDR(&__dmem);
+
+	memcpy((void *) 0xa0001000, (void *) KSEG1ADDR(&__dmem), 0x800);
+
+	/* clear internal dmem */
+	local_irq_save(flags);
+	controlReg = read_c0_cctl();
+	write_c0_cctl(controlReg & ~CCTL_DMEMOFF);
+	write_c0_cctl(controlReg | CCTL_DMEMOFF);
+	write_c0_cctl(controlReg);
+	local_irq_restore(flags);
+
+	/* internal dmem on */
+	local_irq_save(flags);
+	controlReg = read_c0_cctl();
+	write_c0_cctl(controlReg & ~CCTL_DMEMON);
+	write_c0_cctl(controlReg | CCTL_DMEMON);
+	write_c0_cctl(controlReg);
+	local_irq_restore(flags);
+
+	printk("Enable DMEM addr=%x\n", CPHYSADDR(&__dmem));
+
+	memcpy((void *) KSEG1ADDR(&__dmem), (void *) 0xa0001000, 0x800);
+#endif
+#endif
+}
+
+/* flash_base is not used. Keept for reference. */
+static unsigned long flash_base;
+// EXPORT_SYMBOL(flash_base);
+void flash_init(void)
+{
+
+	if ((IS_NANDFLASH) && (isRT63165 || isRT63365 || isMT751020)) {
+		flash_base = 0x0;
+	} else {
+#ifdef TCSUPPORT_ADDR_MAPPING
+		if(isMT751020 || isMT7505 || isEN751221){
+			flash_base = 0xbc000000;
+			printk("%s: flash_base:%x \n",__func__,flash_base);
+		}
+		else if (isTC3162U || isRT63260 || isRT65168 || isTC3182 || isRT63165 || isRT63365)
+#else
+		if (isTC3162U || isRT63260 || isRT65168 || isTC3182 || isRT63165 || isRT63365 || isMT751020 || isMT7505 || isEN751221)
+#endif
+			flash_base = 0xb0000000;
+		else
+			flash_base = 0xbfc00000;
+		printk("%s: flash_base:%x \n",__func__,flash_base);
+	}
+}
+
+const char *get_system_type(void)
+{
+#ifdef CONFIG_MIPS_TC3262
+	if (isEN751221) {
+		return "EcoNet EN751221 SOC";
+	}else if (isTC3182)
+		return "TrendChip TC3182 SOC";
+	else if (isRT65168)
+		return "Ralink RT65168 SOC";
+	else if (isRT63165){
+		return "Ralink RT63165 SOC";
+	} else if (isRT63365) {
+#ifdef TCSUPPORT_DYING_GASP
+		if(!isRT63368){
+			//gpio 4 is share pin for rt63365.
+			VPint(0xbfb00860) &= ~(1<<13);//disable port 4 led when use rt63365.
+		}
+#endif
+		return "Ralink RT63365 SOC";
+	}else if (isMT751020){
+		return "Ralink MT751020 SOC";
+	}else if (isMT7505){
+		return "Ralink MT7505 SOC";
+	}
+	else
+		return "TrendChip TC3169 SOC";
+#else
+	if (isRT63260)
+		return "Ralink RT63260 SOC";
+	else if (isTC3162U)
+		return "TrendChip TC3162U SOC";
+	else if (isTC3162L5P5)
+		return "TrendChip TC3162L5/P5 SOC";
+	else if (isTC3162L4P4)
+		return "TrendChip TC3162L4/P4 SOC";
+	else if (isTC3162L3P3)
+		return "TrendChip TC3162L2F/P2F";
+	else if (isTC3162L2P2)
+		return "TrendChip TC3162L2/P2";
+	else
+		return "TrendChip TC3162";
+#endif
+}
+
+extern struct plat_smp_ops msmtc_smp_ops;
+#define VECTORSPACING 0x100	/* for EI/VI mode */
+
+
+void __init mips_nmi_setup (void)
+{
+	void *base;
+	extern char except_vec_nmi;
+	#if 0
+	base = cpu_has_veic ?
+		(void *)(CAC_BASE + 0xa80) :
+		(void *)(CAC_BASE + 0x380);
+	#endif
+
+	base = cpu_has_veic ?
+		(void *)(ebase + 0x200 + VECTORSPACING*64) :
+		(void *)(ebase + 0x380);
+
+	printk("nmi base is %x\n",base);
+
+	//Fill the NMI_Handler address in a register, which is a R/W register
+	//start.S will read it, then jump to NMI_Handler address
+	VPint(0xbfb00244) = base;
+
+	memcpy(base, &except_vec_nmi, 0x80);
+	flush_icache_range((unsigned long)base, (unsigned long)base + 0x80);
+}
+
+void cpu_dma_round_robin(uint8 mode)
+{
+    uint32 reg_value = 0;
+    reg_value = VPint(ARB_CFG);
+    if(mode == ENABLE) {
+        reg_value |= ROUND_ROBIN_ENABLE;
+    } else {
+        reg_value &= ROUND_ROBIN_DISBALE;
+    }
+    VPint(ARB_CFG) = reg_value;
+}
+
+void __init prom_init(void)
+{
+	unsigned long memsize;
+	unsigned char samt;
+	unsigned long col;
+	unsigned long row;
+
+	flash_init();
+
+#ifdef CONFIG_MIPS_TC3262
+	if (isRT63165 || isRT63365 || isMT751020 || isMT7505 || isEN751221) {
+		/* enable external sync */
+#ifdef TCSUPPORT_IS_FH_PON
+		strcat(arcs_cmdline, "rootfstype=jffs2 ro init=/etc/preinit.sh");
+#endif
+		strcat(arcs_cmdline, " es=1");
+
+#ifndef CONFIG_SMP
+	{
+		/* when kernel is UP, set ES=1. Otherwise, set in mips_mt_set_cpuoptions */
+		unsigned int oconfig7 = read_c0_config7();
+		unsigned int nconfig7 = oconfig7;
+
+		nconfig7 |= (1 << 8);
+
+		__asm__ __volatile("sync");
+		write_c0_config7(nconfig7);
+		ehb();
+		printk("Config7: 0x%08x\n", read_c0_config7());
+	}
+#endif
+	}
+
+	if(isMT751020){
+		memsize = 0x800000 * (1 << (((VPint(0xbfb0008c) >> 13) & 0x7) - 1));
+		if(memsize >= (448<<20)){
+			memsize = (448<<20);
+		}
+		printk("memsize:%dMB\n", (memsize>>20));
+	}
+	else if(isMT7505){
+		if(isFPGA)
+			memsize = 0x800000 * (1 << (((VPint(0xbfb0008c) >> 13) & 0x7) - 1));
+		else{
+			if(VPint(CR_AHB_HWCONF) & (1<<10))
+			{
+				/* DDR1 */
+				memsize = 0x4000000 / (1 << ((VPint(CR_AHB_HWCONF) >> 11) & 0x3));
+			}
+			else{
+				/* DDR2 */
+				if(!((VPint(CR_AHB_HWCONF) >> 11) & 0x3))
+					memsize = 256 * 0x100000;
+				if(((VPint(CR_AHB_HWCONF) >> 11) & 0x3) == 0x1)
+					memsize = 32 * 0x100000;
+				if(((VPint(CR_AHB_HWCONF) >> 11) & 0x3) == 0x2)
+					memsize =  128 * 0x100000;
+				else
+					memsize = 64 * 0x100000;
+			}
+		}
+		printk("memsize:%dMB\n", (memsize>>20));
+
+	}else if(isEN751221){
+		if(isFPGA){
+ 			memsize = 0x800000 * (1 << (((VPint(0xbfb0008c) >> 13) & 0x7) - 1));
+		}
+ 		else{
+			memsize = GET_DRAM_SIZE;
+			if(memsize == 512) {
+				memsize = 440; /* always reserve 8M to QDMA HW when memsize if 512MByte */
+			}
+#ifndef TCSUPPORT_SLM_EN
+			else {
+				memsize = memsize-8; /* without SLM, we should reserve 8M to QDMA HW */
+			}
+#endif
+			memsize = memsize << 20;
+		}
+		printk("memsize:%dMB\n", (memsize>>20));
+	}else if (isRT63165 || isRT63365) {
+		/* DDR */
+		if (VPint(CR_AHB_HWCONF) & (1<<25)) {
+			memsize = 0x800000 * (1 << (((VPint(CR_DMC_DDR_CFG1) >> 18) & 0x7) - 1));
+
+		/* SDRAM */
+		} else {
+			unsigned long sdram_cfg1;
+
+			/* calculate SDRAM size */
+			sdram_cfg1 = VPint(0xbfb20004);
+			row = 11 + ((sdram_cfg1>>16) & 0x3);
+			col = 8 + ((sdram_cfg1>>20) & 0x3);
+			/* 4 bands and 16 bit width */
+			memsize = (1 << row) * (1 << col) * 4 * 2;
+		}
+	} else {
+		memsize = 0x800000 * (1 << (((VPint(CR_DMC_CTL1) >> 18) & 0x7) - 1));
+	}
+#else
+	/* calculate SDRAM size */
+	samt = VPchar(CR_DMC_SAMT);
+	row = 8 + (samt & 0x3);
+	col = 11 + ((samt>>2) & 0x3);
+	/* 4 bands and 16 bit width */
+	memsize = (1 << row) * (1 << col) * 4 * 2;
+#endif
+
+	printk("%s prom init\n", get_system_type());
+
+	tc3162_component_setup();
+
+	add_memory_region(0 + 0x20000, memsize - 0x20000, BOOT_MEM_RAM);
+	if (isMT751020 || isMT7505 || isEN751221) {
+		board_nmi_handler_setup = mips_nmi_setup;
+	}
+
+	//mips_machgroup = MACH_GROUP_TRENDCHIP;
+	//mips_machtype = MACH_TRENDCHIP_TC3162;
+
+#ifdef CONFIG_MIPS_MT_SMP
+	register_smp_ops(&vsmp_smp_ops);
+#endif
+    if(isEN751221)
+		cpu_dma_round_robin(ENABLE);
+}
+
+void __init prom_free_prom_memory(void)
+{
+	/* We do not have any memory to free */
+}
+
+int prom_putchar(char data)
+{
+	while (!(LSR_INDICATOR & LSR_THRE))
+		;
+	VPchar(CR_UART_THR) = data;
+	return 1;
+}
+EXPORT_SYMBOL(prom_putchar);
+
+char prom_getchar(void)
+{
+	while (!(LSR_INDICATOR & LSR_RECEIVED_DATA_READY))
+		;
+	return VPchar(CR_UART_RBR);
+}
+
+static char ppbuf[1024];
+
+void
+prom_write(const char *buf, unsigned int n)
+{
+	char ch;
+
+	while (n != 0) {
+		--n;
+		if ((ch = *buf++) == '\n')
+			prom_putchar('\r');
+		prom_putchar(ch);
+	}
+}
+EXPORT_SYMBOL(prom_write);
+
+void
+prom_printf(const char *fmt, ...)
+{
+	va_list args;
+	int i;
+
+	va_start(args, fmt);
+	i = vscnprintf(ppbuf, sizeof(ppbuf), fmt, args);
+	va_end(args);
+
+	prom_write(ppbuf, i);
+}
+EXPORT_SYMBOL(prom_printf);
+
+#ifdef CONFIG_KGDB
+static unsigned long  uclk_65000[13]={
+	357500, 	// uclk 5.5     Baud Rate 115200
+	175500, 	// uclk 2.7     Baud Rate 57600
+	119808, 	// uclk 1.8432  Baud Rate 38400
+	89856,	// uclk	1.3824	Baud Rate 28800
+	59904,	// uclk 0.9216	Baud Rate 19200
+	44928,	// uclk 0.6912	Baud Rate 14400
+	29952,	// uclk 0.4608	Baud Rate 9600
+	14976,	// uclk 0.2304	Baud Rate 4800
+	7488,	// uclk 0.1152	Baud Rate 2400
+	3744,	// uclk 0.0576	Baud Rate 1200
+	1872,	// uclk 0.0288	Baud Rate 600
+	936,		// uclk 0.0144	Baud Rate 300
+	343		// uclk 0.00528	Baud Rate 110
+};
+
+static void hsuartInit(void)
+{
+	unsigned long	div_x,div_y;
+	unsigned long	word;
+	unsigned long   tmp;
+
+	tmp = VPint(CR_GPIO_CTRL);
+	tmp &= ~0x0fa30000;
+	tmp |= 0x0fa30000;
+	VPint(CR_GPIO_CTRL) = tmp; // set GPIO pin 13 & pin 12 are alternative outputs, GPIO pin 11 & pin 10 are alternative inputs
+	tmp = VPint(CR_GPIO_ODRAIN);
+	tmp &= ~0x00003000;
+	tmp |= 0x00003000;
+	VPint (CR_GPIO_ODRAIN) = tmp; // set GPIO output enable
+
+// Set FIFO controo enable, reset RFIFO, TFIFO, 16550 mode, watermark=0x00 (1 byte)
+	VPchar(CR_HSUART_FCR) = UART_FCR|UART_WATERMARK;
+
+// Set modem control to 0
+	VPchar(CR_HSUART_MCR) = UART_MCR;
+
+// Disable IRDA, Disable Power Saving Mode, RTS , CTS flow control
+	VPchar(CR_HSUART_MISCC) = UART_MISCC;
+
+	/* access the bardrate divider */
+	VPchar(CR_HSUART_LCR) = UART_BRD_ACCESS;
+
+	div_y = UART_XYD_Y;
+	div_x = (unsigned int)(uclk_65000[0]/SYS_HCLK)*2;
+	word = (div_x<<16)|div_y;
+	VPint(CR_HSUART_XYD) = word;
+
+/* Set Baud Rate Divisor to 3*16		*/
+	VPchar(CR_HSUART_BRDL) = UART_BRDL;
+	VPchar(CR_HSUART_BRDH) = UART_BRDH;
+
+/* Set DLAB = 0, clength = 8, stop =1, no parity check 	*/
+	VPchar(CR_HSUART_LCR) = UART_LCR;
+
+// Set interrupt Enable to, enable Tx, Rx and Line status
+	VPchar(CR_HSUART_IER) = UART_IER;
+}
+
+static int hsuartInitialized = 0;
+
+int putDebugChar(char c)
+{
+	if (!hsuartInitialized) {
+		hsuartInit();
+		hsuartInitialized = 1;
+	}
+
+	while (!(VPchar(CR_HSUART_LSR) & LSR_THRE))
+		;
+	VPchar(CR_HSUART_THR) = c;
+
+	return 1;
+}
+
+char getDebugChar(void)
+{
+	if (!hsuartInitialized) {
+		hsuartInit();
+		hsuartInitialized = 1;
+	}
+
+	while (!(VPchar(CR_HSUART_LSR) & LSR_RECEIVED_DATA_READY))
+		;
+	return VPchar(CR_HSUART_RBR);
+}
+#endif
+#if defined(TCSUPPORT_DYING_GASP) && (defined(CONFIG_MIPS_RT65168) || defined(CONFIG_MIPS_RT63365))
+__IMEM
+void dying_gasp_setup_mem_cpu(void){
+#ifdef CONFIG_MIPS_RT65168
+		VPint(0xbfb20000) |= (1<<12); //set ddr to self refresh mode.
+		VPint(0xbfb000c0) &= ~((1<<5)|(1<<6)|(1<<7));//CPU divide to 32 and ram divide to 3
+		VPint(0xbfb000c0) |= (1<<3)|(1<<4)|(1<<5)|(1<<7);
+#endif
+#ifdef CONFIG_MIPS_RT63365
+
+
+#if defined(TCSUPPORT_CPU_MT7510)|| defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7505) || defined(TCSUPPORT_CPU_EN7512)
+
+#ifdef TCSUPPORT_CPU_EN7512
+                  /*FDIV down freq*/
+                   VPint(0xbfa200d0) = 0x2000; /*FNDIV, clock /2*/
+                   VPint(0xbfa20148) = 0xffff800c;
+                   VPint(0xbfa20148) = 0xffff000c;
+#endif
+
+                  VPint(0xbfb00044) = 1; //Enable DDR Self Refresh Mode
+		VPint(0xbfb20004) &= ~(1<<15);
+		VPint(0xbfb200e4) &= ~(1<<2);
+		VPint(0xbfb00074) |= (1<<4);
+		VPint(0xbfb00040) |= (1<<0); // reset ddr device
+
+
+
+
+#else
+		VPint(0xbfb00040) |= (1<<0); // reset ddr device
+		//do not kill CPU because we need do watchdog interrupt
+		//kill CPU
+		//VPint(0xbfb001c8) |= (1<<24); // bypass pll 2 700M
+		//VPint(0xbfb001cc) |= (1<<24); // bypass pll 2 665M
+		//VPint(0xbfb001d0) |= (1<<24); // bypass pll 2 500
+#endif
+#endif
+	if (cpu_wait)
+		(*cpu_wait)();
+}
+EXPORT_SYMBOL(dying_gasp_setup_mem_cpu);
+#endif
diff --git a/arch/mips/tc3162/setup.c b/arch/mips/tc3162/setup.c
new file mode 100644
index 000000000..d59f8c1ff
--- /dev/null
+++ b/arch/mips/tc3162/setup.c
@@ -0,0 +1,128 @@
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+
+// There is no header in linux5.
+// #include <asm/mips-boards/prom.h>
+#include <asm/reboot.h>
+#include <asm/time.h>
+#include <asm/tc3162/tc3162.h>
+
+static void tc3162_machine_restart(char *command);
+static void tc3162_machine_halt(void);
+static void tc3162_machine_power_off(void);
+
+void (*back_to_prom)(void) = (void (*)(void))0xbfc00000;
+
+extern void timerSet(uint32 timer_no, uint32 timerTime, uint32 enable, uint32 mode, uint32 halt);
+extern void timer_WatchDogConfigure(uint8 tick_enable, uint8 watchdog_enable);
+
+static void hw_reset(void)
+{
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_POWERSAVE_ENABLE)
+	if(isRT63365){
+		VPint(CR_AHB_CLK) |= 0x57e1;//restore ahb clk to default value
+	}
+
+#endif
+	/* stop each module dma task */
+	VPint(CR_INTC_IMR) = 0x0;
+	VPint(CR_TIMER_CTL) = 0x0;
+
+	/* stop mac dma */
+#ifndef CONFIG_MIPS_TC3262
+	VPint(CR_MAC_MACCR) = 0;
+#endif
+
+	if (isRT63165)
+		goto watchdog_reset;
+
+	/* stop atm sar dma */
+	TSARM_GFR &= ~((1 << 1) | (1 << 0));
+
+	/* reset USB */
+	/* reset USB DMA */
+	VPint(CR_USB_SYS_CTRL_REG) |= (1 << 31);
+	/* reset USB SIE */
+	VPint(CR_USB_DEV_CTRL_REG) |= (1 << 30);
+	mdelay(5);
+
+	/* restore USB SIE */
+	VPint(CR_USB_DEV_CTRL_REG) &= ~(1 << 30);
+	mdelay(5);
+	VPint(CR_USB_SYS_CTRL_REG) &= ~(1 << 31);
+
+#ifdef CONFIG_MIPS_TC3162U
+	/*stop pcie*/
+	VPint(CR_AHB_PCIC) &= 0x9fffffff;
+	/*reset usb 2.0 device*/
+	/*stop interrupt*/
+	VPint(CR_USB20_INTR_ENABLE_REG) = 0x0;
+	/*do usb reset*/
+	VPint(CR_USB20_SYS_CTRL_REG) |= (1 << 31);
+	mdelay(1);
+	VPint(CR_USB20_SYS_CTRL_REG) &= ~(1 << 31);
+	/*sw disconnect*/
+	VPint(CR_USB20_DEV_CTRL_REG) |= (1 << 31);
+#endif
+
+watchdog_reset:
+	/* watchdog reset */
+//#ifdef CONFIG_MIPS_TC3262
+#if defined(TCSUPPORT_WLAN_MT7592_PCIE) && defined(TCSUPPORT_CPU_MT7520)
+	printk("0xbfb00834=0xeff88ce0 \n");
+	VPint(CR_INTC_IMR) = 0x0;
+	VPint(CR_TIMER_CTL) = 0x0;
+#endif
+	timerSet(5, 10 * TIMERTICKS_10MS, ENABLE, TIMER_TOGGLEMODE, TIMER_HALTDISABLE);
+	timer_WatchDogConfigure(ENABLE, ENABLE);
+#if defined(TCSUPPORT_WLAN_MT7592_PCIE) && defined(TCSUPPORT_CPU_MT7520)
+	VPint(0xbfb00834) = 0xeff88ce0;
+#endif
+#if defined(TCSUPPORT_CPU_MT7505) || defined(TCSUPPORT_CPU_MT7510)
+	VPint(CR_DRAMC_CONF) &= ~(0x1<<2);
+#endif
+
+	while (1);
+//#endif
+}
+
+static void tc3162_machine_restart(char *command)
+{
+	printk("Machine restart ... \n");
+	hw_reset();
+	back_to_prom();
+}
+
+static void tc3162_machine_halt(void)
+{
+	printk("Machine halted ... \n");
+	hw_reset();
+	while (1);
+}
+
+static void tc3162_machine_power_off(void)
+{
+	printk("Machine poweroff ... \n");
+	hw_reset();
+	while (1);
+}
+
+static int panic_event(struct notifier_block *this, unsigned long event,
+		       void *ptr)
+{
+	tc3162_machine_restart(NULL);
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block panic_block = {
+	.notifier_call = panic_event,
+};
+
+void __init plat_mem_setup(void)
+{
+	_machine_restart = tc3162_machine_restart;
+	_machine_halt = tc3162_machine_halt;
+	pm_power_off = tc3162_machine_power_off;
+	atomic_notifier_chain_register(&panic_notifier_list, &panic_block);
+}
diff --git a/arch/mips/tc3162/time.c b/arch/mips/tc3162/time.c
new file mode 100644
index 000000000..a58326d3d
--- /dev/null
+++ b/arch/mips/tc3162/time.c
@@ -0,0 +1,87 @@
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/time.h>
+#include <linux/types.h>
+
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/sections.h>
+#include <asm/time.h>
+#include <asm/tc3162/tc3162.h>
+
+void
+timer_Configure(
+	uint8  timer_no, 
+	uint8 timer_enable, 
+	uint8 timer_mode, 
+	uint8 timer_halt
+)
+{
+    uint32 word,word1;
+    word = VPint(CR_TIMER_CTL);
+    word1 = (timer_enable << timer_no)|(timer_mode << (timer_no + 8))|(timer_halt << (timer_no + 26));
+    word |= word1;
+    VPint (CR_TIMER_CTL)=word;    
+} 
+
+void 
+timerSet(
+	uint32 timer_no,
+	uint32 timerTime, 
+	uint32 enable,
+	uint32 mode, 
+	uint32 halt
+)
+{   
+    uint32 word;
+
+    word = (timerTime * SYS_HCLK) * 1000 /2; 
+    timerLdvSet(timer_no,word);
+    timerCtlSet(timer_no,enable,mode,halt);
+}
+
+void
+timer_WatchDogConfigure (
+	uint8 tick_enable, 
+	uint8 watchdog_enable
+)
+{
+    uint32 word;
+    word = VPint(CR_TIMER_CTL);
+	word &= 0xfdffffdf;
+    word |= ( tick_enable << 5)|(watchdog_enable<<25);
+    VPint (CR_TIMER_CTL)=word;
+}
+
+static void tc3162_timer_ack(void)
+{
+	uint32 word;
+
+	word = VPint(CR_TIMER_CTL);
+	word &= 0xffc0ffff;
+	word |= 0x00020000;
+	VPint(CR_TIMER_CTL) = word; 
+}
+
+void __init tc3162_time_init(void)
+{
+	//mips_timer_state = tc3162_timer_state;
+	mips_timer_ack = tc3162_timer_ack;
+
+	timerSet(1, TIMERTICKS_10MS, ENABLE, TIMER_TOGGLEMODE, TIMER_HALTDISABLE);
+}
+
+void __init plat_timer_setup(struct irqaction *irq)
+{
+	setup_irq(TIMER1_INT, irq);
+}
diff --git a/arch/mips/tc3162/time2.c b/arch/mips/tc3162/time2.c
new file mode 100644
index 000000000..8bad1335b
--- /dev/null
+++ b/arch/mips/tc3162/time2.c
@@ -0,0 +1,455 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Setting up the clock on the MIPS boards.
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/timex.h>
+
+#include <asm/mipsregs.h>
+#include <asm/mipsmtregs.h>
+#include <asm/hardirq.h>
+#include <asm/irq.h>
+#include <asm/div64.h>
+#include <asm/cpu.h>
+#include <asm/time.h>
+
+#include <asm/tc3162/tc3162.h>
+
+unsigned long cpu_khz;
+
+static int mips_cpu_timer_irq;
+extern int cp0_perfcount_irq;
+
+static unsigned long cycles_per_jiffy __read_mostly;
+static unsigned int expirelo[2];
+unsigned int cpu_timer_loss[4];
+static const unsigned int cputmr_cnt[] = {CR_CPUTMR_CNT0, CR_CPUTMR_CNT1};
+static const unsigned int cputmr_cmr[] = {CR_CPUTMR_CMR0, CR_CPUTMR_CMR1};
+
+static int vpe1_timer_installed = 0;
+
+#ifdef CONFIG_PCI
+extern int pcieRegInitConfig(void);
+extern void pcieReset(void);
+extern void setahbstat(int val);
+#endif
+
+static void delay1ms(int ms)
+{
+	volatile uint32 timer_now, timer_last;
+	volatile uint32 tick_acc;
+	uint32 one_tick_unit = SYS_HCLK * 500;//1 * SYS_HCLK * 1000 / 2
+	volatile uint32 tick_wait = ms * one_tick_unit;
+	volatile uint32 timer1_ldv = regRead32(CR_TIMER1_LDV);
+
+	tick_acc = 0;
+	timer_last = regRead32(CR_TIMER1_VLR);
+	do {
+		timer_now = regRead32(CR_TIMER1_VLR);
+	  	if (timer_last >= timer_now)
+	  		tick_acc += timer_last - timer_now;
+		else
+			tick_acc += timer1_ldv - timer_now + timer_last;
+		timer_last = timer_now;
+	} while (tick_acc < tick_wait);
+}
+
+void
+timer_Configure(
+	uint8  timer_no,
+	uint8 timer_enable,
+	uint8 timer_mode,
+	uint8 timer_halt
+)
+{
+	uint32 word,word1;
+
+	word = regRead32(CR_TIMER_CTL);
+	word1 = (timer_enable << timer_no)|(timer_mode << (timer_no + 8))|(timer_halt << (timer_no + 26));
+	word |= word1;
+	regWrite32(CR_TIMER_CTL, word);
+}
+
+void
+timerSet(
+	uint32 timer_no,
+	uint32 timerTime,
+	uint32 enable,
+	uint32 mode,
+	uint32 halt
+)
+{
+    uint32 word;
+
+	/* when SYS_HCLK is large, it will cause overflow. The calculation will be wrong */
+    /* word = (timerTime * SYS_HCLK) * 1000 / 2; */
+    word = (timerTime * SYS_HCLK) * 500;
+    timerLdvSet(timer_no,word);
+    timerCtlSet(timer_no,enable,mode,halt);
+}
+
+void
+timer_WatchDogConfigure (
+	uint8 tick_enable,
+	uint8 watchdog_enable
+)
+{
+	uint32 word;
+
+	word = regRead32(CR_TIMER_CTL);
+	word &= 0xfdffffdf;
+	word |= ( tick_enable << 5)|(watchdog_enable<<25);
+	regWrite32(CR_TIMER_CTL, word);
+}
+
+#if defined(TCSUPPORT_DYING_GASP)
+EXPORT_SYMBOL(timerSet);
+EXPORT_SYMBOL(timer_WatchDogConfigure);
+#endif
+#define get_current_vpe()   \
+	((read_c0_tcbind() >> TCBIND_CURVPE_SHIFT) & TCBIND_CURVPE)
+
+extern void tc3162_enable_irq(unsigned int irq);
+
+static void mips_timer_dispatch(void)
+{
+	do_IRQ(SI_TIMER_INT);
+}
+
+static void mips_perf_dispatch(void)
+{
+	do_IRQ(cp0_perfcount_irq);
+}
+
+extern int (*perf_irq)(void);
+
+/*
+ * Estimate CPU frequency.  Sets mips_hpt_frequency as a side-effect
+ */
+static unsigned int __init estimate_cpu_frequency(void)
+{
+	unsigned int count;
+	unsigned long flags;
+	unsigned int start;
+
+	local_irq_save(flags);
+
+	/* Start r4k counter. */
+	start = read_c0_count();
+
+	/* delay 1 second */
+	delay1ms(1000);
+
+	count = read_c0_count() - start;
+
+	/* restore interrupts */
+	local_irq_restore(flags);
+
+	count += 5000;    /* round */
+	count -= count%10000;
+
+	mips_hpt_frequency = count;
+
+	/* on 34K, 2 cycles per count */
+	count *= 2;
+
+	return count;
+}
+
+irqreturn_t mips_perf_interrupt(int irq, void *dev_id)
+{
+	return perf_irq();
+}
+
+static struct irqaction perf_irqaction = {
+	.handler = mips_perf_interrupt,
+	.flags = IRQF_DISABLED | IRQF_PERCPU,
+	.name = "performance",
+};
+extern struct clocksource clocksource_mips;
+
+#if defined(TCSUPPORT_DYING_GASP) && (defined(CONFIG_MIPS_RT63365) && !(defined(TCSUPPORT_CPU_MT7510)||defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7505)))
+irqreturn_t real_watchdog_timer_interrupt(int irq, void *dev_id)
+#else
+irqreturn_t watchdog_timer_interrupt(int irq, void *dev_id)
+#endif
+{
+	uint32 word;
+
+	word = regRead32(CR_TIMER_CTL);
+	word &= 0xffc0ffff;
+	word |= 0x00200000;
+	regWrite32(CR_TIMER_CTL, word);
+
+	/* The KERN_ALERT will stop printk ring buffer mode.
+	 * This is used for flush ring buffer message to console.
+	 */
+	printk(KERN_ALERT "watchdog timer interrupt\n");
+
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_POWERSAVE_ENABLE)
+	if(isRT63365){
+		word = regRead32(CR_AHB_CLK);
+		word |= 0x57e1;//restore ahb clk to default value
+		regWrite32(CR_AHB_CLK, word);
+	}
+#endif
+	dump_stack();
+
+#if defined(TCSUPPORT_CPU_MT7505) || defined(TCSUPPORT_CPU_MT7510)
+	word = regRead32(CR_DRAMC_CONF);
+	word &= ~(0x1<<2);
+	regWrite32(CR_DRAMC_CONF, word);
+#endif
+
+	return IRQ_HANDLED;
+}
+//only 63365 need another watchdog function in IMEM
+#if defined(TCSUPPORT_DYING_GASP) && (defined(CONFIG_MIPS_RT63365) && !(defined(TCSUPPORT_CPU_MT7510)||defined(TCSUPPORT_CPU_MT7520)||defined(TCSUPPORT_CPU_MT7505)))
+__IMEM
+irqreturn_t watchdog_timer_interrupt(int irq, void *dev_id){
+
+	unsigned int word;
+	word = regRead32(0xbfb00834);
+        word &= ~(1<<18);//enable spi
+        regWrite32(0xbfb00834, word);
+	word = regRead32(0xbfb00040);
+        word &= ~(1<<0); //enable ddr device
+        regWrite32(0xbfb00040, word);
+
+	return real_watchdog_timer_interrupt(irq, dev_id);
+}
+#endif
+static struct irqaction watchdog_timer_irqaction = {
+	.handler = watchdog_timer_interrupt,
+	.flags = IRQF_DISABLED ,
+	.name = "watchdog",
+};
+
+static void watchdog_timer_dispatch(void)
+{
+	do_IRQ(TIMER5_INT);
+}
+
+/************************************************************************
+*                   B U S  T I M E O U T  I N T E R R U P T
+*************************************************************************
+*/
+
+irqreturn_t bus_timeout_interrupt(int irq, void *dev_id)
+{
+	uint32 reg;
+	uint32 addr;
+
+	/* read to clear interrupt */
+	if (isMT751020 || isMT7505 || isEN751221)
+	{
+		if (isMT7505 || isEN751221) {
+			regWrite32(CR_PRATIR, 1);
+		}
+		else {
+			regWrite32(CR_PRATIR, 0);
+		}
+		addr = regRead32(CR_ERR_ADDR);
+		printk("bus timeout interrupt ERR ADDR=%08lx\n", addr);
+		dump_stack();
+	}
+	else
+	{
+		reg = regRead32(CR_PRATIR);
+		printk("bus timeout interrupt ERR ADDR=%08lx\n", regRead32(CR_ERR_ADDR));
+		dump_stack();
+#ifdef CONFIG_PCI
+		pcieReset();
+		pcieRegInitConfig();
+		setahbstat(1);
+#endif
+	}
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction bus_timeout_irqaction = {
+	.handler = bus_timeout_interrupt,
+	.flags = IRQF_DISABLED ,
+	.name = "bus timeout",
+};
+
+static void bus_timeout_dispatch(void)
+{
+	do_IRQ(BUS_TOUT_INT);
+}
+
+/* get_c0_compare_int from cevt-r4k, is prefixed with __weak, so
+   this will be called.
+   c0_compare_interrupt will be set as the handler of returned
+   interrupt.  */
+unsigned int __cpuinit get_c0_compare_int(void)
+{
+	if ((get_current_vpe()) && !vpe1_timer_installed) {
+		tc3162_enable_irq(SI_TIMER1_INT);
+		vpe1_timer_installed++;
+	}
+
+	if (vpe1_timer_installed == 0) {
+		if (cpu_has_veic)
+			set_vi_handler(SI_TIMER_INT, mips_timer_dispatch);
+	}
+	mips_cpu_timer_irq = SI_TIMER_INT;
+
+	return mips_cpu_timer_irq;
+}
+
+static cycle_t cputmr_hpt_read(void)
+{
+	return regRead32(cputmr_cnt[0]);
+}
+
+static void __init cputmr_hpt_timer_init(void)
+{
+	unsigned int tmp;
+
+	regWrite32(cputmr_cnt[0], 0x0);
+	regWrite32(cputmr_cnt[1], 0x0);
+
+	expirelo[0] = cycles_per_jiffy;
+	expirelo[1] = expirelo[0];
+
+	regWrite32(cputmr_cmr[0], expirelo[0]);
+	regWrite32(cputmr_cmr[1], expirelo[1]);
+
+	tmp = regRead32(CR_CPUTMR_CTL);
+	tmp |= (1<<1)|(1<<0);
+	regWrite32(CR_CPUTMR_CTL, tmp);
+}
+
+static void cputmr_timer_ack(void)
+{
+#if defined(CONFIG_MIPS_MT_SMP) || defined(CONFIG_MIPS_MT_SMTC)
+	int cpu = smp_processor_id();
+	int vpe = cpu_data[cpu].vpe_id;
+#else
+	int cpu = 0;
+	int vpe = 0;
+#endif
+
+	/* Ack this timer interrupt and set the next one.  */
+	expirelo[vpe] += cycles_per_jiffy;
+
+	/* Check to see if we have missed any timer interrupts.  */
+	while (unlikely((regRead32(cputmr_cnt[vpe]) - expirelo[vpe]) < 0x7fffffff)) {
+		/* missed_timer_count++; */
+		expirelo[vpe] += cycles_per_jiffy;
+		cpu_timer_loss[cpu]++;
+	}
+
+	/* update CR_CPUTMR_CMR */
+	regWrite32(cputmr_cmr[vpe], expirelo[vpe]);
+}
+
+void __init tc3162_time_init(void)
+{
+
+	timerSet(1, TIMERTICKS_10MS, ENABLE, TIMER_TOGGLEMODE, TIMER_HALTDISABLE);
+
+	if (isRT63165 || isRT63365 || isMT751020 || isMT7505 || isEN751221) {
+		/* watchdog timer */
+		/* set count down 3 seconds to issue interrupt */
+		regWrite32(CR_WDOG_THSLD, ((3 * TIMERTICKS_1S * SYS_HCLK) * 500)); // (3 * TIMERTICKS_1S * SYS_HCLK) * 1000 / 2
+		if (cpu_has_vint)
+			set_vi_handler(TIMER5_INT, watchdog_timer_dispatch);
+		setup_irq(TIMER5_INT, &watchdog_timer_irqaction);
+
+		/* setup bus timeout interrupt */
+   		//VPint(CR_MON_TMR) |= ((1<<30) | (0xff));
+		if(isMT751020 || isMT7505 || isEN751221)
+		{
+			regWrite32(CR_MON_TMR, 0xcfffffff);
+			if(isMT7505 || isEN751221)
+				regWrite32(CR_BUSTIMEOUT_SWITCH, 0xffffffff);
+			else
+				regWrite32(CR_BUSTIMEOUT_SWITCH, 0xfdbfffff);//switch off usb phy(bit22/bit25) control because hw issue
+		}
+
+		if (cpu_has_vint)
+			set_vi_handler(BUS_TOUT_INT, bus_timeout_dispatch);
+		setup_irq(BUS_TOUT_INT, &bus_timeout_irqaction);
+	}
+
+}
+
+/* void (*mips_timer_ack)(void); */
+void __init plat_time_init(void)
+{
+	unsigned int est_freq = 0;
+
+	/* Call in the same order as was in vr300-kernel/time.c#time_init. */
+	tc3162_time_init();
+
+	timerSet(1, TIMERTICKS_10MS, ENABLE, TIMER_TOGGLEMODE, TIMER_HALTDISABLE);
+
+	est_freq = estimate_cpu_frequency ();
+
+	printk("CPU frequency %d.%02d MHz\n", est_freq/1000000,
+	       (est_freq%1000000)*100/1000000);
+
+	cpu_khz = est_freq / 1000;
+
+	/* TODO: mips_timer_ack() should be called from
+	   kernel/cevt-r4k.c:c0_compare_interrupt, I did not merge
+	   this. As I see, if this is not done, the timer
+	   will stop and clocksource.read will return the same
+	   value.
+	   Until this is done somehow, do not use preceission
+	   timer.
+	   c0_compare_interrupt will be triggered on SI_TIME_INT
+	   returned by get_c0_compare_int defined here.
+	   clocksource.read returns read_c0_count and I do not know
+	   what this will return in this case. TODO: */
+#if 0
+	if (isRT63165 || isRT63365 || isMT751020 || isMT7505 ||isEN751221) {
+
+		/* enable CPU external timer */
+		clocksource_mips.read = cputmr_hpt_read;
+		mips_hpt_frequency = CPUTMR_CLK;
+
+		if (isEN751221) {
+			/* mips_hpt_frequency *= (1 - 0.000160025604); */
+			mips_hpt_frequency -= 32005;
+		}
+
+		mips_timer_ack = cputmr_timer_ack;
+		/* Calculate cache parameters.  */
+		cycles_per_jiffy =
+			(mips_hpt_frequency + HZ / 2) / HZ;
+
+		cputmr_hpt_timer_init();
+
+		printk("Using %u.%03u MHz high precision timer.\n",
+		   ((mips_hpt_frequency + 500) / 1000) / 1000,
+		   ((mips_hpt_frequency + 500) / 1000) % 1000);
+	}
+#endif
+}
+
diff --git a/drivers/mtd/chips/spi_controller.c b/drivers/mtd/chips/spi_controller.c
new file mode 100755
index 000000000..243ab0e99
--- /dev/null
+++ b/drivers/mtd/chips/spi_controller.c
@@ -0,0 +1,546 @@
+/***************************************************************************************
+ *      Copyright(c) 2014 ECONET Incorporation All rights reserved.
+ *
+ *      This is unpublished proprietary source code of ECONET Incorporation
+ *
+ *      The copyright notice above does not evidence any actual or intended
+ *      publication of such source code.
+ ***************************************************************************************
+ */
+
+/*======================================================================================
+ * MODULE NAME: spi
+ * FILE NAME: spi_controller.c
+ * DATE: 2014/12/16
+ * VERSION: 1.00
+ * PURPOSE: To Provide SPI Controller Access interface.
+ * NOTES:
+ *
+ * AUTHOR : Chuck Kuo         REVIEWED by
+ *
+ * FUNCTIONS
+ *
+ *      SPI_CONTROLLER_Enable_Manual_Mode To provide interface for Enable SPI Controller Manual Mode.
+ *      SPI_CONTROLLER_Write_One_Byte     To provide interface for write one byte to SPI bus. 
+ *      SPI_CONTROLLER_Write_NByte        To provide interface for write N bytes to SPI bus. 
+ *      SPI_CONTROLLER_Read_NByte         To provide interface for read N bytes from SPI bus. 
+ *      SPI_CONTROLLER_Chip_Select_Low    To provide interface for set chip select low in SPI bus. 
+ *      SPI_CONTROLLER_Chip_Select_High   To provide interface for set chip select high in SPI bus. 
+ *
+ * DEPENDENCIES
+ *
+ * * $History: $
+ * MODIFICTION HISTORY:
+ * Version 1.00 - Date 2014/12/16 By Chuck Kuo
+ * ** This is the first versoin for creating to support the functions of
+ *    current module.
+ *
+ *======================================================================================
+ */
+
+/* INCLUDE FILE DECLARATIONS --------------------------------------------------------- */
+#include "spi_controller.h"
+
+#include <asm/types.h>
+#include <asm/io.h>
+#include <asm/tc3162/tc3162.h>
+#include <asm/types.h>							
+
+/* NAMING CONSTANT DECLARATIONS ------------------------------------------------------ */
+
+/* SPI Controller Register Definition */
+#define _SPI_CONTROLLER_REGS_BASE					0xBFA10000
+#define _SPI_CONTROLLER_REGS_READ_MODE     			(_SPI_CONTROLLER_REGS_BASE + 0x0000)
+#define _SPI_CONTROLLER_REGS_READ_IDLE_EN     		(_SPI_CONTROLLER_REGS_BASE + 0x0004)
+#define _SPI_CONTROLLER_REGS_SIDLY		     		(_SPI_CONTROLLER_REGS_BASE + 0x0008)
+#define _SPI_CONTROLLER_REGS_CSHEXT					(_SPI_CONTROLLER_REGS_BASE + 0x000C)
+#define _SPI_CONTROLLER_REGS_CSLEXT					(_SPI_CONTROLLER_REGS_BASE + 0x0010)
+#define _SPI_CONTROLLER_REGS_MTX_MODE_TOG			(_SPI_CONTROLLER_REGS_BASE + 0x0014)
+#define _SPI_CONTROLLER_REGS_RDCTL_FSM				(_SPI_CONTROLLER_REGS_BASE + 0x0018)
+#define _SPI_CONTROLLER_REGS_MACMUX_SEL				(_SPI_CONTROLLER_REGS_BASE + 0x001C)
+#define _SPI_CONTROLLER_REGS_MANUAL_EN				(_SPI_CONTROLLER_REGS_BASE + 0x0020)
+#define _SPI_CONTROLLER_REGS_MANUAL_OPFIFO_EMPTY	(_SPI_CONTROLLER_REGS_BASE + 0x0024)
+#define _SPI_CONTROLLER_REGS_MANUAL_OPFIFO_WDATA	(_SPI_CONTROLLER_REGS_BASE + 0x0028)
+#define _SPI_CONTROLLER_REGS_MANUAL_OPFIFO_FULL		(_SPI_CONTROLLER_REGS_BASE + 0x002C)
+#define _SPI_CONTROLLER_REGS_MANUAL_OPFIFO_WR		(_SPI_CONTROLLER_REGS_BASE + 0x0030)
+#define _SPI_CONTROLLER_REGS_MANUAL_DFIFO_FULL		(_SPI_CONTROLLER_REGS_BASE + 0x0034)
+#define _SPI_CONTROLLER_REGS_MANUAL_DFIFO_WDATA		(_SPI_CONTROLLER_REGS_BASE + 0x0038)
+#define _SPI_CONTROLLER_REGS_MANUAL_DFIFO_EMPTY		(_SPI_CONTROLLER_REGS_BASE + 0x003C)
+#define _SPI_CONTROLLER_REGS_MANUAL_DFIFO_RD		(_SPI_CONTROLLER_REGS_BASE + 0x0040)
+#define _SPI_CONTROLLER_REGS_MANUAL_DFIFO_RDATA		(_SPI_CONTROLLER_REGS_BASE + 0x0044)
+#define _SPI_CONTROLLER_REGS_DUMMY					(_SPI_CONTROLLER_REGS_BASE + 0x0080)
+#define _SPI_CONTROLLER_REGS_PROBE_SEL				(_SPI_CONTROLLER_REGS_BASE + 0x0088)
+#define _SPI_CONTROLLER_REGS_INTERRUPT				(_SPI_CONTROLLER_REGS_BASE + 0x0090)
+#define _SPI_CONTROLLER_REGS_INTERRUPT_EN			(_SPI_CONTROLLER_REGS_BASE + 0x0094)
+#define _SPI_CONTROLLER_REGS_SI_CK_SEL				(_SPI_CONTROLLER_REGS_BASE + 0x009C)
+
+/* Register Value Definition */
+#define	_SPI_CONTROLLER_VAL_OP_CSH					(0x00)
+#define	_SPI_CONTROLLER_VAL_OP_CSL					(0x01)
+#define	_SPI_CONTROLLER_VAL_OP_CK					(0x02)
+#define	_SPI_CONTROLLER_VAL_OP_OUTS					(0x08)
+#define	_SPI_CONTROLLER_VAL_OP_OUTD					(0x09)
+#define	_SPI_CONTROLLER_VAL_OP_OUTQ					(0x0A)
+#define	_SPI_CONTROLLER_VAL_OP_INS					(0x0C)
+#define	_SPI_CONTROLLER_VAL_OP_INS0					(0x0D)
+#define	_SPI_CONTROLLER_VAL_OP_IND					(0x0E)
+#define	_SPI_CONTROLLER_VAL_OP_INQ					(0x0F)
+#define	_SPI_CONTROLLER_VAL_OP_OS2IS				(0x10)
+#define	_SPI_CONTROLLER_VAL_OP_OS2ID				(0x11)
+#define	_SPI_CONTROLLER_VAL_OP_OS2IQ				(0x12)
+#define	_SPI_CONTROLLER_VAL_OP_OD2IS				(0x13)
+#define	_SPI_CONTROLLER_VAL_OP_OD2ID				(0x14)
+#define	_SPI_CONTROLLER_VAL_OP_OD2IQ				(0x15)
+#define	_SPI_CONTROLLER_VAL_OP_OQ2IS				(0x16)
+#define	_SPI_CONTROLLER_VAL_OP_OQ2ID				(0x17)
+#define	_SPI_CONTROLLER_VAL_OP_OQ2IQ				(0x18)
+#define	_SPI_CONTROLLER_VAL_OP_OSNIS				(0x19)
+#define	_SPI_CONTROLLER_VAL_OP_ODNID				(0x1A)
+#define	_SPI_CONTROLLER_VAL_OP_LEN_MAX				(0x1ff)
+#define	_SPI_CONTROLLER_VAL_OP_LEN_ONE				(1)
+#define	_SPI_CONTROLLER_VAL_OP_LEN_TWO				(2)
+#define	_SPI_CONTROLLER_VAL_OP_LEN_THREE			(3)
+#define	_SPI_CONTROLLER_VAL_OP_LEN_FOUR				(4)
+#define	_SPI_CONTROLLER_VAL_OP_LEN_FIVE				(5)
+#define _SPI_CONTROLLER_VAL_OP_CMD_MASK				(0x1f)
+#define _SPI_CONTROLLER_VAL_OP_LEN_MASK				(0x1ff)
+#define _SPI_CONTROLLER_VAL_OP_SHIFT				(0x9)
+#define _SPI_CONTROLLER_VAL_OP_ENABLE				(0x1)
+#define _SPI_CONTROLLER_VAL_DFIFO_MASK				(0xff)
+#define _SPI_CONTROLLER_VAL_READ_IDLE_DISABLE		(0x0)
+#define _SPI_CONTROLLER_VAL_MANUAL_MTXMODE			(0x9)
+#define _SPI_CONTROLLER_VAL_MANUAL_MANUALEN			(0x1)
+#define _SPI_CONTROLLER_VAL_DDATA_ENABLE			(0x1)
+
+
+#define _SPI_CONTROLLER_CHECK_TIMES					(10000)
+
+
+/* MACRO DECLARATIONS ---------------------------------------------------------------- */
+#ifndef VPint
+#define VPint										*(volatile unsigned long int *)
+#endif
+
+#define	WriteReg(reg, data)							(VPint(reg) = data)
+#define	ReadReg(reg)								(VPint(reg))
+#define	bReadReg(reg, mask)							(VPint(reg) & mask)
+
+//#define _SPI_CONTROLLER_DEBUG_PRINTF				prom_printf
+#define _SPI_CONTROLLER_DEBUG_PRINTF				
+#define _SPI_CONTROLLER_DEBUG_PRINTF_ARRAY			spi_controller_debug_printf_array
+
+/* TYPE DECLARATIONS ----------------------------------------------------------------- */
+
+/* STATIC VARIABLE DECLARATIONS ------------------------------------------------------ */
+
+/* LOCAL SUBPROGRAM BODIES------------------------------------------------------------ */
+void spi_controller_debug_printf_array (u8 *ptr_data, u32 len)
+{
+#if 0
+	u32 idx;
+	
+	for(idx=0 ; idx<len; idx++)
+	{
+		_SPI_CONTROLLER_DEBUG_PRINTF("0x%x ", *(ptr_data+idx));
+	}
+#endif	
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_CONTROLLER_RTN_T spi_controller_set_opfifo( u8  op_cmd,
+ *                                                           u32  op_len )
+ * PURPOSE : To setup SPI Controller opfifo.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : op_cmd - The op_cmd variable of this function.
+ *           op_len - The op_len variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_CONTROLLER_RTN_T spi_controller_set_opfifo(u8 op_cmd, u32 op_len)
+{
+	u32						check_idx;
+	SPI_CONTROLLER_RTN_T	rtn_status = SPI_CONTROLLER_RTN_NO_ERROR; 
+		
+	_SPI_CONTROLLER_DEBUG_PRINTF("spi_controller_set_opfifo: set op_cmd =0x%x, op_len=0x%x\n", op_cmd, op_len);	
+	 
+   	/* 1. Write op_cmd to register OPFIFO_WDATA */
+    WriteReg( _SPI_CONTROLLER_REGS_MANUAL_OPFIFO_WDATA, ((((op_cmd) & _SPI_CONTROLLER_VAL_OP_CMD_MASK) << _SPI_CONTROLLER_VAL_OP_SHIFT) | ((op_len) & _SPI_CONTROLLER_VAL_OP_LEN_MASK)));
+
+    /* 2. Wait until opfifo is not full */
+    while(ReadReg( _SPI_CONTROLLER_REGS_MANUAL_OPFIFO_FULL ));      	      
+     
+  	/* 3. Enable write from register OPFIFO_WDATA to opfifo */  	 
+    WriteReg( _SPI_CONTROLLER_REGS_MANUAL_OPFIFO_WR, _SPI_CONTROLLER_VAL_OP_ENABLE);
+      
+	/* 4. Wait until opfifo is empty */
+    while(!ReadReg( _SPI_CONTROLLER_REGS_MANUAL_OPFIFO_EMPTY ));	      
+    
+    return(rtn_status);    
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_CONTROLLER_RTN_T spi_controller_read_data_fifo( u8      *ptr_rtn_data,
+ *                                                               u32     data_len  )
+ * PURPOSE : To read data from SPI Controller data pfifo.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : data_len  - The data_len variable of this function.
+ *   OUTPUT: ptr_rtn_data  - The ptr_rtn_data variable of this function.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_CONTROLLER_RTN_T spi_controller_read_data_fifo( u8 *ptr_rtn_data, u32 data_len)
+{
+	u32						idx;
+	SPI_CONTROLLER_RTN_T	rtn_status = SPI_CONTROLLER_RTN_NO_ERROR; 	
+
+	for( idx =0 ; idx<data_len ; idx ++)
+	{	
+		 /* 1. wait until dfifo is not empty */
+		 while(ReadReg( _SPI_CONTROLLER_REGS_MANUAL_DFIFO_EMPTY ));
+	 
+		 /* 2. read from dfifo to register DFIFO_RDATA */       	 
+
+		 *(ptr_rtn_data+idx) = (ReadReg( _SPI_CONTROLLER_REGS_MANUAL_DFIFO_RDATA )) &_SPI_CONTROLLER_VAL_DFIFO_MASK;
+		  
+		 _SPI_CONTROLLER_DEBUG_PRINTF(" spi_controller_read_data_fifo : read_data = 0x%x\n", *(ptr_rtn_data+idx));
+		 /* 3. enable register DFIFO_RD to read next byte */
+		 WriteReg( _SPI_CONTROLLER_REGS_MANUAL_DFIFO_RD, _SPI_CONTROLLER_VAL_DDATA_ENABLE);
+	}
+	
+	return(rtn_status);   
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_CONTROLLER_RTN_T spi_controller_write_data_fifo( u8     *ptr_data,
+ *                                                                u32    data_len )
+ * PURPOSE : To write data from SPI Controller data pfifo.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : ptr_data     - The data variable of this function.
+ *           data_len - The data_len variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_CONTROLLER_RTN_T spi_controller_write_data_fifo(u8 *ptr_data, u32 data_len)
+{	
+	u32						idx;
+	SPI_CONTROLLER_RTN_T	rtn_status = SPI_CONTROLLER_RTN_NO_ERROR; 
+	
+	_SPI_CONTROLLER_DEBUG_PRINTF("spi_controller_write_data_fifo : len=0x%x, data: ", data_len);
+	_SPI_CONTROLLER_DEBUG_PRINTF_ARRAY(ptr_data, data_len);
+	
+	for( idx =0 ; idx<data_len ; idx++)
+	{
+		 /* 1. Wait until dfifo is not full */	
+		 while(ReadReg( _SPI_CONTROLLER_REGS_MANUAL_DFIFO_FULL )); 
+		  
+		 /* 2. Write data  to register DFIFO_WDATA */
+		 WriteReg( _SPI_CONTROLLER_REGS_MANUAL_DFIFO_WDATA, ((*(ptr_data+idx)) & _SPI_CONTROLLER_VAL_DFIFO_MASK));
+		  
+
+		 _SPI_CONTROLLER_DEBUG_PRINTF(" spi_controller_write_data_fifo: write data =0x%x\n", ((*(ptr_data+idx)) & _SPI_CONTROLLER_VAL_DFIFO_MASK));
+
+		  
+		 /* 3. Wait until dfifo is not full */						
+		 while(ReadReg( _SPI_CONTROLLER_REGS_MANUAL_DFIFO_FULL ));           
+
+    }
+    
+    return(rtn_status);
+}
+
+/* EXPORTED SUBPROGRAM BODIES -------------------------------------------------------- */
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Enable_Manual_Mode( void )
+ * PURPOSE : To provide interface for enable SPI Controller Manual Mode Enable.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Enable_Manual_Mode( void )
+{	
+	SPI_CONTROLLER_RTN_T	rtn_status = SPI_CONTROLLER_RTN_NO_ERROR; 
+	
+	/* disable read_idle_enable */
+	WriteReg( _SPI_CONTROLLER_REGS_READ_IDLE_EN , _SPI_CONTROLLER_VAL_READ_IDLE_DISABLE);
+	
+	/*wait until auto read status is IDLE */
+	while(ReadReg( _SPI_CONTROLLER_REGS_RDCTL_FSM ));
+	
+	/*auto mode -> manaul mode */
+	/*Set 9  to SF_MTX_MODE_TOG */
+	WriteReg( _SPI_CONTROLLER_REGS_MTX_MODE_TOG, _SPI_CONTROLLER_VAL_MANUAL_MTXMODE);
+	
+	/*Enable Manual Mode */
+	WriteReg( _SPI_CONTROLLER_REGS_MANUAL_EN, _SPI_CONTROLLER_VAL_MANUAL_MANUALEN);
+	
+	return (rtn_status);
+}
+
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Write_One_Byte( u8  data )
+ * PURPOSE : To provide interface for write one byte to SPI bus.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : data - The data variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Write_One_Byte( u8 data )
+{
+	SPI_CONTROLLER_RTN_T	rtn_status = SPI_CONTROLLER_RTN_NO_ERROR; 
+	
+	_SPI_CONTROLLER_DEBUG_PRINTF("SPI_CONTROLLER_Write_One_Byte : data=0x%x\n", data);
+	
+	/* 1. Set opcode to SPI Controller */
+	spi_controller_set_opfifo( _SPI_CONTROLLER_VAL_OP_OUTS, _SPI_CONTROLLER_VAL_OP_LEN_ONE);
+	
+	/* 2. Write data to SPI Controller */
+	spi_controller_write_data_fifo( &data, _SPI_CONTROLLER_VAL_OP_LEN_ONE);
+	
+	return (rtn_status);	
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_CONTROLLER_RTN_T SPI_CONTROLLER_WRITE_NBYTES( u8                        *ptr_data,
+ *                                                             u32                       len,
+ *                                                             SPI_CONTROLLER_SPEED_T    speed )
+ * PURPOSE : To provide interface for write N bytes to SPI bus.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : ptr_data  - The data variable of this function.
+ *           len   - The len variable of this function.
+ *           speed - The speed variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Write_NByte( u8 *ptr_data, u32 len, SPI_CONTROLLER_SPEED_T speed )
+{
+	u8						op_cmd;
+	u32						data_len, remain_len;
+	SPI_CONTROLLER_RTN_T	rtn_status = SPI_CONTROLLER_RTN_NO_ERROR; 
+	
+	_SPI_CONTROLLER_DEBUG_PRINTF("SPI_CONTROLLER_Write_NByte: len=0x%x\n", len );
+	_SPI_CONTROLLER_DEBUG_PRINTF_ARRAY(ptr_data, len);
+	
+	/* 1. Mapping the op code */
+	switch( speed )
+	{
+		case SPI_CONTROLLER_SPEED_SINGLE :
+			op_cmd = _SPI_CONTROLLER_VAL_OP_OUTS;
+			break;
+			
+		case SPI_CONTROLLER_SPEED_DUAL :
+			op_cmd = _SPI_CONTROLLER_VAL_OP_OUTD;
+			break;
+			
+		case SPI_CONTROLLER_SPEED_QUAD :
+			op_cmd = _SPI_CONTROLLER_VAL_OP_OUTQ;			
+			break;
+	}
+	
+	remain_len = len; 
+	while (remain_len > 0)
+	{
+		if( remain_len > _SPI_CONTROLLER_VAL_OP_LEN_MAX )		/*Controller at most process limitation one time */
+		{
+			data_len = _SPI_CONTROLLER_VAL_OP_LEN_MAX;
+		}
+		else
+		{
+			data_len = remain_len;
+		}
+		/* 2. Set opcode to SPI Controller */
+		spi_controller_set_opfifo( op_cmd, data_len);
+	
+		/* 3. Write data to SPI Controller */
+		spi_controller_write_data_fifo( &ptr_data[len - remain_len], data_len );
+		
+		remain_len -= data_len;
+	}
+	
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_CONTROLLER_RTN_T SPI_CONTROLLER_READ_NBYTES( u8                         *ptr_rtn_data,
+ *                                                            u8                         len,
+ *                                                            SPI_CONTROLLER_SPEED_T     speed     )
+ * PURPOSE : To provide interface for read N bytes from SPI bus.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : len       - The len variable of this function.
+ *           speed     - The speed variable of this function.
+ *   OUTPUT: ptr_rtn_data  - The ptr_rtn_data variable of this function.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Read_NByte(u8 *ptr_rtn_data, u32 len, SPI_CONTROLLER_SPEED_T speed)
+{
+	u8						op_cmd;
+	u32						data_len, remain_len;
+	SPI_CONTROLLER_RTN_T	rtn_status = SPI_CONTROLLER_RTN_NO_ERROR; 
+	
+	_SPI_CONTROLLER_DEBUG_PRINTF("SPI_CONTROLLER_Read_NByte : \n");
+	
+	/* 1. Mapping the op code */
+	switch( speed )
+	{
+		case SPI_CONTROLLER_SPEED_SINGLE :
+			op_cmd = _SPI_CONTROLLER_VAL_OP_INS;
+			break;
+			
+		case SPI_CONTROLLER_SPEED_DUAL :
+			op_cmd = _SPI_CONTROLLER_VAL_OP_IND;
+			break;
+			
+		case SPI_CONTROLLER_SPEED_QUAD :
+			op_cmd = _SPI_CONTROLLER_VAL_OP_INQ;			
+			break;
+	}
+
+	remain_len = len;
+	while (remain_len > 0)
+	{		
+		if( remain_len > _SPI_CONTROLLER_VAL_OP_LEN_MAX )		/*Controller at most process limitation one time */
+		{
+			data_len = _SPI_CONTROLLER_VAL_OP_LEN_MAX;
+		}
+		else
+		{
+			data_len = remain_len;
+		}
+		/* 2. Set opcode to SPI Controller */
+		spi_controller_set_opfifo( op_cmd, data_len);
+	
+		/* 3. Read data through SPI Controller */
+		spi_controller_read_data_fifo( &ptr_rtn_data[len - remain_len], data_len );
+		
+		remain_len -= data_len;
+	}
+	
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Chip_Select_Low( void )
+ * PURPOSE : To provide interface for set chip select low in SPI bus.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Chip_Select_Low(void)
+{
+	SPI_CONTROLLER_RTN_T	rtn_status = SPI_CONTROLLER_RTN_NO_ERROR; 
+	
+	spi_controller_set_opfifo( _SPI_CONTROLLER_VAL_OP_CSL, _SPI_CONTROLLER_VAL_OP_LEN_ONE);
+	spi_controller_set_opfifo( _SPI_CONTROLLER_VAL_OP_CSL, _SPI_CONTROLLER_VAL_OP_LEN_ONE);
+	
+	return (rtn_status);		
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Chip_Select_High( void )
+ * PURPOSE : To provide interface for set chip select high in SPI bus.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Chip_Select_High(void)
+{
+	SPI_CONTROLLER_RTN_T	rtn_status = SPI_CONTROLLER_RTN_NO_ERROR; 
+	
+	spi_controller_set_opfifo( _SPI_CONTROLLER_VAL_OP_CSH, _SPI_CONTROLLER_VAL_OP_LEN_ONE);
+	spi_controller_set_opfifo( _SPI_CONTROLLER_VAL_OP_CK, _SPI_CONTROLLER_VAL_OP_LEN_FIVE);
+	
+	return (rtn_status);
+}
+/* End of [spi_controller.c] package */
diff --git a/drivers/mtd/chips/spi_controller.h b/drivers/mtd/chips/spi_controller.h
new file mode 100755
index 000000000..84c05c14d
--- /dev/null
+++ b/drivers/mtd/chips/spi_controller.h
@@ -0,0 +1,200 @@
+ /***************************************************************************************
+ *      Copyright(c) 2014 ECONET Incorporation All rights reserved.
+ *
+ *      This is unpublished proprietary source code of ECONET Incorporation
+ *
+ *      The copyright notice above does not evidence any actual or intended
+ *      publication of such source code.
+ ***************************************************************************************
+ */
+
+/*======================================================================================
+ * MODULE NAME: spi
+ * FILE NAME: spi_controller.h
+ * DATE: 2014/12/16
+ * VERSION: 1.00
+ * PURPOSE: To Provide SPI Controller Access interface.
+ * NOTES:
+ *
+ * AUTHOR : Chuck Kuo         REVIEWED by
+ *
+ * FUNCTIONS
+ *
+ *      SPI_CONTROLLER_Enable_Manual_Mode To provide interface for Enable SPI Controller Manual Mode.
+ *      SPI_CONTROLLER_Write_One_Byte     To provide interface for write one byte to SPI bus. 
+ *      SPI_CONTROLLER_Write_NByte        To provide interface for write N bytes to SPI bus. 
+ *      SPI_CONTROLLER_Read_NByte         To provide interface for read N bytes from SPI bus. 
+ *      SPI_CONTROLLER_Chip_Select_Low    To provide interface for set chip select low in SPI bus. 
+ *      SPI_CONTROLLER_Chip_Select_High   To provide interface for set chip select high in SPI bus. 
+ *
+ * DEPENDENCIES
+ *
+ * * $History: $
+ * MODIFICTION HISTORY:
+ * Version 1.00 - Date 2014/12/16 By Chuck Kuo
+ * ** This is the first versoin for creating to support the functions of
+ *    current module.
+ *
+ *======================================================================================
+ */
+
+#ifndef __SPI_CONTROLLER_H__
+    #define __SPI_CONTROLLER_H__
+
+/* INCLUDE FILE DECLARATIONS --------------------------------------------------------- */
+#include <asm/types.h>
+
+/* NAMING CONSTANT DECLARATIONS ------------------------------------------------------ */
+#define SPI_CONTROLLER_REGS_STRAP					0xBFA10114
+
+/* MACRO DECLARATIONS ---------------------------------------------------------------- */
+
+/* TYPE DECLARATIONS ----------------------------------------------------------------- */
+typedef enum{
+	SPI_CONTROLLER_SPEED_SINGLE =0,
+	SPI_CONTROLLER_SPEED_DUAL,
+	SPI_CONTROLLER_SPEED_QUAD
+
+} SPI_CONTROLLER_SPEED_T;
+
+typedef enum{
+	SPI_CONTROLLER_RTN_NO_ERROR =0,
+	SPI_CONTROLLER_RTN_SET_OPFIFO_ERROR,
+	SPI_CONTROLLER_RTN_READ_DATAPFIFO_ERROR,
+	SPI_CONTROLLER_RTN_WRITE_DATAPFIFO_ERROR,
+
+	SPI_CONTROLLER_RTN_DEF_NO
+} SPI_CONTROLLER_RTN_T;
+
+
+/* EXPORTED SUBPROGRAM SPECIFICATION ------------------------------------------------- */
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Enable_Manual_Mode( void )
+ * PURPOSE : To provide interface for enable SPI Controller Manual Mode Enable.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *------------------------------------------------------------------------------------
+ */
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Enable_Manual_Mode( void );
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Write_One_Byte( u8  data )
+ * PURPOSE : To provide interface for write one byte to SPI bus.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : data - The data variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *------------------------------------------------------------------------------------
+ */
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Write_One_Byte( u8  data );
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_CONTROLLER_RTN_T SPI_CONTROLLER_WRITE_NBYTES( u8                        *ptr_data,
+ *                                                             u32                       len,
+ *                                                             SPI_CONTROLLER_SPEED_T    speed )
+ * PURPOSE : To provide interface for write N bytes to SPI bus.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : ptr_data  - The data variable of this function.
+ *           len   - The len variable of this function.
+ *           speed - The speed variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *------------------------------------------------------------------------------------
+ */
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Write_NByte( u8                         *ptr_data,
+                                                 u32                        len,
+                                                 SPI_CONTROLLER_SPEED_T     speed     );
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_CONTROLLER_RTN_T SPI_CONTROLLER_READ_NBYTES( u8                         *ptr_rtn_data,
+ *                                                            u8                         len,
+ *                                                            SPI_CONTROLLER_SPEED_T     speed     )
+ * PURPOSE : To provide interface for read N bytes from SPI bus.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : len       - The len variable of this function.
+ *           speed     - The speed variable of this function.
+ *   OUTPUT: ptr_rtn_data  - The ptr_rtn_data variable of this function.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *------------------------------------------------------------------------------------
+ */
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Read_NByte( u8                      *ptr_rtn_data,
+                                                u32                     len,
+                                                SPI_CONTROLLER_SPEED_T  speed         );
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Chip_Select_Low( void )
+ * PURPOSE : To provide interface for set chip select low in SPI bus.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *------------------------------------------------------------------------------------
+ */
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Chip_Select_Low( void );
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Chip_Select_High( void )
+ * PURPOSE : To provide interface for set chip select high in SPI bus.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *------------------------------------------------------------------------------------
+ */
+SPI_CONTROLLER_RTN_T SPI_CONTROLLER_Chip_Select_High( void );
+
+
+#endif /* ifndef __SPI_CONTROLLER_H__ */
+/* End of [spi_controller.h] package */
+
diff --git a/drivers/mtd/chips/spi_nand_flash.c b/drivers/mtd/chips/spi_nand_flash.c
new file mode 100755
index 000000000..49ed6ae64
--- /dev/null
+++ b/drivers/mtd/chips/spi_nand_flash.c
@@ -0,0 +1,4609 @@
+/***************************************************************************************
+ *      Copyright(c) 2014 ECONET Incorporation All rights reserved.
+ *
+ *      This is unpublished proprietary source code of ECONET Networks Incorporation
+ *
+ *      The copyright notice above does not evidence any actual or intended
+ *      publication of such source code.
+ ***************************************************************************************
+ */
+
+/*======================================================================================
+ * MODULE NAME: spi
+ * FILE NAME: spi_nand_flash.c
+ * DATE: 2014/11/21
+ * VERSION: 1.00
+ * PURPOSE: To Provide SPI NAND Access interface.
+ * NOTES:
+ *
+ * AUTHOR : Chuck Kuo         REVIEWED by
+ *
+ * FUNCTIONS
+ *
+ *      SPI_NAND_Flash_Init             To provide interface for SPI NAND init.
+ *      SPI_NAND_Flash_Write_Nbyte      To provide interface for Write N Bytes into SPI NAND Flash.
+ *      SPI_NAND_Flash_Read_Byte        To provide interface for read 1 Bytes from SPI NAND Flash.
+ *      SPI_NAND_Flash_Read_DWord       To provide interface for read Double Word from SPI NAND Flash.
+ *      SPI_NAND_Flash_Read_NByte       To provide interface for Read N Bytes from SPI NAND Flash.
+ *      SPI_NAND_Flash_Erase            To provide interface for Erase SPI NAND Flash.
+ *
+ * DEPENDENCIES
+ *
+ * * $History: $
+ * MODIFICTION HISTORY:
+ * Version 1.00 - Date 2014/11/21 By Chuck Kuo
+ * ** This is the first versoin for creating to support the functions of
+ *    current module.
+ *
+ *======================================================================================
+ */
+
+/* INCLUDE FILE DECLARATIONS --------------------------------------------------------- */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/semaphore.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/gen_probe.h>
+
+#include "spi_nand_flash.h"
+#include "spi_controller.h"
+#include <asm/io.h>
+#include <asm/tc3162/tc3162.h>
+#include <stdarg.h>
+
+
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/dma-mapping.h>
+#include <linux/jiffies.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/time.h>
+
+#include <asm/io.h>
+#include <asm/cacheflush.h>
+#include <asm/uaccess.h>
+
+#include <linux/miscdevice.h>
+#include <linux/scatterlist.h>
+
+
+#include "../tc3162/bmt.h"
+
+
+/* Added for TCM used */
+#include <asm/system.h>
+
+#include <linux/mtd/map.h>
+#include <asm/tc3162/tc3162.h>
+
+#ifdef TCSUPPORT_NAND_BMT
+#define POOL_GOOD_BLOCK_PERCENT 8/100
+extern int nand_logic_size;
+#endif
+
+
+DECLARE_MUTEX(SPI_NAND_SEM);  /* Make sure all related SPI NAND operations are atomic */
+
+struct spi_chip_info {
+	struct spi_flash_info *flash;
+	void (*destroy)(struct spi_chip_info *chip_info);
+
+	u32 (*read)(struct map_info *map, u32 from, u32 to, u32 size);
+	u32 (*read_manual)(struct mtd_info *mtd, unsigned long from, unsigned char *buf, unsigned long len);
+	u32 (*write)(struct mtd_info *mtd, u32 from, u32 to, u32 size);
+	u32 (*erase)(struct mtd_info *mtd, u32 addr);
+};
+
+
+/* NAMING CONSTANT DECLARATIONS ------------------------------------------------------ */
+
+/* SPI NAND Command Set */
+#define _SPI_NAND_OP_GET_FEATURE			0x0F	/* Get Feature */
+#define _SPI_NAND_OP_SET_FEATURE			0x1F	/* Set Feature */
+#define _SPI_NAND_OP_PAGE_READ				0x13	/* Load page data into cache of SPI NAND chip */
+#define _SPI_NAND_OP_READ_FROM_CACHE_SINGLE	0x03	/* Read data from cache of SPI NAND chip, single speed*/
+#define _SPI_NAND_OP_READ_FROM_CACHE_DUAL	0x3B	/* Read data from cache of SPI NAND chip, dual speed*/
+#define _SPI_NAND_OP_READ_FROM_CACHE_QUAD	0x6B	/* Read data from cache of SPI NAND chip, quad speed*/
+#define _SPI_NAND_OP_WRITE_ENABLE			0x06	/* Enable write data to  SPI NAND chip */
+#define _SPI_NAND_OP_WRITE_DISABLE			0x04	/* Reseting the Write Enable Latch (WEL) */
+#define _SPI_NAND_OP_PROGRAM_LOAD_SINGLE			0x02	/* Write data into cache of SPI NAND chip with cache reset, single speed */
+#define _SPI_NAND_OP_PROGRAM_LOAD_QUAD				0x32	/* Write data into cache of SPI NAND chip with cache reset, quad speed */
+#define _SPI_NAND_OP_PROGRAM_LOAD_RAMDOM_SINGLE		0x84	/* Write data into cache of SPI NAND chip, single speed */
+#define _SPI_NAND_OP_PROGRAM_LOAD_RAMDON_QUAD		0x34	/* Write data into cache of SPI NAND chip, quad speed */
+
+#define _SPI_NAND_OP_PROGRAM_EXECUTE		0x10	/* Write data from cache into SPI NAND chip */
+#define _SPI_NAND_OP_READ_ID				0x9F	/* Read Manufacture ID and Device ID */
+#define _SPI_NAND_OP_BLOCK_ERASE			0xD8	/* Erase Block */
+#define _SPI_NAND_OP_RESET					0xFF	/* Reset */
+
+/* SPI NAND register address of command set */
+#define _SPI_NAND_ADDR_PROTECTION			0xA0	/* Address of protection */
+#define _SPI_NAND_ADDR_FEATURE				0xB0	/* Address of feature */
+#define _SPI_NAND_ADDR_STATUS				0xC0	/* Address of status */
+#define _SPI_NAND_ADDR_MANUFACTURE_ID		0x00	/* Address of Manufacture ID */
+#define _SPI_NAND_ADDR_DEVICE_ID			0x01	/* Address of Device ID */
+
+/* SPI NAND value of register address of command set */
+#define _SPI_NAND_VAL_DISABLE_PROTECTION	0x0		/* Value for disable write protection */
+#define _SPI_NAND_VAL_ENABLE_PROTECTION		0x38	/* Value for enable write protection */
+#define _SPI_NAND_VAL_OIP					0x1		/* OIP = Operaton In Progress */
+#define _SPI_NAND_VAL_ERASE_FAIL			0x4		/* E_FAIL = Erase Fail */
+#define _SPI_NAND_VAL_PROGRAM_FAIL			0x8		/* P_FAIL = Program Fail */
+
+
+
+/* SPI NAND Size Define */
+#define _SPI_NAND_PAGE_SIZE_2KBYTE			0x0800
+#define _SPI_NAND_OOB_SIZE_64BYTE			0x40
+#define _SPI_NAND_OOB_SIZE_120BYTE			0x78
+#define _SPI_NAND_OOB_SIZE_128BYTE			0x80
+#define _SPI_NAND_BLOCK_SIZE_128KBYTE		0x20000
+#define _SPI_NAND_CHIP_SIZE_512MBIT			0x04000000
+#define _SPI_NAND_CHIP_SIZE_1GBIT			0x08000000
+#define _SPI_NAND_CHIP_SIZE_2GBIT			0x10000000
+#define _SPI_NAND_CHIP_SIZE_4GBIT			0x20000000
+
+/* SPI NAND Manufacturers ID */
+#define _SPI_NAND_MANUFACTURER_ID_GIGADEVICE	0xC8
+#define _SPI_NAND_MANUFACTURER_ID_WINBOND		0xEF
+#define _SPI_NAND_MANUFACTURER_ID_ESMT			0xC8
+#define _SPI_NAND_MANUFACTURER_ID_MXIC		0xC2
+#define _SPI_NAND_MANUFACTURER_ID_ZENTEL		0xC8
+#define _SPI_NAND_MANUFACTURER_ID_ETRON			0xD5
+#define _SPI_NAND_MANUFACTURER_ID_TOSHIBA		0x98
+#define _SPI_NAND_MANUFACTURER_ID_MICRON		0x2C
+
+
+
+
+/* SPI NAND Device ID */
+#define _SPI_NAND_DEVICE_ID_GD5F1GQ4UAYIG	0xF1
+#define _SPI_NAND_DEVICE_ID_GD5F1GQ4UBYIG	0xD1
+#define _SPI_NAND_DEVICE_ID_GD5F1GQ4UCYIG	0xB1
+#define _SPI_NAND_DEVICE_ID_GD5F2GQ4UBYIG	0xD2
+#define _SPI_NAND_DEVICE_ID_GD5F2GQ4UCYIG	0xB2
+#define _SPI_NAND_DEVICE_ID_F50L512M41A		0x20
+#define _SPI_NAND_DEVICE_ID_F50L1G41A0		0x21
+#define _SPI_NAND_DEVICE_ID_W25N01GV		0xAA
+#define _SPI_NAND_DEVICE_ID_W25N02GV        0xAB
+#define _SPI_NAND_DEVICE_ID_MXIC35LF1GE4AB	0x12
+#define _SPI_NAND_DEVICE_ID_MXIC35LF2GE4AB	0x22
+#define _SPI_NAND_DEVICE_ID_MXIC35LF4GE4AB	0x32
+#define _SPI_NAND_DEVICE_ID_A5U12A21ASC		0x20
+#define _SPI_NAND_DEVICE_ID_A5U1GA21BWS		0x21
+#define _SPI_NAND_DEVICE_ID_EM73C044SNB		0x11
+#define _SPI_NAND_DEVICE_ID_EM73D044SNA		0x12
+#define _SPI_NAND_DEVICE_ID_TC58CVG0S3H		0xC2
+#define _SPI_NAND_DEVICE_ID_TC58CVG1S3H		0xCB
+#define _SPI_NAND_DEVICE_ID_MT29F1G01		0x14
+
+
+
+
+
+/* Others Define */
+#define _SPI_NAND_LEN_ONE_BYTE				(1)
+#define _SPI_NAND_LEN_TWO_BYTE				(2)
+#define _SPI_NAND_LEN_THREE_BYTE			(3)
+#define _SPI_NAND_BLOCK_ROW_ADDRESS_OFFSET	(6)
+
+#define _SPI_NAND_PAGE_SIZE  				2048
+#define _SPI_NAND_OOB_SIZE  				128
+#define _SPI_NAND_CACHE_SIZE 				(_SPI_NAND_PAGE_SIZE+_SPI_NAND_OOB_SIZE)
+
+#define _SPI_FREQUENCY_ADJUST_REG			0xBFA200CC
+
+#define LINUX_USE_OOB_START_OFFSET		4
+#define MAX_LINUX_USE_OOB_SIZE			26
+#define MAX_USE_OOB_SIZE				(LINUX_USE_OOB_START_OFFSET + MAX_LINUX_USE_OOB_SIZE + 2)
+
+
+#define MIN(a,b)        ((a) < (b) ? (a) : (b))
+
+
+/* MACRO DECLARATIONS ---------------------------------------------------------------- */
+#define _SPI_NAND_BLOCK_ALIGNED_CHECK( __addr__,__block_size__) ((__addr__) & ( __block_size__ - 1))
+#define _SPI_NAND_GET_DEVICE_INFO_PTR		&(_current_flash_info_t)
+
+
+unsigned long spinand_spinlock_flags;
+static DEFINE_SPINLOCK(spinandLock);
+
+
+
+/* Porting Replacement */
+#define _SPI_NAND_SEMAPHORE_LOCK()			spin_lock_irqsave(&spinandLock, spinand_spinlock_flags)	/* Disable interrupt */
+#define _SPI_NAND_SEMAPHORE_UNLOCK()		spin_unlock_irqrestore(&spinandLock, spinand_spinlock_flags)	/* Enable interrupt  */
+#define _SPI_NAND_PRINTF					printk
+#define _SPI_NAND_DEBUG_PRINTF				spi_nand_flash_debug_printf
+#define _SPI_NAND_DEBUG_PRINTF_ARRAY		spi_nand_flash_debug_printf_array
+#define _SPI_NAND_ENABLE_MANUAL_MODE		SPI_CONTROLLER_Enable_Manual_Mode
+#define _SPI_NAND_WRITE_ONE_BYTE			SPI_CONTROLLER_Write_One_Byte
+#define _SPI_NAND_WRITE_NBYTE				SPI_CONTROLLER_Write_NByte
+#define _SPI_NAND_READ_NBYTE				SPI_CONTROLLER_Read_NByte
+#define _SPI_NAND_READ_CHIP_SELECT_HIGH		SPI_CONTROLLER_Chip_Select_High
+#define _SPI_NAND_READ_CHIP_SELECT_LOW		SPI_CONTROLLER_Chip_Select_Low
+
+
+unsigned char _plane_select_bit = 0;
+
+
+/* TYPE DECLARATIONS ----------------------------------------------------------------- */
+struct _SPI_NAND_FLASH_ID_T {
+	u8 mfr_id;
+	u8 dev_id;
+};
+
+/* STATIC VARIABLE DECLARATIONS ------------------------------------------------------ */
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+
+static int bmt_pool_size = 0;
+static bmt_struct *g_bmt = NULL;
+static init_bbt_struct *g_bbt = NULL;
+#endif
+
+
+SPI_NAND_FLASH_DEBUG_LEVEL_T  _SPI_NAND_DEBUG_LEVEL = SPI_NAND_FLASH_DEBUG_LEVEL_0;
+int							  _SPI_NAND_TEST_FLAG = 0;
+
+
+u8								_SPI_NAND_DEBUG_FLAG= 0;	/* For control printf debug message or not */
+u32 							_current_page_num	= 0xFFFFFFFF;
+u32 							_spare_area_factor 	= 32;
+u8		 						_current_cache_page[_SPI_NAND_CACHE_SIZE];
+u8		 						_current_cache_page_data[_SPI_NAND_PAGE_SIZE];
+u8		 						_current_cache_page_oob[_SPI_NAND_OOB_SIZE];
+u8		 						_current_cache_page_oob_mapping[_SPI_NAND_OOB_SIZE];
+
+
+struct SPI_NAND_FLASH_INFO_T	_current_flash_info_t;			/* Store the current flash information */
+
+
+struct spi_nand_flash_ooblayout ooblayout_esmt = {
+	.oobsize = 36,
+	.oobfree = {{0,1}, {8,8}, {16,1}, {24,8}, {32,1}, {40,8}, {48,1}, {56,8} }
+};
+
+
+struct spi_nand_flash_ooblayout ooblayout_mxic = {
+	.oobsize = 64,
+	.oobfree = {{0,64}}
+};
+
+struct spi_nand_flash_ooblayout ooblayout_winbond = {
+	.oobsize = 32,
+	.oobfree = {{0,8}, {16,8}, {32,8}, {48,8} }
+};
+
+struct spi_nand_flash_ooblayout ooblayout_gigadevice_a = {
+	.oobsize = 48,
+	.oobfree = {{0,12}, {16,12}, {32,12}, {48,12} }
+};
+
+struct spi_nand_flash_ooblayout ooblayout_gigadevice_b = {
+	.oobsize = 64,
+	.oobfree = {{0,64}}
+};
+
+struct spi_nand_flash_ooblayout ooblayout_gigadevice_c = {
+	.oobsize = 64,
+	.oobfree = {{0,64}}
+};
+
+struct spi_nand_flash_ooblayout ooblayout_zentel = {
+	.oobsize = 36,
+	.oobfree = {{0,1}, {8,8}, {16,1}, {24,8}, {32,1}, {40,8}, {48,1}, {56,8} }
+};
+
+struct spi_nand_flash_ooblayout ooblayout_etron = {
+	.oobsize = 60,
+	.oobfree = {{0,16}, {30,16}, {60,16}, {90,16}}
+};
+
+struct spi_nand_flash_ooblayout ooblayout_toshiba = {
+	.oobsize = 64,
+	.oobfree = {{0,64}}
+};
+
+struct spi_nand_flash_ooblayout ooblayout_micron = {
+	.oobsize = 64,
+	.oobfree = {{0,64}}
+};
+
+
+
+/*****************************[ Notice]******************************/
+/* If new spi nand chip have page size more than 2KB,  or oob size more than 128 bytes,  than*/
+/* it will need to adjust the #define of _SPI_NAND_PAGE_SIZE and _SPI_NAND_OOB_SIZE */
+/*****************************[ Notice]******************************/
+
+static const struct SPI_NAND_FLASH_INFO_T spi_nand_flash_tables[] = {
+	{
+		mfr_id:						_SPI_NAND_MANUFACTURER_ID_GIGADEVICE,
+		dev_id:						_SPI_NAND_DEVICE_ID_GD5F1GQ4UAYIG,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_GD5F1GQ4UA",
+		device_size:				_SPI_NAND_CHIP_SIZE_1GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_64BYTE,
+		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_gigadevice_a,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id:						_SPI_NAND_MANUFACTURER_ID_GIGADEVICE,
+		dev_id:						_SPI_NAND_DEVICE_ID_GD5F1GQ4UBYIG,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_GD5F1GQ4UB",
+		device_size:				_SPI_NAND_CHIP_SIZE_1GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_128BYTE,
+		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_gigadevice_b,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_GIGADEVICE,
+		dev_id: 					_SPI_NAND_DEVICE_ID_GD5F1GQ4UCYIG,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_GD5F1GQ4UC",
+		device_size:				_SPI_NAND_CHIP_SIZE_1GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_128BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_PREPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_gigadevice_c,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id:						_SPI_NAND_MANUFACTURER_ID_GIGADEVICE,
+		dev_id:						_SPI_NAND_DEVICE_ID_GD5F2GQ4UBYIG,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_GD5F2GQ4UB",
+		device_size:				_SPI_NAND_CHIP_SIZE_2GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_128BYTE,
+		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_gigadevice_b,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_GIGADEVICE,
+		dev_id: 					_SPI_NAND_DEVICE_ID_GD5F2GQ4UCYIG,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_GD5F2GQ4UC",
+		device_size:				_SPI_NAND_CHIP_SIZE_2GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_128BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_PREPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_gigadevice_c,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id:						_SPI_NAND_MANUFACTURER_ID_ESMT,
+		dev_id:						_SPI_NAND_DEVICE_ID_F50L512M41A,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_F50L512",
+		device_size:				_SPI_NAND_CHIP_SIZE_512MBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_64BYTE,
+		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_esmt,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_ESMT,
+		dev_id: 					_SPI_NAND_DEVICE_ID_F50L1G41A0,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_F50L1G",
+		device_size:				_SPI_NAND_CHIP_SIZE_1GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_64BYTE,
+		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_esmt,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id:						_SPI_NAND_MANUFACTURER_ID_WINBOND,
+		dev_id:						_SPI_NAND_DEVICE_ID_W25N01GV,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_W25N01G",
+		device_size:				_SPI_NAND_CHIP_SIZE_1GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_64BYTE,
+		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_winbond,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_WINBOND,
+		dev_id: 					_SPI_NAND_DEVICE_ID_W25N02GV,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_W25N02G",
+		device_size:				_SPI_NAND_CHIP_SIZE_2GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_64BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_winbond,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id:						_SPI_NAND_MANUFACTURER_ID_MXIC,
+		dev_id:						_SPI_NAND_DEVICE_ID_MXIC35LF1GE4AB,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_MXIC35LF1G",
+		device_size:				_SPI_NAND_CHIP_SIZE_1GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_64BYTE,
+		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_mxic,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id:						_SPI_NAND_MANUFACTURER_ID_MXIC,
+		dev_id:						_SPI_NAND_DEVICE_ID_MXIC35LF2GE4AB,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_MXIC35LF2G",
+		device_size:				_SPI_NAND_CHIP_SIZE_2GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_64BYTE,
+		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_mxic,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_HAVE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_ZENTEL,
+		dev_id: 					_SPI_NAND_DEVICE_ID_A5U12A21ASC,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_A5U12A21ASC",
+		device_size:				_SPI_NAND_CHIP_SIZE_512MBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_64BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_zentel,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_ZENTEL,
+		dev_id: 					_SPI_NAND_DEVICE_ID_A5U1GA21BWS,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_A5U1GA21BWS",
+		device_size:				_SPI_NAND_CHIP_SIZE_1GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_64BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_zentel,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_ETRON,
+		dev_id: 					_SPI_NAND_DEVICE_ID_EM73C044SNB,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_EM73C044SNB",
+		device_size:				_SPI_NAND_CHIP_SIZE_1GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_128BYTE,
+		erase_size:					_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode:					SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_etron,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_ETRON,
+		dev_id: 					_SPI_NAND_DEVICE_ID_EM73D044SNA,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_EM73D044SNA",
+		device_size:				_SPI_NAND_CHIP_SIZE_2GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_128BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout :			&ooblayout_etron,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_TOSHIBA,
+		dev_id: 					_SPI_NAND_DEVICE_ID_TC58CVG0S3H,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_TC58CVG0S3H",
+		device_size:				_SPI_NAND_CHIP_SIZE_1GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_64BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_toshiba,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_TOSHIBA,
+		dev_id: 					_SPI_NAND_DEVICE_ID_TC58CVG1S3H,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_TC58CVG1S3H",
+		device_size:				_SPI_NAND_CHIP_SIZE_2GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_64BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout : 			&ooblayout_toshiba,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	},
+
+	{
+		mfr_id: 					_SPI_NAND_MANUFACTURER_ID_MICRON,
+		dev_id: 					_SPI_NAND_DEVICE_ID_MT29F1G01,
+		ptr_name:					"_SPI_NAND_DEVICE_ID_MT29F1G01",
+		device_size:				_SPI_NAND_CHIP_SIZE_1GBIT,
+		page_size:					_SPI_NAND_PAGE_SIZE_2KBYTE,
+		oob_size:					_SPI_NAND_OOB_SIZE_128BYTE,
+		erase_size: 				_SPI_NAND_BLOCK_SIZE_128KBYTE,
+		dummy_mode: 				SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+		read_mode:					SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE,
+		oob_free_layout :			&ooblayout_micron,
+		plane_select:				SPI_NAND_FLASH_PLANE_SELECT_NONE,
+	}
+
+};
+
+/* LOCAL SUBPROGRAM BODIES------------------------------------------------------------ */
+static int generic_ffs(int x)
+{
+	int r = 1;
+
+	if (!x)
+		return 0;
+	if (!(x & 0xffff)) {
+		x >>= 16;
+		r += 16;
+	}
+	if (!(x & 0xff)) {
+		x >>= 8;
+		r += 8;
+	}
+	if (!(x & 0xf)) {
+		x >>= 4;
+		r += 4;
+	}
+	if (!(x & 3)) {
+		x >>= 2;
+		r += 2;
+	}
+	if (!(x & 1)) {
+		x >>= 1;
+		r += 1;
+	}
+	return r;
+}
+
+static void spi_nand_flash_debug_printf( SPI_NAND_FLASH_DEBUG_LEVEL_T DEBUG_LEVEL, char *fmt, ... )
+{
+	if( _SPI_NAND_DEBUG_LEVEL >= DEBUG_LEVEL )
+	{
+
+		unsigned char 		str_buf[100];
+		va_list 			argptr;
+		int 				cnt;
+
+		va_start(argptr, fmt);
+		cnt = vsprintf(str_buf, fmt, argptr);
+		va_end(argptr);
+
+		_SPI_NAND_PRINTF("%s", str_buf);
+	}
+}
+
+static void spi_nand_flash_debug_printf_array( SPI_NAND_FLASH_DEBUG_LEVEL_T DEBUG_LEVEL, char *buf, u32 len )
+{
+
+	u32	idx_for_debug;
+
+	if( _SPI_NAND_DEBUG_LEVEL >= DEBUG_LEVEL )
+	{
+
+		for(idx_for_debug=0; idx_for_debug< len; idx_for_debug++)
+		{
+			if( ((idx_for_debug) %8 == 0) )
+			{
+				_SPI_NAND_PRINTF("\n%04x: ", (idx_for_debug));
+			}
+			_SPI_NAND_PRINTF("%02x ", buf[idx_for_debug]);
+		}
+		_SPI_NAND_PRINTF("\n");
+	}
+
+}
+
+
+
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_reset( void )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send FFh opcode (Reset) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_SET_FEATURE );
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_reset\n");
+
+	return (rtn_status);
+}
+
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_set_status_reg_1( u8    protection )
+ * PURPOSE : To implement the SPI nand protocol for set status register 1.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : protection - The protection variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/17 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_set_status_reg_1( u8 protection )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 0Fh opcode (Set Feature) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_SET_FEATURE );
+
+	/* 3. Offset addr of protection (0xA0) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_ADDR_PROTECTION );
+
+	/* 4. Write new proteciton setting */
+	_SPI_NAND_WRITE_ONE_BYTE( protection );
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_set_status_reg_1: protection=0x%x\n", protection);
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_get_status_reg_1( u8    *ptr_rtn_protection )
+ * PURPOSE : To implement the SPI nand protocol for get status register 1.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: ptr_rtn_protection  - A pointer to the ptr_rtn_protection variable.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/17 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_get_status_reg_1( u8 *ptr_rtn_protection )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 0Fh opcode (Get Feature) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_GET_FEATURE );
+
+	/* 3. Offset addr of protection (0xA0) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_ADDR_PROTECTION );
+
+	/* 4. Read 1 byte data */
+	_SPI_NAND_READ_NBYTE( ptr_rtn_protection, _SPI_NAND_LEN_ONE_BYTE, SPI_CONTROLLER_SPEED_SINGLE);
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_get_status_reg_1: protection=0x%x\n", *ptr_rtn_protection);
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_set_status_reg_2( u8   feature )
+ * PURPOSE : To implement the SPI nand protocol for set status register 2.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : feature - The feature variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/21 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_set_status_reg_2( u8 feature )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 0Fh opcode (Set Feature) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_SET_FEATURE );
+
+	/* 3. Offset addr of feature (0xB0) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_ADDR_FEATURE );
+
+	/* 4. Write new feature setting */
+	_SPI_NAND_WRITE_ONE_BYTE( feature );
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_set_status_reg_2: feature=0x%x\n", feature);
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_get_status_reg_2( u8   *ptr_rtn_feature )
+ * PURPOSE : To implement the SPI nand protocol for get status register 2.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: ptr_rtn_feature  - A pointer to the ptr_rtn_feature variable.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/21 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_get_status_reg_2( u8 *ptr_rtn_feature )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 0Fh opcode (Get Feature) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_GET_FEATURE );
+
+	/* 3. Offset addr of protection (0xB0) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_ADDR_FEATURE );
+
+	/* 4. Read 1 byte data */
+	_SPI_NAND_READ_NBYTE( ptr_rtn_feature, _SPI_NAND_LEN_ONE_BYTE, SPI_CONTROLLER_SPEED_SINGLE);
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_get_status_reg_2: feature=0x%x\n", *ptr_rtn_feature);
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_NAND_FLASH_RTN_T spi_nand_protocol_get_status_reg_3( u8 *ptr_rtn_status )
+ * PURPOSE : To implement the SPI nand protocol for get status register 3.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : stats_reg - The stats_reg variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_get_status_reg_3( u8 *ptr_rtn_status )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 0Fh opcode (Get Feature) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_GET_FEATURE );
+
+	/* 3. Offset addr of status (0xC0) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_ADDR_STATUS );
+
+	/* 4. Read 1 byte data */
+	_SPI_NAND_READ_NBYTE( ptr_rtn_status, _SPI_NAND_LEN_ONE_BYTE, SPI_CONTROLLER_SPEED_SINGLE);
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_get_status_reg_3: status=0x%x\n", *ptr_rtn_status);
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_write_enable( void )
+ * PURPOSE : To implement the SPI nand protocol for write enable.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/17 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_write_enable( void )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select Low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Write op_cmd 0x06 (Write Enable (WREN)*/
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_WRITE_ENABLE );
+
+	/* 3. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_write_disable( void )
+ * PURPOSE : To implement the SPI nand protocol for write disable.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/17 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_write_disable( void )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select Low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Write op_cmd 0x04 (Write Disable (WRDI)*/
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_WRITE_DISABLE );
+
+	/* 3. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_block_erase( u32   block_idx )
+ * PURPOSE : To implement the SPI nand protocol for block erase.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : block_idx - The block_idx variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/17 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_block_erase( u32 block_idx )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select Low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Write op_cmd 0xD8 (Block Erase) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_BLOCK_ERASE );
+
+	/* 3. Write block number */
+	block_idx = block_idx << _SPI_NAND_BLOCK_ROW_ADDRESS_OFFSET; 	/*Row Address format in SPI NAND chip */
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_block_erase : block idx =0x%x\n", block_idx);
+
+	_SPI_NAND_WRITE_ONE_BYTE( (block_idx >> 16) & 0xff );		/* dummy byte */
+	_SPI_NAND_WRITE_ONE_BYTE( (block_idx >> 8)  & 0xff );
+	_SPI_NAND_WRITE_ONE_BYTE(  block_idx & 0xff );
+
+	/* 4. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_id( struct _SPI_NAND_FLASH_ID_T *ptr_rtn_flash_id )
+ * PURPOSE : To implement the SPI nand protocol for read id.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/12 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_id ( struct _SPI_NAND_FLASH_ID_T * ptr_rtn_flash_id )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select Low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Write op_cmd 0x9F (Read ID) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_READ_ID );
+
+	/* 3. Write Address Byte (0x00) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_ADDR_MANUFACTURE_ID );
+
+	/* 4. Read data (Manufacture ID and Device ID) */
+	_SPI_NAND_READ_NBYTE( &(ptr_rtn_flash_id->mfr_id), _SPI_NAND_LEN_ONE_BYTE, SPI_CONTROLLER_SPEED_SINGLE);
+	_SPI_NAND_READ_NBYTE( &(ptr_rtn_flash_id->dev_id), _SPI_NAND_LEN_ONE_BYTE, SPI_CONTROLLER_SPEED_SINGLE);
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_read_id : mfr_id=0x%x, dev_id=0x%x\n", ptr_rtn_flash_id->mfr_id, ptr_rtn_flash_id->dev_id);
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_id_2( struct _SPI_NAND_FLASH_ID_T *ptr_rtn_flash_id )
+ * PURPOSE : To implement the SPI nand protocol for read id.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/12 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_id_2 ( struct _SPI_NAND_FLASH_ID_T *ptr_rtn_flash_id )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 1. Chip Select Low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Write op_cmd 0x9F (Read ID) */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_READ_ID );
+
+	/* 3. Read data (Manufacture ID and Device ID) */
+	_SPI_NAND_READ_NBYTE( &(ptr_rtn_flash_id->mfr_id), _SPI_NAND_LEN_ONE_BYTE, SPI_CONTROLLER_SPEED_SINGLE);
+	_SPI_NAND_READ_NBYTE( &(ptr_rtn_flash_id->dev_id), _SPI_NAND_LEN_ONE_BYTE, SPI_CONTROLLER_SPEED_SINGLE);
+
+	/* 4. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_read_id_2 : mfr_id=0x%x, dev_id=0x%x\n", ptr_rtn_flash_id->mfr_id, ptr_rtn_flash_id->dev_id);
+
+	return (rtn_status);
+}
+
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_page_read( u32    page_number )
+ * PURPOSE : To implement the SPI nand protocol for page read.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : page_number - The page_number variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/17 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_page_read ( u32 page_number )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 13h opcode */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_PAGE_READ );
+
+	/* 3. Send page number */
+	_SPI_NAND_WRITE_ONE_BYTE( ((page_number >> 16 ) & 0xff) );
+	_SPI_NAND_WRITE_ONE_BYTE( ((page_number >> 8  ) & 0xff) );
+	_SPI_NAND_WRITE_ONE_BYTE( ((page_number)        & 0xff) );
+
+	/* 4. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_load_page_into_cache: value=0x%x\n", ((page_number ) & 0xff) );
+
+	return (rtn_status);
+
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_from_cache_single_speed( u32  data_offset,
+ *                                                                          u32  len,
+ *                                                                          u8   *ptr_rtn_buf )
+ * PURPOSE : To implement the SPI nand protocol for read from cache with single speed.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : data_offset  - The data_offset variable of this function.
+ *           len          - The len variable of this function.
+ *   OUTPUT: ptr_rtn_buf  - A pointer to the ptr_rtn_buf variable.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/19 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_from_cache_single_speed( u32 data_offset,
+																			u32 len,
+																			u8 *ptr_rtn_buf,
+																			SPI_NAND_FLASH_READ_DUMMY_BYTE_T dummy_mode )
+{
+
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 03h opcode */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_READ_FROM_CACHE_SINGLE );
+
+	/* 3. Send data_offset addr */
+	if( dummy_mode == SPI_NAND_FLASH_READ_DUMMY_BYTE_PREPEND )
+	{
+		_SPI_NAND_WRITE_ONE_BYTE( (0xff) );						/* dummy byte */
+	}
+
+
+	if( ((ptr_dev_info_t->plane_select) == SPI_NAND_FLASH_PLANE_SELECT_HAVE) )
+	{
+		if( _plane_select_bit == 0)
+		{
+			_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) &(0xef)) );
+		}
+		if( _plane_select_bit == 1)
+		{
+			_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) | (0x10)) );
+		}
+	}
+	else
+	{
+		_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) &(0xff)) );
+	}
+
+	_SPI_NAND_WRITE_ONE_BYTE( ((data_offset      ) &(0xff)) );
+
+	if( dummy_mode == SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND )
+	{
+		_SPI_NAND_WRITE_ONE_BYTE( (0xff) );						/* dummy byte */
+	}
+
+	/* 4. Read n byte (len) data */
+	_SPI_NAND_READ_NBYTE( ptr_rtn_buf, len, SPI_CONTROLLER_SPEED_SINGLE);
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_read_from_cache_single_speed : data_offset=0x%x, buf=0x%x\n", data_offset, ptr_rtn_buf);
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_from_cache_dual_speed( u32   data_offset,
+ *                                                                                     u32   len,
+ *                                                                                     u8    *ptr_rtn_buf )
+ * PURPOSE : To implement the SPI nand protocol for read from cache with dual speed.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : data_offset  - The data_offset variable of this function.
+ *           len          - The len variable of this function.
+ *   OUTPUT: ptr_rtn_buf  - A pointer to the ptr_rtn_buf variable.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/20 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_from_cache_dual_speed( u32 data_offset,
+																		  u32 len,
+																		  u8 *ptr_rtn_buf,
+																		  SPI_NAND_FLASH_READ_DUMMY_BYTE_T dummy_mode )
+{
+
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 3Bh opcode */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_READ_FROM_CACHE_DUAL );
+
+	/* 3. Send data_offset addr */
+	if( dummy_mode == SPI_NAND_FLASH_READ_DUMMY_BYTE_PREPEND )
+	{
+		_SPI_NAND_WRITE_ONE_BYTE( (0xff) );						/* dummy byte */
+	}
+
+	if( ((ptr_dev_info_t->plane_select) == SPI_NAND_FLASH_PLANE_SELECT_HAVE) )
+	{
+		if( _plane_select_bit == 0)
+		{
+			_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) &(0xef)) );
+		}
+		if( _plane_select_bit == 1)
+		{
+			_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) | (0x10)) );
+		}
+	}
+	else
+	{
+		_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) &(0xff)) );
+	}
+
+	_SPI_NAND_WRITE_ONE_BYTE( ((data_offset      ) &(0xff)) );
+		_SPI_NAND_WRITE_ONE_BYTE( (0xff) );						/* dummy byte */
+
+	/* 4. Read n byte (len) data */
+	_SPI_NAND_READ_NBYTE( ptr_rtn_buf, len, SPI_CONTROLLER_SPEED_DUAL);
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_read_from_cache_dual_speed : data_offset=0x%x, buf=0x%x\n", data_offset, ptr_rtn_buf);
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_from_cache_quad_speed( u32   data_offset,
+ *                                                                                     u32   len,
+ *                                                                                     u8    *ptr_rtn_buf )
+ * PURPOSE : To implement the SPI nand protocol for read from cache with quad speed.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : data_offset  - The data_offset variable of this function.
+ *           len          - The len variable of this function.
+ *   OUTPUT: ptr_rtn_buf  - A pointer to the ptr_rtn_buf variable.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/20 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_read_from_cache_quad_speed( u32 data_offset,
+																		  u32 len,
+																		  u8 *ptr_rtn_buf,
+																		  SPI_NAND_FLASH_READ_DUMMY_BYTE_T dummy_mode )
+{
+
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 6Bh opcode */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_READ_FROM_CACHE_QUAD );
+
+	/* 3. Send data_offset addr */
+	if( dummy_mode == SPI_NAND_FLASH_READ_DUMMY_BYTE_PREPEND )
+	{
+		_SPI_NAND_WRITE_ONE_BYTE( (0xff) );						/* dummy byte */
+	}
+	if( ((ptr_dev_info_t->plane_select) == SPI_NAND_FLASH_PLANE_SELECT_HAVE) )
+
+{
+		if( _plane_select_bit == 0)
+	{
+			_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) &(0xef)) );
+	}
+		if( _plane_select_bit == 1)
+	{
+		_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) | (0x10)) );
+	}
+}
+else
+{
+		_SPI_NAND_WRITE_ONE_BYTE( ((data_offset >> 8 ) &(0xff)) );
+}
+	_SPI_NAND_WRITE_ONE_BYTE( ((data_offset      ) &(0xff)) );
+		_SPI_NAND_WRITE_ONE_BYTE( (0xff) );						/* dummy byte */
+
+	/* 4. Read n byte (len) data */
+	_SPI_NAND_READ_NBYTE( ptr_rtn_buf, len, SPI_CONTROLLER_SPEED_QUAD);
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_read_from_cache_quad_speed : data_offset=0x%x, buf=0x%x\n", data_offset, ptr_rtn_buf);
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_single_speed( u32     addr,
+ *                                                                       u8      *ptr_data,
+ *                                                                       u32     len       )
+ * PURPOSE : To implement the SPI nand protocol for program load, with single speed.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : addr      - The addr variable of this function.
+ *           ptr_data  - A pointer to the ptr_data variable.
+ *           len       - The len variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/17 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_single_speed ( u32 addr,
+																		  u8 *ptr_data,
+																		  u32 len )
+{
+
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_program_load_single_speed: addr=0x%x, len=0x%x\n", addr, len );
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 02h opcode */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_PROGRAM_LOAD_SINGLE );
+
+	/* 3. Send address offset */
+	if( ((ptr_dev_info_t->plane_select) == SPI_NAND_FLASH_PLANE_SELECT_HAVE) )
+	{
+		if( _plane_select_bit == 0)
+		{
+			_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 8 ) & (0xef)) );
+		}
+		if( _plane_select_bit == 1)
+		{
+			_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 8 ) | (0x10)) );
+		}
+	}
+	else
+	{
+		_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 8 ) & (0xff)) );
+	}
+
+	_SPI_NAND_WRITE_ONE_BYTE( ((addr)        & (0xff)) );
+
+	/* 4. Send data */
+	_SPI_NAND_WRITE_NBYTE( ptr_data, len, SPI_CONTROLLER_SPEED_SINGLE);
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_quad_speed( u32  addr,
+ *                                                                                  u8   *ptr_data,
+ *                                                                                  u32  len       )
+ * PURPOSE : To implement the SPI nand protocol for program load, with quad speed.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : addr      - The addr variable of this function.
+ *           ptr_data  - A pointer to the ptr_data variable.
+ *           len       - The len variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/21 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_quad_speed ( u32 addr,
+																		u8 *ptr_data,
+																		u32 len )
+{
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_program_load_quad_speed: addr=0x%x, len=0x%x\n", addr, len );
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 32h opcode */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_PROGRAM_LOAD_QUAD );
+
+	/* 3. Send address offset */
+	if( ((ptr_dev_info_t->plane_select) == SPI_NAND_FLASH_PLANE_SELECT_HAVE)  )
+	{
+		if( _plane_select_bit == 0)
+		{
+			_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 8 ) & (0xef)) );
+		}
+		if( _plane_select_bit == 1)
+		{
+			_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 8 ) | (0x10)) );
+		}
+	}
+	else
+	{
+		_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 8 ) & (0xff)) );
+	}
+
+	_SPI_NAND_WRITE_ONE_BYTE( ((addr)        & (0xff)) );
+
+	/* 4. Send data */
+	_SPI_NAND_WRITE_NBYTE( ptr_data, len, SPI_CONTROLLER_SPEED_QUAD);
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	return (rtn_status);
+}
+
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_random_single_speed( u32     addr,
+ *                                                                       u8      *ptr_data,
+ *                                                                       u32     len       )
+ * PURPOSE : To implement the SPI nand protocol for program load, with single speed.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : addr      - The addr variable of this function.
+ *           ptr_data  - A pointer to the ptr_data variable.
+ *           len       - The len variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/17 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_random_single_speed ( u32 addr,
+																		  u8 *ptr_data,
+																		  u32 len )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_program_load_single_speed: addr=0x%x, len=0x%x\n", addr, len );
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 84h opcode */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_PROGRAM_LOAD_RAMDOM_SINGLE );
+
+	/* 3. Send address offset */
+	_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 8  ) & 0xff) );
+	_SPI_NAND_WRITE_ONE_BYTE( ((addr)        & 0xff) );
+
+	/* 4. Send data */
+	_SPI_NAND_WRITE_NBYTE( ptr_data, len, SPI_CONTROLLER_SPEED_SINGLE);
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_random_quad_speed( u32  addr,
+ *                                                                                  u8   *ptr_data,
+ *                                                                                  u32  len       )
+ * PURPOSE : To implement the SPI nand protocol for program load, with quad speed.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : addr      - The addr variable of this function.
+ *           ptr_data  - A pointer to the ptr_data variable.
+ *           len       - The len variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/21 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_load_random_quad_speed ( u32 addr,
+																		u8 *ptr_data,
+																		u32 len )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_program_load_quad_speed: addr=0x%x, len=0x%x\n", addr, len );
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 34h opcode */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_PROGRAM_LOAD_RAMDON_QUAD );
+
+	/* 3. Send address offset */
+	_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 8  ) & 0xff) );
+	_SPI_NAND_WRITE_ONE_BYTE( ((addr)        & 0xff) );
+
+	/* 4. Send data */
+	_SPI_NAND_WRITE_NBYTE( ptr_data, len, SPI_CONTROLLER_SPEED_QUAD);
+
+	/* 5. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	return (rtn_status);
+}
+
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_execute( u32  addr )
+ * PURPOSE : To implement the SPI nand protocol for program execute.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : addr - The addr variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/17 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_protocol_program_execute ( u32 addr )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_protocol_program_execute: addr=0x%x\n", addr);
+
+	/* 1. Chip Select low */
+	_SPI_NAND_READ_CHIP_SELECT_LOW();
+
+	/* 2. Send 10h opcode */
+	_SPI_NAND_WRITE_ONE_BYTE( _SPI_NAND_OP_PROGRAM_EXECUTE );
+
+	/* 3. Send address offset */
+	_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 16  ) & 0xff) );
+	_SPI_NAND_WRITE_ONE_BYTE( ((addr >> 8	 ) & 0xff) );
+	_SPI_NAND_WRITE_ONE_BYTE( ((addr)         & 0xff) );
+
+	/* 4. Chip Select High */
+	_SPI_NAND_READ_CHIP_SELECT_HIGH();
+
+	return (rtn_status);
+}
+
+
+
+static SPI_NAND_FLASH_RTN_T ecc_fail_check( u32 page_number )
+{
+	u8								status;
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	spi_nand_protocol_get_status_reg_3( &status);
+
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "ecc_fail_check: status=0x%x\n", status);
+
+	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE )
+	{
+
+
+		if( ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F1GQ4UAYIG)
+		{
+			if( ((status & 0x30) >> 4) == 0x2 )
+			{
+				rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+			}
+		}
+
+		if( ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F1GQ4UBYIG)
+		{
+			if( ((status & 0x30) >> 4) == 0x2 )
+			{
+				rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+			}
+		}
+
+		if( ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F2GQ4UBYIG)
+		{
+			if( ((status & 0x30) >> 4) == 0x2 )
+			{
+				rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+			}
+		}
+
+
+		if( ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F1GQ4UCYIG)
+		{
+			if( ((status & 0x70) >> 4) == 0x7 )
+			{
+				rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+			}
+		}
+
+		if( ptr_dev_info_t->dev_id == _SPI_NAND_DEVICE_ID_GD5F2GQ4UCYIG)
+		{
+			if( ((status & 0x70) >> 4) == 0x7 )
+			{
+				rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+			}
+		}
+
+	}
+
+
+	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_MXIC )
+	{
+
+		if( ((status & 0x30) >> 4) == 0x2 )
+		{
+			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+		}
+
+	}
+
+	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_WINBOND )
+	{
+
+		if( ((status & 0x30) >> 4) == 0x2 )
+		{
+			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+		}
+
+	}
+
+	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_ESMT )
+	{
+
+		if( ((status & 0x30) >> 4) == 0x2 )
+		{
+			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+		}
+
+	}
+	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_ZENTEL )
+	{
+
+		if( ((status & 0x30) >> 4) == 0x2 )
+		{
+			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+		}
+
+	}
+	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_ETRON )
+	{
+
+		if( ((status & 0x30) >> 4) == 0x2 )
+		{
+			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+		}
+
+	}
+	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_TOSHIBA )
+	{
+
+		if( ((status & 0x30) >> 4) == 0x2 )
+		{
+			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+		}
+
+	}
+	if( ptr_dev_info_t->mfr_id == _SPI_NAND_MANUFACTURER_ID_MICRON )
+	{
+
+		if( ((status & 0x70) >> 4) == 0x2 )
+		{
+			rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+		}
+
+	}
+
+
+
+	if( rtn_status == SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK)
+	{
+		_SPI_NAND_PRINTF("[spinand_ecc_fail_check] : ECC cannot recover detected !, page=0x%x\n", page_number);
+	}
+
+	return (rtn_status);
+}
+
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_load_page_into_cache( long  page_number )
+ * PURPOSE : To load page into SPI NAND chip.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : page_number - The page_number variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/16 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_load_page_into_cache( u32 page_number)
+{
+	u8						status;
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_load_page_into_cache: page number =0x%x\n", page_number);
+
+	if( _current_page_num == page_number )
+	{
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_load_page_into_cache: page number == _current_page_num\n");
+	}
+	else
+	{
+		spi_nand_protocol_page_read ( page_number );
+
+		/*  Checking status for load page/erase/program complete */
+		do{
+			spi_nand_protocol_get_status_reg_3( &status);
+		}while( status & _SPI_NAND_VAL_OIP) ;
+
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_load_page_into_cache : status =0x%x\n", status);
+
+		rtn_status = ecc_fail_check(page_number);
+	}
+
+	return (rtn_status);
+
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_block_aligned_check( u32   addr,
+ *                                                                     u32   len  )
+ * PURPOSE : To check block align.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : addr - The addr variable of this function.
+ *           len  - The len variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/15 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_block_aligned_check( u32 addr,
+														  u32 len )
+{
+	struct SPI_NAND_FLASH_INFO_T		*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T				rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+
+	ptr_dev_info_t = _SPI_NAND_GET_DEVICE_INFO_PTR ;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "SPI_NAND_BLOCK_ALIGNED_CHECK_check: addr=0x%x, len=0x%x, block size =0x%x \n", addr, len, (ptr_dev_info_t->erase_size));
+
+	if (_SPI_NAND_BLOCK_ALIGNED_CHECK(len, (ptr_dev_info_t->erase_size)))
+	{
+		len = ( (len/ptr_dev_info_t->erase_size) + 1) * (ptr_dev_info_t->erase_size);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand__SPI_NAND_BLOCK_ALIGNED_CHECK_check: erase block aligned first check OK, addr:%x len:%x\n", addr, len, (ptr_dev_info_t->erase_size));
+	}
+
+	if (_SPI_NAND_BLOCK_ALIGNED_CHECK(addr, (ptr_dev_info_t->erase_size)) || _SPI_NAND_BLOCK_ALIGNED_CHECK(len, (ptr_dev_info_t->erase_size)) )
+	{
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand__SPI_NAND_BLOCK_ALIGNED_CHECK_check: erase block not aligned, addr:0x%x len:0x%x, blocksize:0x%x\n", addr, len, (ptr_dev_info_t->erase_size));
+		rtn_status = SPI_NAND_FLASH_RTN_ALIGNED_CHECK_FAIL;
+	}
+
+	return (rtn_status);
+}
+
+
+static SPI_NAND_FLASH_RTN_T spi_nand_erase_block ( u32 block_index)
+{
+
+	u8						status;
+	SPI_NAND_FLASH_RTN_T	rtn_status	= SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	/* 2.2 Enable write_to flash */
+	spi_nand_protocol_write_enable();
+
+	/* 2.3 Erasing one block */
+	spi_nand_protocol_block_erase( block_index );
+
+	/* 2.4 Checking status for erase complete */
+	do{
+		spi_nand_protocol_get_status_reg_3( &status);
+	}while( status & _SPI_NAND_VAL_OIP) ;
+
+	/* 2.5 Disable write_flash */
+	spi_nand_protocol_write_disable();
+
+	/* 2.6 Check Erase Fail Bit */
+	if( status & _SPI_NAND_VAL_ERASE_FAIL )
+	{
+		_SPI_NAND_PRINTF("spi_nand_erase_block : erase block fail, block=0x%x, status=0x%x\n", block_index, status);
+		rtn_status = SPI_NAND_FLASH_RTN_ERASE_FAIL;
+	}
+
+	return rtn_status;
+}
+
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_erase_internal( u32     addr,
+ *                                               				  u32     len )
+ * PURPOSE : To erase flash internally.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : addr - The addr variable of this function.
+ *           len - The size variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/15 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_erase_internal( u32 addr,
+													 u32 len )
+{
+	u32						block_index = 0;
+	u32						erase_len	= 0;
+	SPI_NAND_FLASH_RTN_T	rtn_status  = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+    unsigned short phy_block_bbt;
+	u32				logical_block, physical_block;
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+#endif
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "\nspi_nand_erase_internal (in): addr=0x%x, len=0x%x\n", addr, len );
+
+	_SPI_NAND_SEMAPHORE_LOCK();
+
+	SPI_NAND_Flash_Clear_Read_Cache_Data();
+
+	/* 1. Check the address and len must aligned to NAND Flash block size */
+	if( spi_nand_block_aligned_check( addr, len) == SPI_NAND_FLASH_RTN_NO_ERROR)
+	{
+		/* 2. Erase block one by one */
+		while( erase_len < len )
+		{
+			/* 2.1 Caculate Block index */
+			block_index = (addr/(_current_flash_info_t.erase_size));
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+			logical_block = block_index;
+			physical_block = get_mapping_block_index(logical_block, &phy_block_bbt);
+			if( physical_block != logical_block)
+			{
+				_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "Bad Block Mapping, from %d block to %d block\n", logical_block, physical_block);
+			}
+			block_index = physical_block;
+#endif
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_erase_internal: addr=0x%x, len=0x%x, block_idx=0x%x\n", addr, len, block_index );
+
+
+			rtn_status = spi_nand_erase_block(block_index);
+
+			/* 2.6 Check Erase Fail Bit */
+			if( rtn_status != SPI_NAND_FLASH_RTN_NO_ERROR )
+			{
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+					if (update_bmt(addr,UPDATE_ERASE_FAIL, NULL, NULL))
+					{
+						_SPI_NAND_PRINTF("Erase fail at block: %d, update BMT success\n", addr/(_current_flash_info_t.erase_size));
+						rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+					}
+					else
+					{
+						_SPI_NAND_PRINTF("Erase fail at block: %d, update BMT fail\n", addr/(_current_flash_info_t.erase_size));
+						rtn_status = SPI_NAND_FLASH_RTN_ERASE_FAIL;
+						break;
+					}
+#else
+				_SPI_NAND_PRINTF("spi_nand_erase_internal : Erase Fail at addr=0x%x, len=0x%x, block_idx=0x%x\n", addr, len, block_index);
+				rtn_status = SPI_NAND_FLASH_RTN_ERASE_FAIL;
+				break;
+
+#endif
+			}
+
+			/* 2.7 Erase next block if needed */
+			addr		+= _current_flash_info_t.erase_size;
+			erase_len	+= _current_flash_info_t.erase_size;
+
+		}
+	}
+	else
+	{
+		rtn_status = SPI_NAND_FLASH_RTN_ALIGNED_CHECK_FAIL;
+	}
+
+	_SPI_NAND_SEMAPHORE_UNLOCK();
+
+	return 	(rtn_status);
+}
+
+
+
+
+static SPI_NAND_FLASH_RTN_T spi_nand_read_page ( u32 page_number,
+  													   SPI_NAND_FLASH_READ_SPEED_MODE_T speed_mode
+  													 )
+{
+
+	u32			 					idx=0;
+	u32								i, j;
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+	struct spi_nand_flash_oobfree 	*ptr_oob_entry_idx;
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	/* 1. Load Page into cache of NAND Flash Chip */
+	if( spi_nand_load_page_into_cache(page_number) == SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK )
+	{
+		_SPI_NAND_PRINTF("spi_nand_read_page: Bad Block, ECC cannot recovery detecte, page=0x%x\n", page_number);
+		rtn_status = SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK;
+	}
+
+	/* 2. Read whole data from cache of NAND Flash Chip */
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_read_page: curren_page_num=0x%x, page_number=0x%x\n", _current_page_num, page_number);
+
+	if( (rtn_status==SPI_NAND_FLASH_RTN_NO_ERROR) && (_current_page_num != page_number) )
+	{
+		memset(_current_cache_page, 0x0, sizeof(_current_cache_page));
+
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_read_page: before read, _current_cache_page:\n");
+		_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page[0], _SPI_NAND_CACHE_SIZE);
+
+		if( ((ptr_dev_info_t->plane_select) == SPI_NAND_FLASH_PLANE_SELECT_HAVE) )
+		{
+			_plane_select_bit = ((page_number >> 6)& (0x1));
+
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"spi_nand_read_page: plane select = 0x%x\n",  _plane_select_bit);
+		}
+
+		switch (speed_mode)
+		{
+			case SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE:
+				spi_nand_protocol_read_from_cache_single_speed( 0, ((ptr_dev_info_t->page_size)+(ptr_dev_info_t->oob_size)), &_current_cache_page[0], ptr_dev_info_t->dummy_mode );
+				break;
+
+			case SPI_NAND_FLASH_READ_SPEED_MODE_DUAL:
+				spi_nand_protocol_read_from_cache_dual_speed( 0, ((ptr_dev_info_t->page_size)+(ptr_dev_info_t->oob_size)), &_current_cache_page[0], ptr_dev_info_t->dummy_mode );
+				break;
+
+			case SPI_NAND_FLASH_READ_SPEED_MODE_QUAD:
+				spi_nand_protocol_read_from_cache_quad_speed( 0, ((ptr_dev_info_t->page_size)+(ptr_dev_info_t->oob_size)), &_current_cache_page[0], ptr_dev_info_t->dummy_mode );
+				break;
+
+			default:
+				break;
+		}
+
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_read_page: after read, _current_cache_page:\n");
+		_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page[0], _SPI_NAND_CACHE_SIZE);
+
+		/* Divide read page into data segment and oob segment  */
+		memcpy( &_current_cache_page_data[0], &_current_cache_page[0], (ptr_dev_info_t->page_size) );
+		memcpy( &_current_cache_page_oob[0],  &_current_cache_page[(ptr_dev_info_t->page_size)], (ptr_dev_info_t->oob_size) );
+
+		idx = 0;
+		ptr_oob_entry_idx = (struct spi_nand_flash_oobfree*) &( (ptr_dev_info_t->oob_free_layout)->oobfree );
+
+		/* Transter oob area from physical offset into logical offset */
+		for( i=0; (i<SPI_NAND_FLASH_OOB_FREE_ENTRY_MAX) && (ptr_oob_entry_idx[i].len) && (idx< ((ptr_dev_info_t->oob_free_layout)->oobsize)) ; i++)
+		{
+			for(j=0; (j< (ptr_oob_entry_idx[i].len)) && (idx<(ptr_dev_info_t->oob_free_layout->oobsize)) ; j++)
+			{
+				/* _SPI_NAND_PRINTF("i=%d , j=%d, len=%d, idx=%d, size=%d\n", i, j,(ptr_oob_entry_idx[i].len), idx, (ptr_dev_info_t->oob_free_layout->oobsize) ); */
+				_current_cache_page_oob_mapping[idx] = _current_cache_page_oob[(ptr_oob_entry_idx[i].offset)+j];
+				idx++;
+			}
+		}
+
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_read_page: _current_cache_page:\n");
+		_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page[0], ((ptr_dev_info_t->page_size)+(ptr_dev_info_t->oob_size)));
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_read_page: _current_cache_page_oob:\n");
+		_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page_oob[0], (ptr_dev_info_t->oob_size));
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_read_page: _current_cache_page_oob_mapping:\n");
+		_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page_oob_mapping[0], (ptr_dev_info_t->oob_size));
+
+		_current_page_num = page_number;
+	}
+
+
+	return rtn_status;
+
+
+}
+
+
+
+static SPI_NAND_FLASH_RTN_T spi_nand_write_page(	u32 page_number,
+														u32 data_offset,
+													  	u8  *ptr_data,
+													  	u32 data_len,
+													  	u32 oob_offset,
+														u8  *ptr_oob ,
+														u32 oob_len,
+													    SPI_NAND_FLASH_WRITE_SPEED_MODE_T speed_mode )
+{
+
+		u8		status, status_2;
+		u32		i=0,j=0,idx=0;
+		struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+		struct spi_nand_flash_oobfree 	*ptr_oob_entry_idx;
+		SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+		ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+		/* Read Current page data to software cache buffer */
+		spi_nand_read_page(page_number, SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE);
+
+		/* Rewirte the software cahe buffer */
+		if(data_len > 0)
+		{
+			memcpy( &_current_cache_page_data[data_offset], &ptr_data[0], data_len );
+		}
+
+		if( oob_len > 0 )	/* Write OOB */
+		{
+			ptr_oob_entry_idx = (struct spi_nand_flash_oobfree*) &( ptr_dev_info_t->oob_free_layout->oobfree );
+
+			for( i=0; (i<SPI_NAND_FLASH_OOB_FREE_ENTRY_MAX) && (ptr_oob_entry_idx[i].len) && ((idx< (ptr_dev_info_t->oob_free_layout->oobsize)) && (idx < oob_len))  ; i++)
+			{
+				for(j=0; (j< (ptr_oob_entry_idx[i].len)) && (idx<(ptr_dev_info_t->oob_free_layout->oobsize)) && ((idx< (ptr_dev_info_t->oob_free_layout->oobsize)) && (idx < oob_len)) ; j++)
+				{
+
+					_current_cache_page_oob[(ptr_oob_entry_idx[i].offset)+j] &= ptr_oob[idx];
+					idx++;
+				}
+			}
+		}
+
+		memcpy( &_current_cache_page[0], &_current_cache_page_data[0], _SPI_NAND_PAGE_SIZE );
+		memcpy( &_current_cache_page[_SPI_NAND_PAGE_SIZE],  &_current_cache_page_oob[0], _SPI_NAND_OOB_SIZE );
+
+
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_write_page: data_offset=0x%x, date_len=0x%x, oob_offset=0x%x, oob_len=0x%x\n", data_offset, data_len, oob_offset, oob_len);
+		_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)));
+
+		if( ((ptr_dev_info_t->plane_select) == SPI_NAND_FLASH_PLANE_SELECT_HAVE)  )
+		{
+			_plane_select_bit = ((page_number >> 6) & (0x1));
+
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_write_page: _plane_select_bit=0x%x\n", _plane_select_bit );
+
+		}
+
+		/* Different Manafacture have different prgoram flow and setting */
+
+		if( ((ptr_dev_info_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_MXIC ) || \
+			((ptr_dev_info_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_WINBOND ) || \
+			((ptr_dev_info_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_ESMT)  || \
+			((ptr_dev_info_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_ETRON) )
+		{
+			/*	Enable write_to flash */
+			spi_nand_protocol_write_enable();
+
+			/* Proram data into buffer of SPI NAND chip */
+			switch( speed_mode )
+			{
+				case SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE:
+					spi_nand_protocol_program_load_single_speed( 0, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)) );
+					break;
+
+				case SPI_NAND_FLASH_WRITE_SPEED_MODE_QUAD:
+					spi_nand_protocol_program_load_quad_speed( 0, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)));
+					break;
+
+				default:
+					break;
+			}
+		}
+		else if( ((ptr_dev_info_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE) )
+		{
+
+			switch( speed_mode )
+			{
+				case SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE:
+					spi_nand_protocol_program_load_single_speed( 0, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)) );
+					break;
+
+				case SPI_NAND_FLASH_WRITE_SPEED_MODE_QUAD:
+					spi_nand_protocol_program_load_quad_speed( 0, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)) );
+					break;
+
+				default:
+					break;
+			}
+
+			/*	Enable write_to flash */
+			spi_nand_protocol_write_enable();
+		}
+		else
+		{
+			/*	Enable write_to flash */
+			spi_nand_protocol_write_enable();
+
+			/* Proram data into buffer of SPI NAND chip */
+			switch( speed_mode )
+			{
+				case SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE:
+					spi_nand_protocol_program_load_single_speed(  0, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)) );
+					break;
+
+				case SPI_NAND_FLASH_WRITE_SPEED_MODE_QUAD:
+					spi_nand_protocol_program_load_quad_speed(  0, &_current_cache_page[0], ((ptr_dev_info_t->page_size) + (ptr_dev_info_t->oob_size)) );
+					break;
+
+				default:
+					break;
+			}
+		}
+
+		/*	Execute program data into SPI NAND chip  */
+		spi_nand_protocol_program_execute ( page_number );
+
+		/*	Checking status for erase complete */
+		do{
+			spi_nand_protocol_get_status_reg_3( &status);
+		}while( status & _SPI_NAND_VAL_OIP) ;
+
+		/*. Disable write_flash */
+		spi_nand_protocol_write_disable();
+
+		spi_nand_protocol_get_status_reg_1( &status_2);
+
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spi_nand_write_page]: status 1 = 0x%x, status 3 =0x%x\n", status_2, status);
+
+		/*	Check Program Fail Bit */
+		if( status & _SPI_NAND_VAL_PROGRAM_FAIL )
+		{
+			_SPI_NAND_PRINTF("spi_nand_write_page : Program Fail at addr_offset =0x%x, page_number=0x%x, status=0x%x\n", data_offset, page_number, status);
+			rtn_status = SPI_NAND_FLASH_RTN_PROGRAM_FAIL;
+		}
+
+
+		return (rtn_status);
+
+}
+
+
+
+
+static SPI_NAND_FLASH_RTN_T spi_nand_write_page_internal(	u32 page_number,
+																	u32 data_offset,
+													  				u8  *ptr_data,
+																  	u32 data_len,
+																  	u32 oob_offset,
+																	u8  *ptr_oob ,
+																	u32 oob_len,
+																    SPI_NAND_FLASH_WRITE_SPEED_MODE_T speed_mode )
+{
+
+	u32					 			addr_offset;
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+    unsigned short phy_block_bbt;
+	u32			   logical_block, physical_block;
+	u32			   page_offset_in_block;
+#endif
+
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spi_nand_write_page_internal]: enter\n");
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	_SPI_NAND_SEMAPHORE_LOCK();
+
+	SPI_NAND_Flash_Clear_Read_Cache_Data();
+
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+			page_offset_in_block = ((page_number * (ptr_dev_info_t->page_size))%(ptr_dev_info_t->erase_size))/(ptr_dev_info_t->page_size);
+			logical_block = ((page_number * (ptr_dev_info_t->page_size))/(ptr_dev_info_t->erase_size)) ;
+			physical_block = get_mapping_block_index(logical_block, &phy_block_bbt);
+
+			if( physical_block != logical_block)
+			{
+				_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "Bad Block Mapping, from %d block to %d block\n", logical_block, physical_block);
+			}
+
+			page_number = (page_offset_in_block)+((physical_block*(ptr_dev_info_t->erase_size))/(ptr_dev_info_t->page_size));
+#endif
+
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spi_nand_write_page_internal]: page_number = 0x%x\n", page_number);
+
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+		if(block_is_in_bmt_region(physical_block))
+		{
+			memcpy(ptr_oob + OOB_INDEX_OFFSET, &phy_block_bbt, OOB_INDEX_SIZE);
+		}
+
+       if(_SPI_NAND_TEST_FLAG == 0)
+       {
+
+
+		   _SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spi_nand_write_page_internal: data_offset=0x%x, date_len=0x%x, oob_offset=0x%x, oob_len=0x%x\n", data_offset, data_len, oob_offset, oob_len);
+			_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &ptr_oob[0], oob_len);
+
+			rtn_status = spi_nand_write_page(page_number, addr_offset, ptr_data, data_len, 0, ptr_oob, MAX_USE_OOB_SIZE , speed_mode);
+       }
+	   else
+	   {
+	   		rtn_status = SPI_NAND_FLASH_RTN_PROGRAM_FAIL;
+	   }
+
+		if(rtn_status != SPI_NAND_FLASH_RTN_NO_ERROR)
+		{
+		    _SPI_NAND_PRINTF("write fail at page: 0x%x \n", page_number);
+            if (update_bmt(page_number * (ptr_dev_info_t->page_size), UPDATE_WRITE_FAIL, ptr_data, ptr_oob))
+            {
+                _SPI_NAND_PRINTF("Update BMT success\n");
+				rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+            }
+            else
+            {
+                _SPI_NAND_PRINTF("Update BMT fail\n");
+            }
+		}
+#else
+		rtn_status = spi_nand_write_page(page_number, addr_offset, ptr_data, data_len, 0, ptr_oob, MAX_USE_OOB_SIZE , speed_mode);
+#endif
+
+
+	SPI_NAND_Flash_Clear_Read_Cache_Data();
+
+	_SPI_NAND_SEMAPHORE_UNLOCK();
+
+	return (rtn_status);
+}
+
+
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_write_internal( u32    dst_addr,
+ *                                                                u32    len,
+ *                                                                u32    *ptr_rtn_len,
+ *                                                                u8*    ptr_buf      )
+ * PURPOSE : To write flash internally.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : dst_addr     - The dst_addr variable of this function.
+ *           len          - The len variable of this function.
+ *           ptr_buf      - A pointer to the ptr_buf variable.
+ *   OUTPUT: ptr_rtn_len  - A pointer to the ptr_rtn_len variable.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/19 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+ static SPI_NAND_FLASH_RTN_T spi_nand_write_internal( u32 dst_addr,
+													 u32 len,
+													 u32 *ptr_rtn_len,
+													 u8* ptr_buf,
+													 SPI_NAND_FLASH_WRITE_SPEED_MODE_T speed_mode )
+{
+	u32					 			remain_len, write_addr, data_len, page_number, physical_dst_addr;
+	u32					 			addr_offset;
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+    unsigned short phy_block_bbt;
+	unsigned long  addr_offset_in_block;
+	u32			   logical_block, physical_block;
+	u8			   oob_buf[_SPI_NAND_OOB_SIZE]={0xff};
+#endif
+
+
+	*ptr_rtn_len 	= 0;
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+	remain_len 		= len;
+	write_addr 		= dst_addr;
+
+	_SPI_NAND_SEMAPHORE_LOCK();
+
+	SPI_NAND_Flash_Clear_Read_Cache_Data();
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_write_internal: remain_len =0x%x\n", remain_len);
+
+	while( remain_len > 0 )
+	{
+		physical_dst_addr = write_addr;
+
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+		memset(oob_buf, 0xff, _SPI_NAND_OOB_SIZE);
+			addr_offset_in_block = (write_addr %(ptr_dev_info_t->erase_size) );
+			logical_block = (write_addr / (ptr_dev_info_t->erase_size));
+			physical_block = get_mapping_block_index(logical_block, &phy_block_bbt);
+			physical_dst_addr = (physical_block * (ptr_dev_info_t->erase_size))+ addr_offset_in_block;
+
+			if( physical_block != logical_block)
+			{
+				_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "Bad Block Mapping, from %d block to %d block\n", logical_block, physical_block);
+			}
+#endif
+
+		/* Caculate page number */
+		addr_offset = (physical_dst_addr % (ptr_dev_info_t->page_size));
+		page_number = (physical_dst_addr / (ptr_dev_info_t->page_size));
+
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "\nspi_nand_write_internal: addr_offset =0x%x, page_number=0x%x, remain_len=0x%x, page_size=0x%x\n", addr_offset, page_number, remain_len,(ptr_dev_info_t->page_size) );
+		if( ((addr_offset + remain_len ) > (ptr_dev_info_t->page_size))  )  /* data cross over than 1 page range */
+		{
+			data_len = ((ptr_dev_info_t->page_size) - addr_offset);
+		}
+		else
+		{
+			data_len = remain_len;
+		}
+
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+		if(block_is_in_bmt_region(physical_block))
+		{
+			memcpy(oob_buf + OOB_INDEX_OFFSET, &phy_block_bbt, OOB_INDEX_SIZE);
+		}
+
+       if(_SPI_NAND_TEST_FLAG == 0)
+       {
+		rtn_status = spi_nand_write_page(page_number, addr_offset, &(ptr_buf[len - remain_len]), data_len, 0, &oob_buf[0], _SPI_NAND_OOB_SIZE , speed_mode);
+       }
+	   else
+	   {
+	   	rtn_status = SPI_NAND_FLASH_RTN_PROGRAM_FAIL;
+	   }
+
+		if(rtn_status != SPI_NAND_FLASH_RTN_NO_ERROR)
+		{
+		    _SPI_NAND_PRINTF("write fail at page: %d \n", page_number);
+            if (update_bmt(page_number * (ptr_dev_info_t->page_size), UPDATE_WRITE_FAIL, &(ptr_buf[len - remain_len]), oob_buf))
+            {
+                _SPI_NAND_PRINTF("Update BMT success\n");
+				rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+            }
+            else
+            {
+                _SPI_NAND_PRINTF("Update BMT fail\n");
+				_SPI_NAND_SEMAPHORE_UNLOCK();
+                return -1;
+            }
+		}
+#else
+		rtn_status = spi_nand_write_page(page_number, addr_offset, &(ptr_buf[len - remain_len]), data_len, 0, NULL, 0 , speed_mode);
+#endif
+
+		/* 8. Write remain data if neccessary */
+		write_addr	+= data_len;
+		remain_len  -= data_len;
+		ptr_rtn_len += data_len;
+
+	}
+
+	_SPI_NAND_SEMAPHORE_UNLOCK();
+
+	return (rtn_status);
+}
+
+static SPI_NAND_FLASH_RTN_T spi_nand_read_page_internal ( u32 page_number,
+																 SPI_NAND_FLASH_READ_SPEED_MODE_T speed_mode )
+{
+		u32 							logical_block, physical_block;
+		struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+		SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+		unsigned short phy_block_bbt;
+		u32 		   page_offset_in_block;
+#endif
+		ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+
+		_SPI_NAND_SEMAPHORE_LOCK();
+
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+			page_offset_in_block = (((page_number * (ptr_dev_info_t->page_size))%(ptr_dev_info_t->erase_size))/ (ptr_dev_info_t->page_size));
+			logical_block = ((page_number * (ptr_dev_info_t->page_size))/(ptr_dev_info_t->erase_size)) ;
+			physical_block = get_mapping_block_index(logical_block, &phy_block_bbt);
+
+			if( physical_block != logical_block)
+			{
+				_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "Bad Block Mapping, from %d block to %d block\n", logical_block, physical_block);
+			}
+
+			page_number = (page_offset_in_block)+ ((physical_block*(ptr_dev_info_t->erase_size))/(ptr_dev_info_t->page_size));
+#endif
+
+
+			spi_nand_read_page(page_number, speed_mode);
+
+		_SPI_NAND_SEMAPHORE_UNLOCK();
+
+		return (rtn_status);
+
+}
+
+
+
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_read_internal( u32     addr,
+ *                                                               u32     len,
+ *                                                               u8      *ptr_rtn_buf )
+ * PURPOSE : To read flash internally.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : addr         - The addr variable of this function.
+ *           len          - The len variable of this function.
+ *   OUTPUT: ptr_rtn_buf  - A pointer to the ptr_rtn_buf variable.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/19 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_read_internal ( unsigned long long addr,
+													 u32 len,
+													 u8 *ptr_rtn_buf,
+													 SPI_NAND_FLASH_READ_SPEED_MODE_T speed_mode )
+{
+	u32			 					page_number, data_offset;
+	u32			 					read_addr, physical_read_addr, remain_len, logical_block, physical_block;
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+    unsigned short phy_block_bbt;
+	unsigned long  addr_offset_in_block;
+#endif
+
+	if(  (0xbc000000 <= addr) && (addr<= 0xbfffffff) )		/* Reserver address area for system */
+	{
+		if( (addr & 0xbfc00000) == 0xbfc00000)
+		{
+			addr &= 0x003fffff;
+		}
+		else
+		{
+			addr &= 0x03ffffff;
+		}
+	}
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+	read_addr  		= addr;
+	remain_len 		= len;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "\nspi_nand_read_internal : addr=0x%lx, len=0x%x\n", addr, len );
+
+	_SPI_NAND_SEMAPHORE_LOCK();
+
+	while(remain_len > 0)
+	{
+		physical_read_addr = read_addr;
+
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+		addr_offset_in_block = (read_addr %(ptr_dev_info_t->erase_size) );
+		logical_block = (read_addr / (ptr_dev_info_t->erase_size));
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"read_addr=0x%x, erase size =0x%x, logical_block =0x%x\n", read_addr, (ptr_dev_info_t->erase_size), logical_block);
+		physical_block = get_mapping_block_index(logical_block, &phy_block_bbt);
+		physical_read_addr = (physical_block * (ptr_dev_info_t->erase_size))+ addr_offset_in_block;
+
+		if( physical_block != logical_block)
+		{
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "Bad Block Mapping, from %d block to %d block\n", logical_block, physical_block);
+		}
+#endif
+
+		/* Caculate page number */
+		data_offset = (physical_read_addr % (ptr_dev_info_t->page_size));
+		page_number = (physical_read_addr / (ptr_dev_info_t->page_size));
+
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_read_internal: read_addr=0x%x, page_number=0x%x, data_offset=0x%x\n", physical_read_addr, page_number, data_offset);
+
+		spi_nand_read_page(page_number, speed_mode);
+
+		/* 3. Retrieve the request data */
+		if( (data_offset + remain_len) < _SPI_NAND_PAGE_SIZE )
+			{
+			memcpy( &ptr_rtn_buf[len - remain_len], &_current_cache_page_data[data_offset], (sizeof(unsigned char)*remain_len) );
+			remain_len =0;
+
+		}
+		else
+		{
+			memcpy( &ptr_rtn_buf[len - remain_len], &_current_cache_page_data[data_offset], (sizeof(unsigned char)*(_SPI_NAND_PAGE_SIZE- data_offset)));
+			remain_len -= (_SPI_NAND_PAGE_SIZE- data_offset);
+			read_addr += (_SPI_NAND_PAGE_SIZE- data_offset);
+		}
+	}
+	_SPI_NAND_SEMAPHORE_UNLOCK();
+
+	return (rtn_status);
+}
+
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static void spi_nand_manufacute_init( struct SPI_NAND_FLASH_INFO_T *ptr_device_t )
+ * PURPOSE : To init SPI NAND Flash chip
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None.
+ * RETURN  : None.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/05/15 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static void spi_nand_manufacute_init( struct SPI_NAND_FLASH_INFO_T *ptr_device_t )
+{
+	unsigned char feature;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"SPI NAND Chip Init : Unlock all block and Enable Quad Mode\n");
+
+	if( ((ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_GIGADEVICE) || \
+		((ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_MXIC) )
+	{
+		/* 1. Unlock All block */
+		spi_nand_protocol_get_status_reg_1(&feature);
+		feature &= 0xC1;
+		spi_nand_protocol_set_status_reg_1(feature);
+
+		spi_nand_protocol_get_status_reg_1(&feature);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "After Unlock all block setup, the status register1 =0x%x\n", feature);
+
+
+		/* 2. Enable Qual mode */
+		spi_nand_protocol_get_status_reg_2(&feature);
+		feature |= 0x1;
+		spi_nand_protocol_set_status_reg_2(feature);
+
+		spi_nand_protocol_get_status_reg_2(&feature);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "After enable qual mode setup, the status register2 =0x%x\n", feature);
+	}
+	else if( (ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_WINBOND)
+	{
+		/* Enable to modify the status regsiter 1 */
+		feature = 0x58;
+		spi_nand_protocol_set_status_reg_2(feature);
+
+		/* Unlock all block and Enable Qual mode */
+		feature = 0x81;
+		spi_nand_protocol_set_status_reg_1(feature);
+
+		/* Disable to modify the status regsiter 1 */
+		feature = 0x18;
+		spi_nand_protocol_set_status_reg_2(feature);
+
+		spi_nand_protocol_get_status_reg_1(&feature);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "After Unlock all block setup, the status register1 =0x%x\n", feature);
+	}
+	else if( (ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_ESMT)
+	{
+		/* 1. Unlock All block */
+		spi_nand_protocol_get_status_reg_1(&feature);
+		feature &= 0xC1;
+		spi_nand_protocol_set_status_reg_1(feature);
+
+		spi_nand_protocol_get_status_reg_1(&feature);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "After Unlock all block setup, the status register1 =0x%x\n", feature);
+	}
+	else if( (ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_ZENTEL)
+	{
+		/* 1. Unlock All block */
+		spi_nand_protocol_get_status_reg_1(&feature);
+		feature &= 0xC7;
+		spi_nand_protocol_set_status_reg_1(feature);
+
+		spi_nand_protocol_get_status_reg_1(&feature);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "After Unlock all block setup, the status register1 =0x%x\n", feature);
+	}
+	else if( (ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_ETRON)
+	{
+		/* 1. Unlock All block */
+		spi_nand_protocol_get_status_reg_1(&feature);
+		feature &= 0xC7;
+		spi_nand_protocol_set_status_reg_1(feature);
+
+		spi_nand_protocol_get_status_reg_1(&feature);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "After Unlock all block setup, the status register1 =0x%x\n", feature);
+
+		/* 2. Enable Qual mode */
+		spi_nand_protocol_get_status_reg_2(&feature);
+		feature |= 0x1;
+		spi_nand_protocol_set_status_reg_2(feature);
+
+		spi_nand_protocol_get_status_reg_2(&feature);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "After enable qual mode setup, the status register2 =0x%x\n", feature);
+	}
+	else if( (ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_TOSHIBA)
+	{
+		/* 1. Unlock All block */
+		spi_nand_protocol_get_status_reg_1(&feature);
+		feature &= 0xC7;
+		spi_nand_protocol_set_status_reg_1(feature);
+
+		spi_nand_protocol_get_status_reg_1(&feature);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"After Unlock all block setup, the status register1 =0x%x\n", feature);
+	}
+
+	else if( (ptr_device_t->mfr_id) == _SPI_NAND_MANUFACTURER_ID_MICRON)
+	{
+		/* 1. Unlock All block */
+		spi_nand_protocol_get_status_reg_1(&feature);
+		feature &= 0x83;
+		spi_nand_protocol_set_status_reg_1(feature);
+
+		spi_nand_protocol_get_status_reg_1(&feature);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"After Unlock all block setup, the status register1 =0x%x\n", feature);
+	}
+
+
+
+	else
+	{
+		/* 1. Unlock All block */
+		spi_nand_protocol_get_status_reg_1(&feature);
+		feature &= 0xC1;
+		spi_nand_protocol_set_status_reg_1(feature);
+
+		spi_nand_protocol_get_status_reg_1(&feature);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "After Unlock all block setup, the status register1 =0x%x\n", feature);
+
+
+		/* 2. Enable Qual mode */
+		spi_nand_protocol_get_status_reg_2(&feature);
+		feature |= 0x1;
+		spi_nand_protocol_set_status_reg_2(feature);
+
+		spi_nand_protocol_get_status_reg_2(&feature);
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "After enable qual mode setup, the status register2 =0x%x\n", feature);
+	}
+
+}
+
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: static SPI_NAND_FLASH_RTN_T spi_nand_probe( struct SPI_NAND_FLASH_INFO_T  *ptr_rtn_device_t )
+ * PURPOSE : To probe SPI NAND flash id.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: rtn_index  - The rtn_index variable of this function.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/12 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+static SPI_NAND_FLASH_RTN_T spi_nand_probe( struct SPI_NAND_FLASH_INFO_T * ptr_rtn_device_t )
+{
+	u32 					i=0;
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_PROBE_ERROR;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_probe: start \n");
+
+
+	/* Protocol for read id */
+	_SPI_NAND_SEMAPHORE_LOCK();
+	spi_nand_protocol_read_id( (struct SPI_NAND_FLASH_INFO_T *)ptr_rtn_device_t );
+	_SPI_NAND_SEMAPHORE_UNLOCK();
+
+	_SPI_NAND_PRINTF("spi_nand_probe: mfr_id=0x%x, dev_id=0x%x\n", ptr_rtn_device_t->mfr_id, ptr_rtn_device_t->dev_id);
+
+	for ( i=0 ; i < (sizeof(spi_nand_flash_tables)/sizeof(struct SPI_NAND_FLASH_INFO_T)) ; i++)
+	{
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"spi_nand_probe: table[%d]: mfr_id=0x%x, dev_id=0x%x\n", i, spi_nand_flash_tables[i].mfr_id, spi_nand_flash_tables[i].dev_id );
+
+		if ( ( (ptr_rtn_device_t->mfr_id) == spi_nand_flash_tables[i].mfr_id) &&
+		     ( (ptr_rtn_device_t->dev_id) == spi_nand_flash_tables[i].dev_id)  )
+		{
+			ptr_rtn_device_t->device_size = spi_nand_flash_tables[i].device_size;
+			ptr_rtn_device_t->erase_size  = spi_nand_flash_tables[i].erase_size;
+			ptr_rtn_device_t->page_size	  = spi_nand_flash_tables[i].page_size;
+			ptr_rtn_device_t->oob_size	  = spi_nand_flash_tables[i].oob_size;
+			ptr_rtn_device_t->dummy_mode  = spi_nand_flash_tables[i].dummy_mode;
+			ptr_rtn_device_t->read_mode	  = spi_nand_flash_tables[i].read_mode;
+			memcpy( &(ptr_rtn_device_t->ptr_name) , &(spi_nand_flash_tables[i].ptr_name), sizeof(ptr_rtn_device_t->ptr_name));
+			memcpy( &(ptr_rtn_device_t->oob_free_layout) , &(spi_nand_flash_tables[i].oob_free_layout), sizeof(ptr_rtn_device_t->oob_free_layout));
+			ptr_rtn_device_t->plane_select = spi_nand_flash_tables[i].plane_select;
+
+			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+			break;
+		}
+	}
+
+	if ( rtn_status != SPI_NAND_FLASH_RTN_NO_ERROR )
+	{
+		/* Another protocol for read id  (For example, the GigaDevice SPI NADN chip for Type C */
+		_SPI_NAND_SEMAPHORE_LOCK();
+		spi_nand_protocol_read_id_2( (struct SPI_NAND_FLASH_INFO_T *)ptr_rtn_device_t );
+		_SPI_NAND_SEMAPHORE_UNLOCK();
+
+		_SPI_NAND_PRINTF("spi_nand_probe: mfr_id=0x%x, dev_id=0x%x\n", ptr_rtn_device_t->mfr_id, ptr_rtn_device_t->dev_id);
+
+		for ( i=0 ; i < (sizeof(spi_nand_flash_tables)/sizeof(struct SPI_NAND_FLASH_INFO_T)) ; i++)
+		{
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"spi_nand_probe: table[%d]: mfr_id=0x%x, dev_id=0x%x\n", i, spi_nand_flash_tables[i].mfr_id, spi_nand_flash_tables[i].dev_id );
+
+			if ( ( (ptr_rtn_device_t->mfr_id) == spi_nand_flash_tables[i].mfr_id) &&
+			     ( (ptr_rtn_device_t->dev_id) == spi_nand_flash_tables[i].dev_id)  )
+			{
+				ptr_rtn_device_t->device_size = spi_nand_flash_tables[i].device_size;
+				ptr_rtn_device_t->erase_size  = spi_nand_flash_tables[i].erase_size;
+				ptr_rtn_device_t->page_size	  = spi_nand_flash_tables[i].page_size;
+				ptr_rtn_device_t->oob_size	  = spi_nand_flash_tables[i].oob_size;
+				ptr_rtn_device_t->dummy_mode  = spi_nand_flash_tables[i].dummy_mode;
+				ptr_rtn_device_t->read_mode	  = spi_nand_flash_tables[i].read_mode;
+				memcpy( &(ptr_rtn_device_t->ptr_name) , &(spi_nand_flash_tables[i].ptr_name), sizeof(ptr_rtn_device_t->ptr_name));
+				memcpy( &(ptr_rtn_device_t->oob_free_layout) , &(spi_nand_flash_tables[i].oob_free_layout), sizeof(ptr_rtn_device_t->oob_free_layout));
+				ptr_rtn_device_t->plane_select = spi_nand_flash_tables[i].plane_select;
+
+				rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+				break;
+			}
+		}
+	}
+
+
+	if(rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR)
+	{
+		_SPI_NAND_SEMAPHORE_LOCK();
+		spi_nand_manufacute_init(ptr_rtn_device_t);
+		_SPI_NAND_SEMAPHORE_UNLOCK();
+	}
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spi_nand_probe: end \n");
+
+	return (rtn_status);
+}
+
+/* EXPORTED SUBPROGRAM BODIES -------------------------------------------------------- */
+
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+#define BMT_BAD_BLOCK_INDEX_OFFSET (1)
+#define POOL_GOOD_BLOCK_PERCENT 8/100
+#define MAX_BMT_SIZE_PERCENTAGE 1/10
+
+int en7512_nand_exec_read_page(u32 page, u8* date, u8* oob)
+{
+
+	if( spi_nand_read_page(page, SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE) == SPI_NAND_FLASH_RTN_NO_ERROR)
+	{
+		/* Get data segment and oob segment  */
+		memcpy( date, &_current_cache_page_data[0], _SPI_NAND_PAGE_SIZE );
+		memcpy( oob,  &_current_cache_page_oob_mapping[0], _SPI_NAND_OOB_SIZE );
+
+		return 0;
+	}
+	else
+	{
+		 _SPI_NAND_PRINTF( "en7512_nand_exec_read_page: Read Error\n");
+		return -1;
+	}
+
+}
+int en7512_nand_check_block_bad(u32 offset, u32 bmt_block)
+{
+
+	 u32							 page_number;
+	 struct SPI_NAND_FLASH_INFO_T	 *ptr_dev_info_t;
+
+	 ptr_dev_info_t  = _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	if(  (0xbc000000 <= offset) && (offset<= 0xbfffffff) )		/* Reserver address area for system */
+	{
+		if( (offset & 0xbfc00000) == 0xbfc00000)
+		{
+			offset &= 0x003fffff;
+		}
+		else
+		{
+			offset &= 0x03ffffff;
+		}
+	}
+
+	 /* Caculate page number */
+	 page_number = (offset / (ptr_dev_info_t->page_size));
+
+	 _SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "en7512_nand_check_block_bad: read_addr=0x%x, page_number=0x%x\n", offset, page_number);
+
+	 spi_nand_read_page(page_number, SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE);
+
+
+	 if(bmt_block){
+		 if(_current_cache_page_oob_mapping[BMT_BAD_BLOCK_INDEX_OFFSET] != 0xff){
+			 _SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "Bad block detected at page_addr 0x%x, oob_buf[%d] is 0x%x\n", page_number, BMT_BAD_BLOCK_INDEX_OFFSET,_current_cache_page_oob_mapping[BMT_BAD_BLOCK_INDEX_OFFSET]);
+			 return 1;
+		 }
+	 }
+	 else
+	 {
+		 if(_current_cache_page_oob_mapping[0] != 0xff)
+		 {
+			 _SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "Bad block detected at page_addr 0x%x, oob_buf[0] is 0x%x\n", page_number, _current_cache_page_oob_mapping[0]);
+			 return 1;
+		 }
+	 }
+
+
+	return 0;  /* Good Block*/
+
+}
+int en7512_nand_erase(u32 offset)
+{
+
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "en7512_nand_erase: offset =0x%x, erase_size=0x%x\n", offset, (ptr_dev_info_t->erase_size));
+
+	if(spi_nand_erase_block( (offset / (ptr_dev_info_t->erase_size)) )== SPI_NAND_FLASH_RTN_NO_ERROR)
+	{
+		return 0;
+	}
+	else
+	{
+		_SPI_NAND_PRINTF("en7512_nand_erase : Fail \n");
+		return -1;
+	}
+}
+int en7512_nand_mark_badblock(u32 offset, u32 bmt_block)
+{
+
+	u32 							page_number;
+	u8 buf[8];
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	 ptr_dev_info_t  = _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	 /* Caculate page number */
+	 page_number = (offset / (ptr_dev_info_t->page_size));
+
+
+	memset(buf, 0xFF, 8);
+	if(bmt_block)
+	{
+		buf[BMT_BAD_BLOCK_INDEX_OFFSET] = 0;
+	}
+	else
+	{
+		buf[0] = 0;
+	}
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "en7512_nand_mark_badblock: buf info:\n");
+	_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &buf[0], 8);
+
+	_SPI_NAND_PRINTF("en7512_nand_mark_badblock: page_num=0x%x\n", page_number);
+
+	rtn_status = spi_nand_write_page(page_number, 0, NULL, 0, 0, &buf[0], 8 , SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE);
+
+
+	if( rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR)
+	{
+		return 0;
+	}
+	else
+	{
+		return -1;
+	}
+
+
+}
+int en7512_nand_exec_write_page(u32 page, u8 *dat, u8 *oob)
+{
+
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "en7512_nand_exec_write_page: page=0x%x\n", page);
+
+	rtn_status = spi_nand_write_page(page, 0, dat, _SPI_NAND_PAGE_SIZE, 0, oob, _SPI_NAND_OOB_SIZE , SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE);
+
+	if( rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR)
+	{
+		return 0;
+	}
+	else
+	{
+		return -1;
+	}
+}
+
+
+u32 maximum_bmt_block_count = 0;
+
+int calc_bmt_pool_size(struct mtd_info *mtd)
+{
+	struct nand_chip *nand = mtd->priv;
+    int chip_size = nand->chipsize;
+    int block_size = 1 << nand->phys_erase_shift;
+    int total_block = chip_size / block_size;
+    int last_block = total_block - 1;
+
+    u16 valid_block_num = 0;
+    u16 need_valid_block_num = total_block * POOL_GOOD_BLOCK_PERCENT;
+
+
+	_SPI_NAND_PRINTF("calc_bmt_pool_size : need_valid_block_num=0x%x, total_block=0x%x\n",need_valid_block_num, total_block);
+
+	maximum_bmt_block_count = total_block * MAX_BMT_SIZE_PERCENTAGE;
+
+    for(;last_block > 0; --last_block)
+    {
+        if(en7512_nand_check_block_bad(last_block * block_size, BAD_BLOCK_RAW))
+        {
+            continue;
+
+        }
+        else
+        {
+            valid_block_num++;
+            if(valid_block_num == need_valid_block_num)
+            {
+                break;
+            }
+
+        }
+
+    }
+
+    return (total_block - last_block);
+
+}
+
+
+
+#endif
+
+
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Init( long  rom_base )
+ * PURPOSE : To provide interface for SPI NAND init.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : rom_base - The rom_base variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/12 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Init(u32 rom_base)
+{
+	unsigned long val;
+
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_PROBE_ERROR;
+
+	/* 1. set SFC Clock to 25MHZ */
+	val = VPint(_SPI_FREQUENCY_ADJUST_REG);
+	val |= 0xa01;
+	VPint(_SPI_FREQUENCY_ADJUST_REG) = val;
+
+	/* 2. Enable Manual Mode */
+	_SPI_NAND_ENABLE_MANUAL_MODE();
+
+	_SPI_NAND_PRINTF("SPI_NAND_Flash_init: before init, mtx_mode_tog=0xl%x, manaul_en=0x%lx\n", VPint(0xbfa10014), VPint(0xbfa10020) );
+
+ 	/* 3. Probe flash information */
+	if ( spi_nand_probe(  &_current_flash_info_t) != SPI_NAND_FLASH_RTN_NO_ERROR )
+	{
+		_SPI_NAND_PRINTF("SPI NAND Flash Detected Error !\n");
+	}
+	else
+	{
+		_SPI_NAND_PRINTF("Dected SPI NAND Flash : %s, Flash Size=0x%x\n", _current_flash_info_t.ptr_name,  _current_flash_info_t.device_size);
+		rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+	}
+
+   return (rtn_status);
+}
+
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Get_Flash_Info( struct SPI_NAND_FLASH_INFO_T    *ptr_rtn_into_t )
+ * PURPOSE : To get system current flash info.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: ptr_rtn_into_t  - A pointer to the structure of the ptr_rtn_into_t variable.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/14 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Get_Flash_Info( struct SPI_NAND_FLASH_INFO_T *ptr_rtn_into_t)
+{
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	memcpy( ptr_rtn_into_t, ptr_dev_info_t, sizeof(struct SPI_NAND_FLASH_INFO_T) );
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Write_Nbyte( u32    dst_addr,
+ *                                                            u32    len,
+ *                                                            u32    *ptr_rtn_len,
+ *                                                            u8*    ptr_buf      )
+ * PURPOSE : To provide interface for Write N Bytes into SPI NAND Flash.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : dst_addr - The dst_addr variable of this function.
+ *           len      - The len variable of this function.
+ *           buf      - The buf variable of this function.
+ *   OUTPUT: rtn_len  - The rtn_len variable of this function.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/15 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Write_Nbyte( u32								dst_addr,
+												 u32								len,
+												 u32								*ptr_rtn_len,
+												 u8									*ptr_buf,
+												 SPI_NAND_FLASH_WRITE_SPEED_MODE_T	speed_node )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	rtn_status =  spi_nand_write_internal(dst_addr, len, ptr_rtn_len, ptr_buf, speed_node);
+
+	*ptr_rtn_len = len ;  /* Chuck Kuo, tmp modify */
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: int SPI_NAND_Flash_Read_NByte( long     addr,
+ *                                          long     len,
+ *                                          long     *retlen,
+ *                                          char     *buf    )
+ * PURPOSE : To provide interface for Read N Bytes from SPI NAND Flash.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : addr    - The addr variable of this function.
+ *           len     - The len variable of this function.
+ *           retlen  - The retlen variable of this function.
+ *           buf     - The buf variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/12 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+u32 SPI_NAND_Flash_Read_NByte(	unsigned long long				 addr,
+								u32								 len,
+								u32								 *retlen,
+								u8								 *buf,
+								SPI_NAND_FLASH_READ_SPEED_MODE_T speed_mode)
+{
+
+	return spi_nand_read_internal(addr, len, buf, speed_mode);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Erase( u32  dst_addr,
+ *                                                      u32  len      )
+ * PURPOSE : To provide interface for Erase SPI NAND Flash.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : dst_addr - The dst_addr variable of this function.
+ *           len      - The len variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/17 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Erase(	u32 dst_addr,
+											u32 len )
+{
+	SPI_NAND_FLASH_RTN_T	rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	rtn_status =  spi_nand_erase_internal(dst_addr, len);
+
+	return (rtn_status);
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: char SPI_NAND_Flash_Read_Byte( long     addr )
+ * PURPOSE : To provide interface for read 1 Bytes from SPI NAND Flash.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : addr - The addr variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/12 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+unsigned char SPI_NAND_Flash_Read_Byte(unsigned long long addr)
+{
+	u32 	len = 1;
+	u8 		buf[2];
+
+	memset(buf,0x0,2);
+
+	spi_nand_read_internal(addr, len, &buf[0], SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE);
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "SPI_NAND_Flash_Read_Byte : buf=0x%x\n", buf[0]);
+
+	return buf[0];
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: long SPI_NAND_Flash_Read_DWord( long    addr )
+ * PURPOSE : To provide interface for read Double Word from SPI NAND Flash.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : addr - The addr variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/12 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+unsigned long SPI_NAND_Flash_Read_DWord(unsigned long long addr)
+{
+
+	u8		 buf2[4]={0};
+	u32		 ret_val=0;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "SPI_NAND_Flash_Read_DWord, addr= 0x%llx\n", addr);
+
+	spi_nand_read_internal(addr, 4, &buf2[0], SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE);
+	ret_val = (buf2[0] << 24) | (buf2[1] << 16) | (buf2[2] <<8) | buf2[3];
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "SPI_NAND_Flash_Read_DWord : ret_val=0x%x\n", ret_val);
+
+	return ret_val;
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: void SPI_NAND_DEBUG_ENABLE( void )
+ * PURPOSE : To enable to printf debug message of SPI NAND driver.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/20 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+void SPI_NAND_DEBUG_ENABLE( void )
+{
+	_SPI_NAND_DEBUG_FLAG = 1;
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: void SPI_NAND_DEBUG_DISABLE( void )
+ * PURPOSE : To disable to printf debug message of SPI NAND driver.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/20 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+void SPI_NAND_DEBUG_DISABLE( void )
+{
+	_SPI_NAND_DEBUG_FLAG = 0;
+}
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: void SPI_NAND_Flash_Clear_Read_Cache_Data( void )
+ * PURPOSE : To clear the cache data for read.
+ *           (The next time to read data will get data from flash chip certainly.)
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/21 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+void SPI_NAND_Flash_Clear_Read_Cache_Data( void )
+{
+	_current_page_num	= 0xFFFFFFFF;
+}
+
+
+/***********************************************************************************/
+/***********************************************************************************/
+/***** Modify for SPI NAND linux kernel driver below *******************************/
+/***********************************************************************************/
+/***********************************************************************************/
+/***********************************************************************************/
+
+/*****************************************************************************************/
+/*****************************************************************************************/
+/* Porting */
+/*****************************************************************************************/
+/*****************************************************************************************/
+
+#define LINUX_DEBUG_FLAG				0
+
+/* feature/ status reg */
+#define REG_BLOCK_LOCK                  0xa0
+#define REG_OTP                         0xb0
+#define REG_STATUS                      0xc0/* timing */
+
+/* status */
+#define STATUS_OIP_MASK                 0x01
+#define STATUS_READY                    (0 << 0)
+#define STATUS_BUSY                     (1 << 0)
+
+#define STATUS_E_FAIL_MASK              0x04
+#define STATUS_E_FAIL                   (1 << 2)
+
+#define STATUS_P_FAIL_MASK              0x08
+#define STATUS_P_FAIL                   (1 << 3)
+
+#define STATUS_ECC_MASK                 0x30
+#define STATUS_ECC_1BIT_CORRECTED       (1 << 4)
+#define STATUS_ECC_ERROR                (2 << 4)
+#define STATUS_ECC_RESERVED             (3 << 4)
+
+/*ECC enable defines*/
+#define OTP_ECC_MASK                    0x10
+#define OTP_ECC_OFF                     0
+#define OTP_ECC_ON                      1
+
+#define ECC_DISABLED
+#define ECC_IN_NAND
+#define ECC_SOFT
+
+#define SPI_NAND_PROCNAME				"driver/spi_nand_debug"
+
+
+
+
+#define BUFSIZE (2 * 2048)
+#define CACHE_BUF 2112
+
+
+#define CONFIG_MTD_SPINAND_ONDIEECC		1
+
+
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC
+static int enable_hw_ecc;
+static int enable_read_hw_ecc;
+
+#if 0
+static struct nand_ecclayout spinand_oob_64 = {
+        .eccbytes = 16,
+        .eccpos = {
+                12,13,14,15,
+                28,29,30,31,
+                44,45,46,47,
+                60,61,62,63 },
+        .oobavail = 48,
+        .oobfree = {
+                {.offset = 2,
+                        .length = 10},
+                {.offset = 16,
+                        .length = 12},
+                {.offset = 32,
+                        .length = 12},
+                {.offset = 48,
+                        .length = 12},
+        }
+};
+#endif
+static struct nand_ecclayout spinand_oob_64 = {
+        .eccbytes = 0,
+        .eccpos = {},
+        .oobavail = MAX_LINUX_USE_OOB_SIZE,
+        .oobfree = {
+                {.offset = 0,
+				 .length = MAX_LINUX_USE_OOB_SIZE}
+        }
+};
+
+
+#endif
+
+static inline struct spinand_state *mtd_to_state(struct mtd_info *mtd)
+{
+        struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+        struct spinand_info *info = (struct spinand_info *)chip->priv;
+        struct spinand_state *state = (struct spinand_state *)info->priv;
+
+        return state;
+}
+
+
+/*
+ * spinand_read_id- Read SPI Nand ID
+ * Description:
+ *    Read ID: read two ID bytes from the SPI Nand device
+ */
+static int spinand_read_id(struct spi_device *spi_nand, u8 *id)
+{
+	struct _SPI_NAND_FLASH_ID_T flash_id;
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	ptr_dev_info_t		= 	_SPI_NAND_GET_DEVICE_INFO_PTR;
+
+
+	(id[0])= ptr_dev_info_t->mfr_id;
+	(id[1])= ptr_dev_info_t->dev_id;
+
+#if 0
+	_SPI_NAND_SEMAPHORE_LOCK();
+	spi_nand_protocol_read_id(&flash_id);
+	_SPI_NAND_SEMAPHORE_UNLOCK();
+
+	(id[0])= flash_id.mfr_id;
+	(id[1])= flash_id.dev_id;
+#endif
+
+	return 0;
+}
+
+/*
+ * spinand_read_status- send command 0xf to the SPI Nand status register
+ * Description:
+ *    After read, write, or erase, the Nand device is expected to set the
+ *    busy status.
+ *    This function is to allow reading the status of the command: read,
+ *    write, and erase.
+ *    Once the status turns to be ready, the other status bits also are
+ *    valid status bits.
+ */
+static int spinand_read_status(struct spi_device *spi_nand, uint8_t *status)
+{
+		return spi_nand_protocol_get_status_reg_3(status);
+}
+
+#define MAX_WAIT_JIFFIES  (40 * HZ)
+static int wait_till_ready(struct spi_device *spi_nand)
+{
+        unsigned long deadline;
+        int retval;
+        u8 stat = 0;
+
+        deadline = jiffies + MAX_WAIT_JIFFIES;
+        do {
+                retval = spinand_read_status(spi_nand, &stat);
+                if (retval < 0)
+                        return -1;
+                else if (!(stat & 0x1))
+                        break;
+
+                cond_resched();
+        } while (!time_after_eq(jiffies, deadline));
+
+        if ((stat & 0x1) == 0)
+                return 0;
+
+        return -1;
+}
+/**
+ * spinand_get_otp- send command 0xf to read the SPI Nand OTP register
+ * Description:
+ *   There is one bit( bit 0x10 ) to set or to clear the internal ECC.
+ *   Enable chip internal ECC, set the bit to 1
+ *   Disable chip internal ECC, clear the bit to 0
+ */
+static int spinand_get_otp(struct spi_device *spi_nand, u8 *otp)
+{
+	return spi_nand_protocol_get_status_reg_2(otp);
+}
+
+/**
+ * spinand_set_otp- send command 0x1f to write the SPI Nand OTP register
+ * Description:
+ *   There is one bit( bit 0x10 ) to set or to clear the internal ECC.
+ *   Enable chip internal ECC, set the bit to 1
+ *   Disable chip internal ECC, clear the bit to 0
+ */
+static int spinand_set_otp(struct spi_device *spi_nand, u8 *otp)
+{
+	return spi_nand_protocol_set_status_reg_2(*otp);
+}
+
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC
+/**
+ * spinand_enable_ecc- send command 0x1f to write the SPI Nand OTP register
+ * Description:
+ *   There is one bit( bit 0x10 ) to set or to clear the internal ECC.
+ *   Enable chip internal ECC, set the bit to 1
+ *   Disable chip internal ECC, clear the bit to 0
+ */
+static int spinand_enable_ecc(struct spi_device *spi_nand)
+{
+        int retval;
+        u8 otp = 0;
+
+        retval = spinand_get_otp(spi_nand, &otp);
+        if (retval < 0)
+                return retval;
+
+        if ((otp & OTP_ECC_MASK) == OTP_ECC_MASK)
+                return 0;
+        otp |= OTP_ECC_MASK;
+        retval = spinand_set_otp(spi_nand, &otp);
+        if (retval < 0)
+                return retval;
+        return spinand_get_otp(spi_nand, &otp);
+}
+#endif
+
+static int spinand_disable_ecc(struct spi_device *spi_nand)
+{
+        int retval;
+        u8 otp = 0;
+
+        retval = spinand_get_otp(spi_nand, &otp);
+        if (retval < 0)
+                return retval;
+
+        if ((otp & OTP_ECC_MASK) == OTP_ECC_MASK) {
+                otp &= ~OTP_ECC_MASK;
+                retval = spinand_set_otp(spi_nand, &otp);
+                if (retval < 0)
+                        return retval;
+                return spinand_get_otp(spi_nand, &otp);
+        }
+        return 0;
+}
+
+/**
+ * spinand_write_enable- send command 0x06 to enable write or erase the
+ * Nand cells
+ * Description:
+ *   Before write and erase the Nand cells, the write enable has to be set.
+ *   After the write or erase, the write enable bit is automatically
+ *   cleared (status register bit 2)
+ *   Set the bit 2 of the status register has the same effect
+ */
+static int spinand_write_enable(struct spi_device *spi_nand)
+{
+        return spi_nand_protocol_write_enable();
+}
+
+static int spinand_read_page_to_cache(struct spi_device *spi_nand, u32 page_id)
+{
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "spinand_read_page_to_cache: page_idx=0x%x\n", page_id);
+	return spi_nand_protocol_page_read( (u32)page_id);
+}
+
+/*
+ * spinand_read_from_cache- send command 0x03 to read out the data from the
+ * cache register(2112 bytes max)
+ * Description:
+ *   The read can specify 1 to 2112 bytes of data read at the corresponding
+ *   locations.
+ *   No tRd delay.
+ */
+static int spinand_read_from_cache(struct spi_device *spi_nand, u32 page_id,
+                u32 byte_id, u32 len, u8 *rbuf)
+{
+
+	 unsigned int ret;
+	 u8			status;
+
+      spi_nand_protocol_read_from_cache_single_speed(byte_id, len, rbuf, SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND);
+
+        while (1) {
+                ret = spinand_read_status(spi_nand, &status);
+                if (ret < 0) {
+                              _SPI_NAND_PRINTF("err %d read status register\n", ret);
+                        return ret;
+                }
+
+                if ((status & STATUS_OIP_MASK) == STATUS_READY) {
+                        break;
+                }
+        }
+
+	  return 0;  /* Chuck , tmp return success any way */
+}
+
+/*
+ * spinand_read_page-to read a page with:
+ * @page_id: the physical page number
+ * @offset:  the location from 0 to 2111
+ * @len:     number of bytes to read
+ * @rbuf:    read buffer to hold @len bytes
+ *
+ * Description:
+ *   The read includes two commands to the Nand: 0x13 and 0x03 commands
+ *   Poll to read status to wait for tRD time.
+ */
+static int spinand_read_page(struct spi_device *spi_nand, u32 page_id,
+                u32 offset, u32 len, u8 *rbuf)
+{
+
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	rtn_status = spi_nand_read_internal( (((ptr_dev_info_t->page_size)*page_id)+offset), len, rbuf, SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE);
+
+	if(rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR)
+	{
+		return 0;
+	}
+	else
+	{
+		_SPI_NAND_PRINTF("spinand_read_page, error\n");
+		return -1;
+	}
+
+}
+
+/*
+ * spinand_program_data_to_cache--to write a page to cache with:
+ * @byte_id: the location to write to the cache
+ * @len:     number of bytes to write
+ * @rbuf:    read buffer to hold @len bytes
+ *
+ * Description:
+ *   The write command used here is 0x84--indicating that the cache is
+ *   not cleared first.
+ *   Since it is writing the data to cache, there is no tPROG time.
+ */
+static int spinand_program_data_to_cache(struct spi_device *spi_nand,
+                u32 page_id, u32 byte_id, u32 len, u8 *wbuf)
+{
+        return spi_nand_protocol_program_load_single_speed(byte_id, wbuf, len);
+}
+
+/**
+ * spinand_program_execute--to write a page from cache to the Nand array with
+ * @page_id: the physical page location to write the page.
+ *
+ * Description:
+ *   The write command used here is 0x10--indicating the cache is writing to
+ *   the Nand array.
+ *   Need to wait for tPROG time to finish the transaction.
+ */
+static int spinand_program_execute(struct spi_device *spi_nand, u32 page_id)
+{
+	return spi_nand_protocol_program_execute(page_id);
+}
+
+/**
+ * spinand_program_page--to write a page with:
+ * @page_id: the physical page location to write the page.
+ * @offset:  the location from the cache starting from 0 to 2111
+ * @len:     the number of bytes to write
+ * @wbuf:    the buffer to hold the number of bytes
+ *
+ * Description:
+ *   The commands used here are 0x06, 0x84, and 0x10--indicating that
+ *   the write enable is first sent, the write cache command, and the
+ *   write execute command.
+ *   Poll to wait for the tPROG time to finish the transaction.
+ */
+static int spinand_program_page(struct mtd_info *mtd,
+                u32 page_id, u32 offset, u32 len, u8 *buf)
+{
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_program_page]: enter, page=0x%x\n", page_id);
+
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	struct spinand_state *state = mtd_to_state(mtd);
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spinand_program_page: _current_cache_page_oob_mapping: state->oob_buf_len=0x%x, state->oob_buf=\n", (state->oob_buf_len));
+	_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &(state->oob_buf[0]), (state->oob_buf_len));
+
+	rtn_status = spi_nand_write_page_internal(page_id, (state->buf_idx), &state->buf[(state->buf_idx)], (state->buf_len),  0, (&state->oob_buf[0]), (state->oob_buf_len), SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE);
+
+	if( rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR)
+	{
+		return 0;
+	}
+	else
+	{
+		_SPI_NAND_PRINTF("spinand_program_page, error\n");
+		return -1;
+	}
+
+}
+
+/**
+ * spinand_erase_block_erase--to erase a page with:
+ * @block_id: the physical block location to erase.
+ *
+ * Description:
+ *   The command used here is 0xd8--indicating an erase command to erase
+ *   one block--64 pages
+ *   Need to wait for tERS.
+ */
+static int spinand_erase_block_erase(struct spi_device *spi_nand, u32 block_id)
+{
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"[spinand_erase_block_erase]: enter, block id=0x%x \n", block_id);
+	return spi_nand_protocol_block_erase(block_id);
+}
+
+/**
+ * spinand_erase_block--to erase a page with:
+ * @block_id: the physical block location to erase.
+ *
+ * Description:
+ *   The commands used here are 0x06 and 0xd8--indicating an erase
+ *   command to erase one block--64 pages
+ *   It will first to enable the write enable bit (0x06 command),
+ *   and then send the 0xd8 erase command
+ *   Poll to wait for the tERS time to complete the tranaction.
+ */
+static int spinand_erase_block(struct spi_device *spi_nand, u32 block_id)
+{
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"[spinand_erase_block]: enter, block id=0x%x \n", block_id);
+
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	rtn_status = spi_nand_erase_internal( ((block_id)*(ptr_dev_info_t->erase_size)) , (ptr_dev_info_t->erase_size) );
+
+	if(rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR)
+	{
+		return 0;
+	}
+	else
+	{
+		_SPI_NAND_PRINTF("spinand_erase_block, error\n");
+		return -1;
+	}
+
+}
+
+
+void spinand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_write_buf]: enter \n");
+	int		min_oob_size;
+    struct spinand_state *state = mtd_to_state(mtd);
+
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	if( (state->col) >= (mtd->writesize))	/* Write OOB area */
+	{
+		min_oob_size = MIN(len, (MAX_LINUX_USE_OOB_SIZE - ((state->col) - (mtd->writesize))));
+		memcpy( &(state->oob_buf)[((state->col)-(mtd->writesize))+LINUX_USE_OOB_START_OFFSET], buf, min_oob_size);
+		state->col += min_oob_size;
+		state->oob_buf_len = min_oob_size;
+	}
+	else 										/* Write Data area */
+	{
+		memcpy( &(state->buf)[state->buf_idx], buf, len);
+	    state->col += len;
+		state->buf_len += len;
+	}
+
+}
+
+void spinand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+    struct spinand_state *state = mtd_to_state(mtd);
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_read_buf]: enter, len=0x%x, offset=0x%x\n", len, state->buf_idx);
+
+	if( ((state->command) == NAND_CMD_READID) ||
+		((state->command) == NAND_CMD_STATUS)    )
+	{
+		memcpy(buf, &state->buf, len);
+	}
+	else
+	{
+		if( (state->buf_idx) < ( ptr_dev_info_t->page_size ))		/* Read data area */
+		{
+        	memcpy(buf, &_current_cache_page_data[state->buf_idx], len);
+		}
+		else														/* Read oob area */
+		{
+			/* dump_stack(); */
+			memcpy(buf, &_current_cache_page_oob_mapping[ ((state->buf_idx)-(ptr_dev_info_t->page_size))+ LINUX_USE_OOB_START_OFFSET], len);
+		}
+	}
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spinand_read_buf : idx=0x%x, len=0x%x\n", (state->buf_idx), len);
+	_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &buf[0], len);
+
+	state->buf_idx += len;
+
+}
+
+
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC
+static void spinand_write_page_hwecc(struct mtd_info *mtd,
+                struct nand_chip *chip, const uint8_t *buf, int oob_required)
+{
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_write_page_hwecc]: enter \n");
+
+	spinand_write_buf(mtd, buf, mtd->writesize);
+	spinand_write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spinand_write_page_hwecc: data=\n");
+	_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &buf[0], mtd->writesize);
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spinand_write_page_hwecc: oob=\n");
+	_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &chip->oob_poi[0], mtd->oobsize);
+
+}
+
+static int spinand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
+                uint8_t *buf, int page)
+{
+	u32    idx;
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_read_page_hwecc]: enter, page=0x%x \n", page);
+
+
+	_SPI_NAND_SEMAPHORE_LOCK();
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	if(buf==NULL)
+	{
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_read_page_hwecc]buf is NULL\n");
+	}
+
+	memcpy(buf, &_current_cache_page_data[0], (ptr_dev_info_t->page_size));
+	memcpy((chip->oob_poi), &_current_cache_page_oob_mapping[LINUX_USE_OOB_START_OFFSET], MAX_LINUX_USE_OOB_SIZE);
+
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spinand_read_page_hwecc: data:\n");
+	_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &buf[0], mtd->writesize);
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spinand_read_page_hwecc: oob:\n");
+	_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &chip->oob_poi[0], mtd->oobsize);
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_2, "spinand_read_page_hwecc: _current_cache_page_oob_mapping:\n");
+	_SPI_NAND_DEBUG_PRINTF_ARRAY(SPI_NAND_FLASH_DEBUG_LEVEL_2, &_current_cache_page_oob_mapping[0], mtd->oobsize);
+
+	_SPI_NAND_SEMAPHORE_UNLOCK();
+
+	return 0;
+
+}
+
+#endif
+
+
+static int spinand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+        const u8 *buf, int page, int cached, int raw)
+{
+
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	struct spinand_state *state = mtd_to_state(mtd);
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_write_page]: enter, page=0x%x \n", page);
+
+	memset((state->oob_buf), 0xff, MAX_USE_OOB_SIZE);
+	memcpy(&(state->oob_buf)[LINUX_USE_OOB_START_OFFSET], chip->oob_poi, MAX_LINUX_USE_OOB_SIZE);
+
+	rtn_status = spi_nand_write_page_internal(page, 0, buf, (ptr_dev_info_t->page_size),  0, (state->oob_buf), MAX_LINUX_USE_OOB_SIZE, SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE);
+	if(rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR )
+	{
+		return 0;
+	}
+	else
+	{
+		return -EIO;
+	}
+}
+
+
+static int spinand_write_oob(struct mtd_info *mtd, struct nand_chip *chip, int page)
+{
+
+	struct spinand_state *state = mtd_to_state(mtd);
+	SPI_NAND_FLASH_RTN_T			rtn_status = SPI_NAND_FLASH_RTN_NO_ERROR;
+
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_write_oob]: enter, page=0x%x \n", page);
+
+	memset(state->oob_buf, 0xff, MAX_USE_OOB_SIZE);
+	memcpy(&(state->oob_buf)[LINUX_USE_OOB_START_OFFSET], chip->oob_poi, MAX_LINUX_USE_OOB_SIZE);
+
+	rtn_status = spi_nand_write_page_internal(page, 0, NULL, 0,  0, (&state->oob_buf[0]), MAX_LINUX_USE_OOB_SIZE, SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE);
+
+	if(rtn_status == SPI_NAND_FLASH_RTN_NO_ERROR )
+	{
+		return 0;
+	}
+	else
+	{
+		return -EIO;
+	}
+
+}
+
+
+static int spinand_read_oob(struct mtd_info *mtd,struct nand_chip *chip, int page, int sndcmd)
+{
+	return 0;
+
+}
+
+
+static int spinand_block_markbad(struct mtd_info *mtd, loff_t offset)
+{
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_block_markbad]: enter , offset=0x%x\n", offset);
+
+	return 0;
+
+}
+
+
+static int spinand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
+{
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_block_bad]: enter \n");
+
+	return 0;
+}
+
+
+
+
+static void spinand_select_chip(struct mtd_info *mtd, int dev)
+{
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_select_chip]: enter \n");
+}
+
+static int spinand_dev_ready(struct mtd_info *mtd)
+{
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_dev_ready]: enter \n");
+	return 1;
+}
+
+static void spinand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_enable_hwecc]: enter \n");
+}
+
+
+static int spinand_correct_data(struct mtd_info *mtd, u_char *dat,
+				     u_char *read_ecc, u_char *calc_ecc)
+{
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_correct_data]: enter \n");
+	return 0;
+}
+
+
+
+
+static int spinand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_calculate_ecc]: enter \n");
+	return 0;
+}
+
+
+static uint8_t spinand_read_byte(struct mtd_info *mtd)
+{
+
+        struct spinand_state *state = mtd_to_state(mtd);
+        u8 data;
+
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_read_byte]: enter \n");
+
+        data = state->buf[state->buf_idx];
+        state->buf_idx++;
+        return data;
+}
+
+
+static int spinand_wait(struct mtd_info *mtd, struct nand_chip *chip)
+{
+
+
+        struct spinand_info *info = (struct spinand_info *)chip->priv;
+
+        unsigned long timeo = jiffies;
+        int retval, state = chip->state;
+        u8 status;
+
+		_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_wait]: enter \n");
+
+        if (state == FL_ERASING)
+                timeo += (HZ * 400) / 1000;
+        else
+                timeo += (HZ * 20) / 1000;
+
+        while (time_before(jiffies, timeo)) {
+                retval = spinand_read_status(info->spi, &status);
+                if ((status & STATUS_OIP_MASK) == STATUS_READY)
+                        return 0;
+
+                cond_resched();
+        }
+        return 0;
+}
+
+
+/*
+ * spinand_reset- send RESET command "0xff" to the Nand device.
+ */
+static void spinand_reset(struct spi_device *spi_nand)
+{
+
+	_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_reset]: enter \n");
+
+	spi_nand_protocol_reset();
+}
+
+
+static void spinand_cmdfunc(struct mtd_info *mtd, unsigned int command, int column, int page)
+{
+
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+
+    struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+    struct spinand_info *info = (struct spinand_info *)chip->priv;
+    struct spinand_state *state = (struct spinand_state *)info->priv;
+    u16		block_id;
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	state->command = command;
+
+	switch (command) {
+	/*
+	 * READ0 - read in first  0x800 bytes
+	 */
+	case NAND_CMD_READ1:
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_cmdfunc]: NAND_CMD_READ1 \n");
+	case NAND_CMD_READ0:
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_cmdfunc]: NAND_CMD_READ0 \n");
+
+			state->buf_idx = column;
+			spi_nand_read_page_internal(page, SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE);
+
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"[spinand_cmdfunc]: NAND_CMD_READ0/1, End\n");
+
+	        break;
+	/* READOOB reads only the OOB because no ECC is performed. */
+	case NAND_CMD_READOOB:
+ 			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_cmdfunc]: NAND_CMD_READOOB, page=0x%x \n", page);
+	        state->buf_idx = column + (ptr_dev_info_t->page_size);
+	        spi_nand_read_page_internal(page, SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE);
+
+	        break;
+	case NAND_CMD_RNDOUT:
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_cmdfunc]: NAND_CMD_RNDOUT \n");
+	        state->buf_idx = column;
+	        break;
+	case NAND_CMD_READID:
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_cmdfunc]: NAND_CMD_READID \n");
+	        state->buf_idx = 0;
+	        spinand_read_id(info->spi, (u8 *)state->buf);
+	        break;
+	/* ERASE1 stores the block and page address */
+	case NAND_CMD_ERASE1:
+			block_id = page /((mtd->erasesize)/(mtd->writesize));
+
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_cmdfunc]: NAND_CMD_ERASE1 \n");
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "erasesize=0x%x, writesiez=0x%x, page=0x%x, block_idx=0x%x\n", (mtd->erasesize), (mtd->writesize), page, block_id);
+	        spinand_erase_block(info->spi, block_id);
+	        break;
+	/* ERASE2 uses the block and page address from ERASE1 */
+	case NAND_CMD_ERASE2:
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"[spinand_cmdfunc]: NAND_CMD_ERASE2 \n");
+	        break;
+	/* SEQIN sets up the addr buffer and all registers except the length */
+	case NAND_CMD_SEQIN:
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_cmdfunc]: NAND_CMD_SEQIN \n");
+	        state->col = column;
+	        state->row = page;
+	        state->buf_idx = column;
+			state->buf_len = 0;
+			state->oob_buf_len = 0 ;
+			memset(state->buf, 0xff, BUFSIZE);
+			memset(state->oob_buf, 0xff, MAX_USE_OOB_SIZE);
+	        break;
+	/* PAGEPROG reuses all of the setup from SEQIN and adds the length */
+	case NAND_CMD_PAGEPROG:
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_cmdfunc]: NAND_CMD_PAGEPROG \n");
+	        spinand_program_page(mtd, state->row, state->col,
+	                        state->buf_idx, state->buf);
+	        break;
+	case NAND_CMD_STATUS:
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_cmdfunc]: NAND_CMD_STATUS \n");
+	        spinand_get_otp(info->spi, state->buf);
+	        if (!(state->buf[0] & 0x80))
+	                state->buf[0] = 0x80;
+	        state->buf_idx = 0;
+	        break;
+	/* RESET command */
+	case NAND_CMD_RESET:
+			_SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1, "[spinand_cmdfunc]: NAND_CMD_RESET \n");
+	        if (wait_till_ready(info->spi))
+	                printk("WAIT timedout!!!\n");
+	        /* a minimum of 250us must elapse before issuing RESET cmd*/
+	        udelay(250);
+	        spinand_reset(info->spi);
+	        break;
+	default:
+	        _SPI_NAND_DEBUG_PRINTF(SPI_NAND_FLASH_DEBUG_LEVEL_1,"[spinand_cmdfunc]: Unknown CMD: 0x%x\n", command);
+	}
+}
+
+
+struct nand_flash_dev spi_nand_flash_ids[] = {
+	{NULL,	0, 0, 0, 0, 0},
+	{NULL,}
+};
+
+
+static void free_allcate_memory(struct mtd_info *mtd)
+{
+
+
+	_SPI_NAND_PRINTF("SPI NAND : free_allcate_memory");
+
+	if( ((struct spinand_info *)(((struct nand_chip *)(mtd->priv))->priv))->spi )
+	{
+		kfree( ((struct spinand_info *)(((struct nand_chip *)(mtd->priv))->priv))->spi );
+	}
+
+	if( ((struct spinand_info *)(((struct nand_chip *)(mtd->priv))->priv)) )
+	{
+		kfree( ((struct spinand_info *)(((struct nand_chip *)(mtd->priv))->priv)) );
+	}
+
+	if( (((struct nand_chip *)(mtd->priv))->priv) )
+	{
+		kfree ( (((struct nand_chip *)(mtd->priv))->priv) ) ;
+	}
+
+	if((mtd->priv) )
+	{
+		kfree((mtd->priv));
+	}
+
+	if(mtd)
+	{
+		kfree(mtd);
+	}
+
+}
+
+
+static int spi_nand_setup(u32 *ptr_rtn_mtd_address)
+{
+    struct mtd_info 		*mtd;
+    struct nand_chip 		*chip;
+    struct spinand_info 	*info;
+    struct spinand_state	*state;
+    struct spi_device		*spi_nand;
+	struct SPI_NAND_FLASH_INFO_T	*ptr_dev_info_t;
+	int ret;
+
+	ptr_dev_info_t	= _SPI_NAND_GET_DEVICE_INFO_PTR;
+
+	_SPI_NAND_PRINTF("[spi_nand_setup] : Enter \n");
+
+	/* 1. Allocate neccessary struct memory ,and assigned related pointer */
+    info  = kzalloc(sizeof(struct spinand_info),GFP_KERNEL);
+    if (!info)
+    {
+    	_SPI_NAND_PRINTF("spi_nand_setup: allocate info structure error! \n");
+		return -ENOMEM;
+    }
+
+	/* Chuck Kuo, temp assign. Other function will pass it, but we wil not use it in functions. */
+	spi_nand = kzalloc(sizeof(struct spinand_info),GFP_KERNEL);
+    if (!spi_nand)
+    {
+	    _SPI_NAND_PRINTF("spi_nand_setup: allocate spi_nand structure error! \n");
+		return -ENOMEM;
+    }
+
+    info->spi = spi_nand;
+
+    state = kzalloc(sizeof(struct spinand_state),GFP_KERNEL);
+    if (!state)
+    {
+	    _SPI_NAND_PRINTF("spi_nand_setup: allocate state structure error! \n");
+		return -ENOMEM;
+    }
+
+    info->priv      = state;
+    state->buf_idx  = 0;
+    state->buf      = kzalloc( BUFSIZE, GFP_KERNEL);			/* Data buffer */
+	state->oob_buf	= kzalloc( MAX_USE_OOB_SIZE, GFP_KERNEL);	/* OOB buffer */
+    if (!state->buf)
+    {
+    	_SPI_NAND_PRINTF("spi_nand_setup: allocate data buf error! \n");
+		return -ENOMEM;
+    }
+    if (!state->oob_buf)
+    {
+    	_SPI_NAND_PRINTF("spi_nand_setup: allocate oob buf error! \n");
+		return -ENOMEM;
+    }
+
+    chip = kzalloc(sizeof(struct nand_chip),GFP_KERNEL);
+    if (!chip)
+    {
+	    _SPI_NAND_PRINTF("spi_nand_setup: allocate chip structure error! \n");
+    	return -ENOMEM;
+    }
+
+	chip->priv				= info;
+	chip->read_byte 		= spinand_read_byte;
+	chip->read_buf			= spinand_read_buf;
+	chip->write_buf 		= spinand_write_buf;
+	chip->waitfunc			= spinand_wait;
+	chip->options			|= NAND_CACHEPRG;
+	chip->select_chip		= spinand_select_chip;
+	chip->dev_ready 		= spinand_dev_ready;
+	chip->cmdfunc			= spinand_cmdfunc;
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC
+    chip->ecc.mode  		= NAND_ECC_HW;
+    chip->ecc.size  		= 0x200;
+    chip->ecc.bytes 		= 0x4;
+    chip->ecc.steps 		= 0x4;
+	chip->ecc.total 		= chip->ecc.steps * chip->ecc.bytes;
+#if 0
+    chip->ecc.strength		= 1;
+#endif
+    chip->ecc.layout 		= &spinand_oob_64;
+    chip->ecc.read_page		= spinand_read_page_hwecc;
+    chip->ecc.write_page 	= spinand_write_page_hwecc;
+#else
+    chip->ecc.mode  = NAND_ECC_SOFT;
+    if (spinand_disable_ecc(spi_nand) < 0)
+            pr_info("%s: disable ecc failed!\n", __func__);
+#endif
+
+
+
+    chip->options	|= NAND_SKIP_BBTSCAN;   	/*To skips the bbt scan during initialization.  */
+    /*  For BMT, we need to revise driver architecture */
+#if 0
+    //chip->write_page		= spinand_write_page;
+    //chip->ecc.read_oob		= spinand_read_oob;
+#endif
+    chip->ecc.write_oob		= spinand_write_oob;
+    chip->block_markbad		= spinand_block_markbad;   /* tmp null */
+    chip->block_bad			= spinand_block_bad;		/* tmp null */
+	chip->ecc.calculate		= spinand_calculate_ecc;
+	chip->ecc.correct		= spinand_correct_data;
+	chip->ecc.hwctl			= spinand_enable_hwecc;
+
+    mtd = kzalloc(sizeof(struct mtd_info), GFP_KERNEL);
+    if (!mtd)
+    {
+		    _SPI_NAND_PRINTF("spi_nand_setup: allocate mtd error! \n");
+            return -ENOMEM;
+    }
+
+    mtd->priv = chip;
+    mtd->name = "EN7512-SPI_NAND";
+    mtd->owner = THIS_MODULE;
+    mtd->oobsize = MAX_LINUX_USE_OOB_SIZE;
+
+	spi_nand_flash_ids[0].name 		= ptr_dev_info_t->ptr_name;
+	spi_nand_flash_ids[0].id   		= ptr_dev_info_t->dev_id;
+	spi_nand_flash_ids[0].pagesize  = ptr_dev_info_t->page_size;
+	spi_nand_flash_ids[0].chipsize  = ((ptr_dev_info_t->device_size)>>20);
+	spi_nand_flash_ids[0].erasesize = ptr_dev_info_t->erase_size;
+	spi_nand_flash_ids[0].options   = 0;
+
+	ret = nand_scan_ident(mtd, 1, spi_nand_flash_ids);
+	if (!ret)
+	{
+		_SPI_NAND_PRINTF("nand_scan_ident ok\n");
+		ret = nand_scan_tail(mtd);
+		_SPI_NAND_PRINTF("[spi_nand_setup]: chip size =  0x%llx, erase_shift=0x%x\n", chip->chipsize, chip->phys_erase_shift);
+	}
+	else
+	{
+		_SPI_NAND_PRINTF("nand_scan_ident fail\n");
+		return -ENOMEM;
+	}
+
+
+#if	defined(TCSUPPORT_NAND_BMT) && !defined(LZMA_IMG)
+
+				_SPI_NAND_SEMAPHORE_LOCK();
+
+				bmt_pool_size = calc_bmt_pool_size(mtd);
+				if(bmt_pool_size > maximum_bmt_block_count)
+				{
+					_SPI_NAND_PRINTF("Error : bmt pool size: %d > maximum size %d\n", bmt_pool_size, maximum_bmt_block_count);
+					_SPI_NAND_PRINTF("Error: init bmt failed \n");
+					return -1;
+				}
+				_SPI_NAND_PRINTF("bmt pool size: %d \n", bmt_pool_size);
+
+				if (!g_bmt)
+				{
+					if ( !(g_bmt = init_bmt(mtd, bmt_pool_size)) )
+					{
+						_SPI_NAND_PRINTF("Error: init bmt failed \n");
+						_SPI_NAND_SEMAPHORE_UNLOCK();
+						return -1;
+					}
+				}
+
+				if (!g_bbt)
+				{
+					if ( !(g_bbt = start_init_bbt()) )
+					{
+						_SPI_NAND_PRINTF("Error: init bbt failed \n");
+							_SPI_NAND_SEMAPHORE_UNLOCK();
+						return -1;
+					}
+				}
+
+				if(write_bbt_or_bmt_to_flash() != 0)
+				{
+					_SPI_NAND_PRINTF("Error: save bbt or bmt to nand failed \n");
+					_SPI_NAND_SEMAPHORE_UNLOCK();
+					return -1;
+				}
+
+				if(create_badblock_table_by_bbt())
+				{
+					_SPI_NAND_PRINTF("Error: create bad block table failed \n");
+					_SPI_NAND_SEMAPHORE_UNLOCK();
+					return -1;
+				}
+
+				_SPI_NAND_PRINTF("BMT & BBT Init Success \n");
+
+				_SPI_NAND_SEMAPHORE_UNLOCK();
+
+
+	mtd->size = nand_logic_size;
+#endif
+	*ptr_rtn_mtd_address = mtd;
+
+	return 0;
+
+
+}
+
+
+static int spi_nand_proc_read(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+
+	int len;
+
+	if (off > 0)
+	{
+		return 0;
+	}
+
+	len = sprintf(page, "SPI NAND DEBUG LEVEL=%d, _SPI_NAND_TEST_FLAG=%d\n", _SPI_NAND_DEBUG_LEVEL, _SPI_NAND_TEST_FLAG);
+
+	return len;
+
+}
+
+static int spi_nand_proc_write(struct file* file, const char* buffer,
+	unsigned long count, void *data)
+{
+
+
+	char buf[16];
+
+	int len = count;
+
+	if (copy_from_user(buf, buffer, len))
+    {
+		return -EFAULT;
+	}
+
+	buf[len] = '\0';
+
+	_SPI_NAND_PRINTF("len = 0x%x, buf[0]=%c, buf[1]=%c\n", len , buf[0], buf[1]);
+
+
+	if (buf[0] == '0')
+	{
+		_SPI_NAND_PRINTF("Set SPI NAND DEBUG LEVLE to %d\n", SPI_NAND_FLASH_DEBUG_LEVEL_0);
+		_SPI_NAND_DEBUG_LEVEL = SPI_NAND_FLASH_DEBUG_LEVEL_0;
+	}
+	else if (buf[0] == '1')
+	{
+		_SPI_NAND_PRINTF("Set SPI NAND DEBUG LEVLE to %d\n", SPI_NAND_FLASH_DEBUG_LEVEL_1);
+		_SPI_NAND_DEBUG_LEVEL = SPI_NAND_FLASH_DEBUG_LEVEL_1;
+	}
+	else if (buf[0] == '2')
+	{
+		_SPI_NAND_PRINTF("Set SPI NAND DEBUG LEVLE to %d\n", SPI_NAND_FLASH_DEBUG_LEVEL_2);
+		_SPI_NAND_DEBUG_LEVEL = SPI_NAND_FLASH_DEBUG_LEVEL_2;
+	}
+	else
+	{
+		_SPI_NAND_PRINTF("DEBUG LEVEL only up to %d\n", (SPI_NAND_FLASH_DEBUG_LEVEL_DEF_NO -1 ));
+	}
+
+	if(buf[1] == '0')
+	{
+		_SPI_NAND_TEST_FLAG = 0;
+		_SPI_NAND_PRINTF("Set _SPI_NAND_TEST_FLAG to %d\n", _SPI_NAND_TEST_FLAG);
+	}
+	if(buf[1] == '1')
+	{
+		_SPI_NAND_TEST_FLAG = 1;
+		_SPI_NAND_PRINTF("Set _SPI_NAND_TEST_FLAG to %d\n", _SPI_NAND_TEST_FLAG);
+	}
+
+	return len;
+
+}
+
+
+
+static struct mtd_info *spi_nand_probe_kernel(struct map_info *map)
+{
+
+	u32	mtd_address;
+	int	rtn_status;
+
+	_SPI_NAND_PRINTF("EN7512 mtd init: spi nand probe enter\n");
+
+	rtn_status = spi_nand_setup(&mtd_address);
+
+	if(rtn_status == 0 )   /* Probe without error */
+	{
+		return ((struct mtd_info * )(mtd_address));
+	}
+	else
+	{
+		free_allcate_memory( (struct mtd_info * )(mtd_address) );
+		_SPI_NAND_PRINTF("[spi_nand_probe_kernel] probe fail !\n");
+		return NULL;
+	}
+
+}
+
+static void spi_nand_destroy_kernel(struct mtd_info *mtd)
+{
+	free_allcate_memory(mtd);
+}
+
+static struct mtd_chip_driver spi_nand_chipdrv = {
+	.probe	 = spi_nand_probe_kernel,
+	.destroy = spi_nand_destroy_kernel,
+	.name	 = "nandflash_probe",
+	.module	 = THIS_MODULE
+};
+
+static int __init linux_spi_nand_flash_init(void)
+{
+
+	struct proc_dir_entry *entry;
+
+	_SPI_NAND_PRINTF("IS_SPIFLASH=0x%x, IS_NANDFLASH=0x%x, (0xBFA10114)=0x%lx)\n", (unsigned int)IS_SPIFLASH, (unsigned int)IS_NANDFLASH, VPint(0xBFA10114));
+
+	if(IS_SPIFLASH){ 	/* For boot from SPI NOR, then mount NAND as a MTD partition */
+		_SPI_NAND_PRINTF("[linux_spi_nand_flash_init] spi nor flash\n");
+		return -1;
+	}
+	else{
+		SPI_NAND_Flash_Init(0);
+
+		_SPI_NAND_PRINTF("spi nand flash\n");
+		register_mtd_chip_driver(&spi_nand_chipdrv);
+
+
+		entry = create_proc_entry(SPI_NAND_PROCNAME, 0666, NULL);
+		if (entry == NULL)
+		{
+			_SPI_NAND_PRINTF("SPI NAND  unable to create /proc entry\n");
+			return -ENOMEM;
+		}
+		entry->read_proc = spi_nand_proc_read;
+		entry->write_proc = spi_nand_proc_write;
+
+
+		return 0;
+	}
+
+}
+
+static void __init linux_spi_nand_flash_exit(void)
+{
+	if(IS_SPIFLASH){
+		}
+	else
+	{
+		unregister_mtd_chip_driver(&spi_nand_chipdrv);
+
+		remove_proc_entry(SPI_NAND_PROCNAME, NULL);
+	}
+}
+
+module_init(linux_spi_nand_flash_init);
+module_exit(linux_spi_nand_flash_exit);
+
+
+/* End of [spi_nand_flash.c] package */
diff --git a/drivers/mtd/chips/spi_nand_flash.h b/drivers/mtd/chips/spi_nand_flash.h
new file mode 100755
index 000000000..f7f7f169a
--- /dev/null
+++ b/drivers/mtd/chips/spi_nand_flash.h
@@ -0,0 +1,413 @@
+ /***************************************************************************************
+ *      Copyright(c) 2014 ECONET Incorporation All rights reserved.
+ *
+ *      This is unpublished proprietary source code of ECONET Incorporation
+ *
+ *      The copyright notice above does not evidence any actual or intended
+ *      publication of such source code.
+ ***************************************************************************************
+ */
+
+/*======================================================================================
+ * MODULE NAME: spi
+ * FILE NAME: spi_nand_flash.h
+ * DATE: 2014/11/21
+ * VERSION: 1.00
+ * PURPOSE: To Provide SPI NAND Access interface.
+ * NOTES:
+ *
+ * AUTHOR : Chuck Kuo         REVIEWED by
+ *
+ * FUNCTIONS  
+ *      SPI_NAND_Flash_Init             To provide interface for SPI NAND init. 
+ *      SPI_NAND_Flash_Get_Flash_Info   To get system current flash info. 
+ *      SPI_NAND_Flash_Write_Nbyte      To provide interface for Write N Bytes into SPI NAND Flash. 
+ *      SPI_NAND_Flash_Read_NByte       To provide interface for Read N Bytes from SPI NAND Flash. 
+ *      SPI_NAND_Flash_Erase            To provide interface for Erase SPI NAND Flash. 
+ *      SPI_NAND_Flash_Read_Byte        To provide interface for read 1 Bytes from SPI NAND Flash. 
+ *      SPI_NAND_Flash_Read_DWord       To provide interface for read Double Word from SPI NAND Flash. 
+ *
+ * DEPENDENCIES
+ *
+ * * $History: $
+ * MODIFICTION HISTORY:
+ * Version 1.00 - Date 2014/11/21 By Chuck Kuo
+ * ** This is the first versoin for creating to support the functions of
+ *    current module.
+ *
+ *======================================================================================
+ */
+
+#ifndef __SPI_NAND_FLASH_H__
+    #define __SPI_NAND_FLASH_H__
+
+/* INCLUDE FILE DECLARATIONS --------------------------------------------------------- */
+#include "asm/system.h"
+#include "asm/types.h"
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+
+/* MACRO DECLARATIONS ---------------------------------------------------------------- */
+#define SPI_NAND_FLASH_OOB_FREE_ENTRY_MAX 32
+
+/* TYPE DECLARATIONS ----------------------------------------------------------------- */
+typedef enum{
+	SPI_NAND_FLASH_READ_DUMMY_BYTE_PREPEND,
+	SPI_NAND_FLASH_READ_DUMMY_BYTE_APPEND,
+	
+	SPI_NAND_FLASH_READ_DUMMY_BYTE_DEF_NO
+	
+} SPI_NAND_FLASH_READ_DUMMY_BYTE_T;
+
+typedef enum{
+	SPI_NAND_FLASH_RTN_NO_ERROR =0,
+	SPI_NAND_FLASH_RTN_PROBE_ERROR,
+	SPI_NAND_FLASH_RTN_ALIGNED_CHECK_FAIL,
+	SPI_NAND_FLASH_RTN_DETECTED_BAD_BLOCK,
+	SPI_NAND_FLASH_RTN_ERASE_FAIL,
+	SPI_NAND_FLASH_RTN_PROGRAM_FAIL,
+
+
+	SPI_NAND_FLASH_RTN_DEF_NO
+} SPI_NAND_FLASH_RTN_T;
+
+typedef enum{
+	SPI_NAND_FLASH_READ_SPEED_MODE_SINGLE =0,
+	SPI_NAND_FLASH_READ_SPEED_MODE_DUAL,
+	SPI_NAND_FLASH_READ_SPEED_MODE_QUAD,
+	
+	SPI_NAND_FLASH_READ_SPEED_MODE_DEF_NO	
+} SPI_NAND_FLASH_READ_SPEED_MODE_T;
+
+
+typedef enum{
+	SPI_NAND_FLASH_WRITE_SPEED_MODE_SINGLE =0,
+	SPI_NAND_FLASH_WRITE_SPEED_MODE_QUAD,
+	
+	SPI_NAND_FLASH_WRITE_SPEED_MODE_DEF_NO	
+} SPI_NAND_FLASH_WRITE_SPEED_MODE_T;
+
+
+
+typedef enum{
+	SPI_NAND_FLASH_DEBUG_LEVEL_0 =0,
+	SPI_NAND_FLASH_DEBUG_LEVEL_1,
+	SPI_NAND_FLASH_DEBUG_LEVEL_2,
+	
+	SPI_NAND_FLASH_DEBUG_LEVEL_DEF_NO	
+} SPI_NAND_FLASH_DEBUG_LEVEL_T;
+
+typedef enum{
+	SPI_NAND_FLASH_PLANE_SELECT_NONE =0,
+	SPI_NAND_FLASH_PLANE_SELECT_HAVE,
+
+	SPI_NAND_FLASH_PLANE_SELECT_DEF_NO
+	
+} SPI_NAND_FLASH_PLANE_SELECT_T;
+
+struct spi_nand_flash_oobfree{
+	unsigned long	offset;
+	unsigned long	len;
+};
+
+struct spi_nand_flash_ooblayout
+{	unsigned long	oobsize;
+	struct spi_nand_flash_oobfree oobfree[SPI_NAND_FLASH_OOB_FREE_ENTRY_MAX];
+};	
+
+
+struct SPI_NAND_FLASH_INFO_T {
+	const u8 							mfr_id;
+	const u8 							dev_id;
+	const u8  							*ptr_name;
+	u32 								device_size;	/* Flash total Size */
+	u32									page_size;		/* Page Size 		*/
+	u32 								erase_size;		/* Block Size 		*/
+	u32									oob_size;		/* Spare Area (OOB) Size */
+	SPI_NAND_FLASH_READ_DUMMY_BYTE_T	dummy_mode;
+	u32   								read_mode;
+	struct spi_nand_flash_ooblayout		*oob_free_layout;
+	SPI_NAND_FLASH_PLANE_SELECT_T       plane_select;
+};
+
+struct nand_info {
+	int mfr_id;
+	int dev_id;
+	char *name;
+	int numchips;
+	int chip_shift;
+	int page_shift;
+	int erase_shift;
+	int oob_shift;
+	int badblockpos;
+	int opcode_type;
+};
+
+#if 1
+struct ra_nand_chip {
+	struct nand_info *flash;
+};
+#endif
+
+struct spinand_info {
+        struct nand_ecclayout	*ecclayout;
+        struct spi_device		*spi;
+        void					*priv;
+};
+
+struct spinand_state {
+        uint32_t        col;
+        uint32_t        row;
+        int             buf_idx;
+        u8              *buf;
+		uint32_t		buf_len;
+		int				oob_idx;
+		u8 				*oob_buf;
+		uint32_t		oob_buf_len;
+		uint32_t		command;
+};
+
+struct en7512_spinand_host
+{
+	struct nand_chip		nand_chip;
+	struct mtd_info			mtd;
+	struct nand_ecclayout	*ecclayout;
+	struct spinand_state	state;
+	void					*priv;
+};
+
+
+/* EXPORTED SUBPROGRAM SPECIFICATION ------------------------------------------------- */
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Init( long  rom_base )
+ * PURPOSE : To provide interface for SPI NAND init.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : rom_base - The rom_base variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/12 by Chuck Kuo - The first revision for this function.
+ *
+
+ *------------------------------------------------------------------------------------
+ */
+SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Init( u32   rom_base );
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Get_Flash_Info( struct SPI_NAND_FLASH_INFO_T    *ptr_rtn_into_t )
+ * PURPOSE : To get system current flash info.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: ptr_rtn_into_t  - A pointer to the structure of the ptr_rtn_into_t variable.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/14 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Get_Flash_Info( struct SPI_NAND_FLASH_INFO_T *ptr_rtn_into_t);
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Write_Nbyte( u32    dst_addr,
+ *                                                            u32    len,
+ *                                                            u32    *ptr_rtn_len,
+ *                                                            u8*    ptr_buf      )
+ * PURPOSE : To provide interface for Write N Bytes into SPI NAND Flash.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : dst_addr - The dst_addr variable of this function.
+ *           len      - The len variable of this function.
+ *           buf      - The buf variable of this function.
+ *   OUTPUT: rtn_len  - The rtn_len variable of this function.
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/15 by Chuck Kuo - The first revision for this function.
+ *
+
+ *------------------------------------------------------------------------------------
+ */
+SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Write_Nbyte( u32								dst_addr,
+                                                 u32    							len,
+                                                 u32    							*ptr_rtn_len,
+                                                 u8									*ptr_buf,      
+                                                 SPI_NAND_FLASH_WRITE_SPEED_MODE_T 	speed_mode	);
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: int SPI_NAND_Flash_Read_NByte( long     addr,
+ *                                          long     len,
+ *                                          long     *retlen,
+ *                                          char     *buf    )
+ * PURPOSE : To provide interface for Read N Bytes from SPI NAND Flash.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : addr    - The addr variable of this function.
+ *           len     - The len variable of this function.
+ *           retlen  - The retlen variable of this function.
+ *           buf     - The buf variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/12 by Chuck Kuo - The first revision for this function.
+ *
+
+ *------------------------------------------------------------------------------------
+ */
+u32 SPI_NAND_Flash_Read_NByte( unsigned long long 					addr,
+                               u32  								len,
+                               u32  								*retlen,
+                               u8   								*buf,
+                               SPI_NAND_FLASH_READ_SPEED_MODE_T 	speed_mode   );
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Erase( u32  dst_addr,
+ *                                                      u32  len      )
+ * PURPOSE : To provide interface for Erase SPI NAND Flash.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : dst_addr - The dst_addr variable of this function.
+ *           len      - The len variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/17 by Chuck Kuo - The first revision for this function.
+ *
+
+ *------------------------------------------------------------------------------------
+ */
+SPI_NAND_FLASH_RTN_T SPI_NAND_Flash_Erase( u32  dst_addr,
+                                           u32  len      );
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: char SPI_NAND_Flash_Read_Byte( long     addr )
+ * PURPOSE : To provide interface for read 1 Bytes from SPI NAND Flash.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : addr - The addr variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/12 by Chuck Kuo - The first revision for this function.
+ *
+
+ *------------------------------------------------------------------------------------
+ */
+unsigned char SPI_NAND_Flash_Read_Byte( unsigned long long    addr );
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: long SPI_NAND_Flash_Read_DWord( long    addr )
+ * PURPOSE : To provide interface for read Double Word from SPI NAND Flash.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : addr - The addr variable of this function.
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2014/12/12 by Chuck Kuo - The first revision for this function.
+ *
+
+ *------------------------------------------------------------------------------------
+ */
+unsigned long SPI_NAND_Flash_Read_DWord( unsigned long long  addr );
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: void SPI_NAND_DEBUG_ENABLE( void )
+ * PURPOSE : To enable to printf debug message of SPI NAND driver.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/20 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+void SPI_NAND_DEBUG_ENABLE( void );
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: void SPI_NAND_DEBUG_DISABLE( void )
+ * PURPOSE : To disable to printf debug message of SPI NAND driver.
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/20 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+void SPI_NAND_DEBUG_DISABLE( void );
+
+/*------------------------------------------------------------------------------------
+ * FUNCTION: void SPI_NAND_Flash_Clear_Read_Cache_Data( void )
+ * PURPOSE : To clear the cache data for read. 
+ *           (The next time to read data will get data from flash chip certainly.)
+ * AUTHOR  : Chuck Kuo
+ * CALLED BY
+ *   -
+ * CALLS
+ *   -
+ * PARAMs  :
+ *   INPUT : None
+ *   OUTPUT: None
+ * RETURN  : SPI_RTN_NO_ERROR - Successful.   Otherwise - Failed.
+ * NOTES   :
+ * MODIFICTION HISTORY:
+ * Date 2015/01/21 by Chuck Kuo - The first revision for this function.
+ *
+ *------------------------------------------------------------------------------------
+ */
+void SPI_NAND_Flash_Clear_Read_Cache_Data( void );
+
+#endif /* ifndef __SPI_NAND_FLASH_H__ */
+/* End of [spi_nand_flash.h] package */
+
diff --git a/drivers/mtd/maps/tc3162-flash.c b/drivers/mtd/maps/tc3162-flash.c
new file mode 100644
index 000000000..980bceb30
--- /dev/null
+++ b/drivers/mtd/maps/tc3162-flash.c
@@ -0,0 +1,156 @@
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/root_dev.h>
+#include <linux/kernel.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/vmalloc.h>
+#include <asm/io.h>
+#include <asm/tc3162/tc3162.h>
+// #include <flash/flash_global_def.h>
+
+#define WINDOW_ADDR 0x1fc00000
+#define WINDOW_SIZE 0x400000
+#define BUSWIDTH 	2
+
+static struct mtd_info *tc3162_mtd_info;
+
+static struct map_info tc3162_map = {
+       .name = "tc3162",
+       .size = WINDOW_SIZE,
+       .bankwidth = BUSWIDTH,
+       .phys = WINDOW_ADDR,
+};
+
+static struct mtd_partition tc3162_parts[] = {
+	{
+		name:	"bootloader",
+		size:	0x40000,
+		offset: 0,
+	},
+	{
+		name:	"romfile",
+		size:	0x40000,
+		offset: MTDPART_OFS_APPEND
+	},
+	{
+		name:	"kernel",
+		size:	2 * 1024 * 1024,
+		offset: MTDPART_OFS_APPEND
+	},
+	{
+		name:	"rootfs",
+		size:	30 * 1024 * 1024,
+		offset: MTDPART_OFS_APPEND
+	}
+};
+
+static int tc3162_parts_size = sizeof(tc3162_parts) / sizeof(tc3162_parts[0]);
+
+int tc3162_map_init(void) {
+#ifdef TCSUPPORT_ADDR_MAPPING
+	/* add address mapping on 7510. Pork */
+	if (isMT751020 || isMT7505 || isEN751221) {
+		uint32 tmpVal;
+		tmpVal = regRead32(0xbfb00038);
+		tmpVal &= 0xffe0e0e0;
+		tmpVal |= 0x80070f00;
+		regWrite32(0xbfb00038, tmpVal);
+		// VPint(0xbfb00038) |= 0x80070F00;
+		printk("tc3162: flash device 0x%08x at 0x%08x\n", 0x1000000, 0x1c000000);
+		tc3162_map.virt = ioremap(0x1c000000, 0x1000000);
+		tc3162_map.phys = 0x1c000000;
+		tc3162_map.size = 0x1000000;
+		ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	}
+	/* add 8M 16M flash support. shnwind */
+	else if (isTC3162U || isTC3182 || isRT65168 || isRT63165 || isRT63365 || isRT63260) {
+#else
+	if (isTC3162U || isTC3182 || isRT65168 || isRT63165 || isRT63365 || isRT63260 || isMT751020 || isMT7505 || isEN751221) {
+#endif //TCSUPPORT_ADDR_MAPPING
+		// header = (unsigned int *)0xb0020000;
+		/* Enable addr bigger than 4M support. */
+		VPint(0xbfb00038) |= 0x80000000;
+		printk("tc3162: flash device 0x%08x at 0x%08x\n", 0x1000000, 0x10000000);
+		tc3162_map.virt = ioremap(0x10000000, 0x1000000);
+		tc3162_map.phys = 0x10000000;
+		tc3162_map.size = 0x1000000;
+		ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	} else {
+		// header = (unsigned int *)0xbfc20000;
+		printk("tc3162: flash device 0x%08x at 0x%08x\n", WINDOW_SIZE, WINDOW_ADDR);
+		tc3162_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	}
+	if (!tc3162_map.virt) {
+   		printk("tc3162: ioremap failed.\n");
+		return -EIO;
+	}
+
+	simple_map_init(&tc3162_map);
+
+	return 0;
+}
+
+static int tc3162_mtd_info_init(void) {
+	if (IS_NANDFLASH) {
+		tc3162_mtd_info = do_map_probe("nandflash_probe", &tc3162_map);
+	} else if (IS_SPIFLASH) {
+		printk("tc3162: SPIFLASH driver is not supported at the momemnt. There is a driver in TP-link VR300 sources, but it is not upgraded.\n")
+		// tc3162_mtd_info = do_map_probe("spiflash_probe", &tc3162_map);
+	} else {
+		tc3162_mtd_info = do_map_probe("cfi_probe", &tc3162_map);
+	}
+
+	if (!tc3162_mtd_info) {
+		iounmap(tc3162_map.virt);
+		return -ENXIO;
+	}
+
+  	tc3162_mtd_info->owner = THIS_MODULE;
+
+	return 0;
+}
+
+static void tc3162_put_rootfs(void) {
+	struct mtd_info *mtd = get_mtd_device_nm("rootfs");
+	/* From init/do_mounts.c, it looks like ROOT_DEV will be
+	   mounted as root fs if CONFIG_BLOCK is defined. */
+	ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);
+	put_mtd_device(mtd);
+}
+
+static int __init tc3162_mtd_init(void)
+{
+	int ret = 0;
+
+	if (ret = tc3162_map_init()) {
+		printk("tc3162_map_init() fail\n");
+		return ret;
+	}
+	if (ret = tc3162_mtd_info_init()) {
+		printk("tc3162_mtd_info_init() fail\n");
+		return ret;
+	}
+	add_mtd_partitions(tc3162_mtd_info, tc3162_parts, tc3162_parts_size);
+	tc3162_put_rootfs();
+
+	return 0;
+}
+
+static void __exit tc3162_mtd_cleanup(void)
+{
+	if (tc3162_mtd_info) {
+		del_mtd_partitions(tc3162_mtd_info);
+		map_destroy(tc3162_mtd_info);
+	}
+
+   	if (tc3162_map.virt) {
+   		iounmap(tc3162_map.virt);
+		tc3162_map.virt = 0;
+	}
+}
+
+module_init(tc3162_mtd_init);
+module_exit(tc3162_mtd_cleanup);
+
diff --git a/drivers/mtd/tc3162/bmt.c b/drivers/mtd/tc3162/bmt.c
new file mode 100755
index 000000000..3acfbf829
--- /dev/null
+++ b/drivers/mtd/tc3162/bmt.c
@@ -0,0 +1,1187 @@
+
+#include <linux/types.h>
+
+#include "bmt.h"
+
+typedef struct {
+    char signature[3];
+    u8 version;
+    u8 bad_count;           // bad block count in pool
+    u8 mapped_count;        // mapped block count in pool
+    u8 checksum;
+    u8 reseverd[13];
+} phys_bmt_header;
+
+typedef struct {
+    phys_bmt_header header;
+    bmt_entry table[MAX_BMT_SIZE];
+} phys_bmt_struct;
+
+typedef struct {
+    char signature[3];
+} bmt_oob_data;
+
+typedef struct {
+    char signature[4];
+    u32 checksum;
+    u8 version;
+    u8 badblock_count;
+    u8 reserved[2];
+}init_table_header;
+
+typedef struct {
+    init_table_header header;
+    u16 badblock_table[MAX_RAW_BAD_BLOCK_SIZE];
+}init_table_struct;
+
+static char BBT_SIGNATURE[] = "RAWB";
+#define BBT_SIGNATURE_SIZE      (4)
+
+static char MAIN_SIGNATURE[] = "BMT";
+#define SIGNATURE_SIZE      (3)
+
+#define MAX_DAT_SIZE        0x1000
+#define MAX_OOB_SIZE        0x80
+#define MAX_RAW_BBT_SIZE    65536
+
+static u8 need_write_bmt_to_nand = 0;
+static u8 need_write_bbt_to_nand = 0;
+
+#define __UBOOT_NAND__
+#if	defined(TCSUPPORT_CPU_MT7510)||defined(TCSUPPORT_CPU_MT7520)||defined(TCSUPPORT_CPU_EN7512)||defined(TCSUPPORT_CPU_EN7521)
+#if 1
+#define MSG(args...) printk(args)
+#else
+#define MSG(args...) do{}while(0)
+#endif
+
+
+
+static struct mtd_info *mtd_bmt;
+static struct nand_chip *nand_chip_bmt;
+#define BLOCK_SIZE_BMT          (1 << nand_chip_bmt->phys_erase_shift)
+#define PAGE_SIZE_BMT           (1 << nand_chip_bmt->page_shift)
+#else
+static struct ra_nand_chip *nand_chip_bmt = NULL;
+
+#define BLOCK_SIZE_BMT          (1 << nand_chip_bmt->flash->erase_shift)
+#define PAGE_SIZE_BMT           (1 << nand_chip_bmt->flash->page_shift)
+#endif
+
+#define OFFSET(block)       ((block) * BLOCK_SIZE_BMT)           
+#define PAGE_ADDR(block)    ((block) * BLOCK_SIZE_BMT / PAGE_SIZE_BMT)
+
+/*********************************************************************
+* Flash is splited into 2 parts, system part is for normal system    *
+* system usage, size is system_block_count, another is replace pool  *
+*    +-------------------------------------------------+             *
+*    |     system_block_count     |   bmt_block_count  |             *
+*    +-------------------------------------------------+             *
+*********************************************************************/
+static u32 total_block_count;       // block number in flash
+static u32 system_block_count;      // system block number
+static int bmt_block_count;         // bmt block number
+
+int nand_logic_size;                // logic size
+int nand_flash_avalable_size;
+static int page_per_block;          // page per count
+static int oob_bad_index_offset = OOB_INDEX_OFFSET;       // bad index offset in oob
+
+static u32 bmt_block_index = 0;     // bmt block index
+static bmt_struct bmt;              // dynamic created global bmt table
+
+static u32 bbt_block_index = 0;     // bbt block index
+static init_bbt_struct init_bbt;    // dynamic created global bbt table
+static u16 pBbt[MAX_RAW_BBT_SIZE];              // raw badblock table
+
+static u8 dat_buf[MAX_DAT_SIZE];
+static u8 oob_buf[MAX_OOB_SIZE];
+static bool pool_erased;
+
+/***************************************************************
+*                                                              
+* Interface adaptor for preloader/uboot/kernel                 
+*    These interfaces operate on physical address, read/write
+*       physical data.
+*                                                              
+***************************************************************/
+
+int nand_read_page_bmt(u32 page, u8 *dat, u8 *oob)
+{
+#if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+	return en7512_nand_exec_read_page(page, dat, oob);
+#else
+#if	defined(TCSUPPORT_CPU_MT7510)||defined(TCSUPPORT_CPU_MT7520)
+	return mt6573_nand_exec_read_page(mtd_bmt, page, PAGE_SIZE_BMT, dat, oob);
+#else
+    return mt6573_nand_exec_read_page(nand_chip_bmt, page, PAGE_SIZE_BMT, dat, oob);
+#endif
+#endif
+}
+
+int nand_block_bad_bmt(u32 offset, u32 bmt_block)
+{
+#if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+	return en7512_nand_check_block_bad(offset, bmt_block);
+#else
+#if	defined(TCSUPPORT_CPU_MT7510)||defined(TCSUPPORT_CPU_MT7520)
+	return mt6573_nand_block_bad_hw(mtd_bmt, offset, bmt_block);
+#else
+    return mt6573_nand_block_bad_hw(nand_chip_bmt, offset, bmt_block);
+#endif
+#endif
+}
+
+int nand_erase_bmt(u32 offset)
+{
+#if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+	return en7512_nand_erase(offset);
+#else
+#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520)
+	int status;
+	status = mt6573_nand_erase_hw(mtd_bmt, offset / PAGE_SIZE_BMT);
+	if (status & NAND_STATUS_FAIL)
+		return -EIO;
+	else
+		return 0;
+#else
+	return mt6573_nand_erase_hw(nand_chip_bmt, offset / PAGE_SIZE_BMT);
+#endif
+#endif
+
+}
+
+int mark_block_bad_bmt(u32 offset, u32 bmt_block)
+{
+#if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+	return en7512_nand_mark_badblock(offset, bmt_block);
+#else
+#if	defined(TCSUPPORT_CPU_MT7510)||defined(TCSUPPORT_CPU_MT7520)
+	return mt6573_nand_block_markbad_hw(mtd_bmt, offset, bmt_block);
+#else
+    return mt6573_nand_block_markbad_hw(nand_chip_bmt, offset, bmt_block);
+#endif
+#endif
+}
+
+int nand_write_page_bmt(u32 page, u8 *dat, u8 *oob)
+{
+#if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+	return en7512_nand_exec_write_page(page, dat, oob);
+#else
+#if	defined(TCSUPPORT_CPU_MT7510)||defined(TCSUPPORT_CPU_MT7520)
+	return mt6573_nand_exec_write_page(mtd_bmt, page, PAGE_SIZE_BMT, dat, oob);
+#else
+    return mt6573_nand_exec_write_page(nand_chip_bmt, page, PAGE_SIZE_BMT, dat, oob);
+#endif
+#endif
+}
+
+/***************************************************************
+*                                                              *
+* static internal function                                     *
+*                                                              *
+***************************************************************/
+static void dump_bmt_info(bmt_struct *bmt)
+{
+    int i;
+    
+    MSG("BMT v%d.", bmt->version);
+    MSG("total %d mapping\n", bmt->mapped_count);
+    for (i = 0; i < bmt->mapped_count; i++)
+    {
+        MSG("%d -> %d \n", bmt->table[i].bad_index, bmt->table[i].mapped_index);
+    }
+}
+
+static bool match_bmt_signature(u8 *dat, u8 *oob)
+{
+    if (memcmp(dat + MAIN_SIGNATURE_OFFSET, MAIN_SIGNATURE, SIGNATURE_SIZE))
+    {
+        return false;
+    }
+ 
+    return true;
+}
+
+static bool match_bbt_signature(u8 *dat, u8 *oob)
+{
+    if (memcmp(dat + BBT_SIGNATURE_OFFSET, BBT_SIGNATURE, BBT_SIGNATURE_SIZE))
+    {
+        return false;
+    }
+
+    return true;
+    
+}
+
+static u8 cal_bmt_checksum(phys_bmt_struct *phys_table, int bmt_size)
+{
+    int i;
+    u8 checksum = 0;
+    u8 *dat = (u8 *)phys_table;
+
+    checksum += phys_table->header.version;
+    checksum += phys_table->header.mapped_count;
+
+    dat += sizeof(phys_bmt_header);
+    for (i = 0; i < bmt_size * sizeof(bmt_entry); i++)
+    {
+        checksum += dat[i];
+    }
+
+    return checksum;
+}
+
+static u16 cal_bbt_checksum(init_table_struct *bbt_table)
+{
+    int i;
+    u16 checksum = 0;
+    u8 *dat = (u8*)bbt_table;
+
+    checksum += bbt_table->header.version;
+    checksum += bbt_table->header.badblock_count;
+
+    dat += sizeof(init_table_header);
+
+    for (i = 0; i < sizeof(bbt_table->badblock_table); i++)
+    {
+        checksum += dat[i];            
+
+    }
+
+    return checksum;
+
+}
+
+static int is_block_mapped(int index)
+{
+    int i;
+    for (i = 0; i < bmt.mapped_count; i++)
+    {
+        if (index == bmt.table[i].mapped_index)
+            return i;
+    }
+    return -1;
+}
+
+static int is_badblock_raw(u16 index)
+{
+    int i;
+    
+    for (i = 0; i < bmt.mapped_count; i++)
+    {
+        if (index == bmt.table[i].bad_index)
+            return 0;
+    }
+    return 1;
+
+}
+
+static bool valid_bmt_data(phys_bmt_struct *phys_table)
+{
+    int i;
+    u8 checksum = cal_bmt_checksum(phys_table, bmt_block_count);
+    
+    // checksum correct?
+    if ( phys_table->header.checksum != checksum)
+    {
+        MSG("bmt checksum error \n");
+        return false;
+    }
+    
+    // block index correct?
+    for (i = 0; i < phys_table->header.mapped_count; i++)
+    {
+        if (phys_table->table[i].bad_index >= total_block_count ||
+            phys_table->table[i].mapped_index >= total_block_count ||
+            phys_table->table[i].mapped_index < system_block_count)
+        {
+            MSG("bmt block index error \n");
+            return false;
+        }
+    }
+
+    // pass check, valid bmt.
+    MSG("Valid BMT, version v%d\n", phys_table->header.version);
+    return true;
+}
+
+static bool valid_bbt_data(init_table_struct *bbt_table)
+{
+    int i;
+    u16 checksum = cal_bbt_checksum(bbt_table);
+
+    if (bbt_table->header.checksum != checksum)
+    {
+        MSG("BBT Data checksum error: 0x%x 0x%x\n", bbt_table->header.checksum, checksum);
+        return false;
+    }
+
+    MSG("BBT Checksum is: 0x%x\n", bbt_table->header.checksum);
+
+    for (i = 0; i < bbt_table->header.badblock_count; i++)
+    {
+        if (bbt_table->badblock_table[i] >= system_block_count)
+        {
+            MSG("error: badblock_table[%d]: %d \n", i, bbt_table->badblock_table[i]);
+            return false;
+        }
+    }
+
+    MSG("Valid BBT, version v%d\n", bbt_table->header.version);
+    return true;
+
+}
+
+
+static void fill_nand_bmt_buffer(bmt_struct *bmt, u8 *dat, u8 *oob)
+{
+    phys_bmt_struct phys_bmt;
+
+    dump_bmt_info(bmt);
+
+    // fill phys_bmt_struct structure with bmt_struct
+    memset(&phys_bmt, 0xFF, sizeof(phys_bmt));
+    
+    memcpy(phys_bmt.header.signature, MAIN_SIGNATURE, SIGNATURE_SIZE);
+    phys_bmt.header.version = BMT_VERSION;
+    phys_bmt.header.mapped_count = bmt->mapped_count;
+    memcpy(phys_bmt.table, bmt->table, sizeof(bmt_entry) * bmt_block_count);
+
+    phys_bmt.header.checksum = cal_bmt_checksum(&phys_bmt, bmt_block_count);
+
+    memcpy(dat + MAIN_SIGNATURE_OFFSET, &phys_bmt, sizeof(phys_bmt));
+
+    return;
+}
+
+static void fill_nand_bbt_buffer(init_bbt_struct *bbt, u8 *dat, u8 *oob)
+{
+    init_table_struct init_table;
+
+    memset(&init_table, 0xFF, sizeof(init_table));
+
+    memcpy(init_table.header.signature, BBT_SIGNATURE, BBT_SIGNATURE_SIZE);
+    
+    init_table.header.version = BBT_VERSION;
+    init_table.header.badblock_count = bbt->badblock_count;
+
+    memcpy(init_table.badblock_table, bbt->badblock_table, sizeof(bbt->badblock_table));
+
+    init_table.header.checksum = cal_bbt_checksum(&init_table);
+
+    memcpy(dat + BBT_SIGNATURE_OFFSET, &init_table, sizeof(init_table));
+
+    return;
+
+}
+
+// return valid index if found BMT, else return 0
+static int load_bmt_data(int start, int pool_size)
+{
+    int bmt_index = start + pool_size - 1;        // find from the end
+    phys_bmt_struct phys_table;
+    int i;
+ 
+    MSG("begin to search BMT from block %d \n", bmt_index);
+
+    for (bmt_index = start + pool_size - 1; bmt_index >= start; bmt_index--)
+    {
+        if (nand_block_bad_bmt(OFFSET(bmt_index), BAD_BLOCK_RAW) || nand_block_bad_bmt(OFFSET(bmt_index), BMT_BADBLOCK_GENERATE_LATER))
+        {
+            MSG("Skip bad block: %d \n", bmt_index);
+            continue;
+        }
+        
+        if (nand_read_page_bmt(PAGE_ADDR(bmt_index), dat_buf, oob_buf))
+        {
+            MSG("Error found when read block: %d\n", bmt_index);
+            continue;
+        }
+
+        if (!match_bmt_signature(dat_buf, oob_buf))
+        {
+            continue;
+        }
+
+        MSG("Match bmt signature @ block: %d\n", bmt_index);
+        
+        memcpy(&phys_table, dat_buf + MAIN_SIGNATURE_OFFSET, sizeof(phys_table));
+
+        if (!valid_bmt_data(&phys_table))
+        {
+            MSG("BMT data is not correct: %d\n", bmt_index);
+            continue;
+        }
+        else
+        {
+            bmt.mapped_count = phys_table.header.mapped_count;
+            bmt.version = phys_table.header.version;
+            memcpy(bmt.table, phys_table.table, bmt.mapped_count * sizeof(bmt_entry));
+
+            MSG("bmt found at block: %d, mapped block: %d\n", bmt_index, bmt.mapped_count);
+
+            for (i = 0; i < bmt.mapped_count; i++)
+            {
+                if (!nand_block_bad_bmt(OFFSET(bmt.table[i].bad_index), BAD_BLOCK_RAW))
+                {
+                    MSG("block %d is not mark bad, should be power lost last time\n", bmt.table[i].bad_index);
+                    mark_block_bad_bmt(OFFSET(bmt.table[i].bad_index), BAD_BLOCK_RAW);
+                }
+            }
+            
+            return bmt_index;
+        }
+    }    
+
+    MSG("bmt not found!\n");
+    return 0;
+}
+
+static int load_bbt_data(int start, int pool_size, init_bbt_struct *init_bbt)
+{
+    int i;
+    int ret = 0;
+
+    int bbt_index = start;
+    init_table_struct init_table;
+
+    for(;bbt_index < (start + pool_size); bbt_index++)
+    {
+
+        if (nand_block_bad_bmt(OFFSET(bbt_index), BAD_BLOCK_RAW) || nand_block_bad_bmt(OFFSET(bbt_index), BMT_BADBLOCK_GENERATE_LATER))
+        {
+            MSG("Skip bad block: %d\n", bbt_index);
+            continue;
+        }
+        
+        if (nand_read_page_bmt(PAGE_ADDR(bbt_index), dat_buf, oob_buf))
+        {
+            MSG("Error found when read block %d\n", bbt_index);
+            continue;
+        }
+        
+        if (!match_bbt_signature(dat_buf, oob_buf))
+        {
+            continue;
+        }
+
+        MSG("Match bbt signature \n");
+
+        memcpy(&init_table, dat_buf + BBT_SIGNATURE_OFFSET, sizeof(init_table));
+
+        if (!valid_bbt_data(&init_table))
+        {
+            MSG("BBT data is not correct \n");
+            continue;
+        }
+        else
+        {
+            init_bbt->badblock_count = init_table.header.badblock_count;
+            init_bbt->version = init_table.header.version;
+            memcpy(init_bbt->badblock_table, init_table.badblock_table, (init_bbt->badblock_count) * 2);
+
+            MSG("bbt found, bad block count: %d\n", init_bbt->badblock_count);
+
+            for (i = 0; i < init_bbt->badblock_count; i++)
+            {
+                MSG("init_bbt->badblock_table[%d]: %d \n", i, init_bbt->badblock_table[i]);
+            }
+            
+            return bbt_index;
+        }
+
+    }
+
+    return ret;
+    
+}
+
+
+/*************************************************************************
+* Find an available block and erase.                                     *
+* start_from_end: if true, find available block from end of flash.       *
+*                 else, find from the beginning of the pool              *
+* need_erase: if true, all unmapped blocks in the pool will be erased    *
+*************************************************************************/
+static int find_available_block(bool start_from_end)
+{
+    int i;
+    int block = system_block_count;
+    int direction;
+    MSG("Try to find_available_block, pool_erase: %d\n", pool_erased);
+
+    // erase all un-mapped blocks in pool when finding avaliable block
+    if (!pool_erased)
+    {
+        for (i = 0; i < bmt_block_count; i++)
+        {
+	        if ((block + i) == bmt_block_index)    
+	        {
+	            MSG("Skip bmt block %d \n", block + i);
+	            continue;
+	        }            
+
+	        if ((block + i) == bbt_block_index)    
+	        {
+	            MSG("Skip bbt block %d \n", block + i);
+	            continue;
+	        }  
+	        
+	        if (nand_block_bad_bmt(OFFSET(block + i), BAD_BLOCK_RAW) || nand_block_bad_bmt(OFFSET(block + i), BMT_BADBLOCK_GENERATE_LATER))
+            {
+                MSG("Skip bad block %d \n", block + i);
+                continue;
+            }
+
+            if (is_block_mapped(block + i) >= 0)
+            {
+                MSG("Skip mapped block %d \n", block + i);
+                continue;
+            }
+
+            if (nand_erase_bmt(OFFSET(block + i)))
+            {
+                MSG("Erase block %d fail\n", block + i);
+                mark_block_bad_bmt(OFFSET(block + i), BMT_BADBLOCK_GENERATE_LATER);
+            }
+        }
+
+        pool_erased = 1;
+    }
+
+    if (start_from_end)
+    {
+        block = total_block_count - 1;
+        direction = -1;
+    }
+    else
+    {
+        block = system_block_count;
+        direction = 1;
+    }
+
+    for (i = 0; i < bmt_block_count; i++, block += direction)
+    {
+        if (block == bmt_block_index)
+        {
+            MSG("Skip bmt block %d \n", block);
+            continue;
+        }
+
+        if (block == bbt_block_index)
+        {
+            MSG("Skip bbt block %d \n", block);
+            continue;
+        }
+        
+        if (nand_block_bad_bmt(OFFSET(block), BAD_BLOCK_RAW) || nand_block_bad_bmt(OFFSET(block), BMT_BADBLOCK_GENERATE_LATER))
+        {
+            MSG("Skip bad block %d \n", block);
+            continue;
+        }
+
+        if (is_block_mapped(block) >= 0)
+        {
+            MSG("Skip mapped block %d \n", block);
+            continue;
+        }
+
+        MSG("Find block %d available\n", block);
+        return block;
+    }
+
+    return 0;
+}
+
+
+static unsigned short get_bad_index_from_oob(u8 *oob_buf)
+{
+    unsigned short index;
+
+	memcpy(&index, oob_buf + oob_bad_index_offset, OOB_INDEX_SIZE);
+
+    return index;
+}
+
+void set_bad_index_to_oob(u8 *oob, u16 index)
+{
+	memcpy(oob + oob_bad_index_offset, &index, sizeof(index));
+}
+
+static int migrate_from_bad(int offset, u8 *write_dat, u8 *write_oob)
+{
+    int page;
+    int error_block = offset / BLOCK_SIZE_BMT;
+    int error_page = (offset / PAGE_SIZE_BMT) % page_per_block;
+    int to_index;
+
+    to_index = find_available_block(false);
+  
+
+    if (!to_index)
+    {
+        MSG("Cannot find an available block for BMT\n");
+        return 0;
+    }
+    
+    for (page = 0; page < error_page; page++)
+    {
+        nand_read_page_bmt(PAGE_ADDR(error_block) + page, dat_buf, oob_buf);
+
+        if (error_block < system_block_count)
+        {
+            set_bad_index_to_oob(oob_buf, error_block);
+        }
+ 
+        if (nand_write_page_bmt(PAGE_ADDR(to_index) + page, dat_buf, oob_buf))
+        {
+            MSG("Write page %d fail\n", PAGE_ADDR(to_index) + page);
+            mark_block_bad_bmt(OFFSET(to_index), BMT_BADBLOCK_GENERATE_LATER);
+            return migrate_from_bad(offset, write_dat, write_oob);
+        }          
+    }
+
+
+    {       
+
+        memset(oob_buf, 0xFF, sizeof(oob_buf));
+		#if	defined(TCSUPPORT_CPU_MT7510)||defined(TCSUPPORT_CPU_MT7520)||defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+        memcpy(oob_buf, write_oob, mtd_bmt->oobsize);
+		#else
+		memcpy(oob_buf, write_oob, 1 << nand_chip_bmt->flash->oob_shift);
+		#endif
+   
+        if (error_block < system_block_count)
+            set_bad_index_to_oob(oob_buf, error_block);       // if error_block is already a mapped block, original mapping index is in OOB.
+        
+        if (nand_write_page_bmt(PAGE_ADDR(to_index) + error_page, write_dat, oob_buf))
+        {
+            MSG("Write page %d fail\n", PAGE_ADDR(to_index) + error_page);
+            mark_block_bad_bmt(OFFSET(to_index), BMT_BADBLOCK_GENERATE_LATER);
+            return migrate_from_bad(offset, write_dat, write_oob);
+        }
+    }
+
+    MSG("Migrate from %d to %d done!\n",error_block, to_index);
+
+    return to_index;
+}
+
+static bool write_bmt_to_flash(u8 *dat, u8 *oob)
+{
+    bool need_erase = true;
+    MSG("Try to write BMT\n");
+    
+    if (bmt_block_index == 0)
+    {
+        // if we don't have index, we don't need to erase found block as it has been erased in find_available_block()
+        need_erase = false;     
+        if ( !(bmt_block_index = find_available_block(true)) )
+        {
+            MSG("Cannot find an available block for BMT\n");
+            return false;
+        }
+    }
+   
+    // write bmt to flash
+    if (need_erase)
+    {
+        if (nand_erase_bmt(OFFSET(bmt_block_index)))
+        {
+            MSG("BMT block erase fail, mark bad: 0x%x\n", bmt_block_index);
+            mark_block_bad_bmt(OFFSET(bmt_block_index), BMT_BADBLOCK_GENERATE_LATER);
+            
+            bmt_block_index = 0;
+            return write_bmt_to_flash(dat, oob);        // recursive call 
+        }
+    }
+
+    if ( nand_write_page_bmt(PAGE_ADDR(bmt_block_index), dat, oob) )
+    {
+        MSG("Write BMT data fail \n");
+        mark_block_bad_bmt(OFFSET(bmt_block_index), BMT_BADBLOCK_GENERATE_LATER);
+        
+        bmt_block_index = 0;
+        return write_bmt_to_flash(dat, oob);        // recursive call 
+    }
+
+    MSG("Write BMT to block %d success\n", bmt_block_index);
+    return true;
+}
+
+static bool write_bbt_to_flash(u8 *dat, u8 *oob)
+{
+    
+    if ( !(bbt_block_index = find_available_block(false)) )
+    {
+        MSG("Cannot find an available block for BBT\n");
+        return false;
+    }
+
+    if ( nand_write_page_bmt(PAGE_ADDR(bbt_block_index), dat, oob) )
+    {
+        MSG("Write BBT data fail \n");
+        mark_block_bad_bmt(OFFSET(bbt_block_index), BMT_BADBLOCK_GENERATE_LATER);
+        
+        bbt_block_index = 0;
+        return write_bbt_to_flash(dat, oob);        // recursive call 
+    }
+
+    MSG("Write BBT to block %d success\n", bbt_block_index);
+    return true;
+}
+
+int scan_badblock_raw(init_bbt_struct *init_bbt)
+{
+    u16 block = 0;
+    int count = 0;
+    
+    for(block = 1; block < system_block_count; block++)
+    {
+        if(nand_block_bad_bmt(OFFSET(block), BAD_BLOCK_RAW))
+        {
+            if(is_badblock_raw(block))
+            {
+                if(count >= MAX_RAW_BAD_BLOCK_SIZE)
+                {
+                    return -1;
+                }
+                init_bbt->badblock_table[count] = block;
+                count++;
+            }
+            else
+            {
+                continue;
+            }
+
+        }
+
+    }
+
+    init_bbt->badblock_count = count;
+
+    return 0;
+
+}
+/*******************************************************************
+* Reconstruct bmt, called when found bmt info doesn't match bad 
+* block info in flash.
+* 
+* Return NULL for failure
+*******************************************************************/
+bmt_struct *reconstruct_bmt(bmt_struct * bmt)
+{
+    int i;
+    int index = system_block_count;
+    unsigned short bad_index;
+ 
+    // init everything in BMT struct 
+    bmt->version = BMT_VERSION;
+    bmt->bad_count = 0;
+    bmt->mapped_count = 0;
+    
+    memset(bmt->table, 0, bmt_block_count * sizeof(bmt_entry));
+
+    for (i = 0; i < bmt_block_count; i++, index++)
+    {
+        if (nand_block_bad_bmt(OFFSET(index), BAD_BLOCK_RAW) || nand_block_bad_bmt(OFFSET(index), BMT_BADBLOCK_GENERATE_LATER))
+        {
+            MSG("Skip bad block: %d \n", index);
+            continue;
+        }
+
+        nand_read_page_bmt(PAGE_ADDR(index), dat_buf, oob_buf);
+
+        if ((bad_index = get_bad_index_from_oob(oob_buf)) >= system_block_count)
+        {
+            MSG("get bad index: 0x%x \n", bad_index);
+            if (bad_index != 0xFFFF)
+                MSG("Invalid bad index found in block: %d \n", index);
+            continue;
+        }
+
+        MSG("Block 0x%x is mapped to bad block: 0x%x\n", index, bad_index);
+
+        if (!nand_block_bad_bmt(OFFSET(bad_index), BAD_BLOCK_RAW))
+        {
+            mark_block_bad_bmt(OFFSET(bad_index), BAD_BLOCK_RAW);
+            MSG("block %d is not marked as bad, mark it\n", bad_index);
+        }
+
+        {
+            // add mapping to BMT
+            bmt->table[bmt->mapped_count].bad_index = bad_index;
+            bmt->table[bmt->mapped_count].mapped_index = index;
+            bmt->mapped_count++;
+        }
+
+        MSG("Add mapping: %d -> %d to BMT\n", bad_index, index);
+    }
+
+    MSG("Scan replace pool done, mapped block: %d\n", bmt->mapped_count);
+
+    return bmt;
+}
+
+init_bbt_struct* reconstruct_bbt(init_bbt_struct* init_bbt)
+{
+    init_bbt->version = BBT_VERSION;
+    init_bbt->badblock_count = 0;
+    memset(init_bbt->badblock_table, 0, sizeof(init_bbt->badblock_table));
+
+    if(scan_badblock_raw(init_bbt))
+    {
+        MSG("scan_badblock_raw fail (%d)! \n", BBT_VERSION);
+        return NULL;
+    }
+
+    return init_bbt;
+}
+
+/*******************************************************************
+* [BMT Interface]
+*
+* Description:
+*   Init bmt from nand. Reconstruct if not found or data error
+*
+* Parameter:
+*   size: size of bmt and replace pool
+* 
+* Return: 
+*   NULL for failure, and a bmt struct for success
+*******************************************************************/
+#if defined(TCSUPPORT_CPU_EN7512)||defined(TCSUPPORT_CPU_EN7521)
+bmt_struct *init_bmt(struct mtd_info *mtd, int size)
+#else
+#if	defined(TCSUPPORT_CPU_MT7510)||defined(TCSUPPORT_CPU_MT7520)
+bmt_struct *init_bmt(struct nand_chip *chip, int size)
+#else
+bmt_struct *init_bmt(struct ra_nand_chip *ra, int size)
+#endif
+#endif
+{
+#if	defined(TCSUPPORT_CPU_MT7510)||defined(TCSUPPORT_CPU_MT7520)
+	struct mt6573_nand_host *host;
+#endif
+
+
+#if defined(TCSUPPORT_CPU_EN7512)||defined(TCSUPPORT_CPU_EN7521)
+	struct nand_chip *chip;
+#endif
+    
+
+    if (size > 0 && size < MAX_BMT_SIZE)
+    {
+        MSG("Init bmt table, size: %d\n", size);
+        bmt_block_count = size;
+    }
+    else
+    {
+        MSG("Invalid bmt table size: %d\n", size);
+        return NULL;
+    }
+
+	#if defined(TCSUPPORT_CPU_EN7512)||defined(TCSUPPORT_CPU_EN7521)
+
+	chip = mtd->priv;
+	nand_chip_bmt = chip;
+	total_block_count = chip->chipsize >> chip->phys_erase_shift;
+	system_block_count = total_block_count - bmt_block_count;	
+
+	mtd_bmt = mtd;
+
+	#else
+	#if	defined(TCSUPPORT_CPU_MT7510)||defined(TCSUPPORT_CPU_MT7520)
+	nand_chip_bmt = chip;
+	system_block_count = chip->chipsize >> chip->phys_erase_shift;
+	total_block_count = bmt_block_count + system_block_count;
+
+	host = (struct mt6573_nand_host *)chip->priv;
+    mtd_bmt = &host->mtd;
+	
+	#else
+    nand_chip_bmt = ra;
+    total_block_count = (1 << ra->flash->chip_shift) / (1 << ra->flash->erase_shift);
+    system_block_count = total_block_count - bmt_block_count;
+	#endif
+	#endif
+
+    page_per_block = BLOCK_SIZE_BMT / PAGE_SIZE_BMT;
+
+    MSG("bmt count: %d, system count: %d\n", bmt_block_count, system_block_count);
+
+    // set this flag, and unmapped block in pool will be erased.
+    pool_erased = 0;
+
+    // alloc size for bmt.
+    memset(bmt.table, 0, size * sizeof(bmt_entry));
+
+    bmt_block_index = load_bmt_data(system_block_count, size);
+
+    // load bmt if exist
+    if (bmt_block_index)
+    {
+        MSG("Load bmt data success @ block %d \n", bmt_block_index);
+        dump_bmt_info(&bmt);
+        return &bmt;
+    }
+    else
+    {
+        MSG("Load bmt data fail! \n");
+
+        if (reconstruct_bmt(&bmt))
+        {
+            need_write_bmt_to_nand = 1;
+            return &bmt;
+        }
+        else
+            return NULL;
+    }
+	
+}
+
+init_bbt_struct* start_init_bbt(void)
+{
+    bbt_block_index = load_bbt_data(system_block_count, bmt_block_count, &init_bbt);
+    
+    if(bbt_block_index)
+    {
+        MSG("Load bbt data success \n");
+        return &init_bbt;
+    }  
+    else
+    {
+
+        MSG("Load bbt data fail! \n");
+        if(reconstruct_bbt(&init_bbt))
+        {
+            need_write_bbt_to_nand = 1;
+            return &init_bbt;
+
+        }
+        else
+            return NULL;
+    }
+
+}
+
+int write_bbt_or_bmt_to_flash(void)
+{
+    if(need_write_bmt_to_nand)
+    {
+        // fill NAND BMT buffer
+        memset(dat_buf, 0xFF, sizeof(dat_buf));
+        memset(oob_buf, 0xFF, sizeof(oob_buf));
+        fill_nand_bmt_buffer(&bmt, dat_buf, oob_buf);
+
+        // write BMT back
+        if (!write_bmt_to_flash(dat_buf, oob_buf))
+        {
+            MSG("save bmt to nand fail! \n");
+            return -1;
+        }
+
+    }
+
+    if(need_write_bbt_to_nand)
+    {
+        // fill NAND BBT buffer
+        memset(dat_buf, 0xFF, sizeof(dat_buf));
+        memset(oob_buf, 0xFF, sizeof(oob_buf));
+        fill_nand_bbt_buffer(&init_bbt, dat_buf, oob_buf);
+
+        // write BBT back
+        if (!write_bbt_to_flash(dat_buf, oob_buf))
+        {
+            MSG("save bbt to nand fail! \n");
+            return -1;
+        }
+    }
+
+    return 0;
+
+}
+
+int create_badblock_table_by_bbt(void)
+{
+    int i = 0, j = 0, k = 0;
+    int badblock_table_size = system_block_count - init_bbt.badblock_count;
+
+    for(i = 0; i < badblock_table_size; i++)
+    {
+        pBbt[i] = i;
+
+    }
+
+    for(i = 0; i < init_bbt.badblock_count; i++)
+    {
+        for(; j < badblock_table_size; j++)
+        {
+            if(pBbt[j] == init_bbt.badblock_table[i])
+            {
+                k = j;
+                break;
+
+            }
+
+        }
+
+        for(; k < badblock_table_size; k++)
+        {
+            pBbt[k]++;
+        }
+
+    }
+#if	defined(TCSUPPORT_CPU_MT7510)||defined(TCSUPPORT_CPU_MT7520)||defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+	nand_logic_size = (system_block_count - init_bbt.badblock_count) * (1 << nand_chip_bmt->phys_erase_shift);
+#else
+    nand_logic_size = (system_block_count - init_bbt.badblock_count) * (1 << nand_chip_bmt->flash->erase_shift);
+#endif
+    return 0;
+}
+
+
+/*******************************************************************
+* [BMT Interface]
+*
+* Description:
+*   Update BMT.
+*
+* Parameter:
+*   offset: update block/page offset.
+*   reason: update reason, see update_reason_t for reason.
+*   dat/oob: data and oob buffer for write fail.
+* 
+* Return: 
+*   Return true for success, and false for failure.
+*******************************************************************/
+bool update_bmt(u32 offset, update_reason_t reason, u8 *dat, u8 *oob)
+{
+    int map_index;
+    int orig_bad_block = -1;
+    int i;
+    int bad_index = offset / BLOCK_SIZE_BMT;
+
+    if (reason == UPDATE_WRITE_FAIL)
+    {
+        if ( !(map_index = migrate_from_bad(offset, dat, oob)) )
+        {
+            MSG("migrate fail \n");
+            return false;
+        }
+    }
+    else
+    {
+        if ( !(map_index = find_available_block(false)) )
+        {
+            MSG("Cannot find block in pool \n");
+            return false;
+        }
+    }
+
+    // now let's update BMT
+    if (bad_index >= system_block_count)     // mapped block become bad, find original bad block
+    {
+        for (i = 0; i < bmt_block_count; i++)
+        {
+            if (bmt.table[i].mapped_index == bad_index)
+            {
+                orig_bad_block = bmt.table[i].bad_index;
+                break;
+            }
+        }
+        MSG("Mapped block becomes bad, orig bad block is %d \n", orig_bad_block);
+
+        bmt.table[i].mapped_index = map_index;
+    }
+    else
+    {
+        bmt.table[bmt.mapped_count].mapped_index = map_index;
+        bmt.table[bmt.mapped_count].bad_index = bad_index;
+        bmt.mapped_count++;
+    }
+
+    memset(dat_buf, 0xFF, sizeof(dat_buf));
+    memset(oob_buf, 0xFF, sizeof(oob_buf));
+    fill_nand_bmt_buffer(&bmt, dat_buf, oob_buf);
+    if (!write_bmt_to_flash(dat_buf, oob_buf))
+        return false;
+
+    if (bad_index >= system_block_count)
+        mark_block_bad_bmt(offset, BMT_BADBLOCK_GENERATE_LATER);
+    else
+        mark_block_bad_bmt(offset, BAD_BLOCK_RAW);
+
+    return true;
+}
+
+/*******************************************************************
+* [BMT Interface]
+*
+* Description:
+*   Given an block index, return mapped index if it's mapped, else 
+*   return given index.
+*
+* Parameter:
+*   index: given an block index. This value cannot exceed 
+*   system_block_count.
+*
+* Return NULL for failure
+*******************************************************************/
+int get_mapping_block_index_by_bmt(int index)
+{
+    int i;
+
+    if (index >= system_block_count)
+    {
+        MSG("BMT Given index exceed: %d > %d \n", index, system_block_count);
+        return index;
+    }
+
+    for (i = 0; i < bmt.mapped_count; i++)
+    {
+        if (bmt.table[i].bad_index == index)
+        {
+            MSG("Redirect %d to %d \n", index, bmt.table[i].mapped_index);
+            return bmt.table[i].mapped_index;
+        }
+    }
+
+    return index;
+}
+
+int get_mapping_block_index_by_bbt(int index)
+{
+
+    if (index >= (system_block_count - init_bbt.badblock_count))
+    {
+        MSG("BBT Given index exceed: %d > %d \n", index, (system_block_count - init_bbt.badblock_count));
+        return index;
+    }
+
+    return pBbt[index];
+
+}
+
+int get_mapping_block_index(int index, u16 *phy_block_bbt)
+{
+    int block;
+
+    block = get_mapping_block_index_by_bbt(index);
+    *phy_block_bbt = block;
+    block = get_mapping_block_index_by_bmt(block);
+
+    return block;
+
+}
+
+int block_is_in_bmt_region(int index)
+{
+    if(index >= system_block_count)
+        return 1;
+    else
+        return 0;
+}
+
diff --git a/drivers/mtd/tc3162/bmt.h b/drivers/mtd/tc3162/bmt.h
new file mode 100755
index 000000000..9dc07a170
--- /dev/null
+++ b/drivers/mtd/tc3162/bmt.h
@@ -0,0 +1,112 @@
+#ifndef __BMT_H__
+#define __BMT_H__
+
+#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include "../mtk/mt6573_nand.h"
+#elif defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+#else
+#include "ralink_nand.h"
+#endif
+
+#define MAX_RAW_BAD_BLOCK_SIZE  (1000)
+#define BBT_SIGNATURE_OFFSET    (0)
+#define BBT_VERSION  1
+
+#define BAD_BLOCK_RAW (0)
+#define BMT_BADBLOCK_GENERATE_LATER (1)
+
+#if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+#define MAX_BMT_SIZE                  (500)
+#define BMT_SIZE_FOR_RESERVE_AREA     (0x80)
+#else
+#define MAX_BMT_SIZE        	(0x80)//(500)
+#endif
+#define BMT_VERSION         (1)         // initial version
+
+#define MAIN_SIGNATURE_OFFSET   (0)
+#define OOB_INDEX_OFFSET        (2)
+#define OOB_INDEX_SIZE          (2)
+
+#if	!defined(TCSUPPORT_CPU_MT7510)&& !defined(TCSUPPORT_CPU_MT7520)
+#if 0
+#define MSG(args...) printk(args)
+#else
+#define MSG(args...) do{}while(0)
+#endif
+#endif
+
+typedef struct _bmt_entry_
+{
+    u16 bad_index;      // bad block index
+    u16 mapped_index;  // mapping block index in the replace pool
+} bmt_entry;
+
+typedef enum
+{
+    UPDATE_ERASE_FAIL,
+    UPDATE_WRITE_FAIL,
+    UPDATE_UNMAPPED_BLOCK,
+    UPDATE_REASON_COUNT,
+} update_reason_t;
+
+typedef struct {
+    bmt_entry table[MAX_BMT_SIZE];
+    u8 version;
+    u8 mapped_count;                // mapped block count in pool
+    u8 bad_count;                   // bad block count in pool. Not used in V1
+}bmt_struct;
+
+typedef struct {
+    u16 badblock_table[MAX_RAW_BAD_BLOCK_SIZE];  //store bad block raw
+    u8 version;
+    u8 badblock_count;
+    u8 reserved[2];
+}init_bbt_struct;
+
+/***************************************************************
+*                                                              *
+* Interface BMT need to use                                    *
+*                                                              *
+***************************************************************/
+#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520)
+extern int mt6573_nand_exec_read_page(struct mtd_info *mtd, u32 u4RowAddr, u32 u4PageSize, u8* pPageBuf, u8* pFDMBuf);
+extern int mt6573_nand_block_bad_hw(struct mtd_info *mtd, loff_t ofs, u32 bmt_block);
+extern int mt6573_nand_erase_hw(struct mtd_info *mtd, int page);
+extern int mt6573_nand_block_markbad_hw(struct mtd_info *mtd, loff_t offset, u32 bmt_block);
+extern int mt6573_nand_exec_write_page(struct mtd_info *mtd, u32 u4RowAddr, u32 u4PageSize, u8* pPageBuf, u8* pFDMBuf);
+
+#elif defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+
+#else
+extern int mt6573_nand_exec_read_page(struct ra_nand_chip *ra, int page, u32 page_size, u8 *dat, u8 *oob);
+extern int mt6573_nand_block_bad_hw(struct ra_nand_chip *ra, unsigned long ofs, unsigned long bmt_block);
+extern int mt6573_nand_erase_hw(struct ra_nand_chip *ra, unsigned long page);
+extern int mt6573_nand_block_markbad_hw(struct ra_nand_chip *ra, unsigned long ofs, unsigned long bmt_block);
+extern int mt6573_nand_exec_write_page(struct ra_nand_chip *ra, int page, u32 page_size, u8 *dat, u8 *oob);
+#endif
+/********************************************
+*                                           *
+* Interface for preloader/uboot/kernel      *
+*                                           *
+********************************************/
+extern void set_bad_index_to_oob(u8 *oob, u16 index);
+#if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+bmt_struct *init_bmt(struct mtd_info *mtd, int size);
+#else
+#if	defined(TCSUPPORT_CPU_MT7510)||defined(TCSUPPORT_CPU_MT7520)
+bmt_struct *init_bmt(struct nand_chip *chip, int size);
+#else
+extern bmt_struct *init_bmt(struct ra_nand_chip *ra, int size);
+#endif
+#endif
+extern init_bbt_struct* start_init_bbt(void);
+extern int write_bbt_or_bmt_to_flash(void);
+extern int create_badblock_table_by_bbt(void);
+extern bool update_bmt(u32 offset, update_reason_t reason, u8 *dat, u8 *oob);
+extern int get_mapping_block_index_by_bmt(int index);
+extern int get_mapping_block_index_by_bbt(int index);
+extern int get_mapping_block_index(int index, u16 *phy_block_bbt);
+extern int block_is_in_bmt_region(int index);
+#endif
