diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/cpu.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/cpu.h
--- linux-2.6.36/arch/mips/include/asm/cpu.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/cpu.h	2019-03-07 03:40:17.000000000 +0200
@@ -72,6 +72,8 @@
 #define PRID_IMP_R5500		0x5500
 #define PRID_IMP_LOONGSON2	0x6300
 
+#define PRID_IMP_TC3162		0xcd00
+
 #define PRID_IMP_UNKNOWN	0xff00
 
 /*
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/io.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/io.h
--- linux-2.6.36/arch/mips/include/asm/io.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/io.h	2019-03-07 03:40:17.000000000 +0200
@@ -301,6 +301,156 @@ static inline void iounmap(const volatil
 #define war_octeon_io_reorder_wmb()		do { } while (0)
 #endif
 
+#ifdef TCSUPPORT_MT7510_E1
+#define __BUILD_MEMORY_SINGLE(pfx, bwlq, type, irq)			\
+									\
+static inline void pfx##write##bwlq(type val,				\
+				    volatile void __iomem *mem)		\
+{									\
+	volatile type *__mem;						\
+	type __val;							\
+									\
+	war_octeon_io_reorder_wmb();					\
+									\
+	__mem = (void *)__swizzle_addr_##bwlq((unsigned long)(mem));	\
+									\
+	__val = pfx##ioswab##bwlq(__mem, val);				\
+									\
+	if (sizeof(type) != sizeof(u64) || sizeof(u64) == sizeof(long))	{\
+		*__mem = __val;						\
+		__asm__ __volatile("sync");			\
+	} else if (cpu_has_64bits) {					\
+		unsigned long __flags;					\
+		type __tmp;						\
+									\
+		if (irq)						\
+			local_irq_save(__flags);			\
+		__asm__ __volatile__(					\
+			".set	mips3"		"\t\t# __writeq""\n\t"	\
+			"dsll32	%L0, %L0, 0"			"\n\t"	\
+			"dsrl32	%L0, %L0, 0"			"\n\t"	\
+			"dsll32	%M0, %M0, 0"			"\n\t"	\
+			"or	%L0, %L0, %M0"			"\n\t"	\
+			"sd	%L0, %2"			"\n\t"	\
+			".set	mips0"				"\n"	\
+			: "=r" (__tmp)					\
+			: "0" (__val), "m" (*__mem));			\
+		if (irq)						\
+			local_irq_restore(__flags);			\
+	} else								\
+		BUG();							\
+}									\
+									\
+static inline type pfx##read##bwlq(const volatile void __iomem *mem)	\
+{									\
+	volatile type *__mem;						\
+	type __val;							\
+									\
+	__mem = (void *)__swizzle_addr_##bwlq(((unsigned long)(mem) & 0xf) + 0xbfb003a0);	\
+	__val = *__mem; \
+	__asm__ __volatile("sync");			\
+	__mem = (void *)__swizzle_addr_##bwlq((unsigned long)(mem));	\
+									\
+	if (sizeof(type) != sizeof(u64) || sizeof(u64) == sizeof(long))	{\
+		__val = *__mem;						\
+		__asm__ __volatile("sync");			\
+	} else if (cpu_has_64bits) {					\
+		unsigned long __flags;					\
+									\
+		if (irq)						\
+			local_irq_save(__flags);			\
+		__asm__ __volatile__(					\
+			".set	mips3"		"\t\t# __readq"	"\n\t"	\
+			"ld	%L0, %1"			"\n\t"	\
+			"dsra32	%M0, %L0, 0"			"\n\t"	\
+			"sll	%L0, %L0, 0"			"\n\t"	\
+			".set	mips0"				"\n"	\
+			: "=r" (__val)					\
+			: "m" (*__mem));				\
+		if (irq)						\
+			local_irq_restore(__flags);			\
+	} else {							\
+		__val = 0;						\
+		BUG();							\
+	}								\
+									\
+	return pfx##ioswab##bwlq(__mem, __val);				\
+}
+#else
+#if defined(WIFI_MODULE) && defined(CONFIG_MIPS_TC3262) && !defined(TCSUPPORT_CPU_EN7512) && !defined(TCSUPPORT_CPU_EN7521)
+extern void ahbErrChk(void);
+
+#define __BUILD_MEMORY_SINGLE(pfx, bwlq, type, irq)			\
+									\
+static inline void pfx##write##bwlq(type val,				\
+				    volatile void __iomem *mem)		\
+{									\
+	volatile type *__mem;						\
+	type __val;							\
+									\
+	war_octeon_io_reorder_wmb();					\
+									\
+	__mem = (void *)__swizzle_addr_##bwlq((unsigned long)(mem));	\
+									\
+	__val = pfx##ioswab##bwlq(__mem, val);				\
+									\
+	if (sizeof(type) != sizeof(u64) || sizeof(u64) == sizeof(long))	\
+		*__mem = __val;						\
+	else if (cpu_has_64bits) {					\
+		unsigned long __flags;					\
+		type __tmp;						\
+									\
+		if (irq)						\
+			local_irq_save(__flags);			\
+		__asm__ __volatile__(					\
+			".set	mips3"		"\t\t# __writeq""\n\t"	\
+			"dsll32	%L0, %L0, 0"			"\n\t"	\
+			"dsrl32	%L0, %L0, 0"			"\n\t"	\
+			"dsll32	%M0, %M0, 0"			"\n\t"	\
+			"or	%L0, %L0, %M0"			"\n\t"	\
+			"sd	%L0, %2"			"\n\t"	\
+			".set	mips0"				"\n"	\
+			: "=r" (__tmp)					\
+			: "0" (__val), "m" (*__mem));			\
+		if (irq)						\
+			local_irq_restore(__flags);			\
+	} else								\
+		BUG();							\
+}									\
+									\
+static inline type pfx##read##bwlq(const volatile void __iomem *mem)	\
+{									\
+	volatile type *__mem;						\
+	type __val;							\
+									\
+	__mem = (void *)__swizzle_addr_##bwlq((unsigned long)(mem));	\
+									\
+	if (sizeof(type) != sizeof(u64) || sizeof(u64) == sizeof(long))	\
+		{ahbErrChk();__val = *__mem;}                           \
+	else if (cpu_has_64bits) {					\
+		unsigned long __flags;					\
+									\
+		if (irq)						\
+			local_irq_save(__flags);			\
+		__asm__ __volatile__(					\
+			".set	mips3"		"\t\t# __readq"	"\n\t"	\
+			"ld	%L0, %1"			"\n\t"	\
+			"dsra32	%M0, %L0, 0"			"\n\t"	\
+			"sll	%L0, %L0, 0"			"\n\t"	\
+			".set	mips0"				"\n"	\
+			: "=r" (__val)					\
+			: "m" (*__mem));				\
+		if (irq)						\
+			local_irq_restore(__flags);			\
+	} else {							\
+		__val = 0;						\
+		BUG();							\
+	}								\
+									\
+	return pfx##ioswab##bwlq(__mem, __val);				\
+}
+
+#else
 #define __BUILD_MEMORY_SINGLE(pfx, bwlq, type, irq)			\
 									\
 static inline void pfx##write##bwlq(type val,				\
@@ -370,6 +520,8 @@ static inline type pfx##read##bwlq(const
 									\
 	return pfx##ioswab##bwlq(__mem, __val);				\
 }
+#endif
+#endif
 
 #define __BUILD_IOPORT_SINGLE(pfx, bwlq, type, p, slow)			\
 									\
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/irqflags.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/irqflags.h
--- linux-2.6.36/arch/mips/include/asm/irqflags.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/irqflags.h	2019-03-07 03:40:17.000000000 +0200
@@ -195,11 +195,15 @@ __asm__(
 	"	.set	pop						\n"
 	"	.endm							\n");
 
-
+#ifdef TCSUPPORT_XPON_HAL_API_EXT
+extern void resetWatch(void);
+#endif
 static inline void raw_local_irq_restore(unsigned long flags)
 {
 	unsigned long __tmp1;
-
+	#ifdef TCSUPPORT_XPON_HAL_API_EXT
+	resetWatch();
+	#endif
 #ifdef CONFIG_MIPS_MT_SMTC
 	/*
 	 * SMTC kernel needs to do a software replay of queued
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/irq.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/irq.h
--- linux-2.6.36/arch/mips/include/asm/irq.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/irq.h	2019-03-07 03:40:17.000000000 +0200
@@ -113,7 +113,7 @@ do {									\
 
 #endif
 
-extern void do_IRQ(unsigned int irq);
+extern void do_IRQ(int irq); //xflu 20120522
 
 #ifdef CONFIG_MIPS_MT_SMTC_IRQAFF
 
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/mach-generic/mangle-port.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/mach-generic/mangle-port.h
--- linux-2.6.36/arch/mips/include/asm/mach-generic/mangle-port.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/mach-generic/mangle-port.h	2019-03-07 03:40:16.000000000 +0200
@@ -8,6 +8,10 @@
 #ifndef __ASM_MACH_GENERIC_MANGLE_PORT_H
 #define __ASM_MACH_GENERIC_MANGLE_PORT_H
 
+#if defined(CONFIG_MIPS_TC3262)
+extern unsigned char io_swap_noneed;
+#endif
+
 #define __swizzle_addr_b(port)	(port)
 #define __swizzle_addr_w(port)	(port)
 #define __swizzle_addr_l(port)	(port)
@@ -29,13 +33,22 @@
 
 # define ioswabb(a, x)		(x)
 # define __mem_ioswabb(a, x)	(x)
+//auto Choose SWAP function according to platform;
+#if defined(CONFIG_MIPS_TC3262)
+# define ioswabw(a,x)       (io_swap_noneed ? (x) : le16_to_cpu(x) )
+# define __mem_ioswabw(a,x) (io_swap_noneed ? cpu_to_le16(x) : (x) )
+# define ioswabl(a,x)		(io_swap_noneed ? (x) : le32_to_cpu(x) )
+# define __mem_ioswabl(a,x)	(io_swap_noneed ? cpu_to_le32(x) : (x) )
+# define ioswabq(a,x)		(io_swap_noneed ? (x) : le64_to_cpu(x) )
+# define __mem_ioswabq(a,x) (io_swap_noneed ? cpu_to_le32(x) : (x) )
+#else
 # define ioswabw(a, x)		le16_to_cpu(x)
 # define __mem_ioswabw(a, x)	(x)
 # define ioswabl(a, x)		le32_to_cpu(x)
 # define __mem_ioswabl(a, x)	(x)
 # define ioswabq(a, x)		le64_to_cpu(x)
 # define __mem_ioswabq(a, x)	(x)
-
+#endif
 #else
 
 # define ioswabb(a, x)		(x)
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/mipsregs.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/mipsregs.h
--- linux-2.6.36/arch/mips/include/asm/mipsregs.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/mipsregs.h	2019-03-07 03:40:17.000000000 +0200
@@ -111,6 +111,27 @@
 #define CP0_TX39_CACHE	$7
 
 /*
+ * TrendChip cache control register 
+ */
+#define CP0_CCTL 		$20		/* Lexra Cache Control Register */
+
+/*
+ * Lexra Cache Control Register fields
+ */
+#define CCTL_DINVAL	   	0x00000001
+#define CCTL_IINVAL		0x00000002
+#define CCTL_ILOCK		0x0000000c
+#define CCTL_IRAMFILL4 	0x00000010
+#define CCTL_IRAMOFF	0x00000020
+
+#define CCTL_IMEMFILL4 	0x00000010
+#define CCTL_IMEMOFF	0x00000020
+#define CCTL_DWB		0x00000100
+#define CCTL_DWBINVAL	0x00000200
+#define CCTL_DMEMON 	0x00000400
+#define CCTL_DMEMOFF 	0x00000800
+
+/*
  * Coprocessor 1 (FPU) register names
  */
 #define CP1_REVISION   $0
@@ -822,6 +843,10 @@ do {									\
 	local_irq_restore(__flags);					\
 } while (0)
 
+/* TrendChip cache control register */
+#define read_c0_cctl()		__read_32bit_c0_register($20, 0)
+#define write_c0_cctl(val)	__write_32bit_c0_register($20, 0, val)
+
 #define read_c0_index()		__read_32bit_c0_register($0, 0)
 #define write_c0_index(val)	__write_32bit_c0_register($0, 0, val)
 
@@ -1037,12 +1062,18 @@ do {									\
 #define read_c0_taglo()		__read_32bit_c0_register($28, 0)
 #define write_c0_taglo(val)	__write_32bit_c0_register($28, 0, val)
 
+#define read_c0_idatalo()		__read_32bit_c0_register($28, 1)
+#define write_c0_idatalo(val)	__write_32bit_c0_register($28, 1, val)
+
 #define read_c0_dtaglo()	__read_32bit_c0_register($28, 2)
 #define write_c0_dtaglo(val)	__write_32bit_c0_register($28, 2, val)
 
 #define read_c0_taghi()		__read_32bit_c0_register($29, 0)
 #define write_c0_taghi(val)	__write_32bit_c0_register($29, 0, val)
 
+#define read_c0_idatahi()		__read_32bit_c0_register($29, 1)
+#define write_c0_idatahi(val)	__write_32bit_c0_register($29, 1, val)
+
 #define read_c0_errorepc()	__read_ulong_c0_register($30, 0)
 #define write_c0_errorepc(val)	__write_ulong_c0_register($30, 0, val)
 
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/module.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/module.h
--- linux-2.6.36/arch/mips/include/asm/module.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/module.h	2019-03-07 03:40:17.000000000 +0200
@@ -84,6 +84,8 @@ search_module_dbetables(unsigned long ad
 #define MODULE_PROC_FAMILY "MIPS64_R2 "
 #elif defined CONFIG_CPU_R3000
 #define MODULE_PROC_FAMILY "R3000 "
+#elif defined CONFIG_CPU_TC3162
+#define MODULE_PROC_FAMILY "TC3162 "
 #elif defined CONFIG_CPU_TX39XX
 #define MODULE_PROC_FAMILY "TX39XX "
 #elif defined CONFIG_CPU_VR41XX
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/pgtable-32.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/pgtable-32.h
--- linux-2.6.36/arch/mips/include/asm/pgtable-32.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/pgtable-32.h	2019-03-07 03:40:17.000000000 +0200
@@ -159,7 +159,7 @@ pfn_pte(unsigned long pfn, pgprot_t prot
 #define pte_unmap(pte) ((void)(pte))
 #define pte_unmap_nested(pte) ((void)(pte))
 
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 
 /* Swap entries must have VALID bit cleared. */
 #define __swp_type(x)		(((x).val >> 10) & 0x1f)
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/pgtable-bits.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/pgtable-bits.h
--- linux-2.6.36/arch/mips/include/asm/pgtable-bits.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/pgtable-bits.h	2019-03-07 03:40:17.000000000 +0200
@@ -50,7 +50,7 @@
 #define _CACHE_SHIFT                3
 #define _CACHE_MASK                 (7<<3)
 
-#elif defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#elif defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 
 #define _PAGE_PRESENT               (1<<0)  /* implemented in software */
 #define _PAGE_READ                  (1<<1)  /* implemented in software */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/pgtable.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/pgtable.h
--- linux-2.6.36/arch/mips/include/asm/pgtable.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/pgtable.h	2019-03-07 03:40:17.000000000 +0200
@@ -146,7 +146,7 @@ static inline void pte_clear(struct mm_s
 static inline void set_pte(pte_t *ptep, pte_t pteval)
 {
 	*ptep = pteval;
-#if !defined(CONFIG_CPU_R3000) && !defined(CONFIG_CPU_TX39XX)
+#if !defined(CONFIG_CPU_R3000) && !defined(CONFIG_CPU_TX39XX) && !defined(CONFIG_CPU_TC3162)
 	if (pte_val(pteval) & _PAGE_GLOBAL) {
 		pte_t *buddy = ptep_buddy(ptep);
 		/*
@@ -162,7 +162,7 @@ static inline void set_pte(pte_t *ptep,
 
 static inline void pte_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
 {
-#if !defined(CONFIG_CPU_R3000) && !defined(CONFIG_CPU_TX39XX)
+#if !defined(CONFIG_CPU_R3000) && !defined(CONFIG_CPU_TX39XX) && !defined(CONFIG_CPU_TC3162)
 	/* Preserve global status for the pair */
 	if (pte_val(*ptep_buddy(ptep)) & _PAGE_GLOBAL)
 		set_pte_at(mm, addr, ptep, __pte(_PAGE_GLOBAL));
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/processor.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/processor.h
--- linux-2.6.36/arch/mips/include/asm/processor.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/processor.h	2019-03-07 03:40:17.000000000 +0200
@@ -118,11 +118,15 @@ struct mips_dsp_state {
 	dspreg_t        dspr[NUM_DSP_REGS];
 	unsigned int    dspcontrol;
 };
-
+#ifdef TCSUPPORT_XPON_HAL_API_EXT
+#define INIT_CPUMASK { \
+	{7,} \
+}
+#else
 #define INIT_CPUMASK { \
 	{0,} \
 }
-
+#endif
 struct mips3264_watch_reg_state {
 	/* The width of watchlo is 32 in a 32 bit kernel and 64 in a
 	   64 bit kernel.  We use unsigned long as it has the same
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/spram.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/spram.h
--- linux-2.6.36/arch/mips/include/asm/spram.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/spram.h	2019-03-07 03:40:17.000000000 +0200
@@ -7,4 +7,8 @@ extern __init void spram_config(void);
 static inline void spram_config(void) { };
 #endif /* CONFIG_CPU_MIPSR2 */
 
+extern int is_sram_addr(void *p);
+extern void *alloc_sram(int n);
+extern void free_sram(void *p, int n);
+
 #endif /* _MIPS_SPRAM_H */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/stackframe.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/stackframe.h
--- linux-2.6.36/arch/mips/include/asm/stackframe.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/stackframe.h	2019-03-07 03:40:17.000000000 +0200
@@ -24,7 +24,7 @@
  */
 #ifdef CONFIG_MIPS_MT_SMTC
 #define STATMASK 0x1e
-#elif defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#elif defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 #define STATMASK 0x3f
 #else
 #define STATMASK 0x1f
@@ -187,8 +187,6 @@
 		 * need it to operate correctly
 		 */
 		LONG_S	$0, PT_R0(sp)
-		mfc0	v1, CP0_STATUS
-		LONG_S	$2, PT_R2(sp)
 #ifdef CONFIG_MIPS_MT_SMTC
 		/*
 		 * Ideally, these instructions would be shuffled in
@@ -199,6 +197,8 @@
 		.set	mips0
 		LONG_S	v1, PT_TCSTATUS(sp)
 #endif /* CONFIG_MIPS_MT_SMTC */
+		mfc0	v1, CP0_STATUS
+		LONG_S	$2, PT_R2(sp)
 		LONG_S	$4, PT_R4(sp)
 		LONG_S	$5, PT_R5(sp)
 		LONG_S	v1, PT_STATUS(sp)
@@ -286,7 +286,7 @@
 		LONG_L	$30, PT_R30(sp)
 		.endm
 
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 
 		.macro	RESTORE_SOME
 		.set	push
@@ -386,6 +386,7 @@
 		andi	v1, TCSTATUS_IXMT
 		bnez	v1, 0f
 
+//#ifndef CONFIG_MIPS_TC3262
 /*
  * We'd like to detect any IPIs queued in the tiny window
  * above and request an software interrupt to service them
@@ -408,6 +409,8 @@
 		mfc0	v0, CP0_CAUSE
 		ori	v0, v0, C_SW1
 		mtc0	v0, CP0_CAUSE
+//#endif
+
 0:
 		/*
 		 * This test should really never branch but
@@ -581,7 +584,7 @@
 #endif /* CONFIG_MIPS_MT_SMTC */
 		mfc0	t0, CP0_STATUS
 		li	t1, ST0_CU0 | (STATMASK & ~1)
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 		andi	t2, t0, ST0_IEP
 		srl	t2, 2
 		or	t0, t2
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/string.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/string.h
--- linux-2.6.36/arch/mips/include/asm/string.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/string.h	2019-03-07 03:40:17.000000000 +0200
@@ -84,7 +84,7 @@ static __inline__ int strcmp(__const__ c
 	"addiu\t%1,1\n\t"
 	"bnez\t%2,1b\n\t"
 	"lbu\t%2,(%0)\n\t"
-#if defined(CONFIG_CPU_R3000)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TC3162)
 	"nop\n\t"
 #endif
 	"move\t%2,$1\n"
@@ -117,7 +117,7 @@ strncmp(__const__ char *__cs, __const__
 	"bnez\t%3,1b\n\t"
 	"addiu\t%1,1\n"
 	"2:\n\t"
-#if defined(CONFIG_CPU_R3000)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TC3162)
 	"nop\n\t"
 #endif
 	"move\t%3,$1\n"
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/tc3162/cmdparse.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/cmdparse.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/cmdparse.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/cmdparse.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,32 @@
+#ifndef _CMDPARSE_H_
+#define _CMDPARSE_H_
+/************************************************************************
+ *
+ *	Copyright (C) 2006 Trendchip Technologies, Corp.
+ *	All Rights Reserved.
+ *
+ * Trendchip Confidential; Need to Know only.
+ * Protected as an unpublished work.
+ *
+ * The computer program listings, specifications and documentation
+ * herein are the property of Trendchip Technologies, Co. and shall
+ * not be reproduced, copied, disclosed, or used in whole or in part
+ * for any reason without the prior express written permission of
+ * Trendchip Technologeis, Co.
+ *
+ *************************************************************************/
+
+typedef	struct {
+	char *name;		
+	int	(*func)(int argc,char *argv[],void *p);
+	int	flags;	
+	int	argcmin;
+	char *argc_errmsg;	
+} cmds_t;
+
+extern int cmd_reg_add(char *cmd_name, cmds_t *cmds_p);
+extern int cmd_register(cmds_t *cmds_p);
+extern int cmd_unregister(char *name);
+extern int subcmd(const cmds_t tab[], int argc, char *argv[], void *p);
+
+#endif /* _CMDPARSE_ */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/tc3162/cpu-feature-overrides.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/cpu-feature-overrides.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/cpu-feature-overrides.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/cpu-feature-overrides.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,68 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003, 2004 Chris Dearman
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
+ */
+#ifndef __ASM_MACH_RALINK_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_RALINK_CPU_FEATURE_OVERRIDES_H
+
+
+/*
+ * CPU feature overrides for MIPS boards
+ */
+#ifdef CONFIG_CPU_MIPS32
+#define cpu_has_tlb		1
+#define cpu_has_4kex		1
+#define cpu_has_4k_cache	1
+/* #define cpu_has_fpu		? */
+/* #define cpu_has_32fpr	? */
+#define cpu_has_counter		1
+/* #define cpu_has_watch	? */
+#define cpu_has_divec		1
+#define cpu_has_vce		0
+/* #define cpu_has_cache_cdex_p	? */
+/* #define cpu_has_cache_cdex_s	? */
+/* #define cpu_has_prefetch	? */
+#define cpu_has_mcheck		1
+/* #define cpu_has_ejtag	? */
+#define cpu_has_llsc		1
+/* #define cpu_has_vtag_icache	? */
+/* #define cpu_has_dc_aliases	? */
+/* #define cpu_has_ic_fills_f_dc ? */
+#define cpu_has_nofpuex		0
+/* #define cpu_has_64bits	? */
+/* #define cpu_has_64bit_zero_reg ? */
+/* #define cpu_has_inclusive_pcaches ? */
+#define cpu_icache_snoops_remote_store 1
+#endif
+
+#ifdef CONFIG_CPU_MIPS64
+#define cpu_has_tlb		1
+#define cpu_has_4kex		1
+#define cpu_has_4k_cache	1
+/* #define cpu_has_fpu		? */
+/* #define cpu_has_32fpr	? */
+#define cpu_has_counter		1
+/* #define cpu_has_watch	? */
+#define cpu_has_divec		1
+#define cpu_has_vce		0
+/* #define cpu_has_cache_cdex_p	? */
+/* #define cpu_has_cache_cdex_s	? */
+/* #define cpu_has_prefetch	? */
+#define cpu_has_mcheck		1
+/* #define cpu_has_ejtag	? */
+#define cpu_has_llsc		1
+/* #define cpu_has_vtag_icache	? */
+/* #define cpu_has_dc_aliases	? */
+/* #define cpu_has_ic_fills_f_dc ? */
+#define cpu_has_nofpuex		0
+/* #define cpu_has_64bits	? */
+/* #define cpu_has_64bit_zero_reg ? */
+/* #define cpu_has_inclusive_pcaches ? */
+#define cpu_icache_snoops_remote_store 1
+#endif
+
+#endif /* __ASM_MACH_MIPS_CPU_FEATURE_OVERRIDES_H */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/tc3162/int_source.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/int_source.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/int_source.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/int_source.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,101 @@
+/************************************************************************
+ *
+ *	Copyright (C) 2006 Trendchip Technologies, Corp.
+ *	All Rights Reserved.
+ *
+ * Trendchip Confidential; Need to Know only.
+ * Protected as an unpublished work.
+ *
+ * The computer program listings, specifications and documentation
+ * herein are the property of Trendchip Technologies, Co. and shall
+ * not be reproduced, copied, disclosed, or used in whole or in part
+ * for any reason without the prior express written permission of
+ * Trendchip Technologeis, Co.
+ *
+ *************************************************************************/
+
+#ifndef _INT_SOURCE_H_
+#define _INT_SOURCE_H_
+
+enum
+interrupt_source
+	{
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		DUMMY_INT,
+#endif
+		UART_INT,		//0 	IPL10
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		PTM_B0_INT,		//1
+		SI_SWINT1_INT0,	//2
+		SI_SWINT1_INT1,	//3
+#else
+		RTC_ALARM_INT,	//1 	IPL29
+		RTC_TICK_INT,	//2 	IPL31
+		RESERVED0,		//3 	IPL30
+#endif
+		TIMER0_INT, 	//4 	IPL1
+		TIMER1_INT, 	//5 	IPL5
+		TIMER2_INT, 	//6 	IPL6
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		SI_SWINT_INT0, 	//7
+		SI_SWINT_INT1, 	//8
+#else
+		TIMER3_INT, 	//7 	IPL7
+		TIMER4_INT, 	//8 	IPL8
+#endif
+		TIMER5_INT, 	//9 	IPL9
+		GPIO_INT,		//10	IPL11
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		RESERVED1,		//11	IPL20
+		SI_PC1_INT, 	//12
+		SI_PC_INT, 		//13
+#else
+		PCIE_A_INT,		//11	IPL20
+		PCIE_SERR_INT,	//12	IPL21
+		RESERVED3,		//13	IPL22
+#endif
+		APB_DMA0_INT,	//14	IPL12
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		MAC1_INT,		//15	IPL13
+#else
+		APB_DMA1_INT,	//15	IPL13
+#endif
+		HSUART_INT,		//16	IPL23
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+
+		PTM_B1_INT,		//17
+#else
+		RESERVED5,		//17	IPL24
+#endif
+		DYINGGASP_INT,	//18	IPL25
+		DMT_INT,		//19	IPL26
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		USB20_INT,
+#else
+		ARBITER_ERR_INT,//20	IPL0
+#endif
+		MAC_INT,		//21	IPL3
+		SAR_INT,		//22	IPL2
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		USB11_INT,
+#else
+		USB_INT,		//23	IPL14
+#endif
+		PCI_A_INT,		//24
+		PCI_B_INT,		//25
+//		  RESERVED8,	  //24	  IPL27
+//		  RESERVED9,	  //25	  IPL28
+		XSLV0_INT,		//26	IPL15
+		XSLV1_INT,		//27	IPL16
+		XSLV2_INT,		//28	IPL17
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		SI_TIMER1_INT,	//29
+		SI_TIMER_INT,	//30
+#else
+		XAPB0_INT,		//29	IPL18
+		XAPB1_INT,		//30	IPL19
+#endif
+		SWR_INT 		//31	IPL4
+	};
+
+#endif /* _INT_SOURCE_H_ */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/tc3162/irq.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/irq.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/irq.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/irq.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,13 @@
+#ifndef __ASM_MACH_MIPS_IRQ_H
+#define __ASM_MACH_MIPS_IRQ_H
+
+
+#ifdef CONFIG_MIPS_TC3262
+#define NR_IRQS 64
+#else
+#define NR_IRQS 32
+#endif
+
+#include_next <irq.h>
+
+#endif /* __ASM_MACH_MIPS_IRQ_H */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/tc3162/kprofile_hook.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/kprofile_hook.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/kprofile_hook.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/kprofile_hook.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,42 @@
+#ifndef __KPROFILE_HOOK_H
+#define __KPROFILE_HOOK_H
+
+extern void (*profilingSetupHook)(unsigned int tbl_size);
+extern void (*profilingEventHook)(unsigned int cntr, unsigned int event, unsigned int count, 
+						unsigned int kernel, unsigned int user, unsigned int exl);
+extern void (*profilingStartHook)(void);
+extern void (*profilingStopHook)(void);
+extern void (*profilingLogHook)(unsigned int label, unsigned int usr_data);
+
+static inline void kprofileSetup(unsigned int tbl_size)
+{
+	if (profilingSetupHook)
+		profilingSetupHook(tbl_size);
+}
+
+static inline void kprofileEvent(unsigned int cntr, unsigned int event, unsigned int count, 
+						unsigned int kernel, unsigned int user, unsigned int exl)
+{
+	if (profilingEventHook)
+		profilingEventHook(cntr, event, count, kernel, user, exl);
+}
+
+static inline void kprofileStart(void)
+{
+	if (profilingStartHook)
+		profilingStartHook();
+}
+
+static inline void kprofileStop(void)
+{
+	if (profilingStopHook)
+		profilingStopHook();
+}
+
+static inline void kprofileLog(unsigned int label, unsigned int usr_data)
+{
+	if (profilingLogHook)
+		profilingLogHook(label, usr_data);
+}
+
+#endif
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/tc3162/ledcetrl.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/ledcetrl.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/ledcetrl.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/ledcetrl.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,352 @@
+/*
+** $Id: ledcetrl.h,v 1.4 2011/01/07 04:05:20 pork Exp $
+*/
+/************************************************************************
+ *
+ *	Copyright (C) 2006 Trendchip Technologies, Corp.
+ *	All Rights Reserved.
+ *
+ * Trendchip Confidential; Need to Know only.
+ * Protected as an unpublished work.
+ *
+ * The computer program listings, specifications and documentation
+ * herein are the property of Trendchip Technologies, Co. and shall
+ * not be reproduced, copied, disclosed, or used in whole or in part
+ * for any reason without the prior express written permission of
+ * Trendchip Technologeis, Co.
+ *
+ *************************************************************************/
+/*
+** $Log: ledcetrl.h,v $
+** Revision 1.4  2011/01/07 04:05:20  pork
+** commit TDI layer with Zarlink 2S1O
+**
+** Revision 1.3  2010/10/15 05:02:10  xmdai_nj
+** #7017:add function for wlan button(main trunk)
+**
+** Revision 1.2  2010/06/11 00:31:06  xhshi
+** #5964 support dare's new led and key requests
+**
+** Revision 1.1.1.1  2010/04/09 09:39:21  feiyan
+** New TC Linux Make Flow Trunk
+**
+** Revision 1.3  2010/03/22 14:15:16  yzwang_nj
+** [Bug#5128] Implement TR068 LED
+**
+** Revision 1.2  2010/03/19 07:16:59  xyyou
+** # 5213 Add  RT3390 11n Webpage
+** Support RT3390 AutoChannel feature
+** Support RT3390 WMM feature
+** # 5214 Support RT3390 wps feature
+**      Add wps led spec&not spec
+**
+** Revision 1.1.1.1  2009/12/17 01:42:47  josephxu
+** 20091217, from Hinchu ,with VoIP
+**
+** Revision 1.1.1.1  2007/04/12 09:42:03  ian
+** TCLinuxTurnkey2007
+**
+** Revision 1.2  2006/07/06 07:24:57  lino
+** update copyright year
+**
+** Revision 1.1.1.1  2005/11/02 05:45:38  lino
+** no message
+**
+** Revision 1.3  2004/10/12 08:33:45  lino
+** add 10M/100M ethernet led define
+**
+*/
+
+#ifndef _LEDCETRL_H
+#define _LEDCETRL_H
+
+/*__________________________________________________________________________
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%%      constant definition
+%%________________________________________________________________________*/
+
+
+
+#ifdef TCSUPPORT_GPIO_ECM
+#define LED_TYPE_MAX_NO		16
+	//define led flash peroid parameter
+#define MAX_LED_FLASH_PERIOD		128
+#define LED_FLASH_PERIOD_LOW		1
+#define LED_FLASH_PERIOD_HIGH		0
+#define MAX_LED_FLASH_MAP			8
+	//define serial gpio control status
+#define SLED_STATUS_REDAY			0x1<<31
+	// define led interface type
+#define LED_SERIAL					1
+#define LED_PARALLEL				0
+#endif
+
+#ifdef TCSUPPORT_USB_HOST_LED
+#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7505)
+#define USBPHYPORT1 1
+#define USBPHYPORT2 2
+
+#define USB_DISCONNECT 1
+#define USB_CONNECT 2
+#define USB_BLINK 3
+#define USB_DEFAULT 4
+#endif
+#endif
+
+#ifdef TCSUPPORT_WLAN_LED_BY_SW
+#define WLAN_DISCONNECT 0
+#define WLAN_CONNECT 1
+#define WLAN_BLINK 2
+#define WLAN_DEFAULT 3
+#endif
+// define led mode
+#define LED_MODE_NOT_USED			0
+#define LED_MODE_ONOFF				1
+#define LED_MODE_BLINK				2
+#define LED_MODE_NOACT				3
+#define LED_MODE_PULSE				4
+/*20090811pork modified: add for sys reset gpio*/
+#define LED_MODE_INPUT				5
+#define LED_MODE_BLINKING			6	/* working when gpio led on */
+#define LED_MODE_FLASH				7	/* working when gpio led on */
+#define LED_MODE_MASK				0xf
+#define LED_MODE_BICOLOR			0x10
+
+// define led blink speed
+#define LED_SPEED_FAST				0
+#define LED_SPEED_MED				1
+#define LED_SPEED_SLOW				2
+#define LED_SPEED_VERY_SLOW			3
+#ifdef TCSUPPORT_WLAN_LED_BY_SW
+#define LED_SPEED_FASTEST			4
+#endif
+
+/*Add by YuChuwei, For PV-W422T-1200ACG. To stop LED Blink*/
+#define LED_SPEED_STOP	(LED_SPEED_FAST + 10)
+#define LED_SPEED_BLINK_STOP (LED_SPEED_FAST + 5)
+
+// define software led no
+#define LED_BASE 					0
+
+#define LED_DSL_STATUS				(LED_BASE + 0)
+#define LED_DSL_ACT_STATUS			(LED_BASE + 1)
+#define LED_DSL_NOACT_STATUS		(LED_BASE + 2)
+#define LED_DSL_IDLE_STATUS			(LED_BASE + 3)
+#define LED_DSL_HANDSHAKE_STATUS	(LED_BASE + 4)
+#define LED_DSL_TRAINING_STATUS		(LED_BASE + 5)
+#define LED_DSL_SHOWTIME_STATUS		(LED_BASE + 6)
+
+#define LED_PPP_STATUS				(LED_BASE + 7)
+#define LED_PPP_ACT_STATUS			(LED_BASE + 8)
+#define LED_PPP_NOACT_STATUS		(LED_BASE + 9)
+
+#define LED_USB_STATUS				(LED_BASE + 10)
+#define LED_USB_ACT_STATUS			(LED_BASE + 11)
+#define LED_USB_NOACT_STATUS		(LED_BASE + 12)
+
+#define LED_WLAN_STATUS				(LED_BASE + 13)
+#define LED_WLAN_ACT_STATUS			(LED_BASE + 14)
+#define LED_WLAN_NOACT_STATUS		(LED_BASE + 15)
+
+#define LED_ETHER_STATUS			(LED_BASE + 16)
+#define LED_ETHER_ACT_STATUS		(LED_BASE + 17)
+#define LED_ETHER_NOACT_STATUS		(LED_BASE + 18)
+
+#define LED_FLASH_STATUS			(LED_BASE + 19)
+#define LED_SYS_BOOT_STATUS			(LED_BASE + 20)
+#define LED_SYS_STATUS				(LED_BASE + 21)
+#define LED_SYS_INIT_STATUS			(LED_BASE + 22)
+
+#define LED_ETHER_10M_STATUS		(LED_BASE + 23)
+#define LED_ETHER_10M_ACT_STATUS	(LED_BASE + 24)
+#define LED_ETHER_10M_NOACT_STATUS	(LED_BASE + 25)
+
+#define LED_ETHER_100M_STATUS		(LED_BASE + 26)
+#define LED_ETHER_100M_ACT_STATUS	(LED_BASE + 27)
+#define LED_ETHER_100M_NOACT_STATUS	(LED_BASE + 28)
+
+#define LED_SIM_CFG_STATUS	(LED_BASE + 29)
+/*add by xjt for PV-W42T-1200ACG,2016-06-30*/
+/*LED_SIM_CFG_STATUS is unused,now use it for vdsl showtime led onoff*/
+#define LED_VDSL_SHOWTIME_STATUS	LED_SIM_CFG_STATUS
+/*end add xjt*/
+#define LED_SIM_CFG_ACT_STATUS	(LED_BASE + 30)
+
+#define LED_LAN_RESET				(LED_BASE + 31)
+//add for TR068 compliance
+#define LED_INTERNET_STATUS		(LED_BASE + 33)
+#define LED_INTERNET_ACT_STATUS		(LED_BASE + 34)
+#define LED_INTERNET_NOACT_STATUS	(LED_BASE + 35)
+#define LED_INTERNET_STATUS_TP		(LED_BASE + 36)
+#define LED_INTERNET_TRYING_STATUS	(LED_BASE + 38)
+#define LED_TR68_PWR_BOOTING		(LED_BASE + 40)
+#define LED_TR68_PWR_BOOTED		(LED_BASE + 41)
+#define LED_PHY_TX_POWER_DISABLE		(LED_BASE + 42)
+#define LED_WLAN_WPS_STATUS		(LED_BASE + 43)
+#define LED_WLAN_WPS_ACT_STATUS	(LED_BASE + 44)
+#define LED_WLAN_WPS_NOACT_STATUS	(LED_BASE + 45)
+
+#define LED_VOIP_SLIC1_RESET (LED_BASE + 46)
+#define LED_VOIP_SLIC2_RESET (LED_BASE + 47)
+#define LED_DSL_ALARM (LED_BASE + 48)
+#define LED_VOIP_HOOK1_STATUS (LED_BASE + 49)
+#define LED_VOIP_HOOK2_STATUS (LED_BASE + 50)
+
+/*Modify by  YuChuwei.For PV-W422T-1200ACGv1*/
+#if 0
+#define LED_SIM_STATUS	(LED_BASE + 51)
+#define LED_SIM_ACT_STATUS	(LED_BASE + 52)
+#define LED_SIM_NOACT_STATUS	(LED_BASE + 53)
+#else
+#define LED_VOIP_USBVM1_STATUS (LED_BASE + 51)
+#define LED_VOIP_USBVM2_STATUS (LED_BASE + 52)
+#endif
+
+/* Modified by Zhao Mengqing, 2016-8-3, always define LED_USB2_STATUS & LED_USB2_ACT_STATUS */
+//#ifdef TCSUPPORT_USB_HOST_LED
+//#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7505)
+#define LED_USB2_STATUS				(LED_BASE + 54)
+#define LED_USB2_ACT_STATUS			(LED_BASE + 55)
+//#endif
+//#endif
+
+#define GPIO_SYS_RESET				(LED_BASE + 56)
+
+#define LED_WLAN_RADIO                 	(LED_BASE + 57) 
+#define GPIO_WLAN_WPS				(LED_BASE + 58)
+
+//add by brian for gpio additional request
+#define LED_PWR_FLASH				(LED_BASE + 59)
+
+
+#define LED_PWR_USB				(LED_BASE + 61)
+
+#define LED_LED_SWITCH                          (LED_BASE + 62)
+
+/*20090811 pork added: fit for linos LED setting*/
+#define LED_LAN1_RESET				(LED_BASE + 63)
+
+#ifdef TCSUPPORT_XPON_LED
+#define LED_XPON_STATUS				(LED_BASE + 64)
+#define LED_XPON_TRYING_STATUS		(LED_BASE + 65)
+
+#define LED_XPON_LOS_ON_STATUS		(LED_BASE + 66)
+#define LED_XPON_LOS_STATUS			(LED_BASE + 67)
+
+#define LED_ETHER_PORT1_STATUS			(LED_BASE + 68)
+#define LED_ETHER_PORT1_ACT_STATUS	(LED_BASE + 69)
+#define LED_ETHER_PORT2_STATUS			(LED_BASE + 70)
+#define LED_ETHER_PORT2_ACT_STATUS	(LED_BASE + 71)
+#define LED_ETHER_PORT3_STATUS			(LED_BASE + 72)
+#define LED_ETHER_PORT3_ACT_STATUS	(LED_BASE + 73)
+#define LED_ETHER_PORT4_STATUS			(LED_BASE + 74)
+#define LED_ETHER_PORT4_ACT_STATUS	(LED_BASE + 75)
+#endif
+
+#define LED_VOIP_REG_STATUS	(LED_BASE + 101)
+#define LED_PHY_VCC_DISABLE		(LED_BASE + 102)
+#define LED_WLAN_2_4G_STATUS		(LED_BASE + 103)
+#define LED_WLAN_5G_STATUS		(LED_BASE + 104)
+
+#define LED_ETH_LAN1		(LED_BASE + 105)
+#define LED_ETH_LAN2		(LED_BASE + 106)
+#define LED_ETH_LAN3		(LED_BASE + 107)
+#define LED_ETH_LAN4		(LED_BASE + 108)
+#define LED_ETH_WAN			(LED_BASE + 109)
+
+/* 49与51, 50与53应该是同样的用途?yuanshang,2012-06-21 */
+//#define LED_VOIP_FXS1_HOOK_STATUS (LED_BASE + 76)
+//#define LED_VOIP_FXS1_RING_STATUS (LED_BASE + 77)
+#define LED_VOIP_FXS2_HOOK_STATUS (LED_BASE + 78)
+#define LED_VOIP_FXS2_RING_STATUS (LED_BASE + 79)
+#define LED_VOIP_FXO_HOOK_STATUS  (LED_BASE + 80)
+#define LED_VOIP_FXO_RING_STATUS  (LED_BASE + 81)
+
+#define mtkled_read_reg_word(reg) 			regRead32(reg)
+#define mtkled_write_reg_word(reg, wdata) 	regWrite32(reg, wdata)
+/*__________________________________________________________________________
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%%      function declaration
+%%________________________________________________________________________*/
+
+void ledInit(void);
+void ledSysInitOn(void);
+void ledSysInitOff(void);
+void ledTurnOn(uint8 led_no);
+void ledTurnOff(uint8 led_no);
+uint8 ledGetMode(uint8 led_no);
+void ledSetMode(uint8 led_no, uint8 mode);
+void ledSetSpeed(uint8 led_no, uint8 speed);
+uint8 ledGetGpio(uint8 led_no);
+void led_oen(uint8 led_no);
+void led_ien(uint8 led_no);
+//#define ledTurnOn(led_no)
+//#define ledTurnOff(led_no)
+int exModeMDIOGpioConf(uint8 mdc_gpio_num,uint8  mdio_gpio_num);
+void exModeMDIOGpioQuery(uint8 * mdc_gpio_num,uint8 * mdio_gpio_num);
+uint32 exModeMDIORead(uint32 reg);
+void exModeMDIOWrite(uint32 reg, uint32 data);
+
+void ledMtnInit(void);
+
+int	ledTaskInit(void);
+void ledTask(void);
+
+#ifdef TCSUPPORT_XPON_HAL_API_EXT
+/* get the ctrl value of gpio num x */
+#define MTK_LED_GET_GPIO_CTRL(x) ((x>31)?(regRead32(CR_GPIO_CTRL1)&(1<<(x-32))):(regRead32(CR_GPIO_CTRL)&(1<<x)))
+/* get the data value of gpio num x */
+#define MTK_LED_GET_GPIO_DATA(x) ((x>31)?(regRead32(CR_GPIO_DATA1)&(1<<(x-32))):(regRead32(CR_GPIO_DATA)&(1<<x)))
+/* gpio num x to write value 1 */
+#define MTK_DO_LED_OFF(x) do {								\
+								if(x > 31){					\
+									regWrite32(CR_GPIO_DATA1,regRead32(CR_GPIO_DATA1)|(1<<(x-32)));	\
+								}else{						\
+									regWrite32(CR_GPIO_DATA,regRead32(CR_GPIO_DATA)|(1<<x));	\
+								}						\
+							} while (0)
+/* gpio num x to write value 0 */
+#define MTK_DO_LED_ON(x) do {								\
+								if(x > 31){ 				\
+									regWrite32(CR_GPIO_DATA1,regRead32(CR_GPIO_DATA1)& ~(1<<(x-32)));	\
+								}else{						\
+									regWrite32(CR_GPIO_DATA,regRead32(CR_GPIO_DATA)& ~(1<<x));	\
+								}						\
+							} while (0)
+/* gpio num x set to ouput enable */
+#define MTK_LED_OEN(x)		do { 	\
+							if(x > 31){ 						\
+								if(x > 47){ 					\
+									regWrite32(CR_GPIO_CTRL3,regRead32(CR_GPIO_CTRL3)|(1<<((x-48)*2))); \
+								}else{							\
+									regWrite32(CR_GPIO_CTRL2,regRead32(CR_GPIO_CTRL2)|(1<<((x-32)*2))); \
+								}								\
+								regWrite32(CR_GPIO_ODRAIN1,regRead32(CR_GPIO_ODRAIN1)|(1<<(x-32))); \
+							}else{								\
+								if(x > 15){ 					\
+									regWrite32(CR_GPIO_CTRL1,regRead32(CR_GPIO_CTRL1)|(1<<((x-16)*2))); \
+								}else{							\
+									regWrite32(CR_GPIO_CTRL,regRead32(CR_GPIO_CTRL)|(1<<(x*2)));	\
+								}								\
+								regWrite32(CR_GPIO_ODRAIN,regRead32(CR_GPIO_ODRAIN)|(1<<(x)));	\
+							}\
+						} while(0)
+/* gpio num x set to input enable */
+#define MTK_LED_IEN(x)		do { 	\
+							if(x > 31){ 						\
+								if(x > 47)						\
+									regWrite32(CR_GPIO_CTRL3,regRead32(CR_GPIO_CTRL3)&~(0x00000003 << ((x-48)* 2)));	\
+								else							\
+									regWrite32(CR_GPIO_CTRL2,regRead32(CR_GPIO_CTRL2)&~(0x00000003 << ((x-32)* 2)));	\
+								regWrite32(CR_GPIO_ODRAIN1,regRead32(CR_GPIO_ODRAIN1)&~(0x00000001 << (x-32))); \
+							}else{								\
+								if(x > 15)						\
+									regWrite32(CR_GPIO_CTRL1,regRead32(CR_GPIO_CTRL1)&~(0x00000003 << ((x-16)* 2)));	\
+								else							\
+									regWrite32(CR_GPIO_CTRL,regRead32(CR_GPIO_CTRL)&~(0x00000003 << (x* 2)));	\
+								regWrite32(CR_GPIO_ODRAIN,regRead32(CR_GPIO_ODRAIN)&~(0x00000001 << x));	\
+							}									\
+					} while(0)
+
+#endif
+#endif
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/tc3162/tc3162.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/tc3162.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/tc3162.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/tc3162.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,1329 @@
+/*
+** $Id: tc3162.h,v 1.7 2011/01/07 06:05:58 pork Exp $
+*/
+/************************************************************************
+ *
+ *	Copyright (C) 2006 Trendchip Technologies, Corp.
+ *	All Rights Reserved.
+ *
+ * Trendchip Confidential; Need to Know only.
+ * Protected as an unpublished work.
+ *
+ * The computer program listings, specifications and documentation
+ * herein are the property of Trendchip Technologies, Co. and shall
+ * not be reproduced, copied, disclosed, or used in whole or in part
+ * for any reason without the prior express written permission of
+ * Trendchip Technologeis, Co.
+ *
+ *************************************************************************/
+/*
+** $Log: tc3162.h,v $
+** Revision 1.7  2011/01/07 06:05:58  pork
+** add the definition of INT!16,INT32,SINT15,SINT7
+**
+** Revision 1.6  2010/09/20 07:08:02  shnwind
+** decrease nf_conntrack buffer size
+**
+** Revision 1.5  2010/09/03 16:43:07  here
+** [Ehance] TC3182 GMAC Driver is support TC-Console & WAN2LAN function & update the tc3182 dmt version (3.12.8.83)
+**
+** Revision 1.4  2010/09/02 07:04:50  here
+** [Ehance] Support TC3162U/TC3182 Auto-Bench
+**
+** Revision 1.3  2010/08/30 07:53:02  lino
+** add power saving mode kernel module support
+**
+** Revision 1.2  2010/06/05 05:40:29  lino
+** add tc3182 asic board support
+**
+** Revision 1.1.1.1  2010/04/09 09:39:21  feiyan
+** New TC Linux Make Flow Trunk
+**
+** Revision 1.4  2010/01/14 10:56:42  shnwind
+** recommit
+**
+** Revision 1.3  2010/01/14 08:00:10  shnwind
+** add TC3182 support
+**
+** Revision 1.2  2010/01/10 15:27:26  here
+** [Ehancement]TC3162U MAC EEE is operated at 100M-FD, SAR interface is accroding the SAR_CLK to calculate atm rate.
+**
+** Revision 1.1.1.1  2009/12/17 01:42:47  josephxu
+** 20091217, from Hinchu ,with VoIP
+**
+** Revision 1.2  2006/07/06 07:24:57  lino
+** update copyright year
+**
+** Revision 1.1.1.1  2005/11/02 05:45:38  lino
+** no message
+**
+** Revision 1.5  2005/09/27 08:01:38  bread.hsu
+** adding IMEM support for Tc3162L2
+**
+** Revision 1.4  2005/09/14 11:06:20  bread.hsu
+** new definition for TC3162L2
+**
+** Revision 1.3  2005/06/17 16:26:16  jasonlin
+** Remove redundant code to gain extra 100K bytes free memory.
+** Add "CODE_REDUCTION" definition to switch
+**
+** Revision 1.2  2005/06/14 10:02:01  jasonlin
+** Merge TC3162L2 source code into new main trunk
+**
+** Revision 1.1.1.1  2005/03/30 14:04:22  jasonlin
+** Import Linos source code
+**
+** Revision 1.4  2004/11/15 03:43:17  lino
+** rename ATM SAR max packet length register
+**
+** Revision 1.3  2004/09/01 13:15:47  lino
+** fixed when pc shutdown, system will reboot
+**
+** Revision 1.2  2004/08/27 12:16:37  lino
+** change SYS_HCLK to 96Mhz
+**
+** Revision 1.1  2004/07/02 08:03:04  lino
+** tc3160 and tc3162 code merge
+**
+*/
+
+#ifndef _TC3162_H_
+#define _TC3162_H_
+
+#ifdef CONFIG_MIPS_TC3262 
+#include "./tc3182_int_source.h"
+#else
+#include "./int_source.h" /*shnwind add*/
+#endif
+
+
+#ifndef INT32
+#define INT32
+typedef signed long int int32;    		/* 32-bit signed integer        */
+#endif
+
+#ifndef SINT31
+#define SINT31
+typedef signed long int sint31;        	/* 32-bit signed integer        */
+#endif
+
+#ifndef UINT32
+#define UINT32
+typedef unsigned long int uint32; 		/* 32-bit unsigned integer      */
+#endif
+
+#ifndef SINT15
+#define SINT15
+typedef signed short sint15;            /* 16-bit signed integer        */
+#endif
+
+#ifndef INT16
+#define INT16
+typedef signed short int int16;         /* 16-bit signed integer        */
+#endif
+
+#ifndef UINT16
+#define UINT16
+typedef unsigned short uint16;          /* 16-bit unsigned integer      */
+#endif
+
+#ifndef SINT7
+#define SINT7
+typedef signed char sint7;              /* 8-bit signed integer         */
+#endif
+
+
+#ifndef UINT8
+#define UINT8
+typedef unsigned char uint8;            /* 8-bit unsigned integer       */
+#endif
+
+#ifndef VPint
+#define VPint			*(volatile unsigned long int *)
+#endif
+#ifndef VPshort
+#define VPshort			*(volatile unsigned short *)
+#endif
+#ifndef VPchar
+#define VPchar			*(volatile unsigned char *)
+#endif
+#ifdef TCSUPPORT_MT7510_E1
+static inline unsigned long int regRead32(uint32 reg)	\
+{       						\
+	uint32 tmp;					\
+	tmp = VPint((reg & 0xf) + 0xbfb003a0);   	\
+	__asm__ __volatile("sync");			\
+	tmp = VPint(reg);				\
+	__asm__ __volatile("sync");			\
+        return tmp;             	           	\
+}
+static inline void regWrite32(uint32 reg, uint32 vlaue) \
+{                                                       \
+        VPint(reg) = vlaue;                             \
+	__asm__ __volatile("sync");			\
+}
+
+#else
+static inline uint32 regRead32(uint32 reg)		\
+{						  	\
+	return VPint(reg);			  	\
+}		
+static inline void regWrite32(uint32 reg, uint32 vlaue)	\
+{                                                	\
+        VPint(reg) = vlaue;                      	\
+}
+#endif
+static inline unsigned long int regReadPhy32(uint32 reg)	\
+{       						\
+	uint32 tmp;					\
+	tmp = VPint(reg);	  	\
+	tmp = VPint(reg);				\
+        return tmp;             	           	\
+}
+
+#ifdef CONFIG_CPU_TC3162
+#define TC3162L2		1
+#endif
+
+#define isTC3162L2P2 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)!=0)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L3P3 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==7)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L4P4 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==8)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L5P5E2 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==0xa)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L5P5E3 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==0xb)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L5P5 (isTC3162L5P5E2 || isTC3162L5P5E3)
+#define isTC3162U ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==0x10)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isRT63260 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==0x20)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+
+#define isTC3169 	(((regRead32(0xbfb00064)&0xffff0000))==0x00000000)
+#define isTC3182 	(((regRead32(0xbfb00064)&0xffff0000))==0x00010000)
+#define isRT65168 	(((regRead32(0xbfb00064)&0xffff0000))==0x00020000)
+#define isRT63165 	(((regRead32(0xbfb00064)&0xffff0000))==0x00030000)
+#define isRT63365 	(((regRead32(0xbfb00064)&0xffff0000))==0x00040000)
+#define isRT63368   (isRT63365 ? ((((regRead32(0xbfb0008c)>>8) & 0x3) == 0x3) ? 1 : 0): 0)
+#define isRT62806   (((gswPbusRead(0x7ffc))&0xffff0000)==0x28060000)
+
+#define isENP_MOD	(((regRead32(0xBFBF8214)&0x8)==0x8)?(((regRead32(0xBFBF8214)&0x20)==0x20)?1:0):(((regRead32(0xBFBF8214)&0x2)==0x2)?1:0))
+#define isENS_MOD	(((regRead32(0xBFBF8214)&0x8)==0x8)?((regRead32(0xBFBF8214)&0x40)==0x40):((regRead32(0xBFBF8214)&0x4)==0x4))
+#define isMT751020 	(((regRead32(0xbfb00064)&0xffff0000))==0x00050000)
+#define isMT7505 	(((regRead32(0xbfb00064)&0xffff0000))==0x00060000)
+#define isEN751221 	(((VPint(0xbfb00064)&0xffff0000))==0x00070000)
+#define isMT7510	(isMT751020 && ((regRead32(0xbfb000f8)&0x3)==0) && (isENP_MOD))
+#define isMT7511	(isMT751020 && ((regRead32(0xbfb000f8)&0x3)==0)&& (!isENP_MOD))
+#define isMT7520	(((regRead32(0xbfb000f8)&0x3)==0x2) && isMT751020 && (isENP_MOD) && (!isENS_MOD))
+#define isMT7520G	(((regRead32(0xbfb000f8)&0x3)==0x3) && isMT751020 && (isENP_MOD))
+#define isMT7525	(((regRead32(0xbfb000f8)&0x3)==0x2) && isMT751020 && (!isENP_MOD) && (!isENS_MOD))
+#define isMT7525G	(((regRead32(0xbfb000f8)&0x3)==0x3) && isMT751020 && (!isENP_MOD))
+#define isMT7520S       (((regRead32(0xbfb000f8)&0x3)==0x2) && isMT751020 && (isENS_MOD))
+#define isMT7520E2E3 ((regRead32(0xbfb00064) & 0xFF) <= 0x2 && (isMT7520 || isMT7520G || isMT7525 || isMT7525G || isMT7520S))
+#define isEPONFWID   (((regRead32(0xbfb00064) & 0xF) == 0x3) && ((regRead32(0xbfb5fffc) & 0xF) >= 0x1) && (isMT7520 || isMT7520G || isMT7525 || isMT7525G || isMT7520S))
+
+
+#define isEN751221FPGA      ((regRead32(CR_AHB_HWCONF)&(1<<29)) ? 0 : 1) //used for 7512/7521
+#define isGenernalFPGA          ((regRead32(CR_AHB_HWCONF)&(1<<31)) ? 1 : 0) //used for 63365/751020
+#define isFPGA              0 //(isEN751221 ? isEN751221FPGA : isGenernalFPGA )
+
+#define EFUSE_VERIFY_DATA0 (0xBFBF8214)
+#define EFUSE_PKG_MASK          (0x3F)
+#define EFUSE_REMARK_BIT        (1<<6)
+
+#define EFUSE_PKG_REMARK_SHITF 7
+
+#define EFUSE_EN7526F   (0x0)
+#define EFUSE_EN7521F   (0x10)
+#define EFUSE_EN7521S   (0x20)
+#define EFUSE_EN7512    (0x4)
+#define EFUSE_EN7526D   (0x1)
+#define EFUSE_EN7513    (0x5)
+#define EFUSE_EN7526G   (0x2)
+#define EFUSE_EN7521G   (0x12)
+#define EFUSE_EN7513G   (0x6)
+#define EFUSE_EN7586    (0xA)
+#define EFUSE_EN7586    (0xA)
+
+#define isEN7526F (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7526F): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7526F)))
+#define isEN7521F (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7521F): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7521F)))
+#define isEN7521S (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7521S): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7521S)))
+#define isEN7512 (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7512): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7512)))
+#define isEN7526D (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7526D): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7526D)))
+#define isEN7513 (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7513): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7513)))
+#define isEN7526G (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7526G): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7526G)))
+#define isEN7521G (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7521G): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7521G)))
+#define isEN7513G (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7513G): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7513G)))
+#define isEN7586 (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7586): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7586)))
+
+#define EFUSE_DDR3_BIT (1<<23)
+#define EFUSE_DDR3_REMARK_BIT (1<<24)
+#define EFUSE_IS_DDR3 ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        ((regRead32(EFUSE_VERIFY_DATA0)& EFUSE_DDR3_REMARK_BIT)): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)& EFUSE_DDR3_BIT)))
+
+#define REG_SAVE_INFO 0xBFB00284
+#define SET_DRAM_SIZE(x) regWrite32(REG_SAVE_INFO ,((regRead32(REG_SAVE_INFO)&(~0xfff)) | (x&0xfff)))
+#define GET_DRAM_SIZE   (regRead32(REG_SAVE_INFO)&0xfff)
+#define SET_SYS_CLK(x)  regWrite32(REG_SAVE_INFO ,((regRead32(REG_SAVE_INFO)&~0xfff000) | ((x&0xfff)<<12)))
+#define GET_SYS_CLK     ((regRead32(REG_SAVE_INFO)&0xfff000)>>12)
+
+
+
+
+#ifdef TCSUPPORT_MT7510_E1
+#define READ_E1(x) do{if (VPint(x) == 0)printk("Error Reg %x\n",x);}while(0)
+#endif
+
+#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520)
+#define JUDGE_SWITCH_SCENARIO_BY_751020_SUBMODEL
+#ifdef JUDGE_SWITCH_SCENARIO_BY_751020_SUBMODEL
+#define MT751020_SUBMODEL_REG   (0xbfb000f8)
+
+#define ExistExtMT7530		(isMT7520G || isMT7525G)
+#define DefaultUseExtMT7530	(isMT7520G || isMT7525G)
+#define LanPortIntMT7530	(isMT7510 || isMT7511 || isMT7520 || isMT7525)
+#define LanPortExtMT7530	(isMT7520G || isMT7525G)
+#endif
+#endif
+
+#define isMT7530	(((regRead32(0xbfb58000+0x7ffc)&0xffff0000))==0x75300000)
+//#define isMT7530FPGA	(((gswPbusRead(0x7ffc))&0xffff0000)==0x75300000)
+#define isMT7530ext	(((gswPbusRead(0x7ffc))&0xffff0000)==0x75300000)
+
+#ifdef TC3162L2
+#define RT63260_SYS_HCLK ((12*(((regRead32(0xbfb000b0))&0x1ff)+1)/(((regRead32(0xbfb000b0)>>9)&0x1f)+1))/5)
+#define TC3162U_SYS_HCLK (3*(((regRead32(0xbfb000b0)>>16)&0x1ff)+1)/(((regRead32(0xbfb000b0)>>25)&0x1f)+1))
+#define SYS_HCLK        (isRT63260 ? RT63260_SYS_HCLK : (isTC3162U ? TC3162U_SYS_HCLK : 133))
+#endif
+
+#ifdef CONFIG_MIPS_TC3262
+/* RT63165 ASIC */
+/* FPGA is 25Mhz, ASIC LQFP128 is 166.67Mhz, others are 200Mhz */
+#define	RT63165_SYS_HCLK       	(regRead32(0xbfb0008c)&(1<<31) ? 25 : (regRead32(0xbfb0008c)&(1<<9) ? (200) : (16667/100)))
+/* RT63365 ASIC */
+/* FPGA is 25/32Mhz 
+ * ASIC RT6856/RT63368: DDR(0): 233.33, DDR(1): 175, SDR: 140
+ *      RT6855/RT63365: DDR(0): 166.67, DDR(1): 125, SDR: 140 */
+#define	RT63365_SYS_HCLK       	(regRead32(0xbfb0008c)&(1<<31) ? (25) : (regRead32(0xbfb0008c)&(1<<9) ? (regRead32(0xbfb0008c)&(1<<25) ? (regRead32(0xbfb0008c)&(1<<26) ? (175) : (23333/100)) : (140)) : (regRead32(0xbfb0008c)&(1<<25) ? (regRead32(0xbfb0008c)&(1<<26) ? (125) : (16667/100)) : (140))))
+#define MT751020_CPU_CLK		(((regRead32(0xbfb0008c) >> 0x9) & 0x3) == 0x0) ? (750) : (((regRead32(0xbfb0008c) >> 0x9) & 0x3) == 0x1) ? (650) : (((regRead32(0xbfb0008c) >> 0x9) & 0x3) == 0x2) ? (500) : (250)
+#define	MT751020_SYS_HCLK		((regRead32(0xbfb0008c)&(1<<31)) ? (32) : ((((MT751020_CPU_CLK)* 100) / ((regRead32(0xbfb000f8) >> 0x3) & 0x7)) / 100))
+#define	MT7505_SYS_HCLK		((regRead32(0xbfb0008c)&(1<<31)) ? (32) : (135))  //MT7505 CPU clock is 540
+#define EN7512_SYS_HCLK         ((isFPGA) ? (32) : (GET_SYS_CLK)) //ASIC Clock need Check
+
+#define	SYS_HCLK		(isEN751221?EN7512_SYS_HCLK:(isMT7505? MT7505_SYS_HCLK:(isMT751020  ? MT751020_SYS_HCLK : (isRT63365 ? RT63365_SYS_HCLK : (isRT63165 ? RT63165_SYS_HCLK : (isRT65168 ? (1024/10) : (isTC3182 ? (1024/10) : (3*((VPint(0xbfb00058)>>16)+1)/(((VPint(0xbfb00058)&0x1f)+1)<<1)))))))))
+#endif
+
+#define	SAR_CLK	(SYS_HCLK)/(4.0)		//more accurate if 4.0 not 4
+
+/* define CPU timer clock, FPGA is 50Mhz, ASIC is 250Mhz */
+#define	CPUTMR_CLK		(isFPGA ? (50*1000000) : (isEN751221 ? (200*1000000) : (isMT7505 ? (100*1000000) : (isMT751020 ? (800*1000000/3) :(250*1000000)))))
+
+#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520)
+#define DSPRAM_BASE		0x9dff8000
+#else
+#define DSPRAM_BASE		0x9c000000
+#endif
+
+#define ENABLE          1
+#define DISABLE         0
+
+#define WAN2LAN_CH_ID	(1<<31)
+
+#define tc_inb(offset) 			(*(volatile unsigned char *)(offset))
+#define tc_inw(offset) 			(*(volatile unsigned short *)(offset))
+#define tc_inl(offset) 			(*(volatile unsigned long *)(offset))
+
+#define tc_outb(offset,val)    	(*(volatile unsigned char *)(offset) = val)
+#define tc_outw(offset,val)    	(*(volatile unsigned short *)(offset) = val)
+#define tc_outl(offset,val)    	(*(volatile unsigned long *)(offset) = val)
+
+#if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+#define IS_SPIFLASH		((~(VPint(0xBFA10114))) & 0x2)
+#define IS_NANDFLASH		(VPint(0xBFA10114) & 0x2)
+#else
+#if defined(TCSUPPORT_CPU_MT7505)
+#define IS_SPIFLASH		1
+#define IS_NANDFLASH	0
+#else
+#define IS_SPIFLASH				((regRead32(CR_AHB_SSR) & (1<<20)) || !(regRead32(CR_AHB_HWCONF) & 0x1))
+#define IS_NANDFLASH			(regRead32(CR_AHB_HWCONF) & 0x1)
+#endif
+#endif
+#define NF_CONNTRACK_BUF_SIZE 4096
+/*****************************
+ * RBUS CORE Module Registers *
+ *****************************/
+#define ARB_CFG     		0xBFA00008
+#define ROUND_ROBIN_ENABLE  (1<<30)
+#define ROUND_ROBIN_DISBALE  ~(1<<30)
+
+
+
+/*****************************
+ * DMC Module Registers *
+ *****************************/
+
+#define CR_DMC_BASE     	0xBFB20000
+#define CR_DMC_SRT      	(0x00 | CR_DMC_BASE)
+#define CR_DMC_STC      	(0x01 | CR_DMC_BASE)
+#define CR_DMC_SAMT      	(0x02 | CR_DMC_BASE)
+#define CR_DMC_SCR      	(0x03 | CR_DMC_BASE)
+
+/* RT63165 specific */
+/* DDR self refresh control register */
+#define CR_DMC_DDR_SR    	(0x18 | CR_DMC_BASE)
+/* DDR self refresh target count */
+#define CR_DMC_DDR_SR_CNT  	(0x1c | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG0    	(0x40 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG1    	(0x44 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG2    	(0x48 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG3    	(0x4c | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG4    	(0x50 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG8    	(0x60 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG9    	(0x64 | CR_DMC_BASE)
+
+#define CR_DMC_CTL0      	(0x70 | CR_DMC_BASE)
+#define CR_DMC_CTL1      	(0x74 | CR_DMC_BASE)
+#define CR_DMC_CTL2      	(0x78 | CR_DMC_BASE)
+#define CR_DMC_CTL3     	(0x7c | CR_DMC_BASE)
+#define CR_DMC_CTL4     	(0x80 | CR_DMC_BASE)
+
+#define CR_DMC_DCSR     	(0xb0 | CR_DMC_BASE)
+
+#define CR_DMC_ISPCFGR     	(0xc0 | CR_DMC_BASE)
+#define CR_DMC_DSPCFGR     	(0xc4 | CR_DMC_BASE)
+
+/* MT7510 */
+#define CR_DRAMC_CONF1		(0x04 | CR_DMC_BASE)
+#define CR_DRAMC_PADCTL4    (0xe4 | CR_DMC_BASE)
+
+/*****************************
+ * GDMA Module Registers *
+ *****************************/
+
+#define CR_GDMA_BASE     	0xBFB30000
+#define CR_GDMA_DCSA      	(0x00 | CR_GDMA_BASE)
+#define CR_GDMA_DCDA      	(0x04 | CR_GDMA_BASE)
+#define CR_GDMA_DCBT      	(0x08 | CR_GDMA_BASE)
+#define CR_GDMA_DCBL      	(0x0a | CR_GDMA_BASE)
+#define CR_GDMA_DCC      	(0x0c | CR_GDMA_BASE)
+#define CR_GDMA_DCS      	(0x0e | CR_GDMA_BASE)
+#define CR_GDMA_DCKSUM     	(0x10 | CR_GDMA_BASE)
+
+/*****************************
+ * SPI Module Registers *
+ *****************************/
+
+#define CR_SPI_BASE     	0xBFBC0000
+#define CR_SPI_CTL      	(0x00 | CR_SPI_BASE)
+#define CR_SPI_OPCODE      	(0x04 | CR_SPI_BASE)
+#define CR_SPI_DATA      	(0x08 | CR_SPI_BASE)
+
+/*****************************
+ * Ethernet Module Registers *
+ *****************************/
+
+#define CR_MAC_BASE     	0xBFB50000
+#define CR_MAC_ISR      	(0x00 | CR_MAC_BASE)// --- Interrupt Status Register ---
+#define CR_MAC_IMR      	(0x04 | CR_MAC_BASE)// --- Interrupt Mask Register ---
+#define CR_MAC_MADR  	   	(0x08 | CR_MAC_BASE)// --- MAC Address Register [47:32] ---
+#define CR_MAC_LADR     	(0x0c | CR_MAC_BASE)// --- MAC Address Register [31:0] ---
+#define CR_MAC_EEE		(0x10 | CR_MAC_BASE)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+// None
+#else
+  #define CR_MAC_MAHT0         (0x10 | CR_MAC_BASE)// --- MAC Hash Table Address Register [31:0] ---
+  #define CR_MAC_MAHT1         (0x14 | CR_MAC_BASE)// --- MAC Hash Table Address Register [31:0] ---
+#endif
+#define CR_MAC_TXPD     	(0x18 | CR_MAC_BASE)// --- Transmit Poll Demand Register ---
+#define CR_MAC_RXPD     	(0x1c | CR_MAC_BASE)// --- Receive Poll Demand Register ---
+#define CR_MAC_TXR_BADR 	(0x20 | CR_MAC_BASE)// --- Transmit Ring Base Address Register ---
+#define CR_MAC_RXR_BADR 	(0x24 | CR_MAC_BASE)// --- Receive Ring Base Address Register ---
+#define CR_MAC_ITC      	(0x28 | CR_MAC_BASE)// --- Interrupt Timer Control Register ---
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+  #define CR_MAC_TXR_SIZE  	   (0x2c | CR_MAC_BASE)// --- Transmit Ring Size Register ---
+  #define CR_MAC_RXR_SIZE      (0x30 | CR_MAC_BASE)// --- Receive Ring Size Register ---
+  #define CR_MAC_RXR_SWIDX     (0x34 | CR_MAC_BASE)// --- Receive Ring Software Index Register ---
+#else
+#define CR_MAC_APTC     	(0x2c | CR_MAC_BASE)// --- Automatic Polling Timer Control Register ---
+#define CR_MAC_DBLAC    	(0x30 | CR_MAC_BASE)// --- DMA Burst Length and Arbitration Control Register ---
+#endif
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+  #define CR_MAC_TXDESP_SIZE   (0x38 | CR_MAC_BASE)// --- Transmit Descriptor Size Register ---
+  #define CR_MAC_RXDESP_SIZE   (0x3c | CR_MAC_BASE)// --- Receive Descriptor Size Register ---
+#else
+  #define CR_MAC_TXDESCP_ADR   (0x38 | CR_MAC_BASE)// --- Current Transmit Descriptor Address Register ---
+  #define CR_MAC_RXDESCP_ADR   (0x3c | CR_MAC_BASE)// --- Current Receive Descriptor Address Register ---
+#endif
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+  #define CR_MAC_PRIORITY_CFG  (0x50 | CR_MAC_BASE)// --- Priority Configuration Register ---
+  #define CR_MAC_VLAN_CFG      (0x54 | CR_MAC_BASE)// --- VLAN Configuration Register ---
+  #define CR_MAC_TOS0_CFG      (0x58 | CR_MAC_BASE)// --- TOS 0 Configuration Register ---
+  #define CR_MAC_TOS1_CFG      (0x5c | CR_MAC_BASE)// --- TOS 1 Configuration Register ---
+  #define CR_MAC_TOS2_CFG      (0x60 | CR_MAC_BASE)// --- TOS 2 Configuration Register ---
+  #define CR_MAC_TOS3_CFG      (0x64 | CR_MAC_BASE)// --- TOS 3 Configuration Register ---
+  #define CR_MAC_TCP_CFG       (0x68 | CR_MAC_BASE)// --- TCP Configuration Register ---
+  #define CR_MAC_SWTAG_CFG     (0x6c | CR_MAC_BASE)// --- Software Tagging Configuration Register ---
+  #define CR_MAC_PMBL_CYC_NUM  (0x70 | CR_MAC_BASE)// --- Preamble Cycle Number Register ---
+  #define CR_MAC_FCTL_CYC_NUM  (0x74 | CR_MAC_BASE)// --- Flow Control Cycle Number Register ---
+  #define CR_MAC_JAM_CYC_NUM   (0x78 | CR_MAC_BASE)// --- JAM Cycle Number Register ---
+  #define CR_MAC_DEFER_VAL     (0x7c | CR_MAC_BASE)// --- Defer Value Register ---
+  #define CR_MAC_RANDOM_POLY   (0x80 | CR_MAC_BASE)// --- Random Polynomial Register ---
+#else
+// None
+#endif
+#define CR_MAC_MACCR    	(0x88 | CR_MAC_BASE)// --- MAC Control Register ---
+#define CR_MAC_MACSR    	(0x8c | CR_MAC_BASE)// --- MAC Status Register ---
+#define CR_MAC_PHYCR    	(0x90 | CR_MAC_BASE)// --- PHY Control Register ---
+#define CR_MAC_PHYWDATA 	(0x94 | CR_MAC_BASE)// --- PHY Write Data Register ---
+#define CR_MAC_FCR      	(0x98 | CR_MAC_BASE)// --- Flow Control Register ---
+#define CR_MAC_BPR      	(0x9c | CR_MAC_BASE)// --- Back Pressure Register ---
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define CR_MAC_DESP_IDX        (0xc4 | CR_MAC_BASE)// --- Current Tx/Rx Descriptor Index ---
+#endif
+#define CR_MAC_WOLCR    	(0xa0 | CR_MAC_BASE)// --- Wake-On-LAN Control Register ---
+#define CR_MAC_WOLSR    	(0xa4 | CR_MAC_BASE)// --- Wake-On-LAN Status Register ---
+#define CR_MAC_WFCRC    	(0xa8 | CR_MAC_BASE)// --- Wake-up Frame CRC Register ---
+#define CR_MAC_WFBM1    	(0xb0 | CR_MAC_BASE)// --- Wake-up Frame Byte Mask 1st Double Word Register ---
+#define CR_MAC_WFBM2    	(0xb4 | CR_MAC_BASE)// --- Wake-up Frame Byte Mask 2nd Double Word Register ---
+#define CR_MAC_WFBM3    	(0xb8 | CR_MAC_BASE)// --- Wake-up Frame Byte Mask 3rd Double Word Register ---
+#define CR_MAC_WFBM4    	(0xbc | CR_MAC_BASE)// --- Wake-up Frame Byte Mask 4th Double Word Register ---
+#define CR_MAC_DMA_FSM  	(0xc8 | CR_MAC_BASE)// --- DMA State Machine
+#define CR_MAC_TM       	(0xcc | CR_MAC_BASE)// --- Test Mode Register ---
+#define CR_MAC_XMPG_CNT 	(0xdc | CR_MAC_BASE)// --- XM and PG Counter Register ---
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define CR_MAC_RUNT_TLCC_CNT   (0xe0 | CR_MAC_BASE)// --- Receive Runt and Transmit Late Collision Packet Counter Register ---
+#define CR_MAC_RCRC_RLONG_CNT  (0xe4 | CR_MAC_BASE)// --- Receive CRC Error and Long Packet Counter Register ---
+#define CR_MAC_RLOSS_RCOL_CNT  (0xe8 | CR_MAC_BASE)// --- Receive Packet Loss and Receive Collision Counter Register ---
+#else
+#define CR_MAC_RUNT_LCOL_CNT 	(0xe0 | CR_MAC_BASE)// --- Runt and Late Collision Packet Counter Register ---
+#define CR_MAC_CRC_LONG_CNT   	(0xe4 | CR_MAC_BASE)// --- CRC and Long Packet Counter Register ---
+#define CR_MAC_LOSS_COL_CNT   	(0xe8 | CR_MAC_BASE)// --- Receive Packet Loss and Receive Collision Counter Register ---
+#endif
+#define CR_MAC_BROADCAST_CNT  	(0xec | CR_MAC_BASE)// --- Receive Broadcast Counter Register ---
+#define CR_MAC_MULTICAST_CNT  	(0xf0 | CR_MAC_BASE)// --- Receive Multicast Counter Register ---
+#define CR_MAC_RX_CNT   	(0xf4 | CR_MAC_BASE)// --- Receive Good Packet Counter Register ---
+#define CR_MAC_TX_CNT   	(0xf8 | CR_MAC_BASE)// --- Transmit Good Packet Counter Register ---
+
+/*************************
+ * UART Module Registers *
+ *************************/
+#ifdef __BIG_ENDIAN
+#define CR_UART_OFFSET		(0x03)
+#else
+#define CR_UART_OFFSET		(0x0)
+#endif
+
+#define	CR_UART_BASE    	0xBFBF0000
+#define	CR_UART_RBR     	(0x00+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_THR     	(0x00+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_IER     	(0x04+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_IIR     	(0x08+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_FCR     	(0x08+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_LCR     	(0x0c+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_MCR     	(0x10+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_LSR     	(0x14+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_MSR     	(0x18+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_SCR     	(0x1c+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_BRDL    	(0x00+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_BRDH    	(0x04+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_WORDA		(0x20+CR_UART_BASE+0x00)
+#define	CR_UART_HWORDA		(0x28+CR_UART_BASE+0x00)
+#define	CR_UART_MISCC		(0x24+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_XYD     	(0x2c+CR_UART_BASE)
+
+#define	UART_BRD_ACCESS		0x80
+#define	UART_XYD_Y          65000
+#define	UART_UCLK_115200    0
+#define	UART_UCLK_57600     1
+#define	UART_UCLK_38400     2
+#define	UART_UCLK_28800		3
+#define	UART_UCLK_19200		4
+#define	UART_UCLK_14400		5
+#define	UART_UCLK_9600		6
+#define	UART_UCLK_4800		7
+#define	UART_UCLK_2400		8
+#define	UART_UCLK_1200		9
+#define	UART_UCLK_600		10
+#define	UART_UCLK_300		11
+#define	UART_UCLK_110		12
+#define	UART_BRDL			0x03
+#define	UART_BRDH			0x00
+#define	UART_LCR			0x03
+#define	UART_FCR			0x0f
+#define	UART_WATERMARK		(0x0<<6)
+#define	UART_MCR			0x0
+#define	UART_MISCC			0x0
+//#define UART_IER			0x07
+//#define	UART_IER			0x05
+#define	UART_IER			0x01
+
+#define	IER_RECEIVED_DATA_INTERRUPT_ENABLE	0x01
+#define	IER_THRE_INTERRUPT_ENABLE			0x02
+#define	IER_LINE_STATUS_INTERRUPT_ENABLE	0x04
+
+#define	IIR_INDICATOR						VPchar(CR_UART_IIR)
+#define	IIR_RECEIVED_LINE_STATUS			0x06
+#define	IIR_RECEIVED_DATA_AVAILABLE			0x04
+#define IIR_RECEIVER_IDLE_TRIGGER			0x0C
+#define	IIR_TRANSMITTED_REGISTER_EMPTY		0x02
+#define	LSR_INDICATOR						VPchar(CR_UART_LSR)
+#define	LSR_RECEIVED_DATA_READY				0x01
+#define	LSR_OVERRUN							0x02
+#define	LSR_PARITY_ERROR					0x04
+#define	LSR_FRAME_ERROR						0x08
+#define	LSR_BREAK							0x10
+#define	LSR_THRE							0x20
+#define	LSR_THE								0x40
+#define	LSR_RFIFO_FLAG						0x80
+
+#define uartTxIntOn()		VPchar(CR_UART_IER) |= IER_THRE_INTERRUPT_ENABLE
+#define uartTxIntOff()		VPchar(CR_UART_IER) &= ~IER_THRE_INTERRUPT_ENABLE
+#define uartRxIntOn()		VPchar(CR_UART_IER) |= IER_RECEIVED_DATA_INTERRUPT_ENABLE
+#define	uartRxIntOff()		VPchar(CR_UART_IER) &= ~IER_RECEIVED_DATA_INTERRUPT_ENABLE
+
+/*************************
+ * UART2 Module Registers *
+ *************************/
+#ifdef TCSUPPORT_UART2
+#define	CR_UART2_BASE    	0xBFBF0300
+#define	CR_UART2_RBR     	(0x00+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_THR     	(0x00+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_IER     	(0x04+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_IIR     	(0x08+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_FCR     	(0x08+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_LCR     	(0x0c+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_MCR     	(0x10+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_LSR     	(0x14+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_MSR     	(0x18+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_SCR     	(0x1c+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_BRDL    	(0x00+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_BRDH    	(0x04+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_WORDA		(0x20+CR_UART2_BASE+0x00)
+#define	CR_UART2_HWORDA	    (0x28+CR_UART2_BASE+0x00)
+#define	CR_UART2_MISCC		(0x24+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_XYD     	(0x2c+CR_UART2_BASE)
+
+#define	IIR_INDICATOR2		VPchar(CR_UART2_IIR)
+#define	LSR_INDICATOR2		VPchar(CR_UART2_LSR)
+#endif
+
+/*************************
+ * HSUART Module Registers *
+ *************************/
+#define	CR_HSUART_BASE    	0xBFBF0300
+#define	CR_HSUART_RBR     	(0x00+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_THR     	(0x00+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_IER     	(0x04+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_IIR     	(0x08+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_FCR     	(0x08+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_LCR     	(0x0c+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_MCR     	(0x10+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_LSR     	(0x14+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_MSR     	(0x18+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_SCR     	(0x1c+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_BRDL    	(0x00+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_BRDH    	(0x04+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_WORDA		(0x20+CR_HSUART_BASE+0x00)
+#define	CR_HSUART_HWORDA	(0x28+CR_HSUART_BASE+0x00)
+#define	CR_HSUART_MISCC		(0x24+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_XYD     	(0x2c+CR_HSUART_BASE)
+
+/**********************************
+ * Interrupt Controller Registers *
+ **********************************/
+#define CR_INTC_BASE    0xBFB40000
+			// --- Interrupt Type Register ---
+#define CR_INTC_ITR     (CR_INTC_BASE+0x0000)
+			// --- Interrupt Mask Register ---
+#define CR_INTC_IMR     (CR_INTC_BASE+0x0004)
+			// --- Interrupt Pending Register ---
+#define CR_INTC_IPR     (CR_INTC_BASE+0x0008)
+			// --- Interrupt Set Register ---
+#define CR_INTC_ISR    	(CR_INTC_BASE+0x000c)
+			// --- Interrupt Priority Register 0 ---
+#define CR_INTC_IPR0    (CR_INTC_BASE+0x0010)
+			// --- Interrupt Priority Register 1 ---
+#define CR_INTC_IPR1    (CR_INTC_BASE+0x0014)
+			// --- Interrupt Priority Register 2 ---
+#define CR_INTC_IPR2    (CR_INTC_BASE+0x0018)
+			// --- Interrupt Priority Register 3 ---
+#define CR_INTC_IPR3    (CR_INTC_BASE+0x001c)
+			// --- Interrupt Priority Register 4 ---
+#define CR_INTC_IPR4    (CR_INTC_BASE+0x0020)
+			// --- Interrupt Priority Register 5 ---
+#define CR_INTC_IPR5    (CR_INTC_BASE+0x0024)
+			// --- Interrupt Priority Register 6 ---
+#define CR_INTC_IPR6    (CR_INTC_BASE+0x0028)
+			// --- Interrupt Priority Register 7 ---
+#define CR_INTC_IPR7    (CR_INTC_BASE+0x002c)
+			// --- Interrupt Vector egister ---
+#ifdef CONFIG_MIPS_TC3262
+			// --- Interrupt VPE and SRS Register 0 ---
+#define CR_INTC_IVSR0   (CR_INTC_BASE+0x0030)
+			// --- Interrupt VPE and SRS Register 1 ---
+#define CR_INTC_IVSR1   (CR_INTC_BASE+0x0034)
+			// --- Interrupt VPE and SRS Register 2 ---
+#define CR_INTC_IVSR2   (CR_INTC_BASE+0x0038)
+			// --- Interrupt VPE and SRS Register 3 ---
+#define CR_INTC_IVSR3   (CR_INTC_BASE+0x003c)
+			// --- Interrupt VPE and SRS Register 4 ---
+#define CR_INTC_IVSR4   (CR_INTC_BASE+0x0040)
+			// --- Interrupt VPE and SRS Register 5 ---
+#define CR_INTC_IVSR5   (CR_INTC_BASE+0x0044)
+			// --- Interrupt VPE and SRS Register 6 ---
+#define CR_INTC_IVSR6   (CR_INTC_BASE+0x0048)
+			// --- Interrupt VPE and SRS Register 7 ---
+#define CR_INTC_IVSR7   (CR_INTC_BASE+0x004c)
+			// --- Interrupt Vector egister ---
+#define CR_INTC_IVR     (CR_INTC_BASE+0x0050)
+
+/* RT63165 */
+			// --- Interrupt Mask Register ---
+#define CR_INTC_IMR_1   (CR_INTC_BASE+0x0050)
+			// --- Interrupt Pending Register ---
+#define CR_INTC_IPR_1   (CR_INTC_BASE+0x0054)
+			// --- Interrupt Priority Register 8 ---
+#define CR_INTC_IPSR8	(CR_INTC_BASE+0x0058)
+			// --- Interrupt Priority Register 9 ---
+#define CR_INTC_IPSR9	(CR_INTC_BASE+0x005c)
+			// --- Interrupt VPE and SRS Register 8 ---
+#define CR_INTC_IVSR8   (CR_INTC_BASE+0x0060)
+			// --- Interrupt VPE and SRS Register 9 ---
+#define CR_INTC_IVSR9   (CR_INTC_BASE+0x0064)
+
+/*MT7510*/
+#define CR_INTC_NMI0IMR0   (CR_INTC_BASE+0x0080)
+#define CR_INTC_NMI1IMR0   (CR_INTC_BASE+0x0088)
+
+
+
+
+#else
+			// --- Interrupt Vector egister ---
+#define CR_INTC_IVR     (CR_INTC_BASE+0x0030)
+#endif
+
+#if 0
+/*move this to the int_source.h because the definition of unsigned long int...etc has been defined in type.h.
+  The ralink driver uses type.h and needs this interrupt_source structure so move this interrupt_source structure
+	to int_source.h. shnwind */
+enum
+interrupt_source
+	{
+#ifdef CONFIG_MIPS_TC3262
+		DUMMY_INT,
+#endif
+		UART_INT,		//0 	IPL10
+		RTC_ALARM_INT,	//1 	IPL29
+#ifdef CONFIG_MIPS_TC3262
+		SI_SWINT1_INT0,	//2
+		SI_SWINT1_INT1,	//3
+#else
+		RTC_TICK_INT,	//2 	IPL31
+		RESERVED0,		//3 	IPL30
+#endif
+		TIMER0_INT, 	//4 	IPL1
+		TIMER1_INT, 	//5 	IPL5
+		TIMER2_INT, 	//6 	IPL6
+#ifdef CONFIG_MIPS_TC3262
+		SI_SWINT_INT0, 	//7
+		SI_SWINT_INT1, 	//8
+#else
+		TIMER3_INT, 	//7 	IPL7
+		TIMER4_INT, 	//8 	IPL8
+#endif
+		TIMER5_INT, 	//9 	IPL9
+		GPIO_INT,		//10	IPL11
+#ifdef CONFIG_MIPS_TC3262
+		RESERVED1,		//11	IPL20
+		SI_PC1_INT, 	//12
+		SI_PC_INT, 		//13
+#else
+		PCIE_A_INT,		//11	IPL20
+		PCIE_SERR_INT,	//12	IPL21
+		RESERVED3,		//13	IPL22
+#endif
+		APB_DMA0_INT,	//14	IPL12
+		APB_DMA1_INT,	//15	IPL13
+#ifdef CONFIG_MIPS_TC3262
+		HSUART_INT,		//16	IPL23
+#else
+		RESERVED4,		//16	IPL23
+#endif
+		RESERVED5,		//17	IPL24
+		DYINGGASP_INT,	//18	IPL25
+		DMT_INT,		//19	IPL26
+		ARBITER_ERR_INT,//20	IPL0
+		MAC_INT,		//21	IPL3
+		SAR_INT,		//22	IPL2
+		USB_INT,		//23	IPL14
+		PCI_A_INT,		//24
+		PCI_B_INT,		//25
+//		  RESERVED8,	  //24	  IPL27
+//		  RESERVED9,	  //25	  IPL28
+		XSLV0_INT,		//26	IPL15
+		XSLV1_INT,		//27	IPL16
+		XSLV2_INT,		//28	IPL17
+#ifdef CONFIG_MIPS_TC3262
+		SI_TIMER1_INT,	//29
+		SI_TIMER_INT,	//30
+#else
+		XAPB0_INT,		//29	IPL18
+		XAPB1_INT,		//30	IPL19
+#endif
+		SWR_INT 		//31	IPL4
+	};
+#endif
+
+enum
+interrupt_priority
+{
+		IPL0,	IPL1,	IPL2,	IPL3,	IPL4,
+		IPL5,	IPL6,	IPL7,	IPL8,	IPL9,
+		IPL10,	IPL11,	IPL12,	IPL13,	IPL14,
+		IPL15,	IPL16,	IPL17,	IPL18,	IPL19,
+		IPL20,	IPL21,	IPL22,	IPL23,	IPL24,
+		IPL25,	IPL26,	IPL27,	IPL28,	IPL29,
+		IPL30,	IPL31
+};
+
+/**************************
+ * Timer Module Registers *
+ **************************/
+#define CR_TIMER_BASE  		0xBFBF0100
+#define CR_TIMER_CTL    	(CR_TIMER_BASE + 0x00)
+#define CR_TIMER0_LDV   	(CR_TIMER_BASE + 0x04)
+#define CR_TIMER0_VLR    	(CR_TIMER_BASE + 0x08)
+#define CR_TIMER1_LDV       (CR_TIMER_BASE + 0x0C)
+#define CR_TIMER1_VLR       (CR_TIMER_BASE + 0x10)
+#define CR_TIMER2_LDV       (CR_TIMER_BASE + 0x14)
+#define CR_TIMER2_VLR       (CR_TIMER_BASE + 0x18)
+#define CR_TIMER3_LDV       (CR_TIMER_BASE + 0x1C)
+#define CR_TIMER3_VLR       (CR_TIMER_BASE + 0x20)
+#define CR_TIMER4_LDV       (CR_TIMER_BASE + 0x24)
+#define CR_TIMER4_VLR       (CR_TIMER_BASE + 0x28)
+#define CR_TIMER5_LDV       (CR_TIMER_BASE + 0x2C)
+#define CR_TIMER5_VLR       (CR_TIMER_BASE + 0x30)
+/* new watchdog design */
+#define CR_WDOG_THSLD       (CR_TIMER_BASE + 0x34)
+#define CR_WDOG_RLD         (CR_TIMER_BASE + 0x38)
+
+#define TIMER_ENABLE         1
+#define TIMER_DISABLE        0
+#define TIMER_TOGGLEMODE     1
+#define TIMER_INTERVALMODE   0
+#define TIMER_TICKENABLE     1
+#define TIMER_TICKDISABLE    0
+#define TIMER_WDENABLE       1
+#define TIMER_WDDISABLE      0
+#define TIMER_HALTENABLE     1
+#define TIMER_HALTDISABLE    0
+
+#define TIMERTICKS_1MS       1
+#define TIMERTICKS_10MS      10  // set timer ticks as 10 ms
+#define TIMERTICKS_100MS     100
+#define TIMERTICKS_1S        1000
+#define TIMERTICKS_10S       10000
+
+#define timerCtlSet(timer_no, timer_enable, timer_mode,timer_halt)	timer_Configure(timer_no, timer_enable, timer_mode, timer_halt)
+#define timerWdSet(tick_enable, watchdog_enable) timer_WatchDogConfigure(tick_enable,watchdog_enable)
+#define timerLdvSet(timer_no,val) *(volatile uint32 *)(CR_TIMER0_LDV+timer_no*0x08) = (val)
+#define timerVlrGet(timer_no,val) (val)=*(volatile uint32 *)(CR_TIMER0_VLR+timer_no*0x08)
+
+/**************************
+ * Timer Module Registers *
+ **************************/
+#define CR_CPUTMR_BASE 		0xBFBF0400
+#define CR_CPUTMR_CTL    	(CR_CPUTMR_BASE + 0x00)
+#define CR_CPUTMR_CMR0    	(CR_CPUTMR_BASE + 0x04)
+#define CR_CPUTMR_CNT0    	(CR_CPUTMR_BASE + 0x08)
+#define CR_CPUTMR_CMR1    	(CR_CPUTMR_BASE + 0x0c)
+#define CR_CPUTMR_CNT1    	(CR_CPUTMR_BASE + 0x10)
+
+/*************************
+ * GPIO Module Registers *
+ *************************/
+#define CR_GPIO_BASE       	0xBFBF0200
+#define CR_GPIO_CTRL	    (CR_GPIO_BASE + 0x00)
+#define CR_GPIO_DATA	    (CR_GPIO_BASE + 0x04)
+#define CR_GPIO_INTS      	(CR_GPIO_BASE + 0x08)
+#define CR_GPIO_EDET	    (CR_GPIO_BASE + 0x0C)
+#define CR_GPIO_LDET       	(CR_GPIO_BASE + 0x10)
+#define CR_GPIO_ODRAIN      (CR_GPIO_BASE + 0x14)
+#define CR_GPIO_CTRL1	    (CR_GPIO_BASE + 0x20)
+#ifdef TCSUPPORT_GPIO_ECM
+#define CR_SGPIO_DATA        (CR_GPIO_BASE + 0x24)
+#define CR_SGPIO_CDIV        (CR_GPIO_BASE + 0x28)
+#define CR_SGPIO_CDLY        (CR_GPIO_BASE + 0x2C)
+#define CR_SGPIO_MODE	    (CR_GPIO_BASE + 0x30)
+#define CR_GPIO_FLAMOD	    (CR_GPIO_BASE + 0x34)
+#define CR_GPIO_IMME	    (CR_GPIO_BASE + 0x38)
+#define CR_GPIO_FLAP0	    (CR_GPIO_BASE + 0x3C)
+#define CR_GPIO_FLAP1	    (CR_GPIO_BASE + 0x40)
+#define CR_GPIO_FLAP2 	    (CR_GPIO_BASE + 0x44)
+#define CR_GPIO_FLAP3	    (CR_GPIO_BASE + 0x48)
+#define CR_GPIO_FMAP0	    (CR_GPIO_BASE + 0x4C)
+#define CR_GPIO_FMAP1 	    (CR_GPIO_BASE + 0x50)
+#define CR_SGPIO_FMAP0	    (CR_GPIO_BASE + 0x54)
+#define CR_SGPIO_FMAP1	    (CR_GPIO_BASE + 0x58)
+#define CR_SGPIO_FMAP2	    (CR_GPIO_BASE + 0x5C)
+#define CR_GPIO_TYPE	    0xBFB000B0
+#endif
+/* MT7510 */
+#define CR_GPIO_CTRL2	    (CR_GPIO_BASE + 0x60)
+#define CR_GPIO_CTRL3	    (CR_GPIO_BASE + 0x64)
+#define CR_GPIO_FLAMOD_EXT	(CR_GPIO_BASE + 0x68)
+#define CR_GPIO_DATA1		(CR_GPIO_BASE + 0x70)
+#define CR_GPIO_ODRAIN1     (CR_GPIO_BASE + 0x78)
+
+#define GPIO_IN				0x0
+#define GPIO_OUT			0x1
+#define GPIO_ALT_IN			0x2
+#define GPIO_ALT_OUT		0x3
+
+#define GPIO_E_DIS			0x0
+#define GPIO_E_RISE			0x1
+#define GPIO_E_FALL			0x2
+#define GPIO_E_BOTH			0x3
+
+#define GPIO_L_DIS			0x0
+#define GPIO_L_HIGH			0x1
+#define GPIO_L_LOW			0x2
+#define GPIO_L_BOTH			0x3
+
+/*****************************
+ * Arbiter/Decoder Registers *
+ *****************************/
+#define CR_AHB_BASE       	0xBFB00000
+#define CR_AHB_AACS	    	(CR_AHB_BASE + 0x00)
+#define CR_AHB_ABEM      	(CR_AHB_BASE + 0x08)
+#define CR_AHB_ABEA		    (CR_AHB_BASE + 0x0C)
+#define CR_AHB_DMB0       	(CR_AHB_BASE + 0x10)
+#define CR_AHB_DMB1       	(CR_AHB_BASE + 0x14)
+#define CR_AHB_DMB2       	(CR_AHB_BASE + 0x18)
+#define CR_AHB_DMB3       	(CR_AHB_BASE + 0x1C)
+#define CR_AHB_SMB0       	(CR_AHB_BASE + 0x20)
+#define CR_AHB_SMB1       	(CR_AHB_BASE + 0x24)
+#define CR_AHB_SMB2       	(CR_AHB_BASE + 0x28)
+#define CR_AHB_SMB3       	(CR_AHB_BASE + 0x2C)
+#define CR_AHB_SMB4       	(CR_AHB_BASE + 0x30)
+#define CR_AHB_SMB5       	(CR_AHB_BASE + 0x34)
+
+/* RT63165 */
+#define CR_ERR_ADDR    		(CR_AHB_BASE + 0x3c)
+#define CR_PRATIR      		(CR_AHB_BASE + 0x58)
+#define CR_MON_TMR     		(CR_AHB_BASE + 0x60)
+
+/*MT7510*/
+#define CR_AHB_NMI_CONF		(CR_AHB_BASE + 0x50)
+
+#define CR_AHB_PMCR       	(CR_AHB_BASE + 0x80)
+#define CR_AHB_DMTCR       	(CR_AHB_BASE + 0x84)
+#define CR_AHB_PCIC	       	(CR_AHB_BASE + 0x88)
+#define CR_AHB_HWCONF       (CR_AHB_BASE + 0x8C)
+#define CR_AHB_SSR       	(CR_AHB_BASE + 0x90)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define CR_IMEM       	(CR_AHB_BASE + 0x9C)
+#define CR_DMEM       	(CR_AHB_BASE + 0xA0)
+#endif
+/* RT63365 */
+#define CR_CRCC_REG		(CR_AHB_BASE + 0xA0)
+#define CR_AHB_UHCR		(CR_AHB_BASE + 0xA8)
+#define CR_AHB_ABMR       	(CR_AHB_BASE + 0xB8)
+#define CR_CKGEN_CONF		(CR_AHB_BASE + 0xC0)
+#define CR_PSMCR       		(CR_AHB_BASE + 0xCC)
+#define CR_PSMDR       		(CR_AHB_BASE + 0xD0)
+#define CR_PSMMR       		(CR_AHB_BASE + 0xD0)
+
+/* RT63165 */
+#define CR_SRAM       		(CR_AHB_BASE + 0xF4)
+#define CR_AHB_HWCONF2      (CR_AHB_BASE + 0xF8)
+
+/* RT63365 */
+#define CR_AHB_CLK			(CR_AHB_BASE + 0x1c0)
+#define CR_CLK_CFG     		(CR_AHB_BASE + 0x82c)
+#define CR_RSTCTRL2    		(CR_AHB_BASE + 0x834)
+#define CR_GPIO_SHR			(CR_AHB_BASE + 0x860)			
+
+#define CR_BUSTIMEOUT_SWITCH     (CR_AHB_BASE + 0x92c)
+/*************************************************
+ * SRAM/FLASH/ROM Controller Operation Registers *
+ *************************************************/
+#define CR_SMC_BASE       	0xBFB10000
+#define CR_SMC_BCR0	    	(CR_SMC_BASE + 0x00)
+#define CR_SMC_BCR1	    	(CR_SMC_BASE + 0x04)
+#define CR_SMC_BCR2	    	(CR_SMC_BASE + 0x08)
+#define CR_SMC_BCR3	    	(CR_SMC_BASE + 0x0C)
+#define CR_SMC_BCR4	    	(CR_SMC_BASE + 0x10)
+#define CR_SMC_BCR5	    	(CR_SMC_BASE + 0x14)
+
+/************************************************
+ * System Control Uint                          *
+ ************************************************/
+ /* MT7510 */
+#define CR_SCU_BASE				0xbfb00000
+#define CR_DRAMC_HW_SREF_CONF	(0x44 | CR_SCU_BASE)
+#define CR_DRAMC_CONF			(0x74 | CR_SCU_BASE)
+
+/*****************************
+ * Clock Generator Registers *
+ *****************************/
+
+/****************************
+ * USB Module Registers *
+ ****************************/
+
+#define CR_USB_BASE     0xBFB70000
+
+        // --- System Control Register ---
+#define CR_USB_SYS_CTRL_REG           (0x00 | CR_USB_BASE)
+
+        // --- Device Control Register ---
+#define CR_USB_DEV_CTRL_REG           (0x04 | CR_USB_BASE)
+
+        // --- Interrupt Status Register ---
+#define CR_USB_INTR_STATUS_REG        (0x08 | CR_USB_BASE)
+
+        // --- Interrupt Mask Register ---
+#define CR_USB_INTR_MASK_REG          (0x0c | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode Control Register ---
+#define CR_USB_CTRL_ENDP_IO_CTRL_REG  (0x10 | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode OUT Transfer Data Register #00 ---
+#define CR_USB_CTRL_ENDP_IO_OUT_REG0  (0x18 | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode OUT Transfer Data Register #01 ---
+#define CR_USB_CTRL_ENDP_IO_OUT_REG1  (0x1c | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode IN Transfer Data Register #00 ---
+#define CR_USB_CTRL_ENDP_IO_IN_REG0   (0x20 | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode IN Transfer Data Register #01 ---
+#define CR_USB_CTRL_ENDP_IO_IN_REG1   (0x24 | CR_USB_BASE)
+
+        // --- Interrupt IN Endpoint Control Register ---
+#define CR_USB_INTR_IN_ENDP_CTRL_REG  (0x30 | CR_USB_BASE)
+
+        // --- Interrupt IN Endpoint IN Transfer Data Register #00 ---
+#define CR_USB_INTR_IN_ENDP_IN_REG0   (0x38 | CR_USB_BASE)
+
+        // --- Interrupt IN Endpoint IN Transfer Data Register #01 ---
+#define CR_USB_INTR_IN_ENDP_IN_REG1   (0x3c | CR_USB_BASE)
+
+        // --- Bulk/ISO OUT Descriptor Pointer Register ---
+#define CR_USB_BULKISO_OUT_DESCP_BASE_REG   (0x40 | CR_USB_BASE)
+
+        // --- Bulk/ISO IN Descriptor Pointer Register ---
+#define CR_USB_BULKISO_IN_DESCP_BASE_REG    (0x44 | CR_USB_BASE)
+
+        // --- Bulk/ISO IN/OUT Endpoint Number Register ---
+#define CR_USB_BULKISO_INOUT_ENDP_NUM_REG   (0x48 | CR_USB_BASE)
+
+        // --- Bulk/ISO Endpoint DMA Control Register ---
+#define CR_USB_BULKISO_ENDP_DMA_CTRL_REG    (0x4c | CR_USB_BASE)
+
+        // --- Bulk/ISO Endpoint DMA Configuration Register ---
+#define CR_USB_BULKISO_ENDP_DMA_CONF_REG    (0x50 | CR_USB_BASE)
+
+        // --- ISO Endpoint Transfer Delimiter Register #00 ---
+#define CR_USB_ISO_ENDP_DELIMITER_REG0      (0x58 | CR_USB_BASE)
+
+        // --- ISO Endpoint Transfer Delimiter Register #01 ---
+#define CR_USB_ISO_ENDP_DELIMITER_REG1      (0x5c | CR_USB_BASE)
+
+        // --- Vendor ID Register ---
+#define CR_USB_VENDOR_ID_REG                (0x68 | CR_USB_BASE)
+
+        // --- Product ID Register ---
+#define CR_USB_PRODUCT_ID_REG               (0x6c | CR_USB_BASE)
+
+/*************************
+ * HOST BRIDGE Registers *
+ * ***********************/
+#define HOST_BRIDGE_BASE 	0xBFB80000
+#define CR_CFG_ADDR_REG 	(HOST_BRIDGE_BASE+0x0020)
+#define CR_CFG_DATA_REG 	(HOST_BRIDGE_BASE+0x0024)
+/****************************
+ * ATM SAR Module Registers *
+ ****************************/
+#define TSCONTROL_BASE			0xBFB00000
+#define TSARM_REGISTER_BASE		(TSCONTROL_BASE + 0x00060000)
+
+/* ----- General configuration registers  ----- */
+
+/* ----- Reset And Identify register  ----- */
+#define TSARM_RAI				VPint(TSARM_REGISTER_BASE + 0x0000)
+/* ----- General Configuration register  ----- */
+#define TSARM_GFR				VPint(TSARM_REGISTER_BASE + 0x0004)
+/* ----- Traffic Scheduler Timer Base Counter register  ----- */
+#define TSARM_TSTBR				VPint(TSARM_REGISTER_BASE + 0x0008)
+/* ----- Receive Maximum Packet Length register  ----- */
+#define TSARM_RMPLR				VPint(TSARM_REGISTER_BASE + 0x000c)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+//Transmit Priority 0/1 Data Buffer Control and Status Register
+#define TSARM_TXDBCSR_P01		VPint(TSARM_REGISTER_BASE + 0x0010)
+#else
+/* ----- TX Data Buffer Control and Status register  ----- */
+#define TSARM_TXDBCSR			VPint(TSARM_REGISTER_BASE + 0x0010)
+#endif
+/* ----- TX OAM Buffer Control and Status register  ----- */
+#define TSARM_TXMBCSR			VPint(TSARM_REGISTER_BASE + 0x0014)
+/* ----- RX Data Buffer Control and Status register  ----- */
+#define TSARM_RXDBCSR			VPint(TSARM_REGISTER_BASE + 0x0018)
+/* ----- RX OAM Buffer Control and Status register  ----- */
+#define TSARM_RXMBCSR			VPint(TSARM_REGISTER_BASE + 0x001c)
+/* ----- Last IRQ Status register  ----- */
+#define TSARM_LIRQ				VPint(TSARM_REGISTER_BASE + 0x0020)
+/* ----- IRQ Queue Base Address register  ----- */
+#define TSARM_IRQBA				VPint(TSARM_REGISTER_BASE + 0x0024)
+/* ----- IRQ Queue Entry Length register  ----- */
+#define TSARM_IRQLEN			VPint(TSARM_REGISTER_BASE + 0x0028)
+/* ----- IRQ Head Indication register  ----- */
+#define TSARM_IRQH				VPint(TSARM_REGISTER_BASE + 0x002c)
+/* ----- Clear IRQ Entry register  ----- */
+#define TSARM_IRQC				VPint(TSARM_REGISTER_BASE + 0x0030)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+//Traffic Scheduler Line Rate Counter Register
+#define TSARM_TXSLRC			VPint(TSARM_REGISTER_BASE + 0x0034)
+//Transmit Priority 2/3 Data Buffer Control and Status Register
+#define TSARM_TXDBCSR_P23		VPint(TSARM_REGISTER_BASE + 0x0038)
+#endif
+
+/* ----- VC IRQ Mask register  ----- */
+#define TSARM_IRQM_BASE			(TSARM_REGISTER_BASE + 0x0040)
+#define TSARM_IRQM(vc)			VPint(TSARM_IRQM_BASE + (vc * 4))
+#define TSARM_IRQMCC			VPint(TSARM_IRQM_BASE + 0x0040)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_IRQ_QUE_THRE		VPint(TSARM_REGISTER_BASE + 0x0084)		//IRQ Queue Threshold Register
+#define TSARM_IRQ_TIMEOUT_CTRL 	VPint(TSARM_REGISTER_BASE + 0x0088)		//IRQ Timeout Control Register
+#endif
+
+/* ----- VC Configuration register  ----- */
+#define TSARM_VCCR_BASE			(TSARM_REGISTER_BASE + 0x0100)
+#define TSARM_VCCR(vc)			VPint(TSARM_VCCR_BASE + (vc * 4))
+#define TSARM_CCCR				VPint(TSARM_VCCR_BASE + 0x0040)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+/* ----- DMA WRR Configuration Register (DMA_WRR_WEIT) (for TC3162L4) ----- */
+#define TSARM_DMAWRRCR			VPint(TSARM_REGISTER_BASE + 0x0150)
+#endif
+/* ----- Transmit Buffer Descriptor register  ----- */
+#define TSARM_TXDCBDA_BASE		(TSARM_REGISTER_BASE + 0x0200)
+#define TSARM_TXDCBDA(vc)		VPint(TSARM_TXDCBDA_BASE + (vc * 4))
+#define TSARM_TXMCBDA_BASE		(TSARM_REGISTER_BASE + 0x0240)
+#define TSARM_TXMCBDA(vc)		VPint(TSARM_TXMCBDA_BASE + (vc * 4))
+
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_CC_TX_BD_BASE				VPint(TSARM_REGISTER_BASE + 0x0228)		//Control Channel Transmit BD Base Address 0x228
+#define TSARM_CC_TX_BD_MNG_BASE			VPint(TSARM_REGISTER_BASE + 0x0268)		//Control Channel Transmit BD Management Base
+#define TSARM_VC_TX_BD_PRIORITY01_BASE		(TSARM_REGISTER_BASE + 0x0280)
+#define TSARM_VC_TX_BD_PRIORITY01(vc)		VPint(TSARM_VC_TX_BD_PRIORITY01_BASE + vc * 4)		//VC0 Transmit BD Data Priority 0/1 Base 280
+#define TSARM_VC_TX_BD_PRIORITY23_BASE		(TSARM_REGISTER_BASE + 0x02c0)
+#define TSARM_VC_TX_BD_PRIORITY23(vc)		VPint(TSARM_VC_TX_BD_PRIORITY23_BASE + vc * 4)		//VC0 Transmit BD Data Priority 0/1 Base 280
+#else
+#define TSARM_TXCCBDA			VPint(TSARM_REGISTER_BASE + 0x0280)
+#endif
+
+/* ----- Receive Buffer Descriptor register  ----- */
+#define TSARM_RXDCBDA_BASE		(TSARM_REGISTER_BASE + 0x0300)
+#define TSARM_RXDCBDA(vc)		VPint(TSARM_RXDCBDA_BASE + (vc * 4))
+#define TSARM_RXMCBDA_BASE		(TSARM_REGISTER_BASE + 0x0340)
+#define TSARM_RXMCBDA(vc)		VPint(TSARM_RXMCBDA_BASE + (vc * 4))
+
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_CC_RX_BD_BASE			VPint(TSARM_REGISTER_BASE + 0x328)		//Control Channel Receive BD Base Address	0x328
+#define TSARM_CC_RX_BD_MNG_BASE		VPint(TSARM_REGISTER_BASE + 0x368)		//Control Channel Receive BD Management Base	0x368
+#define TSARM_VC_RX_DATA_BASE				(TSARM_REGISTER_BASE + 0x380)
+#define TSARM_VC_RX_DATA(vc)			VPint(TSARM_VC_RX_DATA_BASE + vc * 4)	//VC0 Receive BD Data Base	0x380
+#else
+#define TSARM_RXCCBDA			VPint(TSARM_REGISTER_BASE + 0x0380)
+#endif
+
+/* ----- Traffic Scheduler register  ----- */
+#define TSARM_PCR_BASE			(TSARM_REGISTER_BASE + 0x0400)
+#define TSARM_PCR(vc)			VPint(TSARM_PCR_BASE + (vc * 4))
+#define TSARM_SCR_BASE			(TSARM_REGISTER_BASE + 0x0440)
+#define TSARM_SCR(vc)			VPint(TSARM_SCR_BASE + (vc * 4))
+#define TSARM_MBSTP_BASE		(TSARM_REGISTER_BASE + 0x0480)
+#define TSARM_MBSTP(vc)			VPint(TSARM_MBSTP_BASE + (vc * 4))
+
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_MAX_FRAME_SIZE_BASE	(TSARM_REGISTER_BASE + 0x04c0)
+#define TSARM_MAX_FRAME_SIZE(vc)		VPint(TSARM_MAX_FRAME_SIZE_BASE + (vc * 4))
+/* define for TC3162L4 */
+#define TSARM_TRAFFIC_SHAPER_WEIGHT_BASE (TSARM_REGISTER_BASE + 0x0500)
+#define TSARM_TRAFFIC_SHAPER_WEIGHT(vc)     VPint(TSARM_TRAFFIC_SHAPER_WEIGHT_BASE + (vc * 4))
+#else
+/* ----- Receive Timeout register  ----- */
+#define TSARM_RTOCNT_BASE		(TSARM_REGISTER_BASE + 0x0500)
+#define TSARM_RTOCNT(vc)		VPint(TSARM_RTOCNT_BASE + (vc * 4))
+#endif
+
+/* ----- TX Statistic Counter register  ----- */
+#define TSARM_TDCNT_BASE		(TSARM_REGISTER_BASE + 0x0600)
+#define TSARM_TDCNT(vc)			VPint(TSARM_TDCNT_BASE + (vc * 4))
+#define TSARM_TDCNTCC			VPint(TSARM_TDCNT_BASE + 0x0040)
+
+/* ----- RX Statistic Counter register  ----- */
+#define TSARM_RDCNT_BASE		(TSARM_REGISTER_BASE + 0x0700)
+#define TSARM_RDCNT(vc)			VPint(TSARM_RDCNT_BASE + (vc * 4))
+#define TSARM_RDCNTCC			VPint(TSARM_RDCNT_BASE + 0x0040)
+#define TSARM_MISCNT			VPint(TSARM_RDCNT_BASE + 0x0044)
+
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_MPOA_GCR				VPint(TSARM_REGISTER_BASE + 0x0800)			//MPOA global control register
+#define TSARM_VC_MPOA_CTRL_BASE			(TSARM_REGISTER_BASE + 0x0810)			//VC0 ~9  MPOA Control register
+#define TSARM_VC_MPOA_CTRL(vc)			VPint(TSARM_VC_MPOA_CTRL_BASE + vc * 4)
+#define TSARM_MPOA_HFIV11				VPint(TSARM_REGISTER_BASE + 0x0850)			//MPOA header Field1 Insertion Value1
+#define TSARM_MPOA_HFIV12				VPint(TSARM_REGISTER_BASE + 0x0854)			//MPOA header Field1 Insertion Value2
+#define TSARM_MPOA_HFIV13				VPint(TSARM_REGISTER_BASE + 0x0858)			//MPOA header Field2 Insertion Value1
+#define TSARM_MPOA_HFIV21				VPint(TSARM_REGISTER_BASE + 0x0860)			//MPOA header Field2 Insertion Value2
+#define TSARM_MPOA_HFIV22				VPint(TSARM_REGISTER_BASE + 0x0864)			//MPOA header Field2 Insertion Value2
+#define TSARM_MPOA_HFIV23				VPint(TSARM_REGISTER_BASE + 0x0868)			//MPOA header Field2 Insertion Value2
+#define TSARM_MPOA_HFIV31				VPint(TSARM_REGISTER_BASE + 0x0870)			//MPOA header Field3 Insertion Value1
+#define TSARM_MPOA_HFIV32				VPint(TSARM_REGISTER_BASE + 0x0874)			//MPOA header Field3 Insertion Value2
+#define TSARM_MPOA_HFIV33				VPint(TSARM_REGISTER_BASE + 0x0878)			//MPOA header Field3 Insertion Value3
+#define TSARM_MPOA_HFIV41				VPint(TSARM_REGISTER_BASE + 0x0880)			//MPOA header Field4 Insertion Value1
+#define TSARM_MPOA_HFIV42				VPint(TSARM_REGISTER_BASE + 0x0884)			//MPOA header Field4 Insertion Value2
+#define TSARM_MPOA_HFIV43				VPint(TSARM_REGISTER_BASE + 0x0888)			//MPOA header Field4 Insertion Value2
+#endif
+
+/**************************
+ * USB Module Registers *
+ **************************/
+
+#define LA_DEBUG_TRIGGER(addr,val) VPint(0xbfc00000+addr) = val
+/**************************
+* USB 2.0 device Register *
+**************************/
+#define CR_USB20_BASE     0xBFB70000
+
+// --- System Control Register ---
+#define CR_USB20_SYS_CTRL_REG			(0x00 | CR_USB20_BASE)
+
+// --- Device Control Register ---
+#define CR_USB20_DEV_CTRL_REG			(0x04 | CR_USB20_BASE)
+
+// --- Interrupt Status Register ---
+#define CR_USB20_INTR_STATUS_REG		(0x0c | CR_USB20_BASE)
+
+// --- Interrupt ENABLE Register ---
+#define CR_USB20_INTR_ENABLE_REG          	(0x10 | CR_USB20_BASE)
+
+// --- Interrupt Timing Control Register ---
+#define CR_USB20_INTR_TIMING_CONTROL_REG	(0x14 | CR_USB20_BASE)
+
+// --- SETUP Receive Data Buffer Register ---
+#define CR_USB20_SETUP_BASE_REG          	(0x20 | CR_USB20_BASE)
+
+// --- Control OUT Receive Data Buffer Pointer Register ---
+#define CR_USB20_CONTROL_OUT_BASE_REG		(0x24 | CR_USB20_BASE)
+
+// --- Control IN Receive Data Buffer Pointer Register ---
+#define CR_USB20_CONTROL_IN_BASE_REG		(0x28 | CR_USB20_BASE)
+
+// --- Control IN Receive Data Buffer Pointer Register ---
+#define CR_USB20_CONTROL_CONF_REG		(0x2c | CR_USB20_BASE)
+
+// --- CONTROL Endpoint DMA Transfer Control Register ---
+#define CR_USB20R_CONTROL_EP_DMA_CTRL_REG	(0x30 | CR_USB20_BASE)
+
+// --- CONTROL Endpoint DMA Transfer Status Register ---
+#define CR_USB20_CONTROL_EP_DMA_STATUS_REG	(0x34 | CR_USB20_BASE)
+
+// --- INTERRUPT IN Transmit Data Buffer Pointer  Register ---
+#define CR_USB20_INTERRUPT_IN_BASE_REG		(0x38 | CR_USB20_BASE)
+
+// --- INTERRUPT IN Configuration   Register ---
+#define CR_USB20_INTERRUPT_IN_CONF_REG		(0x3c | CR_USB20_BASE)
+
+// --- INTERRUPT IN Endpoint DMA Transfer Control Register ---
+#define CR_USB20_INTERRUPT_IN_DMA_CTRL_REG	(0x40 | CR_USB20_BASE)
+
+// --- INTERRUPT IN Endpoint DMA Transfer Status Register ---
+#define CR_USB20_INTERRUPT_IN_EP_DMA_STATUS_REG	(0x44 | CR_USB20_BASE)
+
+// --- Bulk/Ctrl/Intr IN/OUT Underrun/Overrun Error Counter  Register ---
+#define CR_USB20_STATUS_COUNT_REG		(0x48 | CR_USB20_BASE)
+
+// --- BULK OUT Endpoint Transfer DMA Polling Demand Control Register ---
+#define CR_USB20_BULK_OUT_DMA_POLLING_REG	(0x60 | CR_USB20_BASE)
+
+// --- BULK IN Endpoint Transfer DMA Polling Demand Control Register ---
+#define CR_USB20_BULK_IN_DMA_POLLING_REG	(0x64 | CR_USB20_BASE)
+
+// --- Bulk OUT Endpoint Transfer Dscriptor Base Address Register ---
+#define CR_USB20_BULK_OUT_DESC_BASE_REG		(0x68 | CR_USB20_BASE)
+
+// --- Bulk IN Endpoint Transfer Dscriptor Base Address Register ---
+#define CR_USB20_BULK_IN_DESC_BASE_REG		(0x6c | CR_USB20_BASE)
+
+// --- Bulk OUT/IN Endpoint Transfer Dscriptor Rinf Size/Offset Register ---
+#define CR_USB20_BULK_DESC_SIZE_OFFSET_REG	(0x70 | CR_USB20_BASE)
+
+// --- Bulk OUT/IN Endpoint Configuration Register ---
+#define CR_USB20_BULK_EP_CONF_REG		(0x74 | CR_USB20_BASE)
+
+// --- Bulk OUT/IN Endpoint DMA Transfer Control Register ---
+#define CR_USB20_BULK_EP_DMA_CTRL_REG          	(0x78 | CR_USB20_BASE)
+
+// --- Bulk OUT/IN Endpoint DMA Transfer Status Register ---
+#define CR_USB20_BULK_EP_DMA_STATUS_REG         (0x7c | CR_USB20_BASE)
+
+// --- UDC Setup Command Address Register ---
+#define CR_USB20_UDC_SETUP_COMMAND_ADDR_REG	(0x80 | CR_USB20_BASE)
+
+// --- UDC Control Endpoint Information Register ---
+#define CR_USB20_UDC_CTRL_EP_INFO_REG          	(0x84 | CR_USB20_BASE)
+
+// --- UDC BULK IN Endpoint Information Register ---
+#define CR_USB20_UDC_BULK_IN_EP_INFO_REG    	(0x88 | CR_USB20_BASE)
+
+// --- UUDC BULK OUT Endpoint Information Register ---
+#define CR_USB20_UDC_BULK_OUT_EP_INFO_REG	(0x8c | CR_USB20_BASE)
+
+// --- UDC INTERRUPT IN Endpoint Information Register ---
+#define CR_USB20_UDC_INTERRUPT_IN_EP_INFO_REG	(0x90 | CR_USB20_BASE)
+
+#if 0
+#define TCSUPPORT_CPU_MT7510_FAKE
+
+#ifdef TCSUPPORT_CPU_MT7510
+#undef DEFAULT_USE_EXT_SWIC
+#endif
+#ifdef TCSUPPORT_CPU_MT7520
+#define DEFAULT_USE_EXT_SWIC
+#endif
+#if defined(TCSUPPORT_CPU_RT65168) || defined(TCSUPPORT_CPU_TC3182)	// for early MT7530 FPGA verification only
+#define DEFAULT_USE_EXT_SWIC
+#endif
+
+#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7520E) || defined(TCSUPPORT_CPU_MT751x20G25G) || defined(TCSUPPORT_CPU_MT7511G) || defined(TCSUPPORT_CPU_MT752025)
+//#define EXT_SWITCH_PHY_CONNECT_INT_MDIO
+
+#ifdef EXT_SWITCH_PHY_CONNECT_INT_MDIO
+#define EXT_SWITCH_PHY_ADDR_OFFSET	(0)
+#define INT_SWITCH_PHY_ADDR_OFFSET	(8)
+
+#endif	//EXT_SWITCH_PHY_CONNECT_INT_MDIO
+
+#endif
+#endif
+#endif /* _TC3162_H_ */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/tc3162/tc3182_int_source.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/tc3182_int_source.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/tc3182_int_source.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/tc3182_int_source.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,67 @@
+/************************************************************************
+ *
+ *	Copyright (C) 2006 Trendchip Technologies, Corp.
+ *	All Rights Reserved.
+ *
+ * Trendchip Confidential; Need to Know only.
+ * Protected as an unpublished work.
+ *
+ * The computer program listings, specifications and documentation
+ * herein are the property of Trendchip Technologies, Co. and shall
+ * not be reproduced, copied, disclosed, or used in whole or in part
+ * for any reason without the prior express written permission of
+ * Trendchip Technologeis, Co.
+ *
+ *************************************************************************/
+
+#ifndef _INT_SOURCE_H_
+#define _INT_SOURCE_H_
+
+enum
+interrupt_source
+	{
+		DUMMY_INT,
+		UART_INT,		//0 	IPL10
+		PTM_B0_INT,		//1
+		SI_SWINT1_INT0,	//2
+		SI_SWINT1_INT1,	//3
+		TIMER0_INT, 	//4 	IPL1
+		TIMER1_INT, 	//5 	IPL5
+		TIMER2_INT, 	//6 	IPL6
+		SI_SWINT_INT0, 	//7
+		SI_SWINT_INT1, 	//8
+		TIMER5_INT, 	//9 	IPL9
+		GPIO_INT,		//10	IPL11
+		RESERVED1,		//11	IPL20
+		SI_PC1_INT, 	//12
+		SI_PC_INT, 		//13
+		APB_DMA0_INT,	//14	IPL12
+		MAC1_INT,		//15	IPL13
+		HSUART_INT,		//16	IPL23
+#if !defined(CONFIG_MIPS_RT63365)
+		RESERVED2,		//17
+#else
+		IRQ_RT3XXX_USB,	//17	IPL24
+#endif
+		DYINGGASP_INT,	//18	IPL25
+		DMT_INT,		//19	IPL26
+		USB20_INT,		//20
+		MAC_INT,		//21	IPL3
+		SAR_INT,		//22	IPL2
+		USB11_INT,
+		PCIE_A_INT,		//24
+		PCIE_SERR_INT,		//25
+		PTM_B1_INT,		//26	IPL15
+		XSLV1_INT,		//27	IPL16
+		USB_INT,		//28	IPL17
+		SI_TIMER1_INT,	//29
+		SI_TIMER_INT,	//30
+		SWR_INT, 		//31	IPL4
+		BUS_TOUT_INT, 	//32
+		RESERVE_A_INT, 	//33
+		RESERVE_B_INT, 	//34
+		RESERVE_C_INT, 	//35
+		AUTO_MANUAL_INT 	//36
+	};
+
+#endif /* _INT_SOURCE_H_ */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/tc3162/TCIfSetQuery_os.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/TCIfSetQuery_os.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/TCIfSetQuery_os.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/TCIfSetQuery_os.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,294 @@
+//******************************************************************************
+//
+// Copyright (C) 2003 TrendChip Technologies Corp.
+//
+// Module name
+// -----------
+// TCIfSetQuery.h
+//
+// Abstract
+// --------
+// This file contains the set and query id definition with ZyNOS
+//              
+// Modification History
+// --------------------
+// Date   : 2003/5/27 Jason
+// Rev.   : 001
+// Modify : 
+//
+//*****************************************************************************
+// $Id: TCIfSetQuery_os.h,v 1.1.1.1 2010/04/09 09:39:21 feiyan Exp $
+// $Log: TCIfSetQuery_os.h,v $
+// Revision 1.1.1.1  2010/04/09 09:39:21  feiyan
+// New TC Linux Make Flow Trunk
+//
+// Revision 1.2  2010/02/03 10:14:31  yuren_nj
+// [Enhancement]#4788 Add tr69 parameters.
+//
+// Revision 1.1.1.1  2009/12/17 01:42:47  josephxu
+// 20091217, from Hinchu ,with VoIP
+//
+// Revision 1.1.1.1  2007/04/12 09:42:03  ian
+// TCLinuxTurnkey2007
+//
+// Revision 1.2  2006/07/06 04:12:45  lino
+// add kernel module support
+//
+// Revision 1.1.1.1  2005/11/02 05:45:38  lino
+// no message
+//
+// Revision 1.2  2005/08/19 14:36:59  jasonlin
+// Merge Huawei's code into new main trunk
+//
+// Revision 1.1.1.1  2005/03/30 14:04:23  jasonlin
+// Import Linos source code
+//
+// Revision 1.8  2005/03/02 06:57:12  jasonlin
+// add extra query function ID for CHINA_NM
+//
+// Revision 1.7  2004/11/10 06:42:04  jasonlin
+// Add CI command "wan adsl opencmf adsl2|adsl2plus"
+//
+// Revision 1.5  2004/11/10 05:40:52  wheellenni
+// wheellenni_931110
+// compatible for the previous firmware
+//
+// Revision 1.4  2004/11/09 08:51:15  wheellenni
+// 931109_wheellenni
+// Add adsl2/adsl2plus to CI command "wan adsl opencmd xxxx"
+// "adsl2" only support G.992.3	and "adsl2plus" support G.992.5
+//
+// Revision 1.3  2004/10/04 12:46:58  bright
+// bright_931004
+//
+// Revision 1.2  2004/09/14 08:50:21  bright
+// bright_930914
+//
+// Revision 1.1.1.1  2004/08/17 07:06:46  jeffrey
+// Import framework code from V3.0.0.
+//
+// Revision 1.1.1.1  2003/08/22 06:19:18  jasonlin
+// no message
+//
+//*****************************************************************************
+
+#ifndef _TCIFSETQUERY_H
+#define _TCIFSETQUERY_H
+
+// ADSL Query ID list   Jason_920527
+#define ADSL_QUERY_MODESET          0x0000              
+#define ADSL_QUERY_MODE             0x0001
+#define ADSL_QUERY_STATUS           0x0002
+#define ADSL_QUERY_SW_VER           0x0003
+#define ADSL_QUERY_VENDOR_ID        0x0004
+#define ADSL_QUERY_NEAR_OP_DATA     0x0005
+#define ADSL_QUERY_FAR_OP_DATA      0x0006
+#define ADSL_QUERY_CH_OP_DATA       0x0007
+#define ADSL_QUERY_DEFECT_CNT       0x0008
+#define ADSL_QUERY_DEFECT           0x0009
+#define ADSL_QUERY_NEAR_ITUID       0x000a
+#define ADSL_QUERY_FAR_ITUID        0x000b
+#define ADSL_QUERY_WATCHDOG         0x000c
+#define ADSL_QUERY_AUTOLINK         0x000d
+#define ADSL_QUERY_CELL_CNT         0x000e
+#define ADSL_QUERY_TX_GAIN          0x000f
+#define ADSL_QUERY_TX_FILTER_TYPE   0x0010
+#define ADSL_QUERY_TX_MEDLEY_TONE   0x0011
+#define ADSL_QUERY_SNR_OFFSET       0x0012
+#define ADSL_QUERY_MIN_SNR_M        0x0013
+#define ADSL_QUERY_FW_VER           0x0014
+#define ADSL_QUERY_FW_REV           0x0015
+#define ADSL_QUERY_TDM_FDM_VER      0x0016
+#define ADSL_QUERY_RTS_LOG_SIZE_STR 0x0017
+#define ADSL_QUERY_RTS_ADDR_STR     0x0018
+#define ADSL_QUERY_RTS_LOG_SIZE     0x0019
+#define ADSL_QUERY_HW_VER           0x001a
+#define ADSL_QUERY_DGASP_CNTR		0x001b
+#define ADSL_QUERY_SHOW_DIAG		0x001c
+//#define ADSL_QUERY_CUSTOMER 		0x001d //bright_930914_1
+#define ADSL_QUERY_BUILD_VERSION	0x001d //bright_930914_1
+#define ADSL_QUERY_ANNEX            0x001e	//julia_070424
+#define ADSL_QUERY_TR69_WLAN_DSL_INTERFACE_Config  0x001f	//jf_070522
+#define ADSL_QUERY_PMS_PARAM        0x0020	//cheng_070727
+#define ADSL_QUERY_TR69_WLAN_DSL_DIAGNOSTIC  0x0021	//dyma_071017
+#define ADSL_QUERY_SHOW_STATE_PARAM        0x0022	//jmxu_071219
+#define ADSL_QUERY_LINERATE      0x0023   //haotang_080416
+#define ADSL_QUERY_TR098_WAN_DSL_INTERFACE_CONFIG 0x0024    //rmzha_080527
+#define ADSL_QUERY_PM_STATE 0x0025  //Roger_090206
+#define ADSL_QUERY_BITSWAP_ONOFF 0x0026//Roger_090206
+
+#define ADSL_QUERY_LAST_DROP_REASON 0x002a    //whliu_090924
+
+#ifdef DADI				//Julia_051117
+#define ADSL_QUERY_ATTAIN_RATE      0x0027	//Julia_051117
+#endif
+#define ADSL_QUERY_CELL_CNT1         0x002b      //zzma_091020
+#define ADSL_QUERY_RX_BEAR_TPSTC_TYPE         0x002c
+
+#if defined(TCSUPPORT_CWMP_VDSL)
+#define VDSL_QUERY_TR098_DSL_INTERFACE_CONFIG 0x2001
+#endif
+
+#define ADSL_QUERY_AFE_DMT_LPBK		0x0033
+#define ADSL_QUERY_AFE_R_W			0x0034//Roger120402
+
+#define TPSTC_DISABLE      			0x00
+#define TPSTC_ATM_TC       			0x01
+#define TPSTC_PTM_TC_64_65B       	0x02
+#define TPSTC_PTM_TC_HDLC       	0x03
+
+#define ADSL_QUERY_SRA_ONOFF 0x0028 //Roger_090206
+#define ADSL_QUERY_PM_ONOFF 0x0029 //Roger_090206
+
+#define ADSL_SET_MODE_A43           0x1000
+#define ADSL_SET_MODE_LITE          0x1001
+#define ADSL_SET_MODE_MULTIMODE     0x1002
+#define ADSL_SET_MODE_ANSI          0x1003
+#define ADSL_SET_MODE_ADSL2         0x1004   // wheellenni_931110
+#define ADSL_SET_MODE_ADSL2PLUS     0x1005   // wheellenni_931110
+#define ADSL_SET_MODE_AUTO_SENSE_GDMT_FIRST   0x1006	//yyfeng_050719
+#define ADSL_SET_MODE_AUTO_SENSE_T1413_FIRST   0x1007	//yyfeng_050719
+#define ADSL_SET_MODE_GDMT_OR_LITE     0x1008	//yyfeng_050719
+#define ADSL_SET_MODE_AUTO_SENSE_T1413_OFF     0x1009	//yyfeng_070210
+#define ADSL_SET_MODE_AUTO_SENSE_ADSL2_OFF     0x100a	//yyfeng_070210
+#define ADSL_SET_MODE_ADSL1_MULTI     0x100b	//yyfeng_070210
+#define ADSL_SET_MODE_ADSL2_MULTI     0x100c	//yyfeng_070210
+#define ADSL_SET_MODE_ADSL2PLUS_T1413 0x100d	// Ryan_961128
+#define ADSL_SET_MODE_VDSL2         0x100e
+#if defined(TCSUPPORT_CWMP_VDSL)
+#define ADSL_SET_MODE_ADSL2PLUS_MULTI	0x100f
+#else
+#endif
+#define ADSL_SET_R_VENDOR_ID        0x1010
+#define ADSL_SET_TX_GAIN            0x1011
+#define ADSL_SET_TX_FILTER_TYPE     0x1012
+#define ADSL_SET_TX_MEDLEY_TONE     0x1013
+#define ADSL_SET_SNR_OFFSET         0x1014
+#define ADSL_SET_MIN_SNR_M          0x1015
+#define ADSL_SET_RTS_LOG_STOP       0x0016
+#define ADSL_SET_RTS_LOG_RESUME     0x0017
+#define ADSL_SET_RTS_LOG_FREE       0x0018
+#define ADSL_SET_R_SOFT_RESET       0x0019
+#define ADSL_SET_DMT_CLOSE          0x001a
+#define ADSL_SET_INT_MASK0          0x001b
+#define ADSL_SET_DGASP_CNTR_ZERO	0x001c		// Gilb_920901_1
+#define ADSL_SET_CONSOLE_DATA		0x001d		// Jason_930315
+#define ADSL_SET_TRELLIS                               0x1100	//yyfeng_050719
+#define ADSL_SET_BITSWAP                              0x1101	//yyfeng_050719
+#define ADSL_SET_PRINT                              0x1102	//jmxu_071219
+#define ADSL_SET_SRA           0X1103  //Roger_090206
+#define ADSL_SET_PM            0X1104 //Roger_090206
+#define ADSL_SET_LDM          0X1105  //Roger_090206
+#define ADSL_SET_DMT_DYING_GASP             0x3000
+/*//yyfeng_060510_1
+#define ADSL_SET_ANNEX_M                                  0x1102          //yyfeng_060424
+#define ADSL_SET_ANNEX                                       0x1103          //yyfeng_060425
+*/
+
+#if defined(TCSUPPORT_CPU_MT7510) && defined(TCSUPPORT_BONDING)
+#define VDSL2_QUERY_BONDING_BACP_SUPPORT    0x2003
+#define TCIF_SET_BONDING_BACP_SUPPORT		0x3001
+#define BONDING_OFF_BACP_OFF    0x0
+#define BONDING_ON_BACP_OFF     0x1
+#define BONDING_OFF_BACP_ON     0x2
+#define BONDING_ON_BACP_ON      0x3
+#endif
+
+
+//julia_070424
+#define         ME_CMD_ADSL_ANNEXA                    0x21
+#define         ME_CMD_ADSL_ANNEXB                    0x22
+#define         ME_CMD_ADSL_ANNEXI                    0x23
+#define         ME_CMD_ADSL_ANNEXJ                    0x24
+#define         ME_CMD_ADSL_ANNEXM                    0x25
+#define         ME_CMD_ADSL_ANNEXL  				  0x26
+//julia_070424
+
+#define ADSL_MODEM_STATE_DOWN       0x00
+#define ADSL_MODEM_STATE_WAIT_INIT  0x08
+#define ADSL_MODEM_STATE_INIT       0x10
+#define ADSL_MODEM_STATE_UP         0x20
+
+#define         ME_CMD_ADSL_SELFTEST1               0x01
+#define         ME_CMD_ADSL_SELFTEST2               0x02
+#define         ME_CMD_ADSL_OPEN                    0x03
+#define         ME_CMD_ADSL_CLOSE                   0x04
+/*
+#define         ME_CMD_ADSL_ANSI                    0x05
+#define         ME_CMD_ADSL_OPEN_GDMT  				0x06
+#define 		ME_CMD_ADSL_OPEN_GLITE 				0x07
+#define 		ME_CMD_ADSL_OPEN_MULTIMODE			0x08
+//xzwang 041103
+#define          ME_CMD_ADSL_OPEN_GDMT_GLITE              0x0B
+*/
+//Jason_930706
+#define    		ME_CMD_ADSL2						0x09
+#define    		ME_CMD_ADSL2PLUS					0x0A
+#define    		ME_CMD_VDSL2						0x0B
+//Sam 20140305
+#define    		ME_CMD_GVECTOR						0x0C
+#define    		ME_CMD_GVECTOR_GINP					0x0D
+#define    		ME_CMD_VDSL2_GINP					0x0E
+#define    		ME_CMD_ADSL2_GINP					0x0F
+#define    		ME_CMD_ADSL2PLUS_GINP					0x10
+
+// add by chenyingbo 2018-05-14 
+#define			ME_CMD_GVECTOR_GINP_US_ONLY			0x11
+#define			ME_CMD_GVECTOR_GINP_DS_ONLY			0x12
+#define			ME_CMD_VDSL2_GINP_US_ONLY			0x13
+#define			ME_CMD_VDSL2_GINP_DS_ONLY			0x14
+
+//xzwang
+#define         ME_CMD_ADSL_ANSI                    0x05
+#define         ME_CMD_ADSL_OPEN_GDMT  				0x06
+#define 		ME_CMD_ADSL_OPEN_GLITE 				0x07
+#define 		ME_CMD_ADSL_OPEN_MULTIMODE		       0x08
+#define         ME_CMD_ADSL_GDMT_OR_LITE                     0x91 //yyfeng_041015_14
+#define         ME_CMD_ADSL_AUTO_GDMT_FIRST              0x92
+#define         ME_CMD_ADSL_AUTO_T1413_FIRST             0x93
+
+void TCIfQuery( unsigned short query_id, void *result1, void *result2 );
+void TCIfSet( unsigned short set_id, void *value1, void *value2 );
+
+typedef struct {
+	void (*query)(unsigned short query_id, void *result1, void *result2);
+	void (*set)(unsigned short set_id, void *value1, void *value2);
+
+	void (*rts_rcv)(struct sk_buff *skb);
+
+	int	(*rts_cmd)(int argc,char *argv[],void *p);
+	int	(*dmt_cmd)(int argc,char *argv[],void *p);
+	int	(*dmt2_cmd)(int argc,char *argv[],void *p);
+	int	(*hw_cmd)(int argc,char *argv[],void *p);
+	int	(*sw_cmd)(int argc,char *argv[],void *p);
+	int	(*ghs_cmd)(int argc,char *argv[],void *p);
+	int	(*tcif_cmd)(int argc,char *argv[],void *p);
+} adsldev_ops;
+
+extern adsldev_ops *adsl_dev_ops;
+void adsl_dev_ops_register(adsldev_ops *ops);
+void adsl_dev_ops_deregister(void);
+#if defined(TCSUPPORT_BONDING)
+extern adsldev_ops *adsl_dev_ops_slave;
+void adsl_dev_ops_register_slave(adsldev_ops *ops);
+void adsl_dev_ops_deregister_slave(void);
+#endif
+
+#if defined(CONFIG_RALINK_VDSL)
+typedef struct {
+	int	(*vdsl2_cmd)(int argc,char *argv[],void *p);
+} vdsldev_ops;
+
+extern vdsldev_ops *vdsl_dev_ops;
+void vdsl_dev_ops_register(vdsldev_ops *ops);
+void vdsl_dev_ops_deregister(void);
+
+#if defined(TCSUPPORT_BONDING)
+extern vdsldev_ops *vdsl_dev_ops_slave;
+void vdsl_dev_ops_register_slave(vdsldev_ops *ops);
+void vdsl_dev_ops_deregister_slave(void);
+#endif
+
+#endif
+
+#endif
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/tc3162/voip_hook.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/voip_hook.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/voip_hook.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/voip_hook.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,5 @@
+#ifndef __VOIP_HOOK_H
+#define __VOIP_HOOK_H
+
+extern unsigned int* (*recv_rtp_src_port_get_hook)(void);
+#endif
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/tc3162/war.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/war.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/war.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/war.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_RALINK_WAR_H
+#define __ASM_MIPS_MACH_RALINK_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	1
+#define MIPS_CACHE_SYNC_WAR		1
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	1
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_RALINK_WAR_H */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/thread_info.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/thread_info.h
--- linux-2.6.36/arch/mips/include/asm/thread_info.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/thread_info.h	2019-03-07 03:40:17.000000000 +0200
@@ -62,8 +62,12 @@ register struct thread_info *__current_t
 
 /* thread information allocation */
 #if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_32BIT)
+#if defined(CONFIG_CPU_TC3162) || defined(CONFIG_MIPS_TC3262)
+#define THREAD_SIZE_ORDER (2)
+#else
 #define THREAD_SIZE_ORDER (1)
 #endif
+#endif
 #if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_64BIT)
 #define THREAD_SIZE_ORDER (2)
 #endif
@@ -88,8 +92,12 @@ register struct thread_info *__current_t
 #ifdef CONFIG_DEBUG_STACK_USAGE
 #define alloc_thread_info(tsk) kzalloc(THREAD_SIZE, GFP_KERNEL)
 #else
+#if defined(CONFIG_CPU_TC3162) || defined(CONFIG_MIPS_TC3262)
+#define alloc_thread_info(tsk) kzalloc(THREAD_SIZE, GFP_KERNEL)
+#else
 #define alloc_thread_info(tsk) kmalloc(THREAD_SIZE, GFP_KERNEL)
 #endif
+#endif
 
 #define free_thread_info(info) kfree(info)
 
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/include/asm/time.h tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/time.h
--- linux-2.6.36/arch/mips/include/asm/time.h	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/include/asm/time.h	2019-03-07 03:40:17.000000000 +0200
@@ -22,6 +22,14 @@
 extern spinlock_t rtc_lock;
 
 /*
+ * Timer interrupt functions.
+ * mips_timer_state is needed for high precision timer calibration.
+ * mips_timer_ack may be NULL if the interrupt is self-recoverable.
+ */
+extern void (*board_time_init)(void);
+extern void (*mips_timer_ack)(void);
+
+/*
  * RTC ops.  By default, they point to weak no-op RTC functions.
  *	rtc_mips_set_time - reverse the above translation and set time to RTC.
  *	rtc_mips_set_mmss - similar to rtc_set_time, but only min and sec need
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/Kbuild tplink-vr300/mtk/linux-2.6.36/arch/mips/Kbuild
--- linux-2.6.36/arch/mips/Kbuild	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/Kbuild	2019-03-07 03:40:18.000000000 +0200
@@ -1,7 +1,7 @@
 # Fail on warnings - also for files referenced in subdirs
 # -Werror can be disabled for specific files using:
 # CFLAGS_<file.o> := -Wno-error
-subdir-ccflags-y := -Werror
+#subdir-ccflags-y := -Werror
 
 # platform specific definitions
 include arch/mips/Kbuild.platforms
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/Kbuild.platforms tplink-vr300/mtk/linux-2.6.36/arch/mips/Kbuild.platforms
--- linux-2.6.36/arch/mips/Kbuild.platforms	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/Kbuild.platforms	2019-03-07 03:40:18.000000000 +0200
@@ -18,6 +18,7 @@ platforms += pmc-sierra
 platforms += pnx833x
 platforms += pnx8550
 platforms += powertv
+platforms += ralink
 platforms += rb532
 platforms += sgi-ip22
 platforms += sgi-ip27
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/Kconfig tplink-vr300/mtk/linux-2.6.36/arch/mips/Kconfig
--- linux-2.6.36/arch/mips/Kconfig	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/Kconfig	2019-03-07 03:40:18.000000000 +0200
@@ -252,6 +252,65 @@ config MIPS_MALTA
 	  This enables support for the MIPS Technologies Malta evaluation
 	  board.
 
+config MIPS_TC3262
+	bool "TrendChip's TC3262 Board"
+	select CPU_MIPSR2_IRQ_VI
+	select CPU_MIPSR2_IRQ_EI
+	select NO_EXCEPT_FILL
+	select BOOT_RAW
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select HW_HAS_PCI
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_CPU_MIPS64_R1
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_MULTITHREADING
+	select TC3162_ADSL
+	select TC3162_IMEM
+	select TC3162_DMEM
+	help
+	  This enables support for TrendChip's TC3262 based board.  
+	  board.
+
+config MIPS_TC3182
+	bool "TrendChip's TC3182 Board"
+	depends on MIPS_TC3262
+	help
+	  This enables support for TrendChip's TC3182 based board.  
+	  board.
+
+config MIPS_RT63165
+	bool "Ralink's RT63165 Board"
+	depends on MIPS_TC3262
+	help
+	  This enables support for Ralink's RT63165 based board.  
+
+config MIPS_RT65168
+	bool "Ralink's RT65168 Board"
+	depends on MIPS_TC3262
+	select RALINK_VDSL
+	help
+	  This enables support for Ralink's RT65168 based board.  
+
+config MIPS_RT63365
+	bool "Ralink's RT63365 Board"
+	depends on MIPS_TC3262
+	help
+	  This enables support for Ralink's RT63365 based board.  
+config MIPS_MT7510
+	bool "MediaTek's MT7510 Board"
+	depends on MIPS_TC3262
+	select RALINK_VDSL
+	help
+	  This enables support for MediaTek's MT7510 based board.  
+	  
 config MIPS_SIM
 	bool 'MIPS simulator (MIPSsim)'
 	select CEVT_R4K
@@ -1053,6 +1112,32 @@ config SNIPROM
 config BOOT_ELF32
 	bool
 
+config MIPS_PATENTFREE
+	bool
+	depends on SYS_HAS_CPU_TC3162
+
+config TC3162_ADSL
+	bool 
+	depends on SYS_HAS_CPU_TC3162
+
+config RALINK_VDSL
+	bool 
+	depends on SYS_HAS_CPU_TC3162
+
+config TC3162_IMEM
+	bool 
+	depends on SYS_HAS_CPU_TC3162
+
+config TC3162_DMEM
+	bool 
+	depends on SYS_HAS_CPU_TC3162
+
+config IMEM_SIZE
+	int
+	default "32768" if MIPS_TC3162U || MIPS_TC3182 || MIPS_TC3262
+	default "16384" if MIPS_TC3162
+	depends on TC3162_IMEM
+
 config MIPS_L1_CACHE_SHIFT
 	int
 	default "4" if MACH_DECSTATION || MIKROTIK_RB532 || PMC_MSP4200_EVAL
@@ -2303,3 +2388,5 @@ source "security/Kconfig"
 source "crypto/Kconfig"
 
 source "lib/Kconfig"
+
+source "pwModel/Kconfig"
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/asm-offsets.s tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/asm-offsets.s
--- linux-2.6.36/arch/mips/kernel/asm-offsets.s	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/asm-offsets.s	2019-03-07 05:06:20.000000000 +0200
@@ -0,0 +1,1134 @@
+	.file	1 "asm-offsets.c"
+	.section .mdebug.abi32
+	.previous
+	.gnu_attribute 4, 3
+
+ # -G value = 0, Arch = mips32r2, ISA = 33
+ # GNU C (Buildroot 2012.05) version 4.3.6 (mips-unknown-linux-uclibc)
+ #	compiled by GNU C version 3.4.6, GMP version 5.0.4, MPFR version 3.1.0-p6.
+ # GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
+ # options passed:  -nostdinc
+ # -I/home/swd/Dev/VR300/linux_mtk_VR300v1/mtk/linux-2.6.36/arch/mips/include
+ # -Iinclude
+ # -I/home/swd/Dev/VR300/linux_mtk_VR300v1/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/
+ # -I/home/swd/Dev/VR300/linux_mtk_VR300v1/mtk/linux-2.6.36/arch/mips/include/asm/mach-generic
+ # -I/home/swd/Dev/VR300/linux_mtk_VR300v1/build/../mtk/global_inc
+ # -I/home/swd/Dev/VR300/linux_mtk_VR300v1/build/../mtk/modules/private/ra_hwnat_7510
+ # -D__KERNEL__ -DVMLINUX_LOAD_ADDRESS=0xffffffff80002000 -DDATAOFFSET=0
+ # -DTCSUPPORT_NEWTOOLCHAIN -DTCSUPPORT_DRIVER_API -DTC3262
+ # -DTCSUPPORT_CPU_RT63365 -DTCSUPPORT_CPU_MT7510 -DTCSUPPORT_CPU_EN7512
+ # -DTCSUPPORT_MT7510_FE -DTCSUPPORT_ADDR_MAPPING -DTCSUPPORT_HWNAT_LED
+ # -DTCSUPPORT_MULTIWAN -DTCSUPPORT_MT7530_SWITCH_API
+ # -DTCSUPPORT_2_6_36_KERNEL -DTCSUPPORT_MT7530_SWITCH_API
+ # -DTCSUPPORT_WAN_ATM -DTCSUPPORT_WAN_PTM -DTCSUPPORT_QDMA_BUFMGR
+ # -DTCSUPPORT_SLM_EN -DTCSUPPORT_BB_NAND -DTCSUPPORT_DDR_CALI
+ # -DSTART_ADDR=0x80002000 -DTCSUPPORT_FREE_BOOTBASE -DTR068_LED
+ # -DTCSUPPORT_I2C -DTCSUPPORT_WLAN -DWSC_AP_SUPPORT -DLED_WPSSPEC_COMPLY
+ # -DIGMP_SNOOP_SUPPORT -DTCSUPPORT_WLAN_GPIO -DMT7592 -DBBUTOWBU
+ # -DTCSUPPORT_WLAN_MT7592 -DMT7612E -DBBUTOWBU -DTCSUPPORT_DUAL_WLAN
+ # -DTCSUPPORT_WLAN_AC -DMTK_CRYPTO_DRIVER -DTCSUPPORT_IPSEC_PASSTHROUGH
+ # -DTCSUPPORT_VPN -DCMD_API -DTCSUPPORT_RA_HWNAT -DTCSUPPORT_IPV6 -DIPV6
+ # -DTCSUPPORT_IPV6_ENHANCEMENT -DTCSUPPORT_DSLITE -DTCSUPPORT_6RD
+ # -DTCSUPPORT_OPT212 -DTCSUPPORT_IPV6_ADVANCE -DTCSUPPORT_IPV6_FIREWALL
+ # -DCONFIG_SYN_COOKIES -DTCSUPPORT_IPV6_FIREWALL_RFC2827
+ # -DTCSUPPORT_IPV6_TELNET -DTCSUPPORT_IPV6_TFTP -DTCSUPPORT_IPV6_FTP
+ # -DTCSUPPORT_IPV6_INETD -DTCSUPPORT_CWMP -DCWMP -DCWMP_MULTI_CA
+ # -DMULTI_CA -DTR111 -DTR143 -DTCSUPPORT_DOWNSTREAM_QOS -DTCSUPPORT_QOS
+ # -DCONFIG_QOS -DTCSUPPORT_IGMP_QOS -DTCSUPPORT_PORTBIND
+ # -DTCSUPPORT_VLAN_TAG -DTCSUPPORT_SNMP -DTCSUPPORT_SNMP_TRUSTIP
+ # -DTCSUPPORT_SNMP_ATMADSL -DTCSUPPORT_SNMP_FULL -DTCSUPPORT_START_TRAP
+ # -DTCSUPPORT_SNMP_V3 -DTCSUPPORT_IPV6_SNMP -DALIAS_IP -DSTATIC_DHCP
+ # -DDHCP_PROFILE -DTCSUPPORT_MLD_SNOOPING -DTCSUPPORT_MLD_PROXY
+ # -DTCSUPPORT_IGMP_SNOOPING -DTCSUPPORT_IGMPSNOOPING_ENHANCE
+ # -DTCSUPPORT_MULTICAST_SPEED -DTCSUPPORT_IGMP_PROXY_V3 -DTCSUPPORT_SMUX
+ # -DTCSUPPORT_LEDKEY -DTCSUPPORT_IGMP_SNOOPING_V3
+ # -DTCSUPPORT_MTD_PARTITIONS_CMDLINE
+ # -DTCSUPPORT_PARTITIONS_CMDLINE_STR="-[tclinux]"
+ # -DTCSUPPORT_MTD_ENCHANCEMENT -DTCSUPPORT_RESERVEAREA_BLOCK=4
+ # -DTCSUPPORT_BACKUPROMFILE -DTCSUPPORT_PRODUCTIONLINE -DTCSUPPORT_DMS
+ # -DTCSUPPORT_DMS_FULL_FORMAT -DTCSUPPORT_WEB_SAVE -DTCSUPPORT_MODEL_CHECK
+ # -DTCSUPPORT_FILTER_DSCP -DTCSUPPORT_DHCP_PORT_FLT -DTCSUPPORT_PPP_AUTHEN
+ # -DTCSUPPORT_UPNP_CERT -DTCSUPPORT_TR069_OPT43 -DTCSUPPORT_SYSLOG_ENHANCE
+ # -DTCSUPPORT_WLAN_8021X -DTCSUPPORT_WLAN_RATELIMIT
+ # -DTCSUPPORT_WEBSERVER_SSL -DTCSUPPORT_SSH -DTCSUPPORT_FW_UPGRADE_16M
+ # -DTCSUPPORT_REMOTE_SYSLOG -DTCSUPPORT_GENERAL_MULTILANGUAGE
+ # -DRA_PARENTALCONTROL -DTCSUPPORT_PARENTAL_URLBLOCK -DRA_ETHERMEDIATYPE
+ # -DTCSUPPORT_SYSLOG -DTCSUPPORT_SAMBA -DTCSUPPORT_RA_GUI
+ # -DTCSUPPORT_MEMORY_CONTROL -DTCSUPPORT_TFTP_UPGRADE_PROTECT
+ # -DTCSUPPORT_MODEL_NAME_CUSKIT -DTCSUPPORT_VPN_SWITCH_GUI
+ # -DTCSUPPORT_LAYER3FORWARD_ENHANCEMENT -DTCSUPPORT_WPA_SUPPLICANT
+ # -DTCSUPPORT_SUPPORT_FLASH -DTCSUPPORT_TEST_LED_ALL
+ # -DTCSUPPORT_WLAN_MAXSTANUM_GUI -DTCSUPPORT_MULTISERVICE_ON_WAN
+ # -DTCSUPPORT_CWMP_VDSL -DTCSUPPORT_AGEOUT_MAC -DTCSUPPORT_OOM_RB_NEXT
+ # -DTCSUPPORT_MT7530_SWITCH_API -DTCSUPPORT_NEW_SPIFLASH
+ # -DTCSUPPORT_DOT11N_SPEC_COMPLY -DTCSUPPORT_HTBW_40M
+ # -DTCSUPPORT_WPA2_PRE_AUTH -DCONFIG_TP_WPS_SHARED_LED
+ # -DINCLUDE_CPU_BIG_ENDIAN -DINCLUDE_MTK_ACCELERATE -DINCLUDE_MTD_TYPE4
+ # -DINCLUDE_FLASH_8M -DINCLUDE_CLI_FULL_FEATURE -DINCLUDE_CHGINIT_PWD
+ # -DINCLUDE_AUTH_PASSWORD -DINCLUDE_EWAN_VLAN -DINCLUDE_DUAL_CONFIG
+ # -DINCLUDE_OPENSSL_1_0_2x -DINCLUDE_ETH_RA -DINCLUDE_LAN_WLAN
+ # -DINCLUDE_WLAN_RA -DINCLUDE_LAN_WLAN_MSSID -DWLAN_VAP_NUM=1
+ # -DINCLUDE_LAN_WLAN_GUESTNETWORK -DINCLUDE_LAN_WLAN_WDS
+ # -DINCLUDE_LAN_WLAN_802_1X -DINCLUDE_LAN_WLAN_DUALBAND
+ # -DINCLUDE_LAN_WLAN_AC -DINCLUDE_LAN_WLAN_SCHEDULE
+ # -DINCLUDE_WIFI_5G_CHIP_MT7612E -DINCLUDE_DNS_PROXY -DINCLUDE_BRIDGING
+ # -DINCLUDE_ADSLWAN -DINCLUDE_VDSLWAN -DINCLUDE_ADSL_RA
+ # -DINCLUDE_ETHERNET_WAN -DINCLUDE_IGMP -DINCLUDE_IPTV -DINCLUDE_IPTV_V2
+ # -DINCLUDE_EWAN_IPTV -DINCLUDE_RU_IPTV -DINCLUDE_RIP -DINCLUDE_SNMP
+ # -DINCLUDE_SSL -DINCLUDE_CWMP -DINCLUDE_CWMP_SSL -DINCLUDE_NEW_WEB_UI_V2
+ # -DINCLUDE_DDNS -DINCLUDE_DYNDNS -DINCLUDE_NOIPDNS
+ # -DINCLUDE_DDNS_USERDEFINE -DINCLUDE_ALG -DINCLUDE_ALG_H323
+ # -DINCLUDE_ALG_SIP -DINCLUDE_ALG_RTSP -DINCLUDE_TC -DINCLUDE_HTTP_SSL
+ # -DINCLUDE_NEW_WEB_UI -DINCLUDE_MIC -DINCLUDE_IPV6 -DINCLUDE_DISABLE_LAN6
+ # -DINCLUDE_IPV6_SLAAC -DINCLUDE_IPV6_HTTP -DINCLUDE_IPV6_FORWARDING_RULE
+ # -DINCLUDE_IPSEC -DINCLUDE_WAN_MODE -DINCLUDE_PPP_HOST_UNIQ -DINCLUDE_ACL
+ # -DINCLUDE_PORTABLE_APP -DINCLUDE_CLOUD -DINCLUDE_CLOUD_V2
+ # -DINCLUDE_WAN_BLOCK -DINCLUDE_WAN_BLOCK_FW_UP_INFO
+ # -DINCLUDE_HOSTNAME_EDITABLE -DINCLUDE_REBOOT_SCHEDULE -DINCLUDE_VPN
+ # -DINCLUDE_MER -DINCLUDE_FACTORY_DEFAULT -DINCLUDE_DHCP_OPT_121
+ # -DINCLUDE_VR300V1_20 -DUSE_FILE_TO_PASS_PPP_ARG -DWEB_INCLUDE_MOBILE_UI
+ # -DINCLUDE_MULTI_LANGUAGE -DINCLUDE_WEB_REGION -DMTD_PART_TYPE=4
+ # -DCONFIG_TP_IMAGE -DINCLUDE_CPU_BIG_ENDIAN -DINCLUDE_MTK_ACCELERATE
+ # -DINCLUDE_MTD_TYPE4 -DINCLUDE_FLASH_8M -DINCLUDE_CLI_FULL_FEATURE
+ # -DINCLUDE_CHGINIT_PWD -DINCLUDE_AUTH_PASSWORD -DINCLUDE_EWAN_VLAN
+ # -DINCLUDE_DUAL_CONFIG -DINCLUDE_OPENSSL_1_0_2x -DINCLUDE_ETH_RA
+ # -DINCLUDE_LAN_WLAN -DINCLUDE_WLAN_RA -DINCLUDE_LAN_WLAN_MSSID
+ # -DWLAN_VAP_NUM=1 -DINCLUDE_LAN_WLAN_GUESTNETWORK -DINCLUDE_LAN_WLAN_WDS
+ # -DINCLUDE_LAN_WLAN_802_1X -DINCLUDE_LAN_WLAN_DUALBAND
+ # -DINCLUDE_LAN_WLAN_AC -DINCLUDE_LAN_WLAN_SCHEDULE
+ # -DINCLUDE_WIFI_5G_CHIP_MT7612E -DINCLUDE_DNS_PROXY -DINCLUDE_BRIDGING
+ # -DINCLUDE_ADSLWAN -DINCLUDE_VDSLWAN -DINCLUDE_ADSL_RA
+ # -DINCLUDE_ETHERNET_WAN -DINCLUDE_IGMP -DINCLUDE_IPTV -DINCLUDE_IPTV_V2
+ # -DINCLUDE_EWAN_IPTV -DINCLUDE_RU_IPTV -DINCLUDE_RIP -DINCLUDE_SNMP
+ # -DINCLUDE_SSL -DINCLUDE_CWMP -DINCLUDE_CWMP_SSL -DINCLUDE_NEW_WEB_UI_V2
+ # -DINCLUDE_DDNS -DINCLUDE_DYNDNS -DINCLUDE_NOIPDNS
+ # -DINCLUDE_DDNS_USERDEFINE -DINCLUDE_ALG -DINCLUDE_ALG_H323
+ # -DINCLUDE_ALG_SIP -DINCLUDE_ALG_RTSP -DINCLUDE_TC -DINCLUDE_HTTP_SSL
+ # -DINCLUDE_NEW_WEB_UI -DINCLUDE_MIC -DINCLUDE_IPV6 -DINCLUDE_DISABLE_LAN6
+ # -DINCLUDE_IPV6_SLAAC -DINCLUDE_IPV6_HTTP -DINCLUDE_IPV6_FORWARDING_RULE
+ # -DINCLUDE_IPSEC -DINCLUDE_WAN_MODE -DINCLUDE_PPP_HOST_UNIQ -DINCLUDE_ACL
+ # -DINCLUDE_PORTABLE_APP -DINCLUDE_CLOUD -DINCLUDE_CLOUD_V2
+ # -DINCLUDE_WAN_BLOCK -DINCLUDE_WAN_BLOCK_FW_UP_INFO
+ # -DINCLUDE_HOSTNAME_EDITABLE -DINCLUDE_REBOOT_SCHEDULE -DINCLUDE_VPN
+ # -DINCLUDE_MER -DINCLUDE_FACTORY_DEFAULT -DINCLUDE_DHCP_OPT_121
+ # -DINCLUDE_VR300V1_20 -DUSE_FILE_TO_PASS_PPP_ARG -DWEB_INCLUDE_MOBILE_UI
+ # -DINCLUDE_MULTI_LANGUAGE -DINCLUDE_WEB_REGION -DKBUILD_STR(s)=#s
+ # -DKBUILD_BASENAME=KBUILD_STR(asm_offsets)
+ # -DKBUILD_MODNAME=KBUILD_STR(asm_offsets) -isystem
+ # /opt/trendchip/mips-linux-uclibc-4.3.6-v2/usr/lib/gcc/mips-unknown-linux-uclibc/4.3.6/include
+ # -include include/generated/autoconf.h -MD
+ # arch/mips/kernel/.asm-offsets.s.d arch/mips/kernel/asm-offsets.c -G 0
+ # -mno-check-zero-division -mabi=32 -mno-abicalls -msoft-float
+ # -march=mips32r2 -mtune=mips32r2 -mllsc -mno-shared -auxbase-strip
+ # arch/mips/kernel/asm-offsets.s -O2 -Wall -Wundef -Wstrict-prototypes
+ # -Wno-trigraphs -Wdeclaration-after-statement -Wno-pointer-sign
+ # -fno-strict-aliasing -fno-common -ffunction-sections -fno-pic
+ # -ffreestanding -fno-stack-protector -fomit-frame-pointer
+ # -fno-strict-overflow -fverbose-asm
+ # options enabled:  -falign-loops -fargument-alias -fauto-inc-dec
+ # -fbranch-count-reg -fcaller-saves -fcprop-registers -fcrossjumping
+ # -fcse-follow-jumps -fdefer-pop -fdelete-null-pointer-checks
+ # -fearly-inlining -feliminate-unused-debug-types
+ # -fexpensive-optimizations -fforward-propagate -ffunction-cse
+ # -ffunction-sections -fgcse -fgcse-lm -fguess-branch-probability -fident
+ # -fif-conversion -fif-conversion2 -finline-functions-called-once
+ # -finline-small-functions -fipa-pure-const -fipa-reference -fivopts
+ # -fkeep-static-consts -fleading-underscore -fmath-errno -fmerge-constants
+ # -fmerge-debug-strings -fmove-loop-invariants -fomit-frame-pointer
+ # -foptimize-register-move -foptimize-sibling-calls -fpcc-struct-return
+ # -fpeephole -fpeephole2 -fregmove -freorder-blocks -freorder-functions
+ # -frerun-cse-after-loop -fsched-interblock -fsched-spec
+ # -fsched-stalled-insns-dep -fschedule-insns -fschedule-insns2
+ # -fsigned-zeros -fsplit-ivs-in-unroller -fsplit-wide-types -fthread-jumps
+ # -ftoplevel-reorder -ftrapping-math -ftree-ccp -ftree-ch -ftree-copy-prop
+ # -ftree-copyrename -ftree-cselim -ftree-dce -ftree-dominator-opts
+ # -ftree-dse -ftree-fre -ftree-loop-im -ftree-loop-ivcanon
+ # -ftree-loop-optimize -ftree-parallelize-loops= -ftree-pre -ftree-reassoc
+ # -ftree-salias -ftree-scev-cprop -ftree-sink -ftree-sra -ftree-store-ccp
+ # -ftree-ter -ftree-vect-loop-version -ftree-vrp -funit-at-a-time
+ # -fverbose-asm -fzero-initialized-in-bss -mdivide-traps -mdouble-float
+ # -meb -mexplicit-relocs -mextern-sdata -mfp-exceptions -mfp32
+ # -mfused-madd -mgp32 -mgpopt -mllsc -mlocal-sdata -mlong32 -mno-mips16
+ # -mno-mips3d -msoft-float -msplit-addresses -muclibc
+
+ # Compiler executable checksum: 5473d803ee373647040f460bca6ba7b9
+
+#APP
+	.macro _ssnop; sll $0, $0, 1; .endm
+	.macro _ehb; sll $0, $0, 3; .endm
+	.macro mtc0_tlbw_hazard; _ehb; .endm
+	.macro tlbw_use_hazard; _ehb; .endm
+	.macro tlb_probe_hazard; _ehb; .endm
+	.macro irq_enable_hazard; _ehb; .endm
+	.macro irq_disable_hazard; _ehb; .endm
+	.macro back_to_back_c0_hazard; _ehb; .endm
+	.macro enable_fpu_hazard; _ehb; .endm
+	.macro disable_fpu_hazard; _ehb; .endm
+		.macro	raw_local_irq_enable				
+	.set	push						
+	.set	reorder						
+	.set	noat						
+	mfc0	$1, $2, 1	# SMTC - clear TCStatus.IXMT	
+	ori	$1, 0x400					
+	xori	$1, 0x400					
+	mtc0	$1, $2, 1					
+	irq_enable_hazard					
+	.set	pop						
+	.endm
+		.macro	raw_local_irq_disable
+	.set	push						
+	.set	noat						
+	mfc0	$1, $2, 1					
+	ori	$1, 0x400					
+	.set	noreorder					
+	mtc0	$1, $2, 1					
+	irq_disable_hazard					
+	.set	pop						
+	.endm							
+
+		.macro	raw_local_save_flags flags			
+	.set	push						
+	.set	reorder						
+	mfc0	\flags, $2, 1					
+	.set	pop						
+	.endm							
+
+		.macro	raw_local_irq_save result			
+	.set	push						
+	.set	reorder						
+	.set	noat						
+	mfc0	\result, $2, 1					
+	ori	$1, \result, 0x400				
+	.set	noreorder					
+	mtc0	$1, $2, 1					
+	andi	\result, \result, 0x400			
+	irq_disable_hazard					
+	.set	pop						
+	.endm							
+
+		.macro	raw_local_irq_restore flags			
+	.set	push						
+	.set	noreorder					
+	.set	noat						
+mfc0	$1, $2, 1						
+andi	\flags, 0x400						
+ori	$1, 0x400						
+xori	$1, 0x400						
+or	\flags, $1						
+mtc0	\flags, $2, 1						
+	irq_disable_hazard					
+	.set	pop						
+	.endm							
+
+#NO_APP
+	.section	.text.output_ptreg_defines,"ax",@progbits
+	.align	2
+	.globl	output_ptreg_defines
+	.ent	output_ptreg_defines
+	.type	output_ptreg_defines, @function
+output_ptreg_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 23 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#MIPS pt_regs offsets.
+ # 0 "" 2
+ # 24 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R0 24 offsetof(struct pt_regs, regs[0])	 #
+ # 0 "" 2
+ # 25 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R1 28 offsetof(struct pt_regs, regs[1])	 #
+ # 0 "" 2
+ # 26 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R2 32 offsetof(struct pt_regs, regs[2])	 #
+ # 0 "" 2
+ # 27 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R3 36 offsetof(struct pt_regs, regs[3])	 #
+ # 0 "" 2
+ # 28 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R4 40 offsetof(struct pt_regs, regs[4])	 #
+ # 0 "" 2
+ # 29 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R5 44 offsetof(struct pt_regs, regs[5])	 #
+ # 0 "" 2
+ # 30 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R6 48 offsetof(struct pt_regs, regs[6])	 #
+ # 0 "" 2
+ # 31 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R7 52 offsetof(struct pt_regs, regs[7])	 #
+ # 0 "" 2
+ # 32 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R8 56 offsetof(struct pt_regs, regs[8])	 #
+ # 0 "" 2
+ # 33 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R9 60 offsetof(struct pt_regs, regs[9])	 #
+ # 0 "" 2
+ # 34 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R10 64 offsetof(struct pt_regs, regs[10])	 #
+ # 0 "" 2
+ # 35 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R11 68 offsetof(struct pt_regs, regs[11])	 #
+ # 0 "" 2
+ # 36 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R12 72 offsetof(struct pt_regs, regs[12])	 #
+ # 0 "" 2
+ # 37 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R13 76 offsetof(struct pt_regs, regs[13])	 #
+ # 0 "" 2
+ # 38 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R14 80 offsetof(struct pt_regs, regs[14])	 #
+ # 0 "" 2
+ # 39 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R15 84 offsetof(struct pt_regs, regs[15])	 #
+ # 0 "" 2
+ # 40 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R16 88 offsetof(struct pt_regs, regs[16])	 #
+ # 0 "" 2
+ # 41 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R17 92 offsetof(struct pt_regs, regs[17])	 #
+ # 0 "" 2
+ # 42 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R18 96 offsetof(struct pt_regs, regs[18])	 #
+ # 0 "" 2
+ # 43 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R19 100 offsetof(struct pt_regs, regs[19])	 #
+ # 0 "" 2
+ # 44 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R20 104 offsetof(struct pt_regs, regs[20])	 #
+ # 0 "" 2
+ # 45 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R21 108 offsetof(struct pt_regs, regs[21])	 #
+ # 0 "" 2
+ # 46 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R22 112 offsetof(struct pt_regs, regs[22])	 #
+ # 0 "" 2
+ # 47 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R23 116 offsetof(struct pt_regs, regs[23])	 #
+ # 0 "" 2
+ # 48 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R24 120 offsetof(struct pt_regs, regs[24])	 #
+ # 0 "" 2
+ # 49 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R25 124 offsetof(struct pt_regs, regs[25])	 #
+ # 0 "" 2
+ # 50 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R26 128 offsetof(struct pt_regs, regs[26])	 #
+ # 0 "" 2
+ # 51 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R27 132 offsetof(struct pt_regs, regs[27])	 #
+ # 0 "" 2
+ # 52 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R28 136 offsetof(struct pt_regs, regs[28])	 #
+ # 0 "" 2
+ # 53 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R29 140 offsetof(struct pt_regs, regs[29])	 #
+ # 0 "" 2
+ # 54 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R30 144 offsetof(struct pt_regs, regs[30])	 #
+ # 0 "" 2
+ # 55 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R31 148 offsetof(struct pt_regs, regs[31])	 #
+ # 0 "" 2
+ # 56 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_LO 160 offsetof(struct pt_regs, lo)	 #
+ # 0 "" 2
+ # 57 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_HI 156 offsetof(struct pt_regs, hi)	 #
+ # 0 "" 2
+ # 61 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_EPC 172 offsetof(struct pt_regs, cp0_epc)	 #
+ # 0 "" 2
+ # 62 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_BVADDR 164 offsetof(struct pt_regs, cp0_badvaddr)	 #
+ # 0 "" 2
+ # 63 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_STATUS 152 offsetof(struct pt_regs, cp0_status)	 #
+ # 0 "" 2
+ # 64 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_CAUSE 168 offsetof(struct pt_regs, cp0_cause)	 #
+ # 0 "" 2
+ # 66 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_TCSTATUS 176 offsetof(struct pt_regs, cp0_tcstatus)	 #
+ # 0 "" 2
+ # 72 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_SIZE 184 sizeof(struct pt_regs)	 #
+ # 0 "" 2
+ # 73 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_ptreg_defines
+	.section	.text.output_task_defines,"ax",@progbits
+	.align	2
+	.globl	output_task_defines
+	.ent	output_task_defines
+	.type	output_task_defines, @function
+output_task_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 78 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#MIPS task_struct offsets.
+ # 0 "" 2
+ # 79 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TASK_STATE 0 offsetof(struct task_struct, state)	 #
+ # 0 "" 2
+ # 80 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TASK_THREAD_INFO 4 offsetof(struct task_struct, stack)	 #
+ # 0 "" 2
+ # 81 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TASK_FLAGS 12 offsetof(struct task_struct, flags)	 #
+ # 0 "" 2
+ # 82 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TASK_MM 184 offsetof(struct task_struct, mm)	 #
+ # 0 "" 2
+ # 83 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TASK_PID 232 offsetof(struct task_struct, pid)	 #
+ # 0 "" 2
+ # 84 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TASK_STRUCT_SIZE 1152 sizeof(struct task_struct)	 #
+ # 0 "" 2
+ # 85 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_task_defines
+	.section	.text.output_thread_info_defines,"ax",@progbits
+	.align	2
+	.globl	output_thread_info_defines
+	.ent	output_thread_info_defines
+	.type	output_thread_info_defines, @function
+output_thread_info_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 90 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#MIPS thread_info offsets.
+ # 0 "" 2
+ # 91 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_TASK 0 offsetof(struct thread_info, task)	 #
+ # 0 "" 2
+ # 92 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_EXEC_DOMAIN 4 offsetof(struct thread_info, exec_domain)	 #
+ # 0 "" 2
+ # 93 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_FLAGS 8 offsetof(struct thread_info, flags)	 #
+ # 0 "" 2
+ # 94 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_TP_VALUE 12 offsetof(struct thread_info, tp_value)	 #
+ # 0 "" 2
+ # 95 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_CPU 16 offsetof(struct thread_info, cpu)	 #
+ # 0 "" 2
+ # 96 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_PRE_COUNT 20 offsetof(struct thread_info, preempt_count)	 #
+ # 0 "" 2
+ # 97 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_ADDR_LIMIT 24 offsetof(struct thread_info, addr_limit)	 #
+ # 0 "" 2
+ # 98 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_RESTART_BLOCK 32 offsetof(struct thread_info, restart_block)	 #
+ # 0 "" 2
+ # 99 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_REGS 72 offsetof(struct thread_info, regs)	 #
+ # 0 "" 2
+ # 100 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_THREAD_SIZE 16384 THREAD_SIZE	 #
+ # 0 "" 2
+ # 101 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_THREAD_MASK 16383 THREAD_MASK	 #
+ # 0 "" 2
+ # 102 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_thread_info_defines
+	.section	.text.output_thread_defines,"ax",@progbits
+	.align	2
+	.globl	output_thread_defines
+	.ent	output_thread_defines
+	.type	output_thread_defines, @function
+output_thread_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 107 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#MIPS specific thread_struct offsets.
+ # 0 "" 2
+ # 108 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG16 504 offsetof(struct task_struct, thread.reg16)	 #
+ # 0 "" 2
+ # 109 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG17 508 offsetof(struct task_struct, thread.reg17)	 #
+ # 0 "" 2
+ # 110 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG18 512 offsetof(struct task_struct, thread.reg18)	 #
+ # 0 "" 2
+ # 111 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG19 516 offsetof(struct task_struct, thread.reg19)	 #
+ # 0 "" 2
+ # 112 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG20 520 offsetof(struct task_struct, thread.reg20)	 #
+ # 0 "" 2
+ # 113 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG21 524 offsetof(struct task_struct, thread.reg21)	 #
+ # 0 "" 2
+ # 114 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG22 528 offsetof(struct task_struct, thread.reg22)	 #
+ # 0 "" 2
+ # 115 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG23 532 offsetof(struct task_struct, thread.reg23)	 #
+ # 0 "" 2
+ # 116 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG29 536 offsetof(struct task_struct, thread.reg29)	 #
+ # 0 "" 2
+ # 117 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG30 540 offsetof(struct task_struct, thread.reg30)	 #
+ # 0 "" 2
+ # 118 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG31 544 offsetof(struct task_struct, thread.reg31)	 #
+ # 0 "" 2
+ # 119 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_STATUS 548 offsetof(struct task_struct, thread.cp0_status)	 #
+ # 0 "" 2
+ # 121 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPU 552 offsetof(struct task_struct, thread.fpu)	 #
+ # 0 "" 2
+ # 123 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_BVADDR 876 offsetof(struct task_struct, thread.cp0_badvaddr)	 #
+ # 0 "" 2
+ # 125 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_BUADDR 880 offsetof(struct task_struct, thread.cp0_baduaddr)	 #
+ # 0 "" 2
+ # 127 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_ECODE 884 offsetof(struct task_struct, thread.error_code)	 #
+ # 0 "" 2
+ # 129 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_TRAMP 888 offsetof(struct task_struct, thread.irix_trampoline)	 #
+ # 0 "" 2
+ # 131 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_OLDCTX 892 offsetof(struct task_struct, thread.irix_oldctx)	 #
+ # 0 "" 2
+ # 133 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_thread_defines
+	.section	.text.output_thread_fpu_defines,"ax",@progbits
+	.align	2
+	.globl	output_thread_fpu_defines
+	.ent	output_thread_fpu_defines
+	.type	output_thread_fpu_defines, @function
+output_thread_fpu_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 138 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR0 552 offsetof(struct task_struct, thread.fpu.fpr[0])	 #
+ # 0 "" 2
+ # 139 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR1 560 offsetof(struct task_struct, thread.fpu.fpr[1])	 #
+ # 0 "" 2
+ # 140 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR2 568 offsetof(struct task_struct, thread.fpu.fpr[2])	 #
+ # 0 "" 2
+ # 141 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR3 576 offsetof(struct task_struct, thread.fpu.fpr[3])	 #
+ # 0 "" 2
+ # 142 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR4 584 offsetof(struct task_struct, thread.fpu.fpr[4])	 #
+ # 0 "" 2
+ # 143 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR5 592 offsetof(struct task_struct, thread.fpu.fpr[5])	 #
+ # 0 "" 2
+ # 144 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR6 600 offsetof(struct task_struct, thread.fpu.fpr[6])	 #
+ # 0 "" 2
+ # 145 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR7 608 offsetof(struct task_struct, thread.fpu.fpr[7])	 #
+ # 0 "" 2
+ # 146 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR8 616 offsetof(struct task_struct, thread.fpu.fpr[8])	 #
+ # 0 "" 2
+ # 147 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR9 624 offsetof(struct task_struct, thread.fpu.fpr[9])	 #
+ # 0 "" 2
+ # 148 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR10 632 offsetof(struct task_struct, thread.fpu.fpr[10])	 #
+ # 0 "" 2
+ # 149 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR11 640 offsetof(struct task_struct, thread.fpu.fpr[11])	 #
+ # 0 "" 2
+ # 150 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR12 648 offsetof(struct task_struct, thread.fpu.fpr[12])	 #
+ # 0 "" 2
+ # 151 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR13 656 offsetof(struct task_struct, thread.fpu.fpr[13])	 #
+ # 0 "" 2
+ # 152 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR14 664 offsetof(struct task_struct, thread.fpu.fpr[14])	 #
+ # 0 "" 2
+ # 153 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR15 672 offsetof(struct task_struct, thread.fpu.fpr[15])	 #
+ # 0 "" 2
+ # 154 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR16 680 offsetof(struct task_struct, thread.fpu.fpr[16])	 #
+ # 0 "" 2
+ # 155 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR17 688 offsetof(struct task_struct, thread.fpu.fpr[17])	 #
+ # 0 "" 2
+ # 156 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR18 696 offsetof(struct task_struct, thread.fpu.fpr[18])	 #
+ # 0 "" 2
+ # 157 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR19 704 offsetof(struct task_struct, thread.fpu.fpr[19])	 #
+ # 0 "" 2
+ # 158 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR20 712 offsetof(struct task_struct, thread.fpu.fpr[20])	 #
+ # 0 "" 2
+ # 159 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR21 720 offsetof(struct task_struct, thread.fpu.fpr[21])	 #
+ # 0 "" 2
+ # 160 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR22 728 offsetof(struct task_struct, thread.fpu.fpr[22])	 #
+ # 0 "" 2
+ # 161 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR23 736 offsetof(struct task_struct, thread.fpu.fpr[23])	 #
+ # 0 "" 2
+ # 162 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR24 744 offsetof(struct task_struct, thread.fpu.fpr[24])	 #
+ # 0 "" 2
+ # 163 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR25 752 offsetof(struct task_struct, thread.fpu.fpr[25])	 #
+ # 0 "" 2
+ # 164 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR26 760 offsetof(struct task_struct, thread.fpu.fpr[26])	 #
+ # 0 "" 2
+ # 165 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR27 768 offsetof(struct task_struct, thread.fpu.fpr[27])	 #
+ # 0 "" 2
+ # 166 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR28 776 offsetof(struct task_struct, thread.fpu.fpr[28])	 #
+ # 0 "" 2
+ # 167 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR29 784 offsetof(struct task_struct, thread.fpu.fpr[29])	 #
+ # 0 "" 2
+ # 168 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR30 792 offsetof(struct task_struct, thread.fpu.fpr[30])	 #
+ # 0 "" 2
+ # 169 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR31 800 offsetof(struct task_struct, thread.fpu.fpr[31])	 #
+ # 0 "" 2
+ # 171 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FCR31 808 offsetof(struct task_struct, thread.fpu.fcr31)	 #
+ # 0 "" 2
+ # 172 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_thread_fpu_defines
+	.section	.text.output_mm_defines,"ax",@progbits
+	.align	2
+	.globl	output_mm_defines
+	.ent	output_mm_defines
+	.type	output_mm_defines, @function
+output_mm_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 177 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#Size of struct page
+ # 0 "" 2
+ # 178 "arch/mips/kernel/asm-offsets.c" 1
+	
+->STRUCT_PAGE_SIZE 32 sizeof(struct page)	 #
+ # 0 "" 2
+ # 179 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+ # 180 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#Linux mm_struct offsets.
+ # 0 "" 2
+ # 181 "arch/mips/kernel/asm-offsets.c" 1
+	
+->MM_USERS 40 offsetof(struct mm_struct, mm_users)	 #
+ # 0 "" 2
+ # 182 "arch/mips/kernel/asm-offsets.c" 1
+	
+->MM_PGD 36 offsetof(struct mm_struct, pgd)	 #
+ # 0 "" 2
+ # 183 "arch/mips/kernel/asm-offsets.c" 1
+	
+->MM_CONTEXT 344 offsetof(struct mm_struct, context)	 #
+ # 0 "" 2
+ # 184 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+ # 185 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PGD_T_SIZE 4 sizeof(pgd_t)	 #
+ # 0 "" 2
+ # 186 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PMD_T_SIZE 4 sizeof(pmd_t)	 #
+ # 0 "" 2
+ # 187 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PTE_T_SIZE 4 sizeof(pte_t)	 #
+ # 0 "" 2
+ # 188 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+ # 189 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PGD_T_LOG2 2 PGD_T_LOG2	 #
+ # 0 "" 2
+ # 193 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PTE_T_LOG2 2 PTE_T_LOG2	 #
+ # 0 "" 2
+ # 194 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+ # 195 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PGD_ORDER 0 PGD_ORDER	 #
+ # 0 "" 2
+ # 199 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PTE_ORDER 0 PTE_ORDER	 #
+ # 0 "" 2
+ # 200 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+ # 201 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PMD_SHIFT 22 PMD_SHIFT	 #
+ # 0 "" 2
+ # 202 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PGDIR_SHIFT 22 PGDIR_SHIFT	 #
+ # 0 "" 2
+ # 203 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+ # 204 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PTRS_PER_PGD 1024 PTRS_PER_PGD	 #
+ # 0 "" 2
+ # 205 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PTRS_PER_PMD 1 PTRS_PER_PMD	 #
+ # 0 "" 2
+ # 206 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PTRS_PER_PTE 1024 PTRS_PER_PTE	 #
+ # 0 "" 2
+ # 207 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_mm_defines
+	.section	.text.output_sc_defines,"ax",@progbits
+	.align	2
+	.globl	output_sc_defines
+	.ent	output_sc_defines
+	.type	output_sc_defines, @function
+output_sc_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 213 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#Linux sigcontext offsets.
+ # 0 "" 2
+ # 214 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_REGS 16 offsetof(struct sigcontext, sc_regs)	 #
+ # 0 "" 2
+ # 215 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_FPREGS 272 offsetof(struct sigcontext, sc_fpregs)	 #
+ # 0 "" 2
+ # 216 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_ACX 528 offsetof(struct sigcontext, sc_acx)	 #
+ # 0 "" 2
+ # 217 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_MDHI 552 offsetof(struct sigcontext, sc_mdhi)	 #
+ # 0 "" 2
+ # 218 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_MDLO 560 offsetof(struct sigcontext, sc_mdlo)	 #
+ # 0 "" 2
+ # 219 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_PC 8 offsetof(struct sigcontext, sc_pc)	 #
+ # 0 "" 2
+ # 220 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_FPC_CSR 532 offsetof(struct sigcontext, sc_fpc_csr)	 #
+ # 0 "" 2
+ # 221 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_FPC_EIR 536 offsetof(struct sigcontext, sc_fpc_eir)	 #
+ # 0 "" 2
+ # 222 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_HI1 568 offsetof(struct sigcontext, sc_hi1)	 #
+ # 0 "" 2
+ # 223 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_LO1 572 offsetof(struct sigcontext, sc_lo1)	 #
+ # 0 "" 2
+ # 224 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_HI2 576 offsetof(struct sigcontext, sc_hi2)	 #
+ # 0 "" 2
+ # 225 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_LO2 580 offsetof(struct sigcontext, sc_lo2)	 #
+ # 0 "" 2
+ # 226 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_HI3 584 offsetof(struct sigcontext, sc_hi3)	 #
+ # 0 "" 2
+ # 227 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_LO3 588 offsetof(struct sigcontext, sc_lo3)	 #
+ # 0 "" 2
+ # 228 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_sc_defines
+	.section	.text.output_signal_defined,"ax",@progbits
+	.align	2
+	.globl	output_signal_defined
+	.ent	output_signal_defined
+	.type	output_signal_defined, @function
+output_signal_defined:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 259 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#Linux signal numbers.
+ # 0 "" 2
+ # 260 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGHUP 1 SIGHUP	 #
+ # 0 "" 2
+ # 261 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGINT 2 SIGINT	 #
+ # 0 "" 2
+ # 262 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGQUIT 3 SIGQUIT	 #
+ # 0 "" 2
+ # 263 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGILL 4 SIGILL	 #
+ # 0 "" 2
+ # 264 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGTRAP 5 SIGTRAP	 #
+ # 0 "" 2
+ # 265 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGIOT 6 SIGIOT	 #
+ # 0 "" 2
+ # 266 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGABRT 6 SIGABRT	 #
+ # 0 "" 2
+ # 267 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGEMT 7 SIGEMT	 #
+ # 0 "" 2
+ # 268 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGFPE 8 SIGFPE	 #
+ # 0 "" 2
+ # 269 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGKILL 9 SIGKILL	 #
+ # 0 "" 2
+ # 270 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGBUS 10 SIGBUS	 #
+ # 0 "" 2
+ # 271 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGSEGV 11 SIGSEGV	 #
+ # 0 "" 2
+ # 272 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGSYS 12 SIGSYS	 #
+ # 0 "" 2
+ # 273 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGPIPE 13 SIGPIPE	 #
+ # 0 "" 2
+ # 274 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGALRM 14 SIGALRM	 #
+ # 0 "" 2
+ # 275 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGTERM 15 SIGTERM	 #
+ # 0 "" 2
+ # 276 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGUSR1 16 SIGUSR1	 #
+ # 0 "" 2
+ # 277 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGUSR2 17 SIGUSR2	 #
+ # 0 "" 2
+ # 278 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGCHLD 18 SIGCHLD	 #
+ # 0 "" 2
+ # 279 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGPWR 19 SIGPWR	 #
+ # 0 "" 2
+ # 280 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGWINCH 20 SIGWINCH	 #
+ # 0 "" 2
+ # 281 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGURG 21 SIGURG	 #
+ # 0 "" 2
+ # 282 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGIO 22 SIGIO	 #
+ # 0 "" 2
+ # 283 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGSTOP 23 SIGSTOP	 #
+ # 0 "" 2
+ # 284 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGTSTP 24 SIGTSTP	 #
+ # 0 "" 2
+ # 285 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGCONT 25 SIGCONT	 #
+ # 0 "" 2
+ # 286 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGTTIN 26 SIGTTIN	 #
+ # 0 "" 2
+ # 287 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGTTOU 27 SIGTTOU	 #
+ # 0 "" 2
+ # 288 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGVTALRM 28 SIGVTALRM	 #
+ # 0 "" 2
+ # 289 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGPROF 29 SIGPROF	 #
+ # 0 "" 2
+ # 290 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGXCPU 30 SIGXCPU	 #
+ # 0 "" 2
+ # 291 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGXFSZ 31 SIGXFSZ	 #
+ # 0 "" 2
+ # 292 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_signal_defined
+	.section	.text.output_irq_cpustat_t_defines,"ax",@progbits
+	.align	2
+	.globl	output_irq_cpustat_t_defines
+	.ent	output_irq_cpustat_t_defines
+	.type	output_irq_cpustat_t_defines, @function
+output_irq_cpustat_t_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 297 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#Linux irq_cpustat_t offsets.
+ # 0 "" 2
+ # 298 "arch/mips/kernel/asm-offsets.c" 1
+	
+->IC_SOFTIRQ_PENDING 0 offsetof(irq_cpustat_t, __softirq_pending)	 #
+ # 0 "" 2
+ # 300 "arch/mips/kernel/asm-offsets.c" 1
+	
+->IC_IRQ_CPUSTAT_T 32 sizeof(irq_cpustat_t)	 #
+ # 0 "" 2
+ # 301 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_irq_cpustat_t_defines
+	.ident	"GCC: (Buildroot 2012.05) 4.3.6"
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/cevt-r4k.c tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/cevt-r4k.c
--- linux-2.6.36/arch/mips/kernel/cevt-r4k.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/cevt-r4k.c	2019-03-07 03:40:15.000000000 +0200
@@ -14,6 +14,7 @@
 #include <asm/smtc_ipi.h>
 #include <asm/time.h>
 #include <asm/cevt-r4k.h>
+#include <asm/tc3162/tc3162.h>
 
 /*
  * The SMTC Kernel for the 34K, 1004K, et. al. replaces several
@@ -47,12 +48,12 @@ DEFINE_PER_CPU(struct clock_event_device
 int cp0_timer_irq_installed;
 
 #ifndef CONFIG_MIPS_MT_SMTC
-
 irqreturn_t c0_compare_interrupt(int irq, void *dev_id)
 {
 	const int r2 = cpu_has_mips_r2;
 	struct clock_event_device *cd;
 	int cpu = smp_processor_id();
+	unsigned int tmp;
 
 	/*
 	 * Suckage alert:
@@ -63,6 +64,16 @@ irqreturn_t c0_compare_interrupt(int irq
 	if (handle_perf_irq(r2))
 		goto out;
 
+	if (isRT63165 || isRT63365 || isMT751020 || isMT7505 || isEN751221) {				
+		if (cpu == 0) {
+			mips_timer_ack();
+		}
+		else{
+			tmp = regRead32(CR_CPUTMR_CNT1) + (mips_hpt_frequency/HZ);
+                        regWrite32(CR_CPUTMR_CMR1, tmp);
+		}
+	}
+
 	/*
 	 * The same applies to performance counter interrupts.  But with the
 	 * above we now know that the reason we got here must be a timer
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/cevt-smtc.c tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/cevt-smtc.c
--- linux-2.6.36/arch/mips/kernel/cevt-smtc.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/cevt-smtc.c	2019-03-07 03:40:15.000000000 +0200
@@ -15,6 +15,7 @@
 #include <asm/smtc_ipi.h>
 #include <asm/time.h>
 #include <asm/cevt-r4k.h>
+#include <asm/tc3162/tc3162.h>
 
 /*
  * Variant clock event timer support for SMTC on MIPS 34K, 1004K
@@ -229,12 +230,20 @@ repeat:
 				goto repeat;
 	}
 }
-
-
+#ifdef TCSUPPORT_XPON_HAL_API_EXT
+extern void resetWatchAlways(void);
+#endif
 irqreturn_t c0_compare_interrupt(int irq, void *dev_id)
 {
 	int cpu = smp_processor_id();
 
+	if (isRT63165 || isRT63365 || isMT751020 || isMT7505 || isEN751221) {				
+		mips_timer_ack();
+	}
+#ifdef TCSUPPORT_XPON_HAL_API_EXT
+	resetWatchAlways();
+#endif
+
 	/* If we're running SMTC, we've got MIPS MT and therefore MIPS32R2 */
 	handle_perf_irq(1);
 
@@ -243,9 +252,77 @@ irqreturn_t c0_compare_interrupt(int irq
 		write_c0_compare(read_c0_compare());
 		smtc_distribute_timer(cpu_data[cpu].vpe_id);
 	}
+ 
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_MIPS_TC3262
+unsigned int mips_hpt_frequency_true;
+unsigned long loops_per_jiffy_true = 0;
+extern unsigned long loops_per_jiffy;
+unsigned long udelay_val_true[NR_CPUS];
+static unsigned long cycles_per_jiffy __read_mostly;
+extern struct clocksource clocksource_mips;
+
+int reset_time_value(int time_shift){
+	u64 temp=0;
+	u32 shift=0;
+	int i=0;
+	unsigned int cpu = smp_processor_id();
+		
+#ifdef DBG
+	printk("cycles_per_jiffy %x\n",cycles_per_jiffy);
+	printk("true mips_hpt_frequency  %x shift %d\n",mips_hpt_frequency_true,time_shift);
+#endif	
+	if(loops_per_jiffy_true == 0){
+		//save correct value
+		if(loops_per_jiffy == (1<<12)){
+			printk("init not over\n");	
+			return -1;
+		}else{
+			loops_per_jiffy_true = loops_per_jiffy;
+			for(i=0;i<NR_CPUS;i++){
+				udelay_val_true[i] = cpu_data[i].udelay_val;
+			}
+		}
+	} 
+#ifdef DBG	
+	printk("true loops_per_jiffie  %x loops_per_jiffie %x\n", loops_per_jiffy_true, loops_per_jiffy);
+#endif
+	local_irq_disable();
+	mips_hpt_frequency = (mips_hpt_frequency_true>>(time_shift));
+#ifdef DBG	
+	printk("After mips_hpt_frequency %x \n",mips_hpt_frequency);
+#endif
+	/* Calculate cache parameters.	*/
+	cycles_per_jiffy = (mips_hpt_frequency + HZ / 2) / HZ;
+#ifdef DBG	
+	printk("cycles_per_jiffy %x\n",cycles_per_jiffy);
+#endif	
+	/* Calclate a somewhat reasonable rating value */
+	clocksource_mips.rating = 200 + mips_hpt_frequency / 10000000;
+	clocksource_set_clock(&clocksource_mips, mips_hpt_frequency);
+
+	//about date
+	clocksource_change_rating(&clocksource_mips, clocksource_mips.rating);
+#ifdef DBG	
+	printk("clocksource_mips.rate %x shift %x mult %x cycle_interval null\n",clocksource_mips.rating,clocksource_mips.shift,clocksource_mips.mult/*,clocksource_mips.cycle_interval*/);
+#endif
+	//about delay
+	for(i=0;i<NR_CPUS;i++){
+		cpu_data[i].udelay_val = (udelay_val_true[i] >> (time_shift));
+	}
+	loops_per_jiffy = loops_per_jiffy_true >> (time_shift) ;
+#ifdef DBG	
+	printk("loops_per_jiffy %x\n",loops_per_jiffy);
+#endif
+	
+	local_irq_enable();
+	
+	return 0;
+}
+EXPORT_SYMBOL(reset_time_value);
+#endif
 
 int __cpuinit smtc_clockevent_init(void)
 {
@@ -258,6 +335,10 @@ int __cpuinit smtc_clockevent_init(void)
 
 	if (!cpu_has_counter || !mips_hpt_frequency)
 		return -ENXIO;
+	cycles_per_jiffy =(mips_hpt_frequency + HZ / 2) / HZ;
+#ifdef CONFIG_MIPS_TC3262 
+	mips_hpt_frequency_true = mips_hpt_frequency;
+#endif	
 	if (cpu == 0) {
 		for (i = 0; i < num_possible_cpus(); i++) {
 			smtc_nextinvpe[i] = 0;
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/cpu-probe.c tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/cpu-probe.c
--- linux-2.6.36/arch/mips/kernel/cpu-probe.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/cpu-probe.c	2019-03-07 03:40:15.000000000 +0200
@@ -25,6 +25,9 @@
 #include <asm/system.h>
 #include <asm/watch.h>
 #include <asm/spram.h>
+#ifdef TCSUPPORT_CPU_EN7512
+#include <asm/tc3162/tc3162.h>
+#endif
 /*
  * Not all of the MIPS CPUs have the "wait" instruction available. Moreover,
  * the implementation of the "wait" feature differs between CPU families. This
@@ -72,6 +75,17 @@ void r4k_wait_irqoff(void)
 	return;
 }
 
+#ifdef TCSUPPORT_CPU_EN7512
+void cpu_wait_en7512(void)
+{
+	volatile unsigned int ram_access = 0;
+	int cnt;
+
+	for (cnt = 0; cnt < 100; cnt++)
+		ram_access = VPint(0xA0000000); /* DRAM access */
+}
+#endif
+
 /*
  * The RM7000 variant has to handle erratum 38.  The workaround is to not
  * have any pending stores when the WAIT instruction is executed.
@@ -201,6 +215,11 @@ void __init check_wait(void)
 		cpu_wait = r4k_wait;
 		if (read_c0_config7() & MIPS_CONF7_WII)
 			cpu_wait = r4k_wait_irqoff;
+	#ifdef TCSUPPORT_CPU_EN7512
+		if (isEN7512){
+			cpu_wait = cpu_wait_en7512;
+		}
+	#endif
 		break;
 
 	case CPU_74K:
@@ -356,6 +375,13 @@ static inline void cpu_probe_legacy(stru
 			c->options |= MIPS_CPU_FPU;
 		c->tlbsize = 64;
 		break;
+	case PRID_IMP_TC3162:
+		c->cputype = CPU_R3000;
+		c->isa_level = MIPS_CPU_ISA_I;
+		c->options = MIPS_CPU_TLB | MIPS_CPU_3K_CACHE |
+		             MIPS_CPU_NOFPUEX;
+		c->tlbsize = 32;
+		break;
 	case PRID_IMP_R4000:
 		if (read_c0_config() & CONF_SC) {
 			if ((c->processor_id & 0xff) >= PRID_REV_R4400) {
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/csrc-r4k.c tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/csrc-r4k.c
--- linux-2.6.36/arch/mips/kernel/csrc-r4k.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/csrc-r4k.c	2019-03-07 03:40:15.000000000 +0200
@@ -15,7 +15,8 @@ static cycle_t c0_hpt_read(struct clocks
 	return read_c0_count();
 }
 
-static struct clocksource clocksource_mips = {
+//static 
+struct clocksource clocksource_mips = {
 	.name		= "MIPS",
 	.read		= c0_hpt_read,
 	.mask		= CLOCKSOURCE_MASK(32),
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/entry.S tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/entry.S
--- linux-2.6.36/arch/mips/kernel/entry.S	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/entry.S	2019-03-07 03:40:15.000000000 +0200
@@ -123,7 +123,7 @@ FEXPORT(restore_partial)		# restore part
 	SAVE_AT
 	SAVE_TEMP
 	LONG_L	v0, PT_STATUS(sp)
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 	and	v0, ST0_IEP
 #else
 	and	v0, ST0_IE
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/genex.S tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/genex.S
--- linux-2.6.36/arch/mips/kernel/genex.S	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/genex.S	2019-03-07 03:40:15.000000000 +0200
@@ -178,7 +178,7 @@ NESTED(handle_int, PT_SIZE, sp)
 	.set	push
 	.set	noat
 	mfc0	k0, CP0_STATUS
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 	and	k0, ST0_IEP
 	bnez	k0, 1f
 
@@ -278,6 +278,7 @@ NESTED(except_vec_vi_handler, 0, sp)
 	 * service routine will have cleared the state, and any active
 	 * level represents a new or otherwised unserviced event...
 	 */
+#ifndef CONFIG_MIPS_TC3262
 	mfc0	t1, CP0_STATUS
 	and	t0, a0, t1
 #ifdef CONFIG_MIPS_MT_SMTC_IM_BACKSTOP
@@ -288,6 +289,7 @@ NESTED(except_vec_vi_handler, 0, sp)
 	xor	t1, t1, t0
 	mtc0	t1, CP0_STATUS
 	_ehb
+#endif
 #endif /* CONFIG_MIPS_MT_SMTC */
 	CLI
 #ifdef CONFIG_TRACE_IRQFLAGS
@@ -512,7 +514,7 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	get_saved_sp	/* k1 := current_thread_info */
 	.set	noreorder
 	MFC0	k0, CP0_EPC
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 	ori	k1, _THREAD_MASK
 	xori	k1, _THREAD_MASK
 	LONG_L	v1, TI_TP_VALUE(k1)
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/irq.c tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/irq.c
--- linux-2.6.36/arch/mips/kernel/irq.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/irq.c	2019-03-07 03:40:15.000000000 +0200
@@ -156,13 +156,14 @@ void __init init_IRQ(void)
  * SMP cross-CPU interrupts have their own specific
  * handlers).
  */
-void __irq_entry do_IRQ(unsigned int irq)
+__IMEM void __irq_entry do_IRQ(int irq)//xflu 20120522
 {
 	irq_enter();
 	__DO_IRQ_SMTC_HOOK(irq);
 	generic_handle_irq(irq);
 	irq_exit();
 }
+EXPORT_SYMBOL(do_IRQ);
 
 #ifdef CONFIG_MIPS_MT_SMTC_IRQAFF
 /*
@@ -170,7 +171,7 @@ void __irq_entry do_IRQ(unsigned int irq
  * IRQ affinity, we have this variant that skips the affinity check.
  */
 
-void __irq_entry do_IRQ_no_affinity(unsigned int irq)
+__IMEM void __irq_entry do_IRQ_no_affinity(unsigned int irq)
 {
 	irq_enter();
 	__NO_AFFINITY_IRQ_SMTC_HOOK(irq);
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/Makefile tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/Makefile
--- linux-2.6.36/arch/mips/kernel/Makefile	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/Makefile	2019-03-07 03:40:15.000000000 +0200
@@ -36,6 +36,7 @@ obj-$(CONFIG_CPU_LOONGSON2)	+= r4k_fpu.o
 obj-$(CONFIG_CPU_MIPS32)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_MIPS64)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R3000)		+= r2300_fpu.o r2300_switch.o
+obj-$(CONFIG_CPU_TC3162)	+= r2300_fpu.o r2300_switch.o
 obj-$(CONFIG_CPU_R4300)		+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R4X00)		+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R5000)		+= r4k_fpu.o r4k_switch.o
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/mips-mt.c tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/mips-mt.c
--- linux-2.6.36/arch/mips/kernel/mips-mt.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/mips-mt.c	2019-03-07 03:40:15.000000000 +0200
@@ -31,7 +31,7 @@ static int __init maxvpes(char *str)
 
 __setup("maxvpes=", maxvpes);
 
-int tclimit;
+int tclimit = 4;
 
 static int __init maxtcs(char *str)
 {
@@ -125,12 +125,108 @@ void mips_mt_regdump(unsigned long mvpct
 	local_irq_restore(flags);
 }
 
+/*
+ * Dump new MIPS MT state for the core. Does not leave TCs halted.
+ * Takes an argument which taken to be a pre-call MVPControl value.
+ */
+
+void mips_mt_regdump_nmi(unsigned long mvpctl)
+{
+	unsigned long flags;
+	unsigned long vpflags;
+	unsigned long mvpconf0;
+	int nvpe;
+	int ntc;
+	int i;
+	int tc;
+	unsigned long haltval;
+	unsigned long tcstatval;
+#ifdef CONFIG_MIPS_MT_SMTC
+	void smtc_soft_dump(void);
+#endif /* CONFIG_MIPT_MT_SMTC */
+
+	local_irq_save(flags);
+	vpflags = dvpe();
+	printk("=== MIPS MT State Dump ===\n");
+	printk("-- Global State --\n");
+	printk("   MVPControl Passed: %08lx\n", mvpctl);
+	printk("   MVPControl Read: %08lx\n", vpflags);
+	printk("   MVPConf0 : %08lx\n", (mvpconf0 = read_c0_mvpconf0()));
+	nvpe = ((mvpconf0 & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT) + 1;
+	ntc = ((mvpconf0 & MVPCONF0_PTC) >> MVPCONF0_PTC_SHIFT) + 1;
+	printk("-- per-VPE State --\n");
+	for (i = 0; i < nvpe; i++) {
+		for (tc = 0; tc < ntc; tc++) {
+			settc(tc);
+			if ((read_tc_c0_tcbind() & TCBIND_CURVPE) == i) {
+				printk("  VPE %d\n", i);
+				printk("   VPEControl : %08lx\n",
+				       read_vpe_c0_vpecontrol());
+				printk("   VPEConf0 : %08lx\n",
+				       read_vpe_c0_vpeconf0());
+				printk("   VPE%d.Status : %08lx\n",
+				       i, read_vpe_c0_status());
+				//printk("   VPE%d.EPC : %08lx %pS\n",
+				//       i, read_vpe_c0_epc(),
+				//       (void *) read_vpe_c0_epc());
+				printk("   VPE%d.EPC : %08lx\n",
+				       i, read_vpe_c0_epc());
+				printk("   VPE%d.Cause : %08lx\n",
+				       i, read_vpe_c0_cause());
+				printk("   VPE%d.Config7 : %08lx\n",
+				       i, read_vpe_c0_config7());
+				break; /* Next VPE */
+			}
+		}
+	}
+	printk("-- per-TC State --\n");
+	for (tc = 0; tc < ntc; tc++) {
+		settc(tc);
+		if (read_tc_c0_tcbind() == read_c0_tcbind()) {
+			/* Are we dumping ourself?  */
+			haltval = 0; /* Then we're not halted, and mustn't be */
+			tcstatval = flags; /* And pre-dump TCStatus is flags */
+			printk("  TC %d (current TC with VPE EPC above)\n", tc);
+		} else {
+			haltval = read_tc_c0_tchalt();
+			write_tc_c0_tchalt(1);
+			tcstatval = read_tc_c0_tcstatus();
+			printk("  TC %d\n", tc);
+		}
+		printk("   TCStatus : %08lx\n", tcstatval);
+		printk("   TCBind : %08lx\n", read_tc_c0_tcbind());
+		//printk("   TCRestart : %08lx %pS\n",
+		//       read_tc_c0_tcrestart(), (void *) read_tc_c0_tcrestart());
+		printk("   TCRestart : %08lx\n",
+		       read_tc_c0_tcrestart());
+		printk("   TCHalt : %08lx\n", haltval);
+		printk("   TCContext : %08lx\n", read_tc_c0_tccontext());
+		if (!haltval)
+			write_tc_c0_tchalt(0);
+	}
+#ifdef CONFIG_MIPS_MT_SMTC
+	smtc_soft_dump();
+#endif /* CONFIG_MIPT_MT_SMTC */
+	printk("===========================\n");
+	evpe(vpflags);
+	local_irq_restore(flags);
+}
+
+
+static int mt_opt_es;
 static int mt_opt_norps;
 static int mt_opt_rpsctl = -1;
 static int mt_opt_nblsu = -1;
 static int mt_opt_forceconfig7;
 static int mt_opt_config7 = -1;
 
+static int __init es_set(char *str)
+{
+	get_option(&str, &mt_opt_es);
+	return 1;
+}
+__setup("es=", es_set);
+
 static int __init rps_disable(char *s)
 {
 	mt_opt_norps = 1;
@@ -209,6 +305,13 @@ void mips_mt_set_cpuoptions(void)
 	unsigned int oconfig7 = read_c0_config7();
 	unsigned int nconfig7 = oconfig7;
 
+	if (mt_opt_es >= 0) {
+		printk("34K sync es set to %d.\n", mt_opt_es);
+		if (mt_opt_es)
+			nconfig7 |= (1 << 8);
+		else
+			nconfig7 &= ~(1 << 8);
+	}
 	if (mt_opt_norps) {
 		printk("\"norps\" option deprectated: use \"rpsctl=\"\n");
 	}
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/mips-mt-fpaff.c tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/mips-mt-fpaff.c
--- linux-2.6.36/arch/mips/kernel/mips-mt-fpaff.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/mips-mt-fpaff.c	2019-03-07 03:40:15.000000000 +0200
@@ -73,6 +73,28 @@ asmlinkage long mipsmt_sys_sched_setaffi
 	if (copy_from_user(&new_mask, user_mask_ptr, sizeof(new_mask)))
 		return -EFAULT;
 
+
+#ifdef CONFIG_MIPS_MT_SMP
+#ifndef CONFIG_MIPS_MT_SMTC
+	printk("\r\n\r\n%s new_mask origin value is %08x\r\n\r\n", __FUNCTION__, *new_mask);
+	if(*(unsigned long *)new_mask == 0x8)
+	{
+		*(unsigned long *)new_mask = 0x2;
+	}
+	else if(*(unsigned long *)new_mask == 0xf)
+	{
+		*(unsigned long *)new_mask = 0x3;
+	}
+	else
+	{
+		*(unsigned long *)new_mask = 0x1;
+	}
+	
+	printk("\r\n\r\n%s new_mask changed value is %08x\r\n\r\n", __FUNCTION__, *new_mask);
+#endif
+#endif
+
+
 	get_online_cpus();
 	rcu_read_lock();
 
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/smp-mt.c tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/smp-mt.c
--- linux-2.6.36/arch/mips/kernel/smp-mt.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/smp-mt.c	2019-03-07 03:40:15.000000000 +0200
@@ -151,6 +151,10 @@ static void vsmp_send_ipi_mask(const str
 
 static void __cpuinit vsmp_init_secondary(void)
 {
+#ifdef CONFIG_MIPS_TC3262
+	write_c0_status((read_c0_status() & ~ST0_IM ) |
+	                (STATUSF_IP0 | STATUSF_IP1)); 
+#else
 	extern int gic_present;
 
 	/* This is Malta specific: IPI,performance and timer inetrrupts */
@@ -160,6 +164,7 @@ static void __cpuinit vsmp_init_secondar
 	else
 		change_c0_status(ST0_IM, STATUSF_IP0 | STATUSF_IP1 |
 					 STATUSF_IP6 | STATUSF_IP7);
+#endif
 }
 
 static void __cpuinit vsmp_smp_finish(void)
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/smtc.c tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/smtc.c
--- linux-2.6.36/arch/mips/kernel/smtc.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/smtc.c	2019-03-07 03:40:15.000000000 +0200
@@ -42,6 +42,9 @@
 #include <asm/addrspace.h>
 #include <asm/smtc.h>
 #include <asm/smtc_proc.h>
+#ifdef CONFIG_MIPS_TC3262
+#include <asm/tc3162/tc3162.h>
+#endif
 
 /*
  * SMTC Kernel needs to manipulate low-level CPU interrupt mask
@@ -100,7 +103,8 @@ unsigned int smtc_status;
 
 /* Boot command line configuration overrides */
 
-static int vpe0limit;
+static int vpe0limit = 3;
+
 static int ipibuffers;
 static int nostlb;
 static int asidmask;
@@ -469,6 +473,12 @@ void smtc_prepare_cpus(int cpus)
 	for (tc = 0, vpe = 0 ; (vpe < nvpe) && (tc < ntc) ; vpe++) {
 		if (tcpervpe[vpe] == 0)
 			continue;
+		/*
+		 * Set the MVP bits.
+		 */
+		settc(tc);
+		write_vpe_c0_vpeconf0(read_vpe_c0_vpeconf0() | VPECONF0_MVP);
+
 		if (vpe != 0)
 			printk(", ");
 		printk("VPE %d: TC", vpe);
@@ -501,10 +511,18 @@ void smtc_prepare_cpus(int cpus)
 			 * Clear ERL/EXL of VPEs other than 0
 			 * and set restricted interrupt enable/mask.
 			 */
+		#ifdef CONFIG_MIPS_TC3262
+			write_vpe_c0_status((read_vpe_c0_status()
+				& ~(ST0_BEV | ST0_ERL | ST0_EXL | ST0_IM))
+				| (STATUSF_IP0 | STATUSF_IP1 | STATUSF_IP2 | STATUSF_IP3 
+				| STATUSF_IP4 | STATUSF_IP5 | STATUSF_IP6 | STATUSF_IP7 
+				| ST0_IE));
+		#else
 			write_vpe_c0_status((read_vpe_c0_status()
 				& ~(ST0_BEV | ST0_ERL | ST0_EXL | ST0_IM))
 				| (STATUSF_IP0 | STATUSF_IP1 | STATUSF_IP7
 				| ST0_IE));
+		#endif
 			/*
 			 * set config to be the same as vpe0,
 			 *  particularly kseg0 coherency alg
@@ -827,7 +846,21 @@ void smtc_send_ipi(int cpu, int type, un
 		settc(cpu_data[cpu].tc_id);
 		write_vpe_c0_cause(read_vpe_c0_cause() | C_SW1);
 		UNLOCK_CORE_PRA();
-	} else {
+	} else {	
+		if (type == IRQ_AFFINITY_IPI) {
+			/* Set up a descriptor, to be delivered either promptly or queued */
+			pipi2 = smtc_ipi_dq(&freeIPIq);
+			if (pipi2 == NULL) {
+				bust_spinlocks(1);
+				mips_mt_regdump(dvpe());
+				panic("IPI Msg. Buffers Depleted\n");
+			}
+			pipi2->type = type;
+			pipi2->arg = (void *)action;
+			pipi2->dest = cpu;
+			smtc_ipi_nq(&IPIQ[cpu], pipi2);
+		}
+
 		/*
 		 * Not sufficient to do a LOCK_MT_PRA (dmt) here,
 		 * since ASID shootdown on the other VPE may
@@ -852,16 +885,18 @@ void smtc_send_ipi(int cpu, int type, un
 			 * loop, we need to force exit from the wait and
 			 * do a direct post of the IPI.
 			 */
-			if (cpu_wait == r4k_wait_irqoff) {
+			//if (cpu_wait == r4k_wait_irqoff) {/* marked for "When set IRQ to bind to specific CPU, the interrupt latency is long" ---xflu @20120823*/
 				tcrestart = read_tc_c0_tcrestart();
 				if (tcrestart >= (unsigned long)r4k_wait_irqoff
 				    && tcrestart < (unsigned long)__pastwait) {
 					write_tc_c0_tcrestart(__pastwait);
 					tcstatus &= ~TCSTATUS_IXMT;
 					write_tc_c0_tcstatus(tcstatus);
+					ehb();//add for sync register R/W, ensure write success bufore read---xflu@20120823
 					goto postdirect;
 				}
-			}
+		//	}//xflu 
+
 			/*
 			 * Otherwise we queue the message for the target TC
 			 * to pick up when he does a local_irq_restore()
@@ -945,7 +980,11 @@ static void __irq_entry smtc_clock_tick_
 {
 	unsigned int cpu = smp_processor_id();
 	struct clock_event_device *cd;
+#ifdef CONFIG_MIPS_TC3262
+	int irq = SI_TIMER_INT;
+#else
 	int irq = MIPS_CPU_IRQ_BASE + 1;
+#endif
 
 	irq_enter();
 	kstat_incr_irqs_this_cpu(irq, irq_to_desc(irq));
@@ -1049,7 +1088,11 @@ void deferred_smtc_ipi(void)
  * interrupts.
  */
 
+#ifdef CONFIG_MIPS_TC3262
+static int cpu_ipi_irq = SI_SWINT_INT1;
+#else
 static int cpu_ipi_irq = MIPS_CPU_IRQ_BASE + MIPS_CPU_IPI_IRQ;
+#endif
 
 static irqreturn_t ipi_interrupt(int irq, void *dev_idm)
 {
@@ -1135,6 +1178,8 @@ static struct irqaction irq_ipi = {
 	.name		= "SMTC_IPI"
 };
 
+extern void tc3162_enable_irq(unsigned int irq);
+
 static void setup_cross_vpe_interrupts(unsigned int nvpe)
 {
 	if (nvpe < 1)
@@ -1143,7 +1188,13 @@ static void setup_cross_vpe_interrupts(u
 	if (!cpu_has_vint)
 		panic("SMTC Kernel requires Vectored Interrupt support");
 
+#ifdef CONFIG_MIPS_TC3262
+	set_vi_handler(SI_SWINT_INT1, ipi_irq_dispatch);
+
+	tc3162_enable_irq(SI_SWINT1_INT1);
+#else
 	set_vi_handler(MIPS_CPU_IPI_IRQ, ipi_irq_dispatch);
+#endif
 
 	setup_irq_smtc(cpu_ipi_irq, &irq_ipi, (0x100 << MIPS_CPU_IPI_IRQ));
 
@@ -1276,6 +1327,21 @@ void smtc_idle_loop_hook(void)
 			}
 		}
 	}
+	/*
+	 * Now that we limit outstanding timer IPIs, check for hung TC
+	 */
+	for (tc = 0; tc < NR_CPUS; tc++) {
+		/* Don't check ourself - we'll dequeue IPIs just below */
+		if ((tc != smp_processor_id()) &&
+		    ipi_timer_latch[tc] > timerq_limit) {
+		    if (clock_hang_reported[tc] == 0) {
+			pdb_msg += sprintf(pdb_msg,
+				"TC %d looks hung with timer latch at %d\n",
+				tc, ipi_timer_latch[tc]);
+			clock_hang_reported[tc]++;
+			}
+		}
+	}
 
 	emt(mtflags);
 	local_irq_restore(flags);
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/spram.c tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/spram.c
--- linux-2.6.36/arch/mips/kernel/spram.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/spram.c	2019-03-07 03:40:15.000000000 +0200
@@ -12,12 +12,84 @@
 #include <linux/kernel.h>
 #include <linux/ptrace.h>
 #include <linux/stddef.h>
+#include <linux/module.h>
 
+#include <asm/cpu.h>
 #include <asm/fpu.h>
 #include <asm/mipsregs.h>
 #include <asm/system.h>
 #include <asm/r4kcache.h>
 #include <asm/hazards.h>
+#ifdef CONFIG_MIPS_TC3262
+#include <asm/tc3162/tc3162.h>
+
+extern int __imem, __dmem;
+#endif
+static char *sram_allocp = NULL;
+static int sram_size = 0;
+static int sram_free = 0;
+
+static char *dspram_p = NULL;
+static int dspram_used_size = 0;
+static int dspram_max_size = 0x1000;	//4K
+int is_sram_addr(void *p)
+{
+	if ((CKSEG1ADDR(p) & 0xffffc000) == (CKSEG1ADDR(DSPRAM_BASE) & 0xffffc000))
+		return 1;
+	else 
+		return 0;
+}
+EXPORT_SYMBOL(is_sram_addr);
+
+void *alloc_sram(int n)
+{
+	if (sram_allocp == NULL)
+		return NULL;
+
+	if (sram_free >= n) {
+		sram_free -= n;
+		sram_allocp += n;
+		printk("alloc_sram p=%p free=%04x\n", sram_allocp, sram_free);
+		return sram_allocp - n;
+	} else 
+		return NULL;
+}
+EXPORT_SYMBOL(alloc_sram);
+
+void free_sram(void *p, int n)
+{
+	if (sram_allocp == (p+n)) {
+		sram_free += n;
+		sram_allocp -= n;
+	}
+	printk("free_sram p=%p free=%04x\n", sram_allocp, sram_free);
+}
+EXPORT_SYMBOL(free_sram);
+
+void write_to_dspram(long  data)
+{
+	if(dspram_p == NULL || dspram_max_size == 0)
+		return;
+
+	
+	*(long *)dspram_p = data;
+	dspram_p += sizeof(long);
+
+	dspram_used_size += sizeof(long);
+
+	if(dspram_used_size >= dspram_max_size){
+		dspram_p = (char *)(DSPRAM_BASE);
+		dspram_used_size = 0;
+	}
+}
+
+unsigned int dspram_base_addr()
+{
+	return DSPRAM_BASE;
+}
+
+
+#define MIPS34K_Index_Store_Data_I	0x0c
 
 /*
  * These definitions are correct for the 24K/34K/74K SPRAM sample
@@ -38,7 +110,7 @@
 /*
  * Different semantics to the set_c0_* function built by __BUILD_SET_C0
  */
-static __cpuinit unsigned int bis_c0_errctl(unsigned int set)
+static unsigned int bis_c0_errctl(unsigned int set)
 {
 	unsigned int res;
 	res = read_c0_errctl();
@@ -46,7 +118,36 @@ static __cpuinit unsigned int bis_c0_err
 	return res;
 }
 
-static __cpuinit void ispram_store_tag(unsigned int offset, unsigned int data)
+static void ispram_store_data(unsigned int offset, unsigned int datalo, unsigned int datahi)
+{
+	unsigned int errctl;
+
+	/* enable SPRAM tag access */
+	errctl = bis_c0_errctl(ERRCTL_SPRAM);
+	ehb();
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+	write_c0_idatalo(datahi);
+	ehb();
+
+	write_c0_idatahi(datalo);
+	ehb();
+#else
+	write_c0_idatalo(datalo);
+	ehb();
+
+	write_c0_idatahi(datahi);
+	ehb();
+#endif
+
+	cache_op(MIPS34K_Index_Store_Data_I, CKSEG0|offset);
+	ehb();
+
+	write_c0_errctl(errctl);
+	ehb();
+}
+
+static void ispram_store_tag(unsigned int offset, unsigned int data)
 {
 	unsigned int errctl;
 
@@ -65,7 +166,7 @@ static __cpuinit void ispram_store_tag(u
 }
 
 
-static __cpuinit unsigned int ispram_load_tag(unsigned int offset)
+static unsigned int ispram_load_tag(unsigned int offset)
 {
 	unsigned int data;
 	unsigned int errctl;
@@ -176,6 +277,7 @@ static __cpuinit void probe_spram(char *
 		if (strcmp(type, "DSPRAM") == 0) {
 			unsigned int *vp = (unsigned int *)(CKSEG1 | pa);
 			unsigned int v;
+			if(!isMT751020 && !isMT7505 && !isEN751221){
 #define TDAT	0x5a5aa5a5
 			vp[0] = TDAT;
 			vp[1] = ~TDAT;
@@ -190,6 +292,18 @@ static __cpuinit void probe_spram(char *
 			if (v != ~TDAT)
 				printk(KERN_ERR "vp=%p wrote=%08x got=%08x\n",
 				       vp+1, ~TDAT, v);
+			}
+#ifdef CONFIG_MIPS_TC3262
+			if (enabled) {
+				if(isMT751020 || isMT7505 || isEN751221){
+					dspram_max_size = size;
+				}
+				else{
+				sram_allocp = (char *) vp;
+				sram_size = sram_free = size;
+				}
+			}
+#endif
 		}
 
 		pr_info("%s%d: PA=%08x,Size=%08x%s\n",
@@ -197,6 +311,36 @@ static __cpuinit void probe_spram(char *
 		offset += 2 * SPRAM_TAG_STRIDE;
 	}
 }
+
+void ispram_fill(void)
+{
+	unsigned int pa, size, tag0, tag1;
+	unsigned int offset;
+	unsigned int datalo, datahi;
+
+	tag0 = ispram_load_tag(0);
+	tag1 = ispram_load_tag(0+SPRAM_TAG_STRIDE);
+
+	pa = tag0 & SPRAM_TAG0_PA_MASK;
+	size = tag1 & SPRAM_TAG1_SIZE_MASK;
+
+	if (size == 0)
+		return;
+
+	for (offset = 0; offset < size; offset += 8) {
+		datalo = *(unsigned int *) (PHYS_TO_K0(pa + offset));
+		datahi = *(unsigned int *) (PHYS_TO_K0(pa + offset + 4));
+		ispram_store_data(offset, datalo, datahi);
+	}
+}
+
+void ispram_refill(void)
+{
+	//probe_spram("ISPRAM", CPHYSADDR(&__imem),
+	//		&ispram_load_tag, &ispram_store_tag);
+	ispram_fill();
+}
+
 void __cpuinit spram_config(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
@@ -209,6 +353,41 @@ void __cpuinit spram_config(void)
 	case CPU_1004K:
 		config0 = read_c0_config();
 		/* FIXME: addresses are Malta specific */
+#ifdef CONFIG_MIPS_TC3262
+#ifdef CONFIG_TC3162_IMEM
+		if (config0 & (1<<24)) {
+			probe_spram("ISPRAM", CPHYSADDR(&__imem),
+				    &ispram_load_tag, &ispram_store_tag);
+			ispram_fill();
+			if (!isRT63165 && !isRT63365 && !isMT751020 && !isMT7505 && !isEN751221)
+				VPint(CR_DMC_ISPCFGR) = (CPHYSADDR(&__imem) & 0xfffff000) | (1<<8) | (0x7);
+		}
+#endif
+#ifdef CONFIG_TC3162_DMEM
+		if (isRT63165 || isRT63365) {
+			VPint(CR_SRAM) = (CPHYSADDR(DSPRAM_BASE) & 0xffffc000) | (1<<0);
+			printk("Enable SRAM=%08lx\n", VPint(CR_SRAM));
+
+			sram_allocp = (char *) CKSEG1ADDR(DSPRAM_BASE);
+			sram_size = sram_free = 0x8000;
+		} else {
+			if (!isTC3182 && !isRT65168) {
+				if (config0 & (1<<23)) {
+					if(isMT751020){
+						probe_spram("DSPRAM", CPHYSADDR(DSPRAM_BASE),
+							&dspram_load_tag, &dspram_store_tag);
+						dspram_p = (char *)(DSPRAM_BASE);
+					}
+					else{
+						probe_spram("DSPRAM", CPHYSADDR(DSPRAM_BASE),
+							&dspram_load_tag, &dspram_store_tag);
+						VPint(CR_DMC_DSPCFGR) = (CPHYSADDR(DSPRAM_BASE) & 0xfffff000) | (1<<8) | (0x7);
+					}
+				}
+			}
+		}
+#endif
+#else
 		if (config0 & (1<<24)) {
 			probe_spram("ISPRAM", 0x1c000000,
 				    &ispram_load_tag, &ispram_store_tag);
@@ -216,5 +395,6 @@ void __cpuinit spram_config(void)
 		if (config0 & (1<<23))
 			probe_spram("DSPRAM", 0x1c100000,
 				    &dspram_load_tag, &dspram_store_tag);
+#endif
 	}
 }
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/time.c tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/time.c
--- linux-2.6.36/arch/mips/kernel/time.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/time.c	2019-03-07 03:40:15.000000000 +0200
@@ -27,7 +27,7 @@
 #include <asm/div64.h>
 #include <asm/smtc_ipi.h>
 #include <asm/time.h>
-
+#include <linux/profile.h>
 /*
  * forward reference
  */
@@ -116,9 +116,78 @@ static __init int cpu_has_mfc0_count_bug
 
 	return 0;
 }
+#if 0 //def CONFIG_MIPS_TC3262
+int reset_time_value(int time_shift){
+	u64 temp;
+	u32 shift;
+	int i;
+	unsigned int cpu;
+	
+#ifdef DBG
+	printk("cycles_per_jiffy %x\n",cycles_per_jiffy);
+	printk("true mips_hpt_frequency  %x shift %d\n",mips_hpt_frequency_true,time_shift);
+#endif	
+	if(loops_per_jiffy_true == 0){
+		//save correct value
+		if(loops_per_jiffy == (1<<12)){
+			printk("init not over\n");	
+			return -1;
+		}else{
+			loops_per_jiffy_true = loops_per_jiffy;
+			for(i=0;i<NR_CPUS;i++){
+				udelay_val_true[i] = cpu_data[i].udelay_val;
+			}
+		}
+	} 
+#ifdef DBG	
+	printk("true loops_per_jiffie  %x loops_per_jiffie %x\n", loops_per_jiffy_true, loops_per_jiffy);
+#endif
+	local_irq_disable();
+	mips_hpt_frequency = (mips_hpt_frequency_true>>(time_shift));
+#ifdef DBG	
+	printk("After mips_hpt_frequency %x \n",mips_hpt_frequency);
+#endif
+	/* Calculate cache parameters.  */
+	cycles_per_jiffy = (mips_hpt_frequency + HZ / 2) / HZ;
+#ifdef DBG	
+	printk("cycles_per_jiffy %x\n",cycles_per_jiffy);
+#endif	
+	/* Calclate a somewhat reasonable rating value */
+	clocksource_mips.rating = 200 + mips_hpt_frequency / 10000000;	
+	/* Find a shift value */
+	for (shift = 32; shift > 0; shift--) {
+		temp = (u64) NSEC_PER_SEC << shift;
+		do_div(temp, mips_hpt_frequency);
+		if ((temp >> 32) == 0)
+			break;
+	}
+	clocksource_mips.shift = shift;
+	clocksource_mips.mult = (u32)temp;
+	//about date
+	clocksource_calculate_interval(&clocksource_mips, NTP_INTERVAL_LENGTH);
+	clocksource_change_rating(&clocksource_mips, clocksource_mips.rating);
+#ifdef DBG	
+	printk("clocksource_mips.rate %x shift %x mult %x cycle_interval %x\n",clocksource_mips.rating,clocksource_mips.shift,clocksource_mips.mult,clocksource_mips.cycle_interval);
+#endif
+	//about delay
+	for(i=0;i<NR_CPUS;i++){
+		cpu_data[i].udelay_val = (udelay_val_true[i] >> (time_shift));
+	}
+	loops_per_jiffy = loops_per_jiffy_true >> (time_shift) ;
+
+	local_irq_enable();
+
+	return 0;
+}
+EXPORT_SYMBOL(reset_time_value);
+#endif
 
+void (*board_time_init)(void);
 void __init time_init(void)
 {
+	if(board_time_init)
+		board_time_init();
+
 	plat_time_init();
 
 	if (!mips_clockevent_init() || !cpu_has_mfc0_count_bug())
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/traps.c tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/traps.c
--- linux-2.6.36/arch/mips/kernel/traps.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/traps.c	2019-03-07 03:40:15.000000000 +0200
@@ -53,6 +53,9 @@
 #include <asm/stacktrace.h>
 #include <asm/irq.h>
 #include <asm/uasm.h>
+#ifdef TCSUPPORT_XPON_HAL_API_EXT
+#include <linux/kallsyms.h>
+#endif
 
 extern void check_wait(void);
 extern asmlinkage void r4k_wait(void);
@@ -113,6 +116,76 @@ static void show_raw_backtrace(unsigned
 	printk("\n");
 }
 
+#define NMI_STACK_LEN	80
+#define NMI_STACK_MAGIC_NUM	0x5abc2312
+
+
+void show_raw_backtrace_nmi(unsigned long sp_start, unsigned long stack_len)
+{
+	unsigned long *sp = (unsigned long *)(sp_start & ~3);
+	unsigned long addr, i = 0;
+
+	printk("Call Trace NMI:");
+#ifdef CONFIG_KALLSYMS
+	printk("\n");
+#endif
+	while (i < stack_len) {
+		unsigned long __user *p =
+			(unsigned long __user *)(unsigned long)sp++;
+		if (__get_user(addr, p)) {
+			printk(" (Bad stack address)");
+			break;
+		}
+		if (__kernel_text_address(addr))
+			print_ip_sym(addr);
+
+		i++;
+	}
+	printk("\n");
+}
+
+void show_stack_nmi()
+{
+	unsigned int dspram_addr = dspram_base_addr();
+	int i, dspram_data_len=NMI_STACK_LEN;
+	unsigned int *p = (unsigned int *)dspram_addr;
+
+	printk("dspram_addr=0x%x\n", dspram_addr);
+
+	if(*p != NMI_STACK_MAGIC_NUM){
+		printk("No NMI Happen!\n");
+		return;
+	}
+	
+	p++;
+	printk("epc   : %08lx %pS\n", *p,
+	       (void *) (*p));
+	p++;
+	printk("ra    : %08lx %pS\n",*p,
+	       (void *) (*p));
+
+	p++;
+	printk("Status: %08x    ", (uint32_t) (*p));
+	p++;
+	printk("Cause : %08x\n", (*p));
+
+	p++;
+
+	while(dspram_data_len){
+		if(dspram_data_len % 8 == 0)
+			printk("\n       ");
+		printk(" %08lx", *p);
+
+		p++;
+		dspram_data_len--;
+	}
+	printk("\n       ");
+
+	show_raw_backtrace_nmi(dspram_base_addr(),NMI_STACK_LEN);
+	
+	
+}
+
 #ifdef CONFIG_KALLSYMS
 int raw_show_trace;
 static int __init set_raw_show_trace(char *str)
@@ -175,6 +248,36 @@ static void show_stacktrace(struct task_
 	show_backtrace(task, regs);
 }
 
+static void show_stacktrace_nmi(struct task_struct *task,
+	const struct pt_regs *regs)
+{
+	const int field = 2 * sizeof(unsigned long);
+	long stackdata;
+	int i;
+	unsigned long __user *sp = (unsigned long __user *)regs->regs[29];
+
+	printk("Stack :");
+	i = 0;
+	while ((unsigned long) sp & (PAGE_SIZE - 1)) {
+		if (i && ((i % (64 / field)) == 0))
+			printk("\n       ");
+		if (i > NMI_STACK_LEN-1) {
+			printk(" ...");
+			break;
+		}
+
+		if (__get_user(stackdata, sp++)) {
+			printk(" (Bad stack address)");
+			break;
+		}
+
+		printk(" %0*lx", field, stackdata);
+		i++;
+	}
+	printk("\n");
+	//show_backtrace(task, regs);
+}
+
 void show_stack(struct task_struct *task, unsigned long *sp)
 {
 	struct pt_regs regs;
@@ -327,6 +430,105 @@ static void __show_regs(const struct pt_
 	       cpu_name_string());
 }
 
+static void __show_regs_nmi(const struct pt_regs *regs)
+{
+	const int field = 2 * sizeof(unsigned long);
+	unsigned int cause = regs->cp0_cause;
+	int i;
+
+	printk("Cpu %d\n", smp_processor_id());
+
+	/*
+	 * Saved main processor registers
+	 */
+	for (i = 0; i < 32; ) {
+		if ((i % 4) == 0)
+			printk("$%2d   :", i);
+		if (i == 0)
+			printk(" %0*lx", field, 0UL);
+		else if (i == 26 || i == 27)
+			printk(" %*s", field, "");
+		else
+			printk(" %0*lx", field, regs->regs[i]);
+
+		i++;
+		if ((i % 4) == 0)
+			printk("\n");
+	}
+
+#ifdef CONFIG_CPU_HAS_SMARTMIPS
+	printk("Acx    : %0*lx\n", field, regs->acx);
+#endif
+	printk("Hi    : %0*lx\n", field, regs->hi);
+	printk("Lo    : %0*lx\n", field, regs->lo);
+
+	/*
+	 * Saved cp0 registers
+	 */
+	//printk("epc   : %0*lx %pS\n", field, regs->cp0_epc,
+	//       (void *) regs->cp0_epc);
+	printk("epc   : %0*lx\n", field, regs->cp0_epc);
+	printk("    %s\n", print_tainted());
+	//printk("ra    : %0*lx %pS\n", field, regs->regs[31],
+	//       (void *) regs->regs[31]);
+	printk("ra    : %0*lx\n", field, regs->regs[31]);
+
+	printk("Status: %08x    ", (uint32_t) regs->cp0_status);
+
+	if (current_cpu_data.isa_level == MIPS_CPU_ISA_I) {
+		if (regs->cp0_status & ST0_KUO)
+			printk("KUo ");
+		if (regs->cp0_status & ST0_IEO)
+			printk("IEo ");
+		if (regs->cp0_status & ST0_KUP)
+			printk("KUp ");
+		if (regs->cp0_status & ST0_IEP)
+			printk("IEp ");
+		if (regs->cp0_status & ST0_KUC)
+			printk("KUc ");
+		if (regs->cp0_status & ST0_IEC)
+			printk("IEc ");
+	} else {
+		if (regs->cp0_status & ST0_KX)
+			printk("KX ");
+		if (regs->cp0_status & ST0_SX)
+			printk("SX ");
+		if (regs->cp0_status & ST0_UX)
+			printk("UX ");
+		switch (regs->cp0_status & ST0_KSU) {
+		case KSU_USER:
+			printk("USER ");
+			break;
+		case KSU_SUPERVISOR:
+			printk("SUPERVISOR ");
+			break;
+		case KSU_KERNEL:
+			printk("KERNEL ");
+			break;
+		default:
+			printk("BAD_MODE ");
+			break;
+		}
+		if (regs->cp0_status & ST0_ERL)
+			printk("ERL ");
+		if (regs->cp0_status & ST0_EXL)
+			printk("EXL ");
+		if (regs->cp0_status & ST0_IE)
+			printk("IE ");
+	}
+	printk("\n");
+
+	printk("Cause : %08x\n", cause);
+
+	cause = (cause & CAUSEF_EXCCODE) >> CAUSEB_EXCCODE;
+	if (1 <= cause && cause <= 5)
+		printk("BadVA : %0*lx\n", field, regs->cp0_badvaddr);
+
+	printk("PrId  : %08x (%s)\n", read_c0_prid(),
+	       cpu_name_string());
+}
+
+
 /*
  * FIXME: really the generic show_regs should take a const pointer argument.
  */
@@ -357,6 +559,29 @@ void show_registers(struct pt_regs *regs
 	printk("\n");
 }
 
+void show_registers_nmi(struct pt_regs *regs)
+{
+	const int field = 2 * sizeof(unsigned long);
+
+	__show_regs_nmi(regs);
+	//print_modules();
+	printk("Process %s (pid: %d, threadinfo=%p, task=%p, tls=%0*lx)\n",
+	       current->comm, current->pid, current_thread_info(), current,
+	      field, current_thread_info()->tp_value);
+	if (cpu_has_userlocal) {
+		unsigned long tls;
+
+		tls = read_c0_userlocal();
+		if (tls != current_thread_info()->tp_value)
+			printk("*HwTLS: %0*lx\n", field, tls);
+	}
+
+	show_stacktrace_nmi(current, regs);
+	//show_code((unsigned int __user *) regs->cp0_epc);
+	printk("\n");
+}
+
+
 static int regs_to_trapnr(struct pt_regs *regs)
 {
 	return (regs->cp0_cause >> 2) & 0x1f;
@@ -401,6 +626,84 @@ void __noreturn die(const char *str, str
 	do_exit(sig);
 }
 
+void nmi_info_store( struct pt_regs *regs)
+{
+	const int field = 2 * sizeof(unsigned long);
+	unsigned int cause = regs->cp0_cause;
+	long stackdata;
+	int i;
+	unsigned long __user *sp = (unsigned long __user *)regs->regs[29];
+	
+	/*Store Magic Number*/
+	write_to_dspram(NMI_STACK_MAGIC_NUM);
+
+	/*Store register value*/
+	write_to_dspram(regs->cp0_epc);
+	write_to_dspram(regs->regs[31]); //ra
+	write_to_dspram((uint32_t) regs->cp0_status);
+	write_to_dspram(cause);
+	
+	/*Store stack data*/
+	i = 0;
+	while ((unsigned long) sp & (PAGE_SIZE - 1)) {
+		if (i > NMI_STACK_LEN-1) {
+			break;
+		}
+
+		if (__get_user(stackdata, sp++)) {
+			//printk(" (Bad stack address)");
+			break;
+		}
+
+		//printk(" %0*lx", field, stackdata);
+		write_to_dspram(stackdata);
+		i++;
+	}
+}
+
+void __noreturn die_nmi(const char *str, struct pt_regs *regs)
+{
+	static int die_counter;
+	int sig = SIGSEGV;
+#ifdef CONFIG_MIPS_MT_SMTC
+	unsigned long dvpret = dvpe();
+#endif /* CONFIG_MIPS_MT_SMTC */
+
+	notify_die(DIE_OOPS, str, regs, 0, regs_to_trapnr(regs), SIGSEGV);
+
+	console_verbose();
+	spin_lock_irq(&die_lock);
+	bust_spinlocks(1);
+#ifdef CONFIG_MIPS_MT_SMTC
+	mips_mt_regdump_nmi(dvpret);
+#endif /* CONFIG_MIPS_MT_SMTC */
+	
+
+	if (notify_die(DIE_OOPS, str, regs, 0, regs_to_trapnr(regs), SIGSEGV) == NOTIFY_STOP)
+		sig = 0;
+
+	printk("%s[#%d]:\n", str, ++die_counter);
+	show_registers_nmi(regs);
+
+	while(1); //waiting for watchdog reboot
+	#if 0
+	add_taint(TAINT_DIE);
+	spin_unlock_irq(&die_lock);
+
+	if (in_interrupt())
+		panic("Fatal exception in interrupt");
+
+	if (panic_on_oops) {
+		printk(KERN_EMERG "Fatal exception: panic in 5 seconds\n");
+		ssleep(5);
+		panic("Fatal exception");
+	}
+
+	do_exit(sig);
+	#endif
+}
+
+
 extern struct exception_table_entry __start___dbe_table[];
 extern struct exception_table_entry __stop___dbe_table[];
 
@@ -1013,6 +1316,152 @@ asmlinkage void do_mdmx(struct pt_regs *
 /*
  * Called with interrupts disabled.
  */
+int watchFlag=0;
+EXPORT_SYMBOL(watchFlag);
+#ifdef TCSUPPORT_XPON_HAL_API_EXT
+volatile int watchOccured = 0;
+volatile int watchLo2Val = 0;
+u32 kmem_cache_alloc_addr = 0;
+u32 kmem_cache_free_addr = 0;
+u32 __slab_alloc_addr = 0;
+u32 __slab_alloc_addr2 = 0;
+u32 deactivate_slab_addr = 0;
+u32 kfree_addr = 0;
+
+void resetWatch(void)
+{
+	if(watchOccured)
+	{
+		u32 val_Hi;
+		u32 val_Lo;
+		u32 *ptr;
+
+		val_Hi = read_c0_watchhi2();
+
+		val_Hi = 0x4000000b;
+		write_c0_watchhi2(val_Hi);
+		write_c0_watchlo2(watchLo2Val);
+		//printk("Reset WATCH exception: write val_Lo %08x val_Hi %08x\r\n", val_Lo, val_Hi);
+
+
+		val_Hi = read_c0_watchhi2();
+		val_Lo = read_c0_watchlo2();
+			
+		//printk("Caught WATCH exception: reread val_Lo %08x val_Hi %08x\r\n", val_Lo, val_Hi);
+		ptr = watchLo2Val & 0xFFFFFFF8;
+		
+		watchOccured = 0;
+		//prom_printf("resetWatch: Caught WATCH exception: resetWatch val_Lo %08x val_Hi %08x ptr %08x, val is %08x\\r\n", 
+		//			val_Lo, val_Hi, ptr, *ptr);
+
+	}
+}
+EXPORT_SYMBOL(resetWatch);
+
+void resetWatchAlways(void)
+{
+	if(watchFlag) {
+	u32 val_Lo;
+	val_Lo = read_c0_watchlo2();
+	if(watchLo2Val && ((val_Lo & 0x7) == 0))
+	{
+		prom_printf("Reset Watch: watchLo2Val %08x\r\n", watchLo2Val);
+		write_c0_watchhi2(0x4000000b);
+		write_c0_watchlo2(watchLo2Val);
+	}
+	}
+}
+
+
+void checkWatch(struct pt_regs *regs)
+{
+	u32 val_Hi;
+	u32 val_Lo;
+	u32 *ptr;
+	u32 findsymbol = 0;
+
+	//val_Hi = read_c0_watchhi2();
+	val_Lo = read_c0_watchlo2();
+
+	watchLo2Val = val_Lo;
+	//ptr = val_Lo & 0xFFFFFFF8;
+
+	//printk("\r\nCaught WATCH exception: val_Lo %08x val_Hi %08x ptr %08x, val is %08x\r\n", val_Lo, val_Hi, ptr, *ptr);
+	if((kmem_cache_alloc_addr != 0) && (regs->cp0_epc == kmem_cache_alloc_addr))
+	{
+		findsymbol = 1;
+	}
+
+	if((kmem_cache_free_addr != 0) && (regs->cp0_epc == kmem_cache_free_addr))
+	{
+		findsymbol = 1;
+	}
+
+	if((__slab_alloc_addr != 0) && (regs->cp0_epc == __slab_alloc_addr))
+	{
+		findsymbol = 1;
+	}
+
+	if((__slab_alloc_addr2 != 0) && (regs->cp0_epc == __slab_alloc_addr2))
+	{
+		findsymbol = 1;
+	}
+	
+	if((deactivate_slab_addr != 0) && (regs->cp0_epc == deactivate_slab_addr))
+	{
+		findsymbol = 1;
+	}
+
+	if((kfree_addr != 0) && (regs->cp0_epc == kfree_addr))
+	{
+		findsymbol = 1;
+	}
+
+	if(findsymbol == 0)
+	{
+		char buffer[KSYM_SYMBOL_LEN] = {0};
+		memset(buffer, 0, KSYM_SYMBOL_LEN);
+		sprint_symbol(buffer, regs->cp0_epc);
+		printk("epc %08x, func %s\r\n", regs->cp0_epc, buffer);
+		if((kmem_cache_alloc_addr == 0) && strstr(buffer, "kmem_cache_alloc+"))
+		{
+			kmem_cache_alloc_addr = regs->cp0_epc;
+			printk("kmem_cache_alloc_addr is %08x\r\n", kmem_cache_alloc_addr);
+		}
+		else if((kmem_cache_free_addr == 0) && strstr(buffer, "kmem_cache_free+"))
+		{
+			kmem_cache_free_addr = regs->cp0_epc;
+			printk("kmem_cache_free_addr is %08x\r\n", kmem_cache_free_addr);
+		}
+		else if((__slab_alloc_addr == 0) && strstr(buffer, "__slab_alloc+"))
+		{
+			__slab_alloc_addr = regs->cp0_epc;
+			printk("__slab_alloc_addr is %08x\r\n", __slab_alloc_addr);
+		}
+		else if((__slab_alloc_addr2 == 0) && strstr(buffer, "__slab_alloc+"))
+		{
+			__slab_alloc_addr2 = regs->cp0_epc;
+			printk("__slab_alloc_addr2 is %08x\r\n", __slab_alloc_addr2);
+		}
+		else if((deactivate_slab_addr == 0) && strstr(buffer, "deactivate_slab+"))
+		{
+			deactivate_slab_addr = regs->cp0_epc;
+			printk("deactivate_slab_addr is %08x\r\n", deactivate_slab_addr);
+		}
+		else if((kfree_addr == 0) && strstr(buffer, "kfree+"))
+		{
+			kfree_addr = regs->cp0_epc;
+			printk("kfree_addr is %08x\r\n", kfree_addr);
+		}
+		else
+		{
+			show_registers(regs);
+		}
+
+	}
+
+}
+#endif
 asmlinkage void do_watch(struct pt_regs *regs)
 {
 	u32 cause;
@@ -1021,10 +1470,25 @@ asmlinkage void do_watch(struct pt_regs
 	 * Clear WP (bit 22) bit of cause register so we don't loop
 	 * forever.
 	 */
+	 #ifdef TCSUPPORT_XPON_HAL_API_EXT
+	 if(0){
+	 #else
+	 if(watchFlag){
+	 #endif
+	 dump_tlb_all();
+	 show_registers(regs);	 	 
+	 //show_regs(regs);
+	//compute_return_epc(regs);
+	panic("Caught WATCH exception - probably caused by stack overflow\n");
+		return;
+	}
+	else{
 	cause = read_c0_cause();
 	cause &= ~(1 << 22);
 	write_c0_cause(cause);
-
+	#ifdef TCSUPPORT_XPON_HAL_API_EXT
+		checkWatch(regs);
+	#endif
 	/*
 	 * If the current thread has the watch registers loaded, save
 	 * their values and send SIGTRAP.  Otherwise another thread
@@ -1038,6 +1502,10 @@ asmlinkage void do_watch(struct pt_regs
 		mips_clear_watch_registers();
 		local_irq_enable();
 	}
+	#ifdef TCSUPPORT_XPON_HAL_API_EXT
+		watchOccured = 1;
+	#endif
+	}
 }
 
 asmlinkage void do_mcheck(struct pt_regs *regs)
@@ -1300,8 +1768,10 @@ void ejtag_exception_handler(struct pt_r
 NORET_TYPE void ATTRIB_NORET nmi_exception_handler(struct pt_regs *regs)
 {
 	bust_spinlocks(1);
+	nmi_info_store(regs);
 	printk("NMI taken!!!!\n");
-	die("NMI", regs);
+	//die("NMI", regs);
+	die_nmi("NMI", regs);
 }
 
 #define VECTORSPACING 0x100	/* for EI/VI mode */
@@ -1404,10 +1874,15 @@ static void *set_vi_srs_handler(int n, v
 
 		memcpy(b, vec_start, handler_len);
 #ifdef CONFIG_MIPS_MT_SMTC
+		if (!cpu_has_veic) 
 		BUG_ON(n > 7);	/* Vector index %d exceeds SMTC maximum. */
 
 		w = (u32 *)(b + mori_offset);
+#ifdef CONFIG_MIPS_TC3262
+		*w = (*w & 0xffff0000) | (n);
+#else
 		*w = (*w & 0xffff0000) | (0x100 << n);
+#endif
 #endif /* CONFIG_MIPS_MT_SMTC */
 		w = (u32 *)(b + lui_offset);
 		*w = (*w & 0xffff0000) | (((u32)handler >> 16) & 0xffff);
@@ -1437,6 +1912,7 @@ void *set_vi_handler(int n, vi_handler_t
 {
 	return set_vi_srs_handler(n, addr, 0);
 }
+EXPORT_SYMBOL(set_vi_handler);
 
 extern void cpu_cache_init(void);
 extern void tlb_init(void);
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/vmlinux.lds.S tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/vmlinux.lds.S
--- linux-2.6.36/arch/mips/kernel/vmlinux.lds.S	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/vmlinux.lds.S	2019-03-07 03:40:15.000000000 +0200
@@ -4,6 +4,10 @@
 
 #undef mips
 #define mips mips
+#if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+#undef CONFIG_IMEM_SIZE
+#define CONFIG_IMEM_SIZE 65536
+#endif
 OUTPUT_ARCH(mips)
 ENTRY(kernel_entry)
 PHDRS {
@@ -51,7 +55,21 @@ SECTIONS
 		*(.fixup)
 		*(.gnu.warning)
 	} :text = 0
+
+#ifdef CONFIG_TC3162_IMEM
+#ifdef CONFIG_CPU_TC3162
+  	. = ALIGN(16384);
+#else
+  	. = ALIGN(32768);
+#endif
+  	__imem = . ;
+  	.imem_text : { *(.imem_text) }
+  	_imem_end = .;
+  	_etext = (__imem + CONFIG_IMEM_SIZE) > . ? (__imem + CONFIG_IMEM_SIZE) : .;
+  	. = _etext;
+#else
 	_etext = .;	/* End of text section */
+#endif  
 
 	EXCEPTION_TABLE(16)
 
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/kernel/vpe.c tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/vpe.c
--- linux-2.6.36/arch/mips/kernel/vpe.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/kernel/vpe.c	2019-03-07 03:40:15.000000000 +0200
@@ -148,9 +148,9 @@ struct {
 	spinlock_t tc_list_lock;
 	struct list_head tc_list;	/* Thread contexts */
 } vpecontrol = {
-	.vpe_list_lock	= SPIN_LOCK_UNLOCKED,
+	.vpe_list_lock	= __SPIN_LOCK_UNLOCKED(vpecontrol.vpe_list_lock),
 	.vpe_list	= LIST_HEAD_INIT(vpecontrol.vpe_list),
-	.tc_list_lock	= SPIN_LOCK_UNLOCKED,
+	.tc_list_lock	= __SPIN_LOCK_UNLOCKED(vpecontrol.tc_list_lock),
 	.tc_list	= LIST_HEAD_INIT(vpecontrol.tc_list)
 };
 
@@ -192,7 +192,7 @@ static struct tc *get_tc(int index)
 	}
 	spin_unlock(&vpecontrol.tc_list_lock);
 
-	return NULL;
+	return res;//modify by xfu seams like a bug
 }
 
 /* allocate a vpe and associate it with this minor (or index) */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/mm/cache.c tplink-vr300/mtk/linux-2.6.36/arch/mips/mm/cache.c
--- linux-2.6.36/arch/mips/mm/cache.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/mm/cache.c	2019-03-07 03:40:15.000000000 +0200
@@ -51,6 +51,7 @@ void (*_dma_cache_wback_inv)(unsigned lo
 void (*_dma_cache_wback)(unsigned long start, unsigned long size);
 void (*_dma_cache_inv)(unsigned long start, unsigned long size);
 
+EXPORT_SYMBOL(_dma_cache_inv);
 EXPORT_SYMBOL(_dma_cache_wback_inv);
 
 #endif /* CONFIG_DMA_NONCOHERENT */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/mm/c-r4k.c tplink-vr300/mtk/linux-2.6.36/arch/mips/mm/c-r4k.c
--- linux-2.6.36/arch/mips/mm/c-r4k.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/mm/c-r4k.c	2019-03-07 03:40:15.000000000 +0200
@@ -595,7 +595,7 @@ static void r4k_flush_icache_range(unsig
 
 #ifdef CONFIG_DMA_NONCOHERENT
 
-static void r4k_dma_cache_wback_inv(unsigned long addr, unsigned long size)
+__IMEM static void r4k_dma_cache_wback_inv(unsigned long addr, unsigned long size)
 {
 	/* Catch bad driver code */
 	BUG_ON(size == 0);
@@ -623,7 +623,7 @@ static void r4k_dma_cache_wback_inv(unsi
 	bc_wback_inv(addr, size);
 }
 
-static void r4k_dma_cache_inv(unsigned long addr, unsigned long size)
+__IMEM static void r4k_dma_cache_inv(unsigned long addr, unsigned long size)
 {
 	/* Catch bad driver code */
 	BUG_ON(size == 0);
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/mm/c-tc3162.c tplink-vr300/mtk/linux-2.6.36/arch/mips/mm/c-tc3162.c
--- linux-2.6.36/arch/mips/mm/c-tc3162.c	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/mm/c-tc3162.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,318 @@
+/*
+ * Cache operations for the TC3162
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <asm/mipsregs.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+#include <asm/mmu_context.h>
+#include <asm/isadep.h>
+#include <asm/io.h>
+#include <asm/wbflush.h>
+#include <asm/cpu.h>
+#include <asm/asm.h>
+#include <asm/cacheops.h>
+
+#include <asm/r4kcache.h>
+
+/**
+ * The icace and dcache size variables are currently set to hard values,
+ * as there is no way to size the Lexra caches through software.
+ */
+unsigned long icache_size, dcache_size;
+__DMEM unsigned long icache_lsize, dcache_lsize;
+
+extern int r3k_have_wired_reg;	/* in r3k-tlb.c */
+
+static inline void tc3162_blast_dcache_page(unsigned long addr)
+{
+	blast_dcache16_page(addr);
+}
+
+static inline void tc3162_blast_icache(void)
+{
+	unsigned int controlReg;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	controlReg = read_c0_cctl();
+
+	write_c0_cctl(controlReg & ~CCTL_IINVAL);
+	write_c0_cctl(controlReg | CCTL_IINVAL);
+
+	/* delay to allow cache to be flushed */
+	__asm__ __volatile__(".set\tnoreorder\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t" "nop\n\t" ".set\treorder\n\t");
+
+	write_c0_cctl(controlReg);
+	local_irq_restore(flags);
+}
+
+static void tc3162_blast_dcache(void)
+{
+	unsigned int controlReg;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	controlReg = read_c0_cctl();
+
+	write_c0_cctl(controlReg & ~CCTL_DWBINVAL);
+	write_c0_cctl(controlReg | CCTL_DWBINVAL);
+
+	/* delay to allow cache to be flushed */
+	__asm__ __volatile__(".set\tnoreorder\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t" "nop\n\t" ".set\treorder\n\t");
+
+	write_c0_cctl(controlReg);
+	local_irq_restore(flags);
+}
+
+static void tc3162_flush_icache_all(void)
+{
+	tc3162_blast_icache();
+}
+
+static inline void tc3162_blast_icache_page(unsigned long addr)
+{
+	tc3162_blast_icache();
+}
+
+static inline void tc3162_flush_cache_all(void)
+{
+	if (!cpu_has_dc_aliases)
+		return;
+
+	tc3162_blast_dcache();
+}
+
+static inline void tc3162___flush_cache_all(void)
+{
+	tc3162_blast_dcache();
+	tc3162_blast_icache();
+}
+
+static void tc3162_flush_cache_mm(struct mm_struct *mm)
+{
+	if (!cpu_has_dc_aliases)
+		return;
+
+	if (cpu_context(smp_processor_id(), mm) != 0)
+		tc3162_blast_dcache();
+}
+
+static void tc3162_flush_cache_range(struct vm_area_struct *vma,
+	unsigned long start, unsigned long end)
+{
+	if (!cpu_has_dc_aliases)
+		return;
+	if (!(cpu_context(smp_processor_id(), vma->vm_mm)))
+		return;
+
+	tc3162_blast_dcache();
+}
+
+static void tc3162_flush_cache_page(struct vm_area_struct *vma, unsigned long page, unsigned long pfn)
+{
+	int exec = vma->vm_flags & VM_EXEC;
+	struct mm_struct *mm = vma->vm_mm;
+	pgd_t *pgdp;
+	pud_t *pudp;
+	pmd_t *pmdp;
+	pte_t *ptep;
+
+	/*
+	 * If ownes no valid ASID yet, cannot possibly have gotten
+	 * this page into the cache.
+	 */
+	if (cpu_context(smp_processor_id(), mm) == 0)
+		return;
+
+	page &= PAGE_MASK;
+	pgdp = pgd_offset(mm, page);
+	pudp = pud_offset(pgdp, page);
+	pmdp = pmd_offset(pudp, page);
+	ptep = pte_offset(pmdp, page);
+
+	/*
+	 * If the page isn't marked valid, the page cannot possibly be
+	 * in the cache.
+	 */
+	if (!(pte_val(*ptep) & _PAGE_PRESENT))
+		return;
+
+	/*
+	 * Doing flushes for another ASID than the current one is
+	 * too difficult since stupid R4k caches do a TLB translation
+	 * for every cache flush operation.  So we do indexed flushes
+	 * in that case, which doesn't overly flush the cache too much.
+	 */
+	if ((mm == current->active_mm) && (pte_val(*ptep) & _PAGE_VALID)) {
+		if (cpu_has_dc_aliases || exec)
+			tc3162_blast_dcache_page(page);
+		if (exec)
+			tc3162_blast_icache_page(page);
+
+		return;
+	}
+}
+
+static void local_tc3162_flush_data_cache_page(void * addr)
+{
+	tc3162_blast_dcache_page((unsigned long)addr);
+}
+
+static void tc3162_flush_data_cache_page(unsigned long addr)
+{
+	tc3162_blast_dcache_page(addr);
+}
+
+static void tc3162_flush_icache_range(unsigned long start, unsigned long end)
+{
+	protected_blast_dcache_range(start, end);
+	tc3162_blast_icache();
+}
+
+static void tc3162_flush_cache_sigtramp(unsigned long addr)
+{
+	protected_writeback_dcache_line(addr & ~(dcache_lsize - 1)); 
+	tc3162_blast_icache();
+}
+
+static void tc3162_dma_cache_wback_inv(unsigned long addr, unsigned long size)
+{
+#if 1
+	blast_dcache_range(addr, addr + size);
+#else
+	unsigned long end;
+
+	if (((size | addr) & (PAGE_SIZE - 1)) == 0) {
+		end = addr + size;
+		do {
+			tc3162_blast_dcache_page(addr);
+			addr += PAGE_SIZE;
+		} while(addr != end);
+	} else if (size > dcache_size) {
+		tc3162_blast_dcache();
+	} else {
+		blast_dcache_range(addr, addr + size);
+	}
+#endif
+}
+
+static void tc3162_dma_cache_inv(unsigned long addr, unsigned long size)
+{
+#if 1
+	blast_inv_dcache_range(addr, addr + size);
+#else
+	unsigned long end;
+
+	if (((size | addr) & (PAGE_SIZE - 1)) == 0) {
+		end = addr + size;
+		do {
+			tc3162_blast_dcache_page(addr);
+			addr += PAGE_SIZE;
+		} while(addr != end);
+	} else if (size > dcache_size) {
+		tc3162_blast_dcache();
+	} else {
+		blast_inv_dcache_range(addr, addr + size);
+	}
+#endif
+}
+
+static void __init tc3162_probe_cache(void)
+{
+	dcache_size = 1024*8;
+	if (dcache_size)
+		dcache_lsize = 16;
+	icache_size = 1024*32;
+	if (icache_size)
+		icache_lsize = 16;
+
+	current_cpu_data.icache.ways = 2;
+	current_cpu_data.icache.linesz = 16;
+	current_cpu_data.dcache.ways = 2;
+	current_cpu_data.dcache.linesz = 16;
+}
+
+void __init r3k_cache_init(void)
+{
+	extern void build_clear_page(void);
+	extern void build_copy_page(void);
+
+	/*
+	 * These variables are unused on this architecture.
+	 */
+	tc3162_probe_cache();
+	
+	r3k_have_wired_reg = 1;
+
+	flush_cache_all = tc3162_flush_cache_all;
+	__flush_cache_all = tc3162___flush_cache_all; 
+	flush_cache_mm = tc3162_flush_cache_mm;
+	flush_cache_range = tc3162_flush_cache_range;
+	flush_cache_page = tc3162_flush_cache_page;
+	flush_icache_range = tc3162_flush_icache_range;
+
+	flush_cache_sigtramp = tc3162_flush_cache_sigtramp;
+	flush_icache_all = tc3162_flush_icache_all;
+	local_flush_data_cache_page = local_tc3162_flush_data_cache_page;
+	flush_data_cache_page = tc3162_flush_data_cache_page;
+
+	_dma_cache_wback_inv = tc3162_dma_cache_wback_inv;
+	_dma_cache_wback = tc3162_dma_cache_wback_inv;
+	_dma_cache_inv = tc3162_dma_cache_inv;
+
+	/*
+	shm_align_mask = max_t(unsigned long,
+			(dcache_size / current_cpu_data.dcache.ways) - 1,
+		   		PAGE_SIZE - 1);
+	*/
+
+	current_cpu_data.icache.waysize = icache_size / current_cpu_data.icache.ways;
+	current_cpu_data.dcache.waysize = dcache_size / current_cpu_data.dcache.ways;
+
+	current_cpu_data.icache.sets =
+		current_cpu_data.icache.waysize / current_cpu_data.icache.linesz;
+	current_cpu_data.dcache.sets =
+		current_cpu_data.dcache.waysize / current_cpu_data.dcache.linesz;
+
+	/* TC3162 is Physically-indexed, physically-tagged cache policy, don't have dcache alias
+	   problem */
+	/*
+	if (current_cpu_data.dcache.waysize > PAGE_SIZE)
+		current_cpu_data.dcache.flags |= MIPS_CACHE_ALIASES;
+	*/
+
+	current_cpu_data.icache.waybit = 0;
+	current_cpu_data.dcache.waybit = 0;
+
+	printk("Primary instruction cache %ldkB, linesize %ld bytes.\n",
+		icache_size >> 10, icache_lsize);
+	printk("Primary data cache %ldkB, linesize %ld bytes.\n",
+		dcache_size >> 10, dcache_lsize);
+
+	build_clear_page();
+	build_copy_page();
+	tc3162_blast_icache();
+}
+
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/mm/Makefile tplink-vr300/mtk/linux-2.6.36/arch/mips/mm/Makefile
--- linux-2.6.36/arch/mips/mm/Makefile	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/mm/Makefile	2019-03-07 03:40:15.000000000 +0200
@@ -16,6 +16,7 @@ obj-$(CONFIG_CPU_MIPS64)	+= c-r4k.o cex-
 obj-$(CONFIG_CPU_NEVADA)	+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R10000)	+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R3000)		+= c-r3k.o tlb-r3k.o
+obj-$(CONFIG_CPU_TC3162)	+= c-tc3162.o tlb-r3k.o pg-r4k.o
 obj-$(CONFIG_CPU_R4300)		+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R4X00)		+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R5000)		+= c-r4k.o cex-gen.o tlb-r4k.o
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/pci/fixup-tc3162.c tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/fixup-tc3162.c
--- linux-2.6.36/arch/mips/pci/fixup-tc3162.c	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/fixup-tc3162.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,64 @@
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <asm/tc3162/tc3162.h>
+
+static char irq_tab_tc3162[] __initdata = {
+#ifndef CONFIG_MIPS_TC3262
+    [1] = PCI_A_INT,
+    [2] = PCI_B_INT,
+#endif
+};
+
+int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+#ifndef PCIE_PCI_COEXIT
+	if (slot <= 0)
+		return -1;
+#else
+
+	if (isEN751221){
+		if (slot == 0)
+			return USB11_INT;
+		else if(slot == 1)
+			return PCIE_A_INT;
+	}
+
+	if (slot == 0){
+		return PCIE_A_INT;
+	}
+#ifdef CONFIG_MIPS_TC3262	
+	else if((isRT63365 || isMT751020 || isMT7505) && (slot == 1)){
+		return USB11_INT; //rt63365 use original usb 11 INT number
+	}
+#endif	
+#endif
+    return irq_tab_tc3162[slot];
+}
+
+static void tc3162_pci_fixup(struct pci_dev *dev)
+{
+	/* setup COMMAND register */
+	pci_write_config_word(dev, PCI_COMMAND,
+		(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER));
+
+	/* setup CACHE_LINE_SIZE register */
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 0x8);
+
+	/* setup LATENCY_TIMER register */
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x20);
+
+	/* setup BARS */
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0);
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_1, 0x1FBA0000);
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_2, 0x1FBB0000);
+}
+
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_TRENDCHIP, PCI_DEVICE_ID_TC3162,
+          tc3162_pci_fixup);
+
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/pci/fixup-tc3162u.c tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/fixup-tc3162u.c
--- linux-2.6.36/arch/mips/pci/fixup-tc3162u.c	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/fixup-tc3162u.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,412 @@
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <asm/tc3162/tc3162.h>
+#include <linux/delay.h>
+#if defined(TCSUPPORT_CPU_MT7505) || defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+#define isRC0_LINKUP		((regRead32(0xbfb80050) & 0x2) ? 1 : 0)  
+#define isRC1_LINKUP		((regRead32(0xbfb80050) & 0x4) ? 1 : 0)
+#else 
+#define isRC0_LINKUP		((regRead32(0xbfb82050) & 0x1) ? 1 : 0)
+#define isRC1_LINKUP		((regRead32(0xbfb83050) & 0x1) ? 1 : 0)
+#endif
+
+
+unsigned long int pcie_read_config_word(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum);
+int pcie_write_config_word(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum, unsigned long int value);
+
+extern int mt7512_pcie_is_slave();
+extern int dual_band_support;
+
+#ifndef PCIE_PCI_COEXIT
+/* 
+static char irq_tab_tc3162_pcie[] __initdata = {
+    //[1] = PCI_A_INT,
+    //[2] = PCI_B_INT,
+    [0] = PCIE_A_INT,//krammer
+};
+*/
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	//if (slot <= 0)
+#if 0
+	if (slot < 0)
+		return -1;
+#endif
+    	//return irq_tab_tc3162[slot];
+	return PCIE_A_INT;
+}
+#endif
+
+
+static void tc3162_pcie_fixup(struct pci_dev *dev)
+{
+	/* setup COMMAND register */
+	pci_write_config_word(dev, PCI_COMMAND,
+		(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER));
+
+	/* setup CACHE_LINE_SIZE register */
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 0x8);
+
+	/* setup LATENCY_TIMER register */
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x20);
+
+	/* setup BARS */
+//	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0);
+//	pci_write_config_dword(dev, PCI_BASE_ADDRESS_1, 0x1FBA0000);
+//	pci_write_config_dword(dev, PCI_BASE_ADDRESS_2, 0x1FBB0000);
+}
+static void tc3162_pcie_fixup_ra63165(struct pci_dev *dev)
+{
+	uint32 tmp;
+#if defined(TCSUPPORT_BONDING)
+	int i;
+#endif
+
+	/* setup COMMAND register */
+	pci_write_config_word(dev, PCI_COMMAND,
+		(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER));
+
+#if defined(TCSUPPORT_BONDING)
+	//Enable slave RC ECRC count . //bus1, dev1
+	regWrite32(0xbfb80020, 0x1080118);
+	tmp = regRead32(0xbfb80024);
+	regWrite32(0xbfb80024, (tmp | (1<<8)));
+
+	//config PCIe RC/EP VC mapping
+	//set bus0, dev0, fun0, reg154 (setup VC0)
+	regWrite32(0xbfb80020, 0x154);
+	regWrite32(0xbfb80024, 0X80000001);
+	//set bus0, dev0, fun0, reg160 (setup VC1)
+	regWrite32(0xbfb80020, 0x160);
+	regWrite32(0xbfb80024, 0X81000002);
+	//set bus1, dev0, fun0, reg154 (setup VC0)
+	regWrite32(0xbfb80020, 0x1000154);
+	regWrite32(0xbfb80024, 0X80000001);
+	//set bus1, dev0, fun0, reg160 (setup VC1)
+	regWrite32(0xbfb80020, 0x1000160);
+	regWrite32(0xbfb80024, 0X81000002);
+
+	//config slave chip EP MSI
+	regWrite32(0xbfb80020, 0x1000050);
+	tmp = regRead32(0xbfb80024);
+	regWrite32(0xbfb80020, 0x1000050);
+	regWrite32(0xbfb80024, (tmp | 0x510000));
+	regWrite32(0xbfb80020, 0x1000054);
+	regWrite32(0xbfb80024, 0x20af1000);
+	regWrite32(0xbfb80020, 0x100005c);
+	regWrite32(0xbfb80024, 0x0);
+
+	//setup RC0 MSI address reg
+	regWrite32(0xbfb82090, 0x20af1000);
+
+	//setup RC0 Pbus/Rbus VC mapping
+	regWrite32(0xbfb82094, 0x1);
+	regWrite32(0xbfb83094, 0x0);
+
+	//wait RC0 VC1 set up OK
+	for(i=0 ; i<1000 ; i++){
+		mdelay(1);
+		regWrite32(0xbfb80020, 0x164);
+		if((regRead32(0xbfb80024) & (1<<17)) == 0){
+			break;
+		}
+	}
+#endif
+
+	//pci-e interrupt enable_dma
+	if(isRT63365 || isMT751020 || isMT7505){
+#if defined(TCSUPPORT_BONDING)
+		if((regRead32(0xbfb82050) & 0x1) != 0){
+			/* slave dmt */
+			tmp = regRead32(0xbfb8000c);
+			regWrite32(0xbfb8000c, (tmp | (1<<23)));
+			/* slave gdma */
+			tmp = regRead32(0xbfb8000c);
+			regWrite32(0xbfb8000c, (tmp | (1<<25)));
+
+			if(regRead32(0xbfb80050) == 1){
+				/* wifi 0 (slave)*/
+				tmp = regRead32(0xbfb8000c);
+				regWrite32(0xbfb8000c, (tmp | (1<<22)));
+			}
+		}
+#else
+		if((regRead32(0xbfb82050) & 0x1) != 0){
+			tmp = regRead32(0xbfb8000c);
+			regWrite32(0xbfb8000c, (tmp | (1<<20)));
+		}
+#endif
+		//second band
+		if(dual_band_support){
+			if((regRead32(0xbfb83050) & 0x1) != 0){
+				if(isMT751020 || isMT7505){
+					tmp = regRead32(0xbfb8000c);
+					regWrite32(0xbfb8000c, (tmp | (1<<26)));
+				}else{
+					tmp = regRead32(0xbfb8000c);
+					regWrite32(0xbfb8000c, (tmp | (1<<21)));
+				}
+			}
+		}
+	}else{
+		tmp = regRead32(0xbfb8100c);
+		regWrite32(0xbfb8100c, (tmp | (1<<20)));
+	}
+
+	if(isMT751020 || isMT7505){
+		pcie_timeout_disable();
+		aer_config(1);
+	}
+}
+
+#ifndef PCIE_PCI_COEXIT
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+#endif
+
+
+int mt7512_pcie_get_pos(char bus,char dev)
+{
+	unsigned int val,pos;
+
+	val = pcie_read_config_word(0,bus,dev,0x34);
+	pos = val&0xff;
+	while(pos && pos != 0xff)
+	{
+		val = pcie_read_config_word(0,bus,dev,pos);
+		if ( (val&0xff) == 0x10)
+			return pos;
+		pos = (val >> 0x08) & 0xff;
+	}
+	return 0;
+}
+
+int  mt7512_pcie_rc1_retrain(void)
+{
+	unsigned int pos = 0, ppos = 0,bus;
+	unsigned int  linkcap, plinkcap,plinksta;
+
+	ppos = mt7512_pcie_get_pos(0,1);
+	if (mt7512_pcie_is_slave()==1)
+		bus = 1;
+	else
+		bus =  2;
+	
+	pos = mt7512_pcie_get_pos(bus,0);
+	
+	if (pos <0x40 || ppos < 0x40)
+		return 0;
+	
+	plinkcap =  pcie_read_config_word(0,0,1,ppos+0x0c);
+	linkcap = pcie_read_config_word(0,bus,0,pos+0x0c);
+	
+	printk("\n mt7512_pcie_rc1_retrain: %x = %08x %x = %08x",pos,linkcap,ppos,plinkcap);
+	
+	if ((linkcap&0x0f)== 1 || (plinkcap&0x0f)==1)
+		return 0;
+	
+	plinksta = pcie_read_config_word(0,0,1,ppos+0x10);
+	if( ((plinksta>>16)&0x0f) ==  (plinkcap&0x0f))
+		return 0;
+
+	plinksta =  pcie_read_config_word(0,0,1,ppos+0x10);
+	plinksta |= 0x20;
+	pcie_write_config_word(0,0,1,ppos+0x10,plinksta);
+	
+	mdelay(1000); 
+	
+	plinksta =  pcie_read_config_word(0,0,1,ppos+0x10);
+	
+	printk("\nRC1 Link Traing Result: %08x",plinksta);
+	
+	return 1;
+}
+/* Add by Zhao Mengqing, 2016-3-20, copy from mt7512_pcie_rc1_retrain() and modified devnum */
+#ifdef CONFIG_PW_MODEL_PVW42T1200ACGV1
+int  mt7512_pcie_rc0_retrain(void)
+{
+	unsigned int pos = 0, ppos = 0,bus;
+	unsigned int  linkcap, plinkcap,plinksta;
+
+	ppos = mt7512_pcie_get_pos(0,0);//dev 1 -> 0
+	if (mt7512_pcie_is_slave()==1)
+		bus = 1;
+	else
+		bus =  2;
+	
+	pos = mt7512_pcie_get_pos(bus,0);
+	
+	if (pos <0x40 || ppos < 0x40)
+		return 0;
+	
+	plinkcap =  pcie_read_config_word(0,0,0,ppos+0x0c);//devnum 1 -> 0
+	linkcap = pcie_read_config_word(0,bus,0,pos+0x0c);
+	
+	printk("\n mt7512_pcie_rc0_retrain: %x = %08x %x = %08x",pos,linkcap,ppos,plinkcap);
+	
+	if ((linkcap&0x0f)== 1 || (plinkcap&0x0f)==1)
+		return 0;
+	
+	plinksta = pcie_read_config_word(0,0,0,ppos+0x10);//devnum 1 -> 0
+	if( ((plinksta>>16)&0x0f) ==  (plinkcap&0x0f))
+		return 0;
+
+	plinksta =  pcie_read_config_word(0,0,0,ppos+0x10);//devnum 1 -> 0
+	plinksta |= 0x20;
+	pcie_write_config_word(0,0,1,ppos+0x10,plinksta);
+	
+	mdelay(1000); 
+	
+	plinksta =  pcie_read_config_word(0,0,0,ppos+0x10);//devnum 1 -> 0
+	
+	printk("\nRC0 Link Traing Result: %08x",plinksta);
+	
+	return 1;
+}
+#endif
+/* End add */
+
+void mt7512_pcie_fixup(void)
+{
+	unsigned int val = 0,tmp = 0 ,i = 0;
+	
+	if (isRC0_LINKUP)
+	{
+	
+		val =  pcie_read_config_word(0,0,0,0x20);
+		tmp = ((val&0xffff)<<16);
+		val = (val&0xffff0000) + 0x100000;
+		val = val - tmp;
+		i = 0;
+		while(i < 32)
+		{
+			if((1<<i) >= val)
+				break;
+			i++;
+		}
+		regWrite32(0xbfb81438,tmp | i);   //config RC0 to EP Addr window
+		mdelay(1);
+		regWrite32(0xbfb81448,0x80);     //enable EP to RC0 access
+		printk("\n mt7512_pcie_fixup: 0x1438 = %x ",tmp | i);
+	}
+	
+	if (isRC1_LINKUP)
+	{
+	
+		val =  pcie_read_config_word(0,0,1,0x20);
+		tmp = ((val&0xffff)<<16);
+		val = (val&0xffff0000) + 0x100000;
+		val = val - tmp;
+		i = 0;
+		while(i < 32)
+		{
+			if((1<<i) >= val)
+				break;
+			i++;
+		}
+		regWrite32(0xbfb83438,tmp | i);   //config RC1 to EP Addr window
+		mdelay(1);
+		regWrite32(0xbfb83448,0x80);     //enable EP to RC1 access
+		printk("\n mt7512_pcie_fixup: 0x3438 = %x ",tmp | i);
+		
+		mt7512_pcie_rc1_retrain();
+		
+	}
+
+	return ;
+}
+
+EXPORT_SYMBOL(mt7512_pcie_fixup);
+
+
+
+void mt7512_pcie_fixup_rc0(struct pci_dev *dev)
+{
+
+	unsigned int val = 0,tmp = 0 ,i = 0;
+
+	if (isRC0_LINKUP)
+	{
+		val =  pcie_read_config_word(0,0,0,0x20);
+		tmp = ((val&0xffff)<<16);
+		val = (val&0xffff0000) + 0x100000;
+		val = val - tmp;
+		i = 0;
+		
+		while(i < 32)
+		{
+			if((1<<i) >= val)
+				break;
+			i++;
+		}
+		
+		/* config RC1 to EP Addr window */	
+		regWrite32(0xbfb81438,tmp | i);  
+		mdelay(1);
+
+	 	/* enable EP to RC1 access */	
+		regWrite32(0xbfb81448,0x80);	
+		printk("\n mt7512_pcie_fixup: 0x1438 = %x ",tmp | i);
+
+//Add by Zhao Mengqing, 2016-5-31 */
+#ifdef CONFIG_PW_MODEL_PVW42T1200ACGV1
+		mt7512_pcie_rc0_retrain();
+#endif
+/* End add */
+	}
+	return;
+}
+
+
+void mt7512_pcie_fixup_rc1(struct pci_dev *dev)
+{
+
+	unsigned int val = 0,tmp = 0 ,i = 0;
+
+
+	if (isRC1_LINKUP)
+	{
+		val =  pcie_read_config_word(0,0,1,0x20);
+		tmp = ((val&0xffff)<<16);
+		val = (val&0xffff0000) + 0x100000;
+		val = val - tmp;
+		i = 0;
+		while(i < 32)
+		{
+			if((1<<i) >= val)
+				break;
+			i++;
+		}
+		
+		/* config RC1 to EP Addr window */
+		regWrite32(0xbfb83438,tmp | i);   
+		mdelay(1);
+
+	 	/* enable EP to RC1 access */
+		regWrite32(0xbfb83448,0x80);	
+		printk("\n mt7512_pcie_fixup: 0x3438 = %x ",tmp | i);
+
+/* Modified by Zhao Mengqing, 2016-5-31 */
+#ifndef CONFIG_PW_MODEL_PVW42T1200ACGV1
+		mt7512_pcie_rc1_retrain();
+#endif
+	}
+	return;
+	
+}
+
+
+
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SIS, PCI_DEVICE_ID_SIS,
+          tc3162_pcie_fixup);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_RT, PCI_DEVICE_ID_RT,
+          tc3162_pcie_fixup_ra63165);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_MTK, PCI_DEVICE_ID_MTK,
+		tc3162_pcie_fixup_ra63165);
+
+DECLARE_PCI_FIXUP_FINAL(0x14c3,0x0810,mt7512_pcie_fixup_rc0);
+DECLARE_PCI_FIXUP_FINAL(0x14c3,0x0811,mt7512_pcie_fixup_rc1);
+
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/pci/Makefile tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/Makefile
--- linux-2.6.36/arch/mips/pci/Makefile	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/Makefile	2019-03-07 03:40:15.000000000 +0200
@@ -19,6 +19,18 @@ obj-$(CONFIG_BCM47XX)		+= pci-bcm47xx.o
 obj-$(CONFIG_BCM63XX)		+= pci-bcm63xx.o fixup-bcm63xx.o \
 					ops-bcm63xx.o
 
+obj-$(CONFIG_MIPS_TC3162)	+= ops-tc3162.o pci-tc3162.o fixup-tc3162.o
+ifdef CONFIG_MIPS_TC3262 
+EXTRA_CFLAGS += -DPCIE_PCI_COEXIT
+endif
+obj-$(CONFIG_MIPS_TC3262)	+= ops-tc3162u.o pci-tc3162u.o fixup-tc3162u.o pcie-phy.o
+obj-$(CONFIG_MIPS_TC3262)       += ops-tc3162.o pci-tc3162.o fixup-tc3162.o pci-7512api.o
+ifdef CONFIG_MIPS_TC3162U
+EXTRA_CFLAGS += -DPCIE_PCI_COEXIT
+endif
+obj-$(CONFIG_MIPS_TC3162U)	+= ops-tc3162u.o pci-tc3162u.o fixup-tc3162u.o pcie-phy.o
+obj-$(CONFIG_MIPS_TC3162U)	+= ops-tc3162.o pci-tc3162.o fixup-tc3162.o
+
 #
 # These are still pretty much in the old state, watch, go blind.
 #
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/pci/ops-tc3162.c tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/ops-tc3162.c
--- linux-2.6.36/arch/mips/pci/ops-tc3162.c	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/ops-tc3162.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,136 @@
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/addrspace.h>
+#include <asm/tc3162/tc3162.h>
+
+#define PCI_CONFIG_ADDR		0x1fb80cf8
+#define PCI_CONFIG_DATA		0x1fb80cfc
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(f, a...)	printk(f, ## a )
+#else
+#define DBG(f, a...)	do {} while (0)
+#endif
+
+#define PCI_ENABLE 0x80000000
+
+static spinlock_t pci_lock = SPIN_LOCK_UNLOCKED;
+
+/* -------------------------------------------------------------------------*/
+
+static inline void write_cfgaddr(u32 addr)
+{
+	__raw_writel((addr | PCI_ENABLE),
+		(void __iomem *)(KSEG1ADDR(PCI_CONFIG_ADDR)));
+}
+
+static inline void write_cfgdata(u32 data)
+{
+	__raw_writel(data, (void __iomem *)KSEG1ADDR(PCI_CONFIG_DATA));
+}
+
+static inline u32 read_cfgdata(void)
+{
+	return __raw_readl((void __iomem *)KSEG1ADDR(PCI_CONFIG_DATA));
+}
+
+static inline u32 mkaddr(struct pci_bus *bus, unsigned int devfn, int where)
+{
+#ifndef PCIE_PCI_COEXIT
+	return (((bus->number & 0xFF) << 16) | ((devfn & 0xFF) << 8) | \
+		(where & 0xFC));
+#else
+	return (((bus->number & 0) << 16) | ((devfn & 0xFF) << 8) | \
+		(where & 0xFC));
+#endif
+}
+
+/* -------------------------------------------------------------------------*/
+
+static int tc3162_pcibios_read(struct pci_bus *bus, unsigned int devfn, int where,
+		int size, u32 *val)
+{
+	unsigned long flags;
+	u32 data;
+
+	spin_lock_irqsave(&pci_lock, flags);
+
+	write_cfgaddr(mkaddr(bus,devfn,where));
+	data = read_cfgdata();
+
+	DBG("PCI: cfg_read  %02u.%02u.%01u/%02X:%01d, cfg:0x%08X",
+		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, size, data);
+
+	switch (size) {
+	case 1:
+		if (where & 1)
+			data >>= 8;
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFF;
+		break;
+	case 2:
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFFFF;
+		break;
+	}
+
+	*val = data;
+	DBG(", 0x%08X returned\n", data);
+
+	spin_unlock_irqrestore(&pci_lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int tc3162_pcibios_write(struct pci_bus *bus, unsigned int devfn, int where,
+		int size, u32 val)
+{
+	unsigned long flags;
+	u32 data;
+	int s;
+
+	spin_lock_irqsave(&pci_lock, flags);
+
+	write_cfgaddr(mkaddr(bus,devfn,where));
+	data = read_cfgdata();
+
+	DBG("PCI: cfg_write %02u.%02u.%01u/%02X:%01d, cfg:0x%08X",
+		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, size, data);
+
+	switch (size) {
+	case 1:
+		s = ((where & 3) << 3);
+		data &= ~(0xFF << s);
+		data |= ((val & 0xFF) << s);
+		break;
+	case 2:
+		s = ((where & 2) << 4);
+		data &= ~(0xFFFF << s);
+		data |= ((val & 0xFFFF) << s);
+		break;
+	case 4:
+		data = val;
+		break;
+	}
+
+	write_cfgdata(data);
+	DBG(", 0x%08X written\n", data);
+
+	spin_unlock_irqrestore(&pci_lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops tc3162_pci_ops = {
+    .read   = tc3162_pcibios_read,
+    .write  = tc3162_pcibios_write
+};
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/pci/ops-tc3162u.c tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/ops-tc3162u.c
--- linux-2.6.36/arch/mips/pci/ops-tc3162u.c	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/ops-tc3162u.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,230 @@
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/addrspace.h>
+#include <asm/tc3162/tc3162.h>
+
+uint32 pcie_config_addr = 0x1fb81cf8;
+uint32 pcie_config_data = 0x1fb81cfc;
+
+#undef DEBUG
+
+//#define DEBUG
+#ifdef DEBUG
+#define DBG(f, a...)	printk(f, ## a )
+#else
+#define DBG(f, a...)	do {} while (0)
+#endif
+
+#define PCIE_ENABLE 0x80000000
+
+spinlock_t pcie_lock = SPIN_LOCK_UNLOCKED;
+
+/* -------------------------------------------------------------------------*/
+
+static inline void write_cfgaddr(u32 addr)
+{
+	__raw_writel(addr,
+			(void __iomem *)(KSEG1ADDR(pcie_config_addr)));
+//	__raw_writel((addr | PCI_ENABLE),
+//		(void __iomem *)(KSEG1ADDR(PCI_CONFIG_ADDR)));
+}
+
+static inline void write_cfgdata(u32 data)
+{
+	__raw_writel(data, (void __iomem *)KSEG1ADDR(pcie_config_data));
+}
+
+static inline u32 read_cfgdata(void)
+{
+	u32 tmp;
+
+	if(isRT63365)
+		 tmp = __raw_readl((void __iomem *)KSEG1ADDR(pcie_config_data));
+
+	return __raw_readl((void __iomem *)KSEG1ADDR(pcie_config_data));
+}
+
+static inline u32 mkaddr(struct pci_bus *bus, unsigned int devfn, int where)
+{
+	u32 type;
+
+	if(isRT63165 || isRT63365 || isMT751020 || isMT7505 || isEN751221){
+		return	(((bus->number & 0xFF) << 24) | ((devfn & 0xFF) << 16) |\
+				(where & 0xFFC));
+	}else{
+		type=(bus->number & 0xFF)?PCIE_ENABLE:0;
+
+		return (type | ((bus->number & 0xFF) << 20) | ((devfn & 0xFF) << 12) | \
+			(where & 0xFFC));
+	}
+}
+
+/* -------------------------------------------------------------------------*/
+extern unsigned long int pcie_read_config_word_extend(unsigned char bus,unsigned char dev,unsigned char func,unsigned int reg);
+extern int pcie_write_config_word_extend(unsigned char bus, unsigned char dev,unsigned char func, unsigned int reg, unsigned long int value);
+
+static int mt7512_pciebios_read(struct pci_bus *bus, unsigned int devfn, int where,int size, u32 *val)
+{
+	unsigned long flags;
+	u32 data,addr;
+	
+/*	spin_lock_irqsave(&pcie_lock, flags);*/
+
+	addr = mkaddr(bus,devfn,where);
+	data = pcie_read_config_word_extend((addr>>24)&0xff,(addr>>19)&0x1f,(addr>>16)&0x7,addr&0xffc);
+	
+/*	printk("\n pcie_read: bus = %d, dev = %d func = %d, reg = %x, val = %x",(addr>>24)&0xff,(addr>>19)&0x1f,(addr>>16)&0x7,addr&0xffc,data); */
+
+	switch (size) {
+	case 1:
+		if (where & 1)
+			data >>= 8;
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFF;
+		break;
+	case 2:
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFFFF;
+		break;
+	}
+	*val = data;
+/*	spin_unlock_irqrestore(&pcie_lock, flags);*/
+	
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+static int mt7512_pciebios_write(struct pci_bus *bus, unsigned int devfn, int where,int size, u32 val)
+{
+	unsigned long flags;
+	u32 data,addr;
+	int s;
+
+
+	addr= mkaddr(bus,devfn,where);
+	data = pcie_read_config_word_extend((addr>>24)&0xff,(addr>>19)&0x1f,(addr>>16)&0x7,addr&0xffc);
+
+	switch (size) {
+	case 1:
+		s = ((where & 3) << 3);
+		data &= ~(0xFF << s);
+		data |= ((val & 0xFF) << s);
+		break;
+	case 2:
+		s = ((where & 2) << 3);
+		data &= ~(0xFFFF << s);
+		data |= ((val & 0xFFFF) << s);
+		break;
+	case 4:
+		data = val;
+		break;
+	}
+/*	printk("\n pcie_write: bus = %d, dev = %d func = %d, reg = %x, val = %x",(addr>>24)&0xff,(addr>>19)&0x1f,(addr>>16)&0x7,addr&0xffc,data);*/
+	
+	pcie_write_config_word_extend((addr>>24)&0xff,(addr>>19)&0x1f,(addr>>16)&0x7,addr&0xffc,data);
+	return PCIBIOS_SUCCESSFUL;
+
+
+}
+
+static int tc3162_pciebios_read(struct pci_bus *bus, unsigned int devfn, int where,
+		int size, u32 *val)
+{
+	unsigned long flags;
+	u32 data;
+
+	spin_lock_irqsave(&pcie_lock, flags);
+
+	if(isRT63165){
+		if((devfn & 0xFF) != 0){
+			*val = 0xffffffff;
+			spin_unlock_irqrestore(&pcie_lock, flags);
+			return PCIBIOS_SUCCESSFUL;
+		}
+	}
+
+	write_cfgaddr(mkaddr(bus,devfn,where));
+	data = read_cfgdata();
+
+	DBG("PCIE: cfg_read  %02u.%02u.%01u/%02X:%01d, cfg:0x%08X",
+		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, size, data);
+
+	switch (size) {
+	case 1:
+		if (where & 1)
+			data >>= 8;
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFF;
+		break;
+	case 2:
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFFFF;
+		break;
+	}
+
+	*val = data;
+	DBG(", 0x%08X returned\n", data);
+
+	spin_unlock_irqrestore(&pcie_lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int tc3162_pciebios_write(struct pci_bus *bus, unsigned int devfn, int where,
+		int size, u32 val)
+{
+	unsigned long flags;
+	u32 data;
+	int s;
+
+	spin_lock_irqsave(&pcie_lock, flags);
+
+	write_cfgaddr(mkaddr(bus,devfn,where));
+	data = read_cfgdata();
+
+	DBG("PCIE: cfg_write %02u.%02u.%01u/%02X:%01d,%08x, cfg:0x%08X",
+		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, size, val, data);
+
+	switch (size) {
+	case 1:
+		s = ((where & 3) << 3);
+		data &= ~(0xFF << s);
+		data |= ((val & 0xFF) << s);
+		break;
+	case 2:
+		//s = ((where & 2) << 4);
+		s = ((where & 2) << 3);//krammer try
+		data &= ~(0xFFFF << s);
+		data |= ((val & 0xFFFF) << s);
+		break;
+	case 4:
+		data = val;
+		break;
+	}
+
+	write_cfgdata(data);
+	DBG(", 0x%08X written\n", data);
+
+	spin_unlock_irqrestore(&pcie_lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops mt7512_pcie_ops = {
+    .read   = mt7512_pciebios_read,
+    .write  = mt7512_pciebios_write
+};
+
+struct pci_ops tc3162_pcie_ops = {
+    .read   = tc3162_pciebios_read,
+    .write  = tc3162_pciebios_write
+};
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/pci/pci-7512api.c tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/pci-7512api.c
--- linux-2.6.36/arch/mips/pci/pci-7512api.c	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/pci-7512api.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,556 @@
+
+
+/************************************************************************
+*               I N C L U D E S
+*************************************************************************
+*/
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h> 
+#include <asm/tc3162/tc3162.h>
+#include <linux/proc_fs.h>
+#include <linux/io.h>
+#include <ecnt_hook/ecnt_hook_pcie.h>
+
+
+/************************************************************************
+*                  D E F I N E S   &   C O N S T A N T S
+*************************************************************************
+*/
+
+
+
+/************************************************************************
+*                  M A C R O S
+*************************************************************************
+*/
+#if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+	
+#if defined(TCSUPPORT_CPU_MT7505) || defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+#define isRC0_LINKUP		((regRead32(0xbfb80050) & 0x2) ? 1 : 0)  
+#define isRC1_LINKUP		((regRead32(0xbfb80050) & 0x4) ? 1 : 0)
+#else
+#define isRC0_LINKUP		((regRead32(0xbfb82050) & 0x1) ? 1 : 0)
+#define isRC1_LINKUP		((regRead32(0xbfb83050) & 0x1) ? 1 : 0)
+#endif
+
+#define PCIE_MAJOR 225
+#define PCIE_CNT_NUMBER 6
+
+/************************************************************************
+*                  D A T A   T Y P E S
+*************************************************************************
+*/
+typedef int (*pcie_api_op_t)(struct ecnt_pcie_data * data);
+enum {
+	PCIE_DEV_RC0 = 0,
+	PCIE_DEV_RC1,
+	PCIE_DEV_EP0,
+	PCIE_DEV_EP1,
+};
+
+/************************************************************************
+*                  E X T E R N A L   D A T A   D E C L A R A T I O N S
+*************************************************************************
+*/
+
+
+/************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+*************************************************************************
+*/
+
+int pcie_write_config_word(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum, unsigned long int value);
+unsigned long  pcie_read_config_word(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum);
+int pcie_api_get_confreg(struct ecnt_pcie_data *data);
+int pcie_api_set_confreg(struct ecnt_pcie_data *data);
+int pcie_api_get_aspm(struct ecnt_pcie_data *data);
+int pcie_api_set_aspm(struct ecnt_pcie_data *data);
+int pcie_api_get_speed(struct ecnt_pcie_data *data);
+int pcie_api_set_speed(struct ecnt_pcie_data *data);
+int pcie_api_get_count(struct ecnt_pcie_data *data);
+int pcie_api_get_linkstate(struct ecnt_pcie_data *data);
+ecnt_ret_val ecnt_pcie_api_hook(struct ecnt_data *in_data);
+static long pcie_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+
+
+/************************************************************************
+*                  P U B L I C   D A T A
+*************************************************************************
+*/
+
+struct ecnt_hook_ops ecnt_pcie_api_op = {
+	.name = "pcie_api_hook",
+	.is_execute = 1,
+	.hookfn = ecnt_pcie_api_hook,
+	.maintype = ECNT_PCIE,
+	.subtype = ECNT_PCIE_API,
+	.priority = 1
+};
+
+struct file_operations pcie_fops = {
+	.owner 			= THIS_MODULE,
+	.unlocked_ioctl	= pcie_ioctl,
+};
+
+
+/************************************************************************
+*                  P R I V A T E   D A T A
+*************************************************************************
+*/
+static spinlock_t pcie_api_lock = SPIN_LOCK_UNLOCKED;
+
+static unsigned int pcie_err_reg[2][PCIE_CNT_NUMBER] = 
+{
+	{0xbfb80054,0xbfb801d8,0xbfb801dc,0xbfb801e0,0xbfb801e4,0xbfb801e8},
+	{0xbfb80058,0xbfb801ec,0xbfb801f0,0xbfb801f4,0xbfb801f8,0xbfb801fc}
+};
+
+static pcie_api_op_t pcie_operation[] = {
+	pcie_api_get_confreg,
+	pcie_api_set_confreg,
+	pcie_api_get_aspm,
+	pcie_api_set_aspm,
+	pcie_api_get_speed,
+	pcie_api_set_speed,
+	pcie_api_get_count,
+	pcie_api_get_linkstate
+};
+
+/************************************************************************
+*                  F U N C T I O N   D E F I N I T I O N S
+*************************************************************************
+*/
+
+
+
+int pcie_write_config_word_hw(unsigned char bus, unsigned char dev,unsigned char func, unsigned int reg, unsigned long int value)
+{
+	return pcie_write_config_word(0,bus,dev,reg,value);
+}
+
+unsigned int pcie_read_config_word_hw(unsigned char bus,unsigned char dev,unsigned char func ,unsigned int reg)
+{
+	return pcie_read_config_word(0,bus,dev,reg);
+}
+
+static int get_cap_pos(char bus,char dev,char func, char id)
+{
+	unsigned int val,pos;
+
+	val = pcie_read_config_word_hw(bus,dev,func,0x34);
+	pos = val&0xff;
+	while(pos && pos != 0xff)
+	{
+		val = pcie_read_config_word_hw(bus,dev,func,pos);
+		if ( (val&0xff) == id)
+			return pos;
+		pos = (val >> 0x08) & 0xff;
+	}
+	return 0;
+}
+
+
+static int pcie_get_confreg(int idx,int offset)
+{
+	unsigned char bus,dev,func;
+	unsigned  int val;
+	
+	if (offset >= 0x1000 || offset < 0)
+		return -1;
+
+	if (isRC0_LINKUP == 0 && idx == PCIE_DEV_EP0)
+		return -1;
+	
+	if (isRC1_LINKUP == 0 && idx == PCIE_DEV_EP1)
+		return -1;	
+	
+	if (idx == PCIE_DEV_RC0){
+		bus = 0; dev = 0; func = 0;
+	}else if (idx == PCIE_DEV_RC1){
+		bus = 0; dev = 1; func = 0;
+	}else if (idx == PCIE_DEV_EP0){
+		bus = 1; dev = 0; func = 0;
+	}else if (idx == PCIE_DEV_EP1){
+		bus = 2;dev = 0; func = 0;
+	}else{
+		return -1;
+	}
+	
+	offset &= 0xffc;
+	
+	val = pcie_read_config_word_hw(bus,dev,func,offset);
+	
+	return val;
+}
+
+
+
+static int pcie_set_confreg(int idx,int offset,unsigned int val)
+{
+	unsigned char bus,dev,func;
+	
+	if (offset >= 0x1000 || offset < 0)
+		return -1;
+
+	if (isRC0_LINKUP == 0 && idx == PCIE_DEV_EP0)
+		return -1;
+	
+	if (isRC1_LINKUP == 0 && idx == PCIE_DEV_EP1)
+		return -1;	
+	
+	if (idx == PCIE_DEV_RC0){
+		bus = 0; dev = 0; func = 0;
+	}else if (idx == PCIE_DEV_RC1){
+		bus = 0; dev = 1; func = 0;
+	}else if (idx == PCIE_DEV_EP0){
+		bus = 1; dev = 0; func = 0;
+	}else if (idx == PCIE_DEV_EP1){
+		bus = 2;dev = 0; func = 0;
+	}else{
+		return -1;
+	}
+
+	
+	offset &= 0xffc;
+
+	pcie_write_config_word_hw(bus,dev,func,offset,val);
+
+	return 0;
+}
+
+
+
+static int pcie_set_aspm_ext(char bus,char dev,char func,unsigned int val)
+{
+	unsigned int pos = 0,value = 0;
+
+	pos = get_cap_pos(bus,dev,func,0x10);
+	
+	if (pos < 0x40)
+		return -1;
+
+	if (val){
+		value = pcie_read_config_word_hw(bus,dev,func,pos+12);
+		value &= 0x0c00;
+		value = value >> 10;
+		if ((val > value) || ((val & value) == 0))
+			return -1;
+	}
+
+	value = pcie_read_config_word_hw(bus,dev,func,pos+16);
+	
+	value &= 0xfffffffc;
+	
+	value |= val;
+	
+	pcie_write_config_word_hw(bus,dev,func,pos+16,value);
+	
+	return 0;
+}
+
+static int pcie_set_aspm(int idx,int sw)
+{
+	sw &= 0x3;
+
+	if (idx == PCIE_DEV_RC0)
+		return pcie_set_aspm_ext(0,0,0,sw);
+
+	if (idx == PCIE_DEV_RC1)
+		return pcie_set_aspm_ext(0,1,0,sw);
+
+	if (idx == PCIE_DEV_EP0 && isRC0_LINKUP)
+		return pcie_set_aspm_ext(1,0,0,sw);
+	
+	if (idx == PCIE_DEV_EP1 && isRC1_LINKUP)
+		return pcie_set_aspm_ext(2,0,0,sw);
+
+	return -1;
+}
+
+static int pcie_get_aspm_ext(char bus,char dev,char func)
+{
+	unsigned int pos = 0,value = 0;
+
+	pos = get_cap_pos(bus,dev,func,0x10);
+	
+	if (pos < 0x40)
+		return -1;
+
+	value = pcie_read_config_word_hw(bus,dev,func,pos+16);
+	
+	value &= 0x3;
+	
+	return value;
+}
+
+static int pcie_get_aspm(int idx)
+{
+	if (idx == PCIE_DEV_RC0)
+		return pcie_get_aspm_ext(0,0,0);
+
+	if (idx == PCIE_DEV_RC1)
+		return pcie_get_aspm_ext(0,1,0);
+
+	if (idx == PCIE_DEV_EP0 && isRC0_LINKUP)
+		return pcie_get_aspm_ext(1,0,0);
+	
+	if (idx == PCIE_DEV_EP1 && isRC1_LINKUP)
+		return pcie_get_aspm_ext(2,0,0);
+
+	return -1;
+}
+
+
+static int pcie_set_speed_ext(char bus,char dev,char func,unsigned int val)
+{
+	unsigned int pos = 0,value = 0;
+
+	pos = get_cap_pos(bus,dev,func,0x10);
+	if (pos < 0x40)
+		return -1;
+
+	value = pcie_read_config_word_hw(bus,dev,func,pos+0x30);
+	value &= (~0x0f);
+	value |= val ;
+	pcie_write_config_word_hw(bus,dev,func,pos+0x30,value);
+	return 0;
+}
+
+static int pcie_set_speed(int idx,unsigned int mode)
+{
+	unsigned int pos = 0,val = 0,dev ,bus;
+
+	if (idx != PCIE_DEV_EP0 && idx != PCIE_DEV_EP1)
+		return -1;
+	
+	if (isRC0_LINKUP == 0 && idx == PCIE_DEV_EP0)
+		return -1;
+	
+	if (isRC1_LINKUP == 0 && idx == PCIE_DEV_EP1)
+		return -1;
+
+	if (idx == PCIE_DEV_EP0)
+	{
+		dev = 0;
+		bus = 1;
+	}
+	else
+	{
+		dev = 1;
+		bus = 2;
+	}
+
+	mode &= 0x3;
+	
+	pos = get_cap_pos(0,dev,0,0x10);
+	if (pos < 0x40)
+		return -1;
+	
+	val = pcie_read_config_word_hw(0,dev,0,pos+0x0c);
+	if ((val&0x0f) < mode)
+		return -1;
+
+	pos = get_cap_pos(bus,0,0,0x10);
+	if (pos < 0x40)
+		return -1;
+	
+	val = pcie_read_config_word_hw(bus,0,0,pos+0x0c);
+	if ((val&0x0f) < mode)
+		return -1;
+
+	pcie_set_speed_ext(0,dev,0,mode);
+	pcie_set_speed_ext(bus,0,0,mode);
+	
+	val = pcie_read_config_word_hw(0,dev,0,pos+0x10);
+	val |=  (1 << 5); 
+	pcie_write_config_word_hw(0,dev,0,pos+0x10,val);
+	mdelay(100);
+	
+	return 0;
+}
+
+
+static int pcie_get_speed(int idx)
+{
+	unsigned int pos = 0,val = 0,dev = 0;
+
+	if (idx != PCIE_DEV_EP0 && idx != PCIE_DEV_EP1)
+		return -1;
+	
+	if (isRC0_LINKUP == 0 && idx == PCIE_DEV_EP0)
+		return -1;
+	
+	if (isRC1_LINKUP == 0 && idx == PCIE_DEV_EP1)
+		return -1;
+
+	
+	if (idx == PCIE_DEV_EP0)
+		dev = 0;
+	else
+		dev = 1;
+
+	pos = get_cap_pos(0,dev,0,0x10);
+	if (pos < 0x40)
+		return -1;
+	
+	val = pcie_read_config_word_hw(0,dev,0,pos+0x10);
+	val = (val >> 16) & 0x0f ;
+
+	return val;
+}
+
+
+static int pcie_get_count(int idx, struct ecnt_pcie_count_data* pcnt)
+{
+	int i;
+
+	if (idx != PCIE_DEV_RC0 && idx != PCIE_DEV_RC1)
+		return -1;
+	
+	for(i=0; i < PCIE_CNT_NUMBER; i++){
+		pcnt->err[i] = regRead32(pcie_err_reg[idx][i]);
+	}
+
+	return 0;
+}
+
+static int pcie_get_linkstate(int idx)
+{
+	if (idx == PCIE_DEV_RC0)
+		return isRC0_LINKUP;
+	
+	if (idx == PCIE_DEV_RC1)
+		return isRC1_LINKUP;
+
+	return -1;
+}
+
+int pcie_api_get_confreg(struct ecnt_pcie_data *data)
+{
+	int idx = data->idx;
+	int off = data->conf.off;
+	data->retValue = pcie_get_confreg(idx,off);
+	return 0;
+}
+
+int pcie_api_set_confreg(struct ecnt_pcie_data *data)
+{
+	int idx = data->idx;
+	unsigned int off = data->conf.off;
+	unsigned int val = data->conf.val;
+	data->retValue = pcie_set_confreg(idx,off,val);
+	return 0;
+}
+
+int pcie_api_get_aspm(struct ecnt_pcie_data *data)
+{
+	int idx = data->idx;
+	data->retValue = pcie_get_aspm(idx);
+	return 0;
+}
+
+int pcie_api_set_aspm(struct ecnt_pcie_data *data)
+{
+	int idx = data->idx;
+	unsigned int val = data->conf.val;
+	data->retValue = pcie_set_aspm(idx,val);
+	return 0;
+}
+
+int pcie_api_get_speed(struct ecnt_pcie_data *data)
+{
+	int idx = data->idx;
+	data->retValue = pcie_get_speed(idx);
+	return 0;
+}
+
+int pcie_api_set_speed(struct ecnt_pcie_data *data)
+{
+	int idx = data->idx;
+	unsigned int val = data->conf.val;
+	data->retValue = pcie_set_speed(idx,val);
+	return 0;
+}
+
+int pcie_api_get_count(struct ecnt_pcie_data *data)
+{
+	int idx = data->idx;
+	data->retValue = pcie_get_count(idx, &data->cnt);
+	return 0;
+}
+
+ int pcie_api_get_linkstate(struct ecnt_pcie_data *data)
+{
+	int idx = data->idx;
+	data->retValue = pcie_get_linkstate(idx);
+	return 0;
+}
+
+ecnt_ret_val ecnt_pcie_api_hook(struct ecnt_data *in_data)
+{
+	struct ecnt_pcie_data *data = (struct ecnt_pcie_data *)in_data ;	
+	
+	if(data->function_id >= PCIE_FUNCTION_MAX_NUM) {
+		printk("pcie data->function_id is %d, exceed max number: %d", data->function_id, PCIE_FUNCTION_MAX_NUM);
+ 		return ECNT_HOOK_ERROR;
+	}
+
+	spin_lock(&pcie_api_lock);
+	pcie_operation[data->function_id](data) ;
+	spin_unlock(&pcie_api_lock);
+	
+	return ECNT_CONTINUE;
+}
+
+static long pcie_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) 
+{
+	int ret = 0 ;
+	struct ecnt_pcie_data data;
+	struct ecnt_pcie_data* puser = (struct ecnt_pcie_data*)arg;
+
+	if (cmd >= PCIE_FUNCTION_MAX_NUM)
+		return -1;
+	
+	memset(&data,0,sizeof(struct ecnt_pcie_data));
+	copy_from_user(&data, puser ,sizeof(struct ecnt_pcie_data));
+	spin_lock(&pcie_api_lock);	
+	ret = pcie_operation[data.function_id](&data);
+	spin_unlock(&pcie_api_lock);
+	copy_to_user(puser,&data,sizeof(struct ecnt_pcie_data));
+	
+	return ret;
+}
+
+int pcie_api_init(void)
+{
+	int ret;
+	
+	if(ecnt_register_hook(&ecnt_pcie_api_op)){
+		printk("pcie ecnt_dev_fe_api_op register fail\n");
+		return 0;
+	}
+
+	ret = register_chrdev(PCIE_MAJOR, "/dev/pcie", &pcie_fops);
+	
+	if (ret < 0) {
+		printk(KERN_WARNING "pcie: can't get major %d\n", PCIE_MAJOR);
+		return ret;
+	}
+
+	return 0;
+}
+
+#else
+
+int pcie_api_init(void)
+{
+	return 0;
+}
+
+#endif
+
+
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/pci/pcie-phy.c tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/pcie-phy.c
--- linux-2.6.36/arch/mips/pci/pcie-phy.c	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/pcie-phy.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,426 @@
+#include <asm/tc3162/tc3162.h>
+#include <linux/delay.h>
+
+//#define PCIE_PHY_DEBUG 1
+
+#define ENABLE 1
+#define DISABLE 0
+
+#if defined(TCSUPPORT_BONDING)
+extern unsigned long slaveVirBaseAddr;
+#endif
+
+
+#if 0 //for FPGA auto scan timing
+#define PCIe_AUTO_SCAN_TIMING 1
+#define PCIE_7510_FPGA_TIMING_PHY_P0 12
+#define PCIE_7510_FPGA_TIMING_PHY_P1 13
+#define PHY_PORT0 0
+#define PHY_PORT1 1
+
+static int  pcie_reset_link(check_addr)
+{
+	int i;
+	uint32 tmp;
+	//PCI-E reset
+	/* enabled PCIe port 1 */
+	VPint(0xbfb00088) |= (1<<22);
+	mdelay(1);
+	/*first reset to default*/
+	VPint(0xbfb00834) &= ~((1<<26) | (1<<27) | (1<<29));
+	mdelay(1);
+	VPint(0xbfb00834) |= ((1<<26) | (1<<27) | (1<<29));
+	mdelay(1);
+	VPint(0xbfb00834) &= ~((1<<26) | (1<<27) | (1<<29));
+	mdelay(1);
+
+	//relese pcie device reset
+	VPint(0xbfb80000) &= ~((1<<1) | (1<<2));
+	mdelay(1);
+
+	//start to check pcie if link up
+	//wait device link up
+	for(i=1 ; i<601 ; i++){
+		mdelay(1);
+		if((VPint(check_addr) & 0x1) != 0){
+			break;
+		}   
+		if((i%100)==0){//reset device PCIe MAC if not link up every 100ms biker_20120816
+			//pcie reset again
+			VPint(0xbfb80000) |= ((1<<1) | (1<<2));
+			mdelay(1);
+
+			VPint(0xbfb80000) &= ~((1<<1) | (1<<2));
+			mdelay(1);
+		}
+	}
+	if(i == 601)
+		return -1;
+	else
+		return 0;
+
+}
+#endif
+
+void pcie_phy_force_mode_en(char enable, char rc_num){
+
+	if(isFPGA)
+		return;
+
+	//printk("pcie_phy_force_mode_en %x %x \n",enable,rc_num);
+	if(enable == ENABLE) //means disable
+	{
+		switch (rc_num){
+			case 0:
+				regWrite32(0xbfaf202c, 0x1010);
+				regWrite32(0xbfaf202c, 0x1090);
+				regWrite32(0xbfaf202c, 0x1010);
+				break;
+			case 1:
+				regWrite32(0xbfaf212c, 0x1010);
+				regWrite32(0xbfaf212c, 0x1090);
+				regWrite32(0xbfaf212c, 0x1010);
+				break;
+#if defined(TCSUPPORT_BONDING)
+
+			case 2: //external chip use for bonding
+				if(slaveVirBaseAddr != 0){
+					regWrite32(slaveVirBaseAddr + 0xaf202c, 0x1010); 
+					regWrite32(slaveVirBaseAddr + 0xaf202c, 0x1090);
+					regWrite32(slaveVirBaseAddr + 0xaf202c, 0x1010);
+					
+					regWrite32(slaveVirBaseAddr + 0xaf212c, 0x1010); 
+					regWrite32(slaveVirBaseAddr + 0xaf212c, 0x1090);
+					regWrite32(slaveVirBaseAddr + 0xaf212c, 0x1010);
+				}	
+				break;
+#endif
+			default:
+				printk("RC number %d Error !! \n",rc_num);
+				break;
+		}
+		
+	}
+	else
+	{
+		switch (rc_num){
+			case 0:
+				regWrite32(0xbfaf202c, 0x0);
+				regWrite32(0xbfaf202c, 0x80);
+				regWrite32(0xbfaf202c, 0x0);
+				break;
+			case 1:
+				regWrite32(0xbfaf212c, 0x0);
+				regWrite32(0xbfaf212c, 0x80);
+				regWrite32(0xbfaf212c, 0x0);
+				break;
+#if defined(TCSUPPORT_BONDING)
+
+			case 2: //external
+				if(slaveVirBaseAddr != 0){
+					regWrite32(slaveVirBaseAddr + 0xaf202c, 0x0); 
+					regWrite32(slaveVirBaseAddr + 0xaf202c, 0x80);
+					regWrite32(slaveVirBaseAddr + 0xaf202c, 0x0);
+					
+					regWrite32(slaveVirBaseAddr + 0xaf212c, 0x0); 
+					regWrite32(slaveVirBaseAddr + 0xaf212c, 0x80);
+					regWrite32(slaveVirBaseAddr + 0xaf212c, 0x0);
+				}
+				break;
+#endif
+			default:
+				printk("RC number %d Error !! \n",rc_num);
+				break;
+		}
+	}
+}
+ void init_60901(void)
+{
+	uint32 tmp;
+	#ifdef PCIE_PHY_DEBUG
+	printk("biker1_pcie_phy_init debug message: master init \n");
+	printk("debug: read address 0xbfaf24a0 (380389); value is: %lx\n",VPint(0xbfaf24a0));
+	printk("debug: read address 0xbfaf24a8 (E80E8); value is: %lx\n",VPint(0xbfaf24a8));
+	#endif
+	//init Master
+	//init 20MHz or 25MHz
+	tmp = (regRead32(0xbfb0008c)&(0x3 <<22))>>22;
+	if (tmp == 0x1 ) 
+	{
+		//xtal is 20MHz 
+		#ifdef PCIE_PHY_DEBUG
+		printk("xtal is 20MHz \n");
+		#endif
+
+		//I2C      70    0xA8[11:00]   0x74      RW      RG_PE1_H_LCDDS_SSC_DELTA        //Improve SSC deviation	
+		//tmp = regRead32(0xbfaf24a8);
+		regWrite32(0xbfaf24a8, 0x740074);
+		//VPint(0xbfaf24a8) = (VPint(0xbfaf24a8) & (~0xfff )) | (0x74);
+		mdelay(1);	
+		//I2C      70    0xA8[23:16]   0x74      RW      RG_PE1_H_LCDDS_SSC_DELTA1       //Improve SSC deviation	
+		//VPint(0xbfaf24a8) =  (VPint(0xbfaf24a8) & (~(0xfff <<16))) | (0x74<<16);
+		//I2C      70    0xA0[19:19]   0x00      RW      RG_PE1_H_LCDDS_SSC_EN           //Disable SSC	
+		tmp = regRead32(0xbfaf24a0);
+		regWrite32(0xbfaf24a0, tmp & (~(0x1 <<19)) );
+		//VPint(0xbfaf24a0) =  VPint(0xbfaf24a0) & (~(0x1 <<19)) ;
+		mdelay(1);	
+		//I2C      70    0xA0[19:19]   0x01      RW      RG_PE1_H_LCDDS_SSC_EN           //Enable SSC	
+		tmp = regRead32(0xbfaf24a0);
+		regWrite32(0xbfaf24a0, tmp | (0x1<<19) );
+		//VPint(0xbfaf24a0) =  VPint(0xbfaf24a0)  | (0x1<<19);
+		mdelay(1);
+	}else if(tmp == 0x0 )
+	{   
+		//xtal is 25MHz 
+		#ifdef PCIE_PHY_DEBUG
+		printk("xtal is 25MHz \n");
+		#endif
+//	I2C      70    0xFC[31:24]   0x00      RW                                      //Change bank address to 0x00
+//	I2C      70    0x00[04:04]   0x01      RW      rg_pe1_frc_phy_en               //Force Port 0 disable control
+		regWrite32(0xbfaf2000,  (regRead32(0xbfaf2000) &(~(0x1 <<4)) ) | (0x1<<4) );
+		mdelay(1);
+//	I2C      70    0xFC[31:24]   0x01      RW                                      //Change bank address to 0x01
+//	I2C      70    0x00[04:04]   0x01      RW      rg_pe1_frc_phy_en               //Force Port 1 disable control
+		regWrite32(0xbfaf2100,  (regRead32(0xbfaf2100) &(~(0x1 <<4)) ) | (0x1<<4) );
+		mdelay(1);
+
+//	I2C      70    0xFC[31:24]   0x00      RW                                      //Change bank address to 0x00
+//	I2C      70    0x00[05:05]   0x00      RW      rg_pe1_phy_en                   //Port 0 disable
+		regWrite32(0xbfaf2000,  (regRead32(0xbfaf2000) &(~(0x1 <<5)) )  );
+		mdelay(1);
+
+//	I2C      70    0xFC[31:24]   0x01      RW                                      //Change bank address to 0x01
+//	I2C      70    0x00[05:05]   0x00      RW      rg_pe1_phy_en                   //Port 1 disable
+		regWrite32(0xbfaf2100,  (regRead32(0xbfaf2100) &(~(0x1 <<5)) ) );
+		mdelay(1);
+
+//	I2C      70    0xFC[31:24]   0x04      RW                                      //Change bank address to 0x04
+//	I2C      70    0x00[08:08]   0x01      RW      rg_pe1_frc_h_xtal_type          //
+		regWrite32(0xbfaf2400,  (regRead32(0xbfaf2400) &(~(0x1 <<8)) ) | (0x1<<8) );
+		mdelay(1);
+
+//	I2C      70    0x00[10:09]   0x00      RW      rg_pe1_h_xtal_type              //
+		regWrite32(0xbfaf2400,  (regRead32(0xbfaf2400) &(~(0x3 <<9)) )  );
+		mdelay(1);
+
+//	I2C      70    0x90[15:12]   0x0A      RW      RG_PE1_H_PLL_IR                 //
+		regWrite32(0xbfaf2490,  (regRead32(0xbfaf2490) &(~(0xf <<12)) ) | (0xA<<12) );
+		mdelay(1);
+
+//	I2C      70    0xAC[18:16]   0x01      RW      RG_PE1_H_PLL_BR                 //
+		regWrite32(0xbfaf24AC,  (regRead32(0xbfaf24AC) &(~(0x7 <<16)) ) | (0x1<<16) );
+		mdelay(1);
+		
+//	I2C      70    0x9C[30:16]   0x1900    RW      RG_PE1_H_LCDDS_PCW_NCPO         //
+		regWrite32(0xbfaf249C,  (regRead32(0xbfaf249C) &(~(0x7fff <<16)) ) | (0x1900<<16) );
+		mdelay(1);
+		
+//	I2C      70    0x9C[31:31]   0x00      RW      RG_PE1_H_LCDDS_PCW_NCPO_CHG     //
+		regWrite32(0xbfaf249C,  (regRead32(0xbfaf249C) &(~(0x1 <<31)) ) );
+		mdelay(1);
+
+//	I2C      70    0x9C[31:31]   0x01      RW      RG_PE1_H_LCDDS_PCW_NCPO_CHG     //
+		regWrite32(0xbfaf249C,  regRead32(0xbfaf249C)  | (0x1<<31) );
+		mdelay(1);
+
+//	I2C      70    0xA4[15:00]   0x018D    RW      RG_PE1_H_LCDDS_SSC_PRD          //
+		regWrite32(0xbfaf24A4,  (regRead32(0xbfaf24A4) &(~(0xffff )) ) | (0x18D) );
+		mdelay(1);
+
+//	I2C      70    0xA8[11:00]   0x004A    RW      RG_PE1_H_LCDDS_SSC_DELTA        //
+		regWrite32(0xbfaf24A8,  (regRead32(0xbfaf24A8) &(~(0xfff )) ) | (0x4A) );
+		mdelay(1);
+
+//	I2C      70    0xA8[27:16]   0x004A    RW      RG_PE1_H_LCDDS_SSC_DELTA1       //
+		regWrite32(0xbfaf24A8,  (regRead32(0xbfaf24A8) &(~(0xfff <<16)) ) | (0x4A<<16) );
+		mdelay(1);
+
+//	I2C      70    0x00[12:12]   0x01      RW      rg_pe1_mstck_25m                //value of mstck_25m when force mode enable
+		regWrite32(0xbfaf2400,  (regRead32(0xbfaf2400)  ) | (0x1<<12) );
+		mdelay(1);
+
+//	I2C      70    0x00[11:11]   0x01      RW      rg_pe1_frc_mstck_25m            //force mode enable of mstck_25m
+		regWrite32(0xbfaf2400,  (regRead32(0xbfaf2400)  ) | (0x1<<11) );
+		mdelay(1);
+
+//	I2C      70    0xFC[31:24]   0x00      RW                                      //Change bank address to 0x00
+//	I2C      70    0x00[05:05]   0x01      RW      rg_pe1_phy_en                   //Port 0 enable
+		regWrite32(0xbfaf2000,  (regRead32(0xbfaf2000) |(0x1 <<5) )  );
+		mdelay(1);
+//	I2C      70    0xFC[31:24]   0x01      RW                                      //Change bank address to 0x01
+//	I2C      70    0x00[05:05]   0x01      RW      rg_pe1_phy_en                   //Port 1 enable
+		regWrite32(0xbfaf2100,  (regRead32(0xbfaf2100) |(0x1 <<5) ));
+		mdelay(1);
+
+//	I2C      70    0xFC[31:24]   0x00      RW                                      //Change bank address to 0x00
+//	I2C      70    0x00[04:04]   0x00      RW      rg_pe1_frc_phy_en               //Force Port 0 disable control
+		//regWrite32(0xbfaf2000,  (regRead32(0xbfaf2000) &(~(0x1 <<4)) ));
+		//mdelay(1);
+
+//	I2C      70    0xFC[31:24]   0x01      RW                                      //Change bank address to 0x01
+//	I2C      70    0x00[04:04]   0x00      RW      rg_pe1_frc_phy_en               //Force Port 1 disable control
+		//regWrite32(0xbfaf2100,  (regRead32(0xbfaf2100) &(~(0x1 <<4)) ));
+		//mdelay(1);
+
+//	I2C      70    0xFC[31:24]   0x00      RW                                      //Change bank address to 0x00
+
+	}
+	#ifdef PCIE_PHY_DEBUG
+	printk("pcie_phy_init debug message:\n");
+	printk("debug: read address 0xbfaf24a0 (380389); value is: %lx\n",VPint(0xbfaf24a0));
+	printk("debug: read address 0xbfaf24a8 (740074); value is: %lx\n",VPint(0xbfaf24a8));
+	#endif
+	
+	//init Slave
+	
+}
+
+#if 0 //for FPGA auto scan timing
+uint8 pcie_60901_auto_scan(uint8 PHY_PORT, uint8 win_range, uint8 win_loop, uint32 check_addr)
+{
+	uint8 win_init = 0;
+	uint8 win_start = 0;	
+	uint8 win_len = 0; 	
+	uint8 max_win_start = 0;	
+	uint8 max_win_len = 0; 	
+	uint8 i = 0;
+	uint8 timing = 0;
+
+	printk(">>>>>Start to scan PCIe timing setting<<<<<\n");
+		for (i=win_init; i<win_range; i++){
+			if (PHY_PORT == PHY_PORT0)
+				init_60901((uint32) (i%win_loop),0);
+			else
+				init_60901(0,(uint32) (i%win_loop));
+			//printk("timing setting: %2d ",i);
+			if (pcie_reset_link(check_addr) == 0){
+				win_len++;				
+				if(win_len > max_win_len){					
+					max_win_len = win_len;					
+					max_win_start = win_start;				
+				}				
+				printk("Link up! \n");		
+			}else{				
+			win_len = 0;				
+			win_start = i + 1;				
+			printk("Not link \n");			
+			}		
+		}		
+		timing = (uint8) ((max_win_start%win_loop) + ((max_win_len%win_loop)>>1));
+		printk("The pcie timing window start at : %d \n",max_win_start);		
+		printk("Window length is : %d \n",max_win_len);		
+		printk("The chosen PCIe: %d \n ",timing);
+		return timing;
+}
+#endif
+
+ void init_7505(void)
+{
+	//For WCN ch14 de-sence issue, default Disable SSC, bit 28 => 1
+	printk("Disable PCIe SSC\n");
+	regWrite32(0xbfaf2414,  (regRead32(0xbfaf2414) |(0x1 <<28) ));
+	
+	//change MSTSET from 1 to 5;
+	mdelay(1);
+	regWrite32(0xbfaf2498,  ((regRead32(0xbfaf2498) &(~0xff) )|(0x5) ));
+
+	//decrease PLL BW to improve jitter; by biker_20140721; add 25MHz_20140815
+	mdelay(1);
+	regWrite32(0xbfaf2400,  ((regRead32(0xbfaf2400) &(~(0x1<<8)) )|(0x1<<8) ));
+	mdelay(1);
+	regWrite32(0xbfaf2400,  ((regRead32(0xbfaf2400) &(~(0x3<<9)) )|(0x0<<9) ));
+	mdelay(1);
+	regWrite32(0xbfaf2000,  ((regRead32(0xbfaf2000) &(~(0x1<<4)) )|(0x1<<4) ));
+	mdelay(1);
+	regWrite32(0xbfaf2000,  ((regRead32(0xbfaf2000) &(~(0x1<<5)) )|(0x0<<5) ));
+	mdelay(1);
+	regWrite32(0xbfaf24ac,  ((regRead32(0xbfaf24ac) &(~(0x7<<16)) )|(0x3<<16) ));
+	mdelay(1);
+	regWrite32(0xbfaf24bc,  ((regRead32(0xbfaf24bc) &(~(0xff<<24)) )|(0x64<<24) ));
+	mdelay(1);
+	regWrite32(0xbfaf2490,  ((regRead32(0xbfaf2490) &(~(0xf<<12)) )|(0xa<<12) ));
+	mdelay(1);
+	regWrite32(0xbfaf2490,  ((regRead32(0xbfaf2490) &(~(0x3<<6)) )|(0x0<<6) ));
+	mdelay(1);
+	regWrite32(0xbfaf24c0,  ((regRead32(0xbfaf24c0) &(~(0xffffffff<<0)) )|(0x19000000<<0) ));
+	mdelay(1);
+	regWrite32(0xbfaf24a4,  ((regRead32(0xbfaf24a4) &(~(0xffff<<0)) )|(0x18d<<0) ));
+	mdelay(1);
+	regWrite32(0xbfaf24a8,  ((regRead32(0xbfaf24a8) &(~(0xfff<<0)) )|(0x4a<<0) ));
+	mdelay(1);
+	regWrite32(0xbfaf24a8,  ((regRead32(0xbfaf24a8) &(~(0xfff<<16)) )|(0x4a<<16) ));
+	mdelay(1);
+	regWrite32(0xbfaf2000,  ((regRead32(0xbfaf2000) &(~(0x1<<5)) )|(0x1<<5) ));
+	mdelay(1);
+	regWrite32(0xbfaf2000,  ((regRead32(0xbfaf2000) &(~(0x1<<4)) )|(0x0<<4) ));
+	mdelay(1);
+
+
+	/*MT7505 input crystall is 40Mhz*/
+	//Fix frequence setting bug when hardware trap is 40MHz XTAL ; 
+#if 0	//Already done in bootloader
+	if(VPint(CR_AHB_HWCONF)&(1<<1)){
+	VPint(0xbfaf2400) = (VPint(0xbfaf2400) | 0x100); /*force mode enable xtal type*/
+	}
+#endif
+		
+}
+void init_7512(void)
+{
+/* By Zhao Mengqing, 2016-7-4, 单频机型则关闭RC1接口，仅使用RC0接口，以降低功耗和温度 */
+#if defined(CONFIG_PW_MODEL_PVW41T300NV2) || defined(CONFIG_PW_MODEL_W9960V1) || defined(CONFIG_PW_MODEL_W9960V1_20)
+	printk("PCIe driver version:751221.2.2016.0429\n");
+	
+	//LCDDS_CLK_PH_INV
+	regWrite32(0xbfaf24a0, ((regRead32(0xbfaf24a0) & (~(0x1<<5))) | (0x1<<5) ));
+	mdelay(1);
+	
+	if (isEN751221)
+	{
+		//7512 is QFP IC, use gen1 prot only, disable gen2 port for COC test
+		regWrite32(0xbfac030c, (regRead32(0xbfac030c) | (0x1 << 31))); //PHY IP_SW_RESET
+		mdelay(1);
+	}
+#else
+	regWrite32(0xbfaf24a0, 0x3813e9);
+	mdelay(1);
+#endif
+}
+
+int pciePhyInit(void){
+
+#if 0	//for FPGA auto scan timing	
+#ifdef PCIe_AUTO_SCAN_TIMING
+		timing_p0 = pcie_60901_auto_scan(PHY_PORT0,36,18,0xbfb83050);
+		timing_p1 = pcie_60901_auto_scan(PHY_PORT1,36,18,0xbfb82050);
+#endif
+#endif
+
+	if(isEN751221) {
+		
+		if (!isFPGA) {
+			init_7512();
+		}
+	}
+
+	if(isMT7505) {
+		
+		if (!isFPGA) {
+			init_7505();
+		}
+	}
+	
+	if(isMT751020){
+#if 0	//for FPGA auto scan timing	
+#ifdef PCIe_AUTO_SCAN_TIMING
+		timing_p0 = pcie_60901_auto_scan(PHY_PORT0,36,18,0xbfb83050);
+		timing_p1 = pcie_60901_auto_scan(PHY_PORT1,36,18,0xbfb82050);
+#endif
+#endif
+		init_60901();
+
+	}
+	
+	return 0;
+}
+
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/pci/pci-tc3162.c tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/pci-tc3162.c
--- linux-2.6.36/arch/mips/pci/pci-tc3162.c	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/pci-tc3162.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,118 @@
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/tc3162/tc3162.h>
+
+
+#ifdef CONFIG_MIPS_TC3262
+#define PCI_COMMAND_WINDOW 0xBFB80CF8
+#endif
+static struct resource tc3162_pci_io_resource = {
+	.name   = "pci IO space",
+	.start  = 0x1FB90000,
+	.end    = 0x1FB9FFFF,
+	.flags  = IORESOURCE_IO
+};
+
+static struct resource tc3162_pci_mem_resource = {
+	.name   = "pci memory space",
+	.start  = 0x1FBA0000,
+	.end    = 0x1FBCFFFF,
+	.flags  = IORESOURCE_MEM
+};
+
+extern struct pci_ops tc3162_pci_ops;
+
+struct pci_controller tc3162_controller = {
+	.pci_ops   		= &tc3162_pci_ops,
+	.io_resource	= &tc3162_pci_io_resource,
+	.mem_resource	= &tc3162_pci_mem_resource,
+};
+
+static __init int tc3162_pci_init(void)
+{
+	int pci_bios;
+	unsigned long tmp;
+
+	if(isRT63365 || isMT751020 || isMT7505 || isEN751221)
+		return -1;
+
+#ifndef CONFIG_MIPS_TC3262
+	pci_bios = regRead32(CR_AHB_HWCONF) & (1<<8);
+
+	printk(KERN_INFO "tc3162: system has %sPCI BIOS\n",
+		pci_bios ? "" : "no ");
+	if (pci_bios == 0)
+		return -1;
+#endif
+	tmp = regRead32(CR_AHB_PCIC);
+	regWrite32(CR_AHB_PCIC, (tmp & ~(1<<31)));
+	mdelay(100);
+	tmp = regRead32(CR_AHB_PCIC);
+	regWrite32(CR_AHB_PCIC, (tmp | (1<<31)));
+	mdelay(300);
+
+	/* PCI memory byte swap enable */
+	/*
+	tmp = regRead32(CR_AHB_PCIC);
+	regWrite32(CR_AHB_PCIC, (tmp | ((1<<24) | (1<<25))) );
+	*/
+
+#ifdef CONFIG_MIPS_TC3262
+
+	/*read pci enable bit from PCI bridge command window to check pci support.
+           shnwind*/
+	regWrite32(PCI_COMMAND_WINDOW, (1<<31));
+	pci_bios = regRead32(PCI_COMMAND_WINDOW);
+	 
+	printk(KERN_INFO "system has %sPCI BIOS\n",pci_bios ? "" : "no ");
+	if (pci_bios == 0){
+		return -1;
+	}
+#endif	
+	/* Set I/O resource limits.  */
+	ioport_resource.end = 0x1fffffff;
+	iomem_resource.end = 0xffffffff;
+
+if(isRT63165)
+{
+/* rt63165's PCI bridge has additional config registers 
+ * which can be direct-accessed, such as the first 3 
+ * registers shown below
+ */
+	//Disable PCI IO SWAP.
+	
+	tmp = regRead32(0xbfb000ec);
+	tmp &= ~(1<<9);
+	regWrite32(0xbfb000ec, tmp);
+
+    /* configure USB Host Control Register to 
+     do byte swaping in HW --Trey */
+	regWrite32(0xbfb000a8, 0x00000060);
+    mdelay(10);
+    /* set space of PCI base address
+    up to 256M  --Trey*/
+    regWrite32(0xbfb80010, 0x0fff0001);
+    /* configure PCIArbitor Control Register to
+    set priority scheme --Trey*/
+    regWrite32(0xbfb80080, 0x00000079);
+
+    //set base address of PCI
+    regWrite32(0xbfb80cf8, 0x80000410);
+    regWrite32(0xbfb80cfc, 0x00000000);
+    
+    //enable PCI's master, memory functions 
+    regWrite32(0xbfb80cf8, 0x80000404);
+    regWrite32(0xbfb80cfc, 0xa4800016);
+    
+    //set PCI's latency-timer, cache-line-size
+    regWrite32(0xbfb80cf8, 0x8000040c);
+    regWrite32(0xbfb80cfc, 0x00002008);
+}
+	register_pci_controller(&tc3162_controller);
+	return 0;
+}
+
+arch_initcall(tc3162_pci_init);
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/pci/pci-tc3162u.c tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/pci-tc3162u.c
--- linux-2.6.36/arch/mips/pci/pci-tc3162u.c	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/pci/pci-tc3162u.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,3261 @@
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h> 
+#include <asm/tc3162/tc3162.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+
+//#define PCIE_DEBUG	1
+//#define ESD_DEBUG 1
+//#define PRE_CONFIG_DEBUG 1
+#ifdef TCSUPPORT_WLAN_MT7592_PCIE
+#define MCU_CFG_BASE		0x2000
+#define MCU_PCIE_REMAP_1	(MCU_CFG_BASE + 0x500)
+#define REMAP_1_OFFSET_MASK (0x3ffff)
+#define GET_REMAP_1_OFFSET(p) (((p) & REMAP_1_OFFSET_MASK))
+#define REMAP_1_BASE_MASK	(0x3fff << 18)
+#define GET_REMAP_1_BASE(p) (((p) & REMAP_1_BASE_MASK) >> 18)
+#define MCU_PCIE_REMAP_2	(MCU_CFG_BASE + 0x504)
+#define REMAP_2_OFFSET_MASK (0x7ffff)
+#define GET_REMAP_2_OFFSET(p) (((p) & REMAP_2_OFFSET_MASK))
+#define REMAP_2_BASE_MASK (0x1fff << 19)
+#define GET_REMAP_2_BASE(p) (((p) & REMAP_2_BASE_MASK) >> 19)
+#endif
+
+#define PCIE_CONFIG_ADDR		0xbfb81cf8
+#define PCIE_CONFIG_DATA		0xbfb81cfc
+#define AHB_BUS_TIMEOUT_ERR		(1<<25)
+#define AHB_BUS_ADDR_ERR		(1<<24)
+
+#define NIC3090_PCIe_DEVICE_ID  0x3090		// 1T/1R miniCard
+#define NIC3091_PCIe_DEVICE_ID  0x3091		// 1T/2R miniCard
+#define NIC3092_PCIe_DEVICE_ID  0x3092		// 2T/2R miniCard
+#define NIC3390_PCIe_DEVICE_ID  0x3390		// 1T/1R miniCard
+#define NIC5390_PCIe_DEVICE_ID	0x5390
+#define NIC539F_PCIe_DEVICE_ID  0x539F
+#define NIC5392_PCIe_DEVICE_ID  0x5392
+#define NIC5592_PCIe_DEVICE_ID  0x5592
+#define NIC3593_PCIe_DEVICE_ID  0x3593
+#define PCIE60901_DEVICE_ID 	0x7510
+#define NIC7603_PCIe_DEVICE_ID	0x7603
+
+#define NIC_PCI_VENDOR_ID	0x1814
+#define MTK_PCI_VENDOR_ID 	0x14c3
+
+#define PCI_DEVICE_MEM1		0xbf700000
+#define PCIE_TYPE_RC		0x0
+#define PCIE_TYPE_DEV		0x1
+
+#define PCIE_BUS_0			0x0
+#define PCIE_BUS_1			0x1
+#define PCIE_BUS_2			0x2
+#define PCIE_BUS_3			0x3
+#define PCIE_DEV_0			0x0
+#define PCIE_DEV_1			0x1
+#define PCIE_BUS_RC			0x0
+#define PCIE_BUS_DEV		0x1
+#define PCIE_DEVNUM_0		0x0
+#define PCIE_DEVNUM_1		0x1
+#define PCIE_RESET_CON_BUSTIMEOUT 0
+#define PCIE_RESET_CON_PCIEERROR 1
+#define PCIE_SAVE_BUS_NUM	4
+#define PCIE_SAVE_DEVICE_NUM	2
+#define ENABLE 1
+#define DISABLE 0
+
+#define PHYSADDR(a)	((unsigned int)(a)&0x1fffffff)
+
+#if defined(TCSUPPORT_CPU_MT7505) || defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+#define isRC0_LINKUP		((regRead32(0xbfb80050) & 0x2) ? 1 : 0)  
+#define isRC1_LINKUP		((regRead32(0xbfb80050) & 0x4) ? 1 : 0)
+#else 
+#define isRC0_LINKUP		((regRead32(0xbfb82050) & 0x1) ? 1 : 0)
+#define isRC1_LINKUP		((regRead32(0xbfb83050) & 0x1) ? 1 : 0)
+
+#define isSLAVERC_LINKUP	((regRead32(0xbfb80050) & 0x1) ? 1 : 0)
+
+#endif
+
+struct pci_config_s{	
+	int reg;	
+	unsigned long int value;
+};
+
+#ifdef TCSUPPORT_WLAN_MT7592_PCIE
+struct pci_linkpath_s{	
+	int rcbusnum;
+	int rcdevnum;
+	int epbusnum;
+	int epdevnum;
+};
+
+struct pci_probeinfo_s{	
+	char rcindex;
+	char flag;
+	struct pci_linkpath_s num[2];
+};
+
+struct pci_access_s{	
+	int busnum;
+	int devnum;
+	int reg;	
+	unsigned long int value;
+};
+#endif
+#if defined(TCSUPPORT_BONDING)
+#define MAX_REG_CONFIG  3
+struct reg_config_s{	
+	unsigned int reg;	
+	unsigned int value;
+};
+#endif
+
+/**************************Gloabol Value***************************/
+
+#if defined(TCSUPPORT_BONDING)
+unsigned long slaveVirBaseAddr = 0;
+struct reg_config_s reg_config_temp[MAX_REG_CONFIG];
+#endif
+extern uint32 pcie_config_addr;
+extern uint32 pcie_config_data;
+
+static int ahb_status=0;
+static int pcie_soft_patch=1;
+static int wifiDeviceId = 0;
+int dual_band_support = 0;
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+static char pcie_reset_condiction = PCIE_RESET_CON_PCIEERROR;/*change default value*/
+#else
+static char pcie_reset_condiction = PCIE_RESET_CON_BUSTIMEOUT;
+#endif
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+static int pcie_error_detect_count = 1;/*when pcie error count is beyond pcie_error_detect_count, do pcie reset*/
+#endif
+static int pcie_reset_count = 0;
+static char rc0_is_exist=0, rc1_is_exist=0;
+static DEFINE_SPINLOCK(pcie_esd_lock);
+struct pci_config_s *pcie_config_temp[PCIE_SAVE_BUS_NUM][PCIE_SAVE_DEVICE_NUM];//save 4 bus and 2 dev for each bus
+
+#ifdef TCSUPPORT_WLAN_MT7592_PCIE
+#define MAX_PRE_CONFIG_NUM 20
+
+enum
+{
+	MODE0RCBASEADDR = 0,
+	MODE1RCBASEADDR = 2,
+	MODE2RCBASEADDR = 4,
+};
+
+struct pci_config_s pcie_config_table_WiFi_RC0_Special[] =
+{
+	//single wifi
+	//wifi mode :(dual band)
+	//linebond mode:(only master wifi)
+	{0x18,0x00010100},
+	{-1,0},
+	//linebond mode:(only slave wifi,dualband)
+	{0x18,0x00020100},
+	{0x18,0x00020201},
+	{-1,0}
+};
+
+struct pci_config_s pcie_config_table_WiFi_RC1_Special[] =
+{
+	//single wifi
+	{0x18,0x00010100},
+	{-1,0},
+	//wifi mode :(dual band)
+	//linebond mode:(only master wifi)
+	{0x18,0x00020200},
+	{-1,0},
+	//linebond mode:(dualband)
+	{0x18,0x00020100},
+	{0x18,0x00030300},
+	{-1,0}
+};
+
+#ifdef TCSUPPORT_BONDING
+struct pci_config_s pcie_config_table_EP[] =
+{
+	{0x04,0x00100006},{0x10,0x21000000},
+	{-1,0}
+};
+
+struct pci_config_s pcie_config_table_WiFi_RC_General[] =
+{
+	//first RC1 and then RC0
+	{0x04,0x00100007},{0x20,0x21002100},
+	{-1,0},
+	{0x04,0x00100007},{0x20,0x21702000},
+	{-1,0}
+};
+struct pci_config_s pcie_config_table_WiFi_RC_Slave_General[] =
+{
+	//first RC1 and then RC0
+	{0x04,0x00100007},{0x20,0x21702100},
+	{-1,0},
+	{0x04,0x00100007},{0x20,0x21702000},
+	{-1,0}
+};
+
+struct pci_config_s pcie_config_table_WiFi_RC_Master_General[] =
+{
+	//first RC1 and then RC0
+	{0x04,0x00100007},{0x20,0x21002100},
+	{-1,0},
+	{0x04,0x00100007},{0x20,0x20002000},
+	{-1,0}
+};
+
+struct pci_config_s pcie_config_table_EP_DMT[] =
+{
+	{0x04,0x00100007},{0x10,0x20000000},
+	{-1,0}
+};
+
+#else
+struct pci_config_s pcie_config_table_EP[] =
+{
+	{0x04,0x00100006},{0x10,0x20000000},
+	{-1,0}
+};
+
+struct pci_config_s pcie_config_table_WiFi_RC_General[] =
+{
+	{0x04,0x00100007},{0x20,0x20002000},
+	{-1,0}
+};
+
+#endif
+
+struct pci_access_s pcie_config_table_temp[MAX_PRE_CONFIG_NUM];
+
+#endif
+
+/**************************function definition***************************/
+static void aer_status_dump(void);
+extern int pciePhyInit(void);
+extern void pcie_phy_force_mode_en(char enable, char rc_num);
+void aer_config(int aerEnable);
+void pcieResetRC0(void);
+void pcieResetRC1(void);
+int pcie_timeout_disable(void);
+static void aer_status_clear(void);
+unsigned long int pcie_read_config_word(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum);
+int pcie_write_config_word(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum, unsigned long int value);
+int pcie_write_config_byte(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum, unsigned char value);
+int pcie_reset_handler(char rc_num);
+struct pci_config_s *save_pcie_config(char bus, char dev);
+void restore_pcie_config(char bus, char dev, struct pci_config_s* restore_p);
+
+
+
+static struct resource tc3162_pcie_io_resource = {
+	.name   = "pcie IO space",
+#ifdef CONFIG_MIPS_TC3162U
+	.start  = 0x1FBD0000,
+	.end    = 0x1FBEFFFF,
+#endif
+#ifdef CONFIG_MIPS_TC3262
+	.start  = 0x1F600000,
+	.end    = 0x1F61FFFF,
+#endif
+	.flags  = IORESOURCE_IO
+};
+
+static struct resource tc3162_pcie_mem_resource = {
+	.name   = "pcie memory space",
+	.start  = 0x1F700000,
+	.end    = 0x1F8FFFFF,
+	.flags  = IORESOURCE_MEM
+};
+
+extern struct pci_ops tc3162_pcie_ops;
+
+struct pci_controller tc3162_pcie_controller = {
+	.pci_ops   		= &tc3162_pcie_ops,
+	.io_resource	= &tc3162_pcie_io_resource,
+	.mem_resource	= &tc3162_pcie_mem_resource,
+};
+
+extern struct pci_ops mt7512_pcie_ops;
+struct pci_controller mt7512_pcie_controller = {
+	.pci_ops   		= &mt7512_pcie_ops,
+	.io_resource	= &tc3162_pcie_io_resource,
+	.mem_resource	= &tc3162_pcie_mem_resource,
+};
+
+#ifdef TCSUPPORT_WLAN_MT7592_PCIE
+unsigned long wifi_csr_addr = 0;
+#ifdef TCSUPPORT_BONDING
+unsigned long mappingaddr = 0;
+#endif
+#define RTMP_IO_READ32(_A, _R, _pV)	\
+{		\
+	(*_pV = readl((void *)((_A) + (_R))));			\
+}
+
+#define RTMP_IO_WRITE32(_A, _R, _V)		\
+{		\
+	writel((_V), (void *)((_A) + (_R)));\
+}
+
+void GlobalCRWrite(unsigned char* baseAddr, unsigned long Offset, unsigned long Value)
+{
+	unsigned long RemapBase, RemapOffset;
+	unsigned long RestoreValue;
+
+	RTMP_IO_READ32(baseAddr, MCU_PCIE_REMAP_1, &RestoreValue);
+	RemapBase = GET_REMAP_1_BASE(Offset) << 18;
+	RemapOffset = GET_REMAP_1_OFFSET(Offset);
+	RTMP_IO_WRITE32(baseAddr, MCU_PCIE_REMAP_1, RemapBase);
+	RTMP_IO_WRITE32(baseAddr, 0x40000 + RemapOffset, Value);
+
+	RTMP_IO_WRITE32(baseAddr, MCU_PCIE_REMAP_1, RestoreValue);
+}
+
+void GlobalCRRead(unsigned char* baseAddr, unsigned long Offset, unsigned long *Value)
+{
+	unsigned long RemapBase, RemapOffset;
+	unsigned long RestoreValue;
+
+	RTMP_IO_READ32(baseAddr, MCU_PCIE_REMAP_1, &RestoreValue);
+	RemapBase = GET_REMAP_1_BASE(Offset) << 18;
+	RemapOffset = GET_REMAP_1_OFFSET(Offset);
+	RTMP_IO_WRITE32(baseAddr, MCU_PCIE_REMAP_1, RemapBase);
+	RTMP_IO_READ32(baseAddr, 0x40000 + RemapOffset, Value);
+
+	RTMP_IO_WRITE32(baseAddr, MCU_PCIE_REMAP_1, RestoreValue);
+}
+
+void RecoverInitialValue()
+{
+	struct pci_access_s * config_p = &pcie_config_table_temp[0];
+	int i = 0;
+#ifdef PRE_CONFIG_DEBUG	
+	printk("\r\n====RecoverInitValue====\r\n");
+#endif
+	while((i < MAX_PRE_CONFIG_NUM) && ((*(config_p + (i))).reg != 0)){
+#ifdef PRE_CONFIG_DEBUG				
+		printk("[write]pre config bus %x dev %x reg %x value %lx \n", (*(config_p + i)).busnum,(*(config_p + i)).devnum,(*(config_p + i)).reg, (*(config_p + i)).value);
+#endif	
+		pcie_write_config_word(PCIE_TYPE_DEV,  (*(config_p + i)).busnum, (*(config_p + i)).devnum, (*(config_p + i)).reg, (*(config_p + i)).value);
+		memset((config_p + (i)),0,sizeof(struct pci_access_s ));
+		i++;
+	}
+}
+
+/*we config RC first and then read EP info,if wifichip==0x7603 then config EP*/
+int RegConfigFunc(struct pci_probeinfo_s* pre_info, struct pci_config_s* pre_config_RC_S)
+{
+	int i = 0,j = 0,k = 0,m = 0;
+	int wifiDevice;
+	int rcnum = pre_info->rcindex;
+	int rcbusindex = pre_info->num[0].rcbusnum;
+	int rcdevindex = pre_info->num[0].rcdevnum;
+	int epbusindex = pre_info->num[0].epbusnum;
+	int epdevindex = pre_info->num[0].epdevnum;
+	struct pci_config_s* pre_config_RC_G = &pcie_config_table_WiFi_RC_General[0];
+	struct pci_config_s* pre_config_EP = &pcie_config_table_EP[0];
+	#ifdef TCSUPPORT_BONDING
+	struct pci_config_s* pre_config_EP_DMT;
+	#endif
+	/*step1: config RC special register to led data pass RC to EP*/
+	while((*(pre_config_RC_S + (i))).reg != -1){		
+		if(i >= MAX_PRE_CONFIG_NUM)
+		{
+			#ifdef PRE_CONFIG_DEBUG
+			printk("\r\n pcie_config_table_temp is not enough");
+			#endif
+			RecoverInitialValue();
+			i = 0;
+		}
+		pcie_config_table_temp[i].busnum = rcbusindex;
+		pcie_config_table_temp[i].devnum = rcdevindex;
+		pcie_config_table_temp[i].reg = (*(pre_config_RC_S + i)).reg;
+		pcie_config_table_temp[i].value =  pcie_read_config_word(PCIE_TYPE_DEV, rcbusindex,rcdevindex, (*(pre_config_RC_S + i)).reg);
+
+		pcie_write_config_word(PCIE_TYPE_DEV,  rcbusindex, rcdevindex, (*(pre_config_RC_S + i)).reg, (*(pre_config_RC_S + i)).value);
+#ifdef PRE_CONFIG_DEBUG				
+		printk("[Config RC]pre config bus %x dev %x reg %x value %lx \n", rcbusindex,rcdevindex,(*(pre_config_RC_S + i)).reg, (*(pre_config_RC_S + i)).value);
+#endif		
+		i++;
+#ifdef TCSUPPORT_BONDING
+		if(--rcnum > 0)
+		{
+			rcbusindex = pre_info->num[i].rcbusnum;
+			rcdevindex = pre_info->num[i].rcdevnum;
+		}
+#endif
+	}	
+
+	/*step2: read EP CHIP info,if not 7603,just return*/
+	wifiDevice = pcie_read_config_word(PCIE_TYPE_DEV,  epbusindex,epdevindex, 0) >> 16;
+#ifdef PRE_CONFIG_DEBUG		
+	printk("[read device id]wifi config bus %x dev %x value %lx \n",epbusindex,epdevindex, pcie_read_config_word(PCIE_TYPE_DEV, epbusindex, epdevindex, 0));
+#endif
+	if(0x7603 != wifiDevice)
+	{
+		RecoverInitialValue();
+		#ifdef PRE_CONFIG_DEBUG	
+		printk("\r\n not 7592 wifi,so just return");
+		#endif
+		return -1;
+	}
+
+	/*step3: config RC general register*/
+	#ifdef TCSUPPORT_BONDING
+	if(1 ==  pre_info->flag)
+		pre_config_RC_G = &pcie_config_table_WiFi_RC_Slave_General[0];
+	else if(2 ==  pre_info->flag)
+		pre_config_RC_G = &pcie_config_table_WiFi_RC_Master_General[0];
+	#endif
+	
+	m = pre_info->rcindex;
+	while(--m >= 0)
+	{
+		while((*(pre_config_RC_G + (k))).reg != -1){		
+		if(i >= MAX_PRE_CONFIG_NUM)
+		{
+			#ifdef PRE_CONFIG_DEBUG
+			printk("\r\n pcie_config_table_temp is not enough");
+			#endif
+			RecoverInitialValue();
+			i = 0;
+		}
+			pcie_config_table_temp[i].busnum = rcbusindex;
+			pcie_config_table_temp[i].devnum = rcdevindex;
+			pcie_config_table_temp[i].reg = (*(pre_config_RC_G + k)).reg;
+			pcie_config_table_temp[i].value =  pcie_read_config_word(PCIE_TYPE_DEV, rcbusindex,rcdevindex, (*(pre_config_RC_G + k)).reg);
+	
+			pcie_write_config_word(PCIE_TYPE_DEV,  rcbusindex, rcdevindex, (*(pre_config_RC_G + k)).reg, (*(pre_config_RC_G + k)).value);
+#ifdef PRE_CONFIG_DEBUG				
+			printk("[Config RC]pre config bus %x dev %x reg %x value %lx \n", rcbusindex,rcdevindex,(*(pre_config_RC_G + k)).reg, (*(pre_config_RC_G + k)).value);
+#endif		
+			k++;
+			i++;
+		}
+		#ifdef TCSUPPORT_BONDING
+		if(m > 0)
+		{
+			k++;
+			rcbusindex = pre_info->num[m-1].rcbusnum;
+			rcdevindex = pre_info->num[m-1].rcdevnum;
+		}
+		#endif
+	};
+	
+#ifdef TCSUPPORT_BONDING
+	if(1 ==  pre_info->flag)
+	{
+		pre_config_EP_DMT = &pcie_config_table_EP_DMT[0];
+		m = 0;
+	/*step4: config EP dmt general register,only for linebond dual band and 7592 in slave ep*/
+		while((*(pre_config_EP_DMT + (m))).reg != -1){		
+				if(i >= MAX_PRE_CONFIG_NUM)
+				{
+					#ifdef PRE_CONFIG_DEBUG
+					printk("\r\n pcie_config_table_temp is not enough");
+					#endif
+					RecoverInitialValue();
+					i = 0;
+				}
+				pcie_config_table_temp[i].busnum = 1;
+				pcie_config_table_temp[i].devnum = 0;
+				pcie_config_table_temp[i].reg = (*(pre_config_EP_DMT + m)).reg;
+				pcie_config_table_temp[i].value =  pcie_read_config_word(PCIE_TYPE_DEV, 1, 0, (*(pre_config_EP_DMT + m)).reg);
+		
+				pcie_write_config_word(PCIE_TYPE_DEV,  1, 0, (*(pre_config_EP_DMT + m)).reg, (*(pre_config_EP_DMT + m)).value);
+#ifdef PRE_CONFIG_DEBUG				
+				printk("[Config EP]pre config bus %x dev %x reg %x value %lx \n", 1,0,(*(pre_config_EP_DMT + m)).reg, (*(pre_config_EP_DMT + m)).value);
+#endif		
+				i++;
+				m++;	
+		}
+		mappingaddr = 0x20000000;
+	}
+	else
+	{
+		mappingaddr = 0x21000000;
+	}
+#endif
+
+	/*step5: config EP general register*/
+	while((*(pre_config_EP + (j))).reg != -1){		
+			if(i >= MAX_PRE_CONFIG_NUM)
+			{
+			#ifdef PRE_CONFIG_DEBUG
+			printk("\r\n pcie_config_table_temp is not enough");
+			#endif
+				RecoverInitialValue();
+				i = 0;
+			}
+				
+			pcie_config_table_temp[i].busnum = epbusindex;
+			pcie_config_table_temp[i].devnum = epdevindex;
+			pcie_config_table_temp[i].reg = (*(pre_config_EP + j)).reg;
+			pcie_config_table_temp[i].value =  pcie_read_config_word(PCIE_TYPE_DEV, epbusindex, epdevindex, (*(pre_config_EP + j)).reg);
+	
+			pcie_write_config_word(PCIE_TYPE_DEV,  epbusindex, epdevindex, (*(pre_config_EP + j)).reg, (*(pre_config_EP + j)).value);
+#ifdef PRE_CONFIG_DEBUG				
+			printk("[Config EP]pre config bus %x dev %x reg %x value %lx \n", epbusindex,epdevindex,(*(pre_config_EP + j)).reg, (*(pre_config_EP + j)).value);
+#endif		
+			i++;
+			j++;	
+		}
+
+	
+#ifdef PRE_CONFIG_DEBUG 
+	printk("\r\nsave total index is %d",i);
+#endif
+
+	return 0;
+}
+
+int pciePreConfigReg()
+{
+	int preconfigflag = -1;
+	int preconfigtemp = -1;
+	int rctempflag = 0;
+	struct pci_probeinfo_s preinfo;
+	struct pci_config_s* pre_config_RC_S;
+	/*
+		preconfigflag
+		0:single wifi(include dual band with only one wifi)
+		1:wifi mode((dual band) and (lineband mode with only master wifi))
+		2:linebond mode(only slave wifi)
+		3:linebond mode(dual band)
+	*/
+	memset(&preinfo,0,sizeof(struct pci_probeinfo_s));
+	if(isMT751020 || isRT63368 || isEN751221)
+	{	
+		if(dual_band_support)
+		{
+			#ifdef TCSUPPORT_BONDING
+			rctempflag = (isRC0_LINKUP)|(isRC1_LINKUP<<1)|(isSLAVERC_LINKUP<<2);
+			#else
+			rctempflag = (isRC0_LINKUP)|(isRC1_LINKUP<<1);
+			#endif
+			switch (rctempflag)
+			{
+			#ifdef TCSUPPORT_BONDING
+				case 3:
+					//master wifi
+					preconfigflag = 1;
+					break;
+				case 5:
+					//slave wifi
+					preconfigflag = 2;
+					break;
+				case 7:
+					//dual band
+					preconfigflag = 3;
+					break;
+			#else
+				case 1:
+				case 2:	
+					//one wifi
+					preconfigflag = 0;
+					break;
+				case 3:
+					//dual band
+					preconfigflag = 1;
+					break;
+
+			#endif
+				default:
+					break;
+			}			
+		}
+		else
+		{
+			if(isRC0_LINKUP)
+				preconfigflag = 0;
+		}
+	}
+	else if(isMT7505 || isRT63365)
+	{
+		if(isRC0_LINKUP)
+			preconfigflag = 0;
+	}
+
+	
+#ifdef PRE_CONFIG_DEBUG	
+	printk("preconfigflag =%d\n",preconfigflag);
+#endif
+	preinfo.rcindex = 1;
+	switch (preconfigflag)
+	{
+		case 0:
+			preinfo.num[0].rcbusnum = PCIE_BUS_0;
+			preinfo.num[0].rcdevnum = PCIE_DEV_0;
+			preinfo.num[0].epbusnum = PCIE_BUS_1;
+			preinfo.num[0].epdevnum = PCIE_DEV_0;
+			pre_config_RC_S = &pcie_config_table_WiFi_RC0_Special[MODE0RCBASEADDR];
+			preconfigtemp =  RegConfigFunc(&preinfo,pre_config_RC_S);
+			break;
+		case 1:
+			#ifndef TCSUPPORT_BONDING
+			preinfo.num[0].rcbusnum = PCIE_BUS_0;
+			preinfo.num[0].rcdevnum = PCIE_DEV_0;
+			preinfo.num[0].epbusnum = PCIE_BUS_1;
+			preinfo.num[0].epdevnum = PCIE_DEV_0;
+			pre_config_RC_S = &pcie_config_table_WiFi_RC0_Special[MODE0RCBASEADDR];
+			preconfigtemp =  RegConfigFunc(&preinfo,pre_config_RC_S);
+			if(!preconfigtemp)
+				return;
+			#endif
+			preinfo.num[0].rcbusnum = PCIE_BUS_0;
+			preinfo.num[0].rcdevnum = PCIE_DEV_1;
+			preinfo.num[0].epbusnum = PCIE_BUS_2;
+			preinfo.num[0].epdevnum = PCIE_DEV_0;
+			pre_config_RC_S = &pcie_config_table_WiFi_RC1_Special[MODE1RCBASEADDR];
+			preconfigtemp =  RegConfigFunc(&preinfo,pre_config_RC_S);
+			break;
+		#ifdef TCSUPPORT_BONDING	
+		case 2:
+			preinfo.rcindex = 2;
+			preinfo.flag = 1;
+			preinfo.num[0].rcbusnum = PCIE_BUS_0;
+			preinfo.num[0].rcdevnum = PCIE_DEV_0;
+			preinfo.num[1].rcbusnum = PCIE_BUS_1;
+			preinfo.num[1].rcdevnum = PCIE_DEV_1;
+			preinfo.num[0].epbusnum = PCIE_BUS_2;
+			preinfo.num[0].epdevnum = PCIE_DEV_0;
+			pre_config_RC_S = &pcie_config_table_WiFi_RC0_Special[MODE1RCBASEADDR];
+			preconfigtemp =  RegConfigFunc(&preinfo,pre_config_RC_S);
+			break;
+		case 3:
+			preinfo.flag = 1;
+			preinfo.rcindex = 2;
+			preinfo.num[0].rcbusnum = PCIE_BUS_0;
+			preinfo.num[0].rcdevnum = PCIE_DEV_0;
+			preinfo.num[1].rcbusnum = PCIE_BUS_1;
+			preinfo.num[1].rcdevnum = PCIE_DEV_1;
+			preinfo.num[0].epbusnum = PCIE_BUS_2;
+			preinfo.num[0].epdevnum = PCIE_DEV_0;
+			pre_config_RC_S = &pcie_config_table_WiFi_RC0_Special[MODE1RCBASEADDR];
+			preconfigtemp =  RegConfigFunc(&preinfo,pre_config_RC_S);
+			if(!preconfigtemp)
+				return;
+
+			preinfo.flag = 2;
+			preinfo.num[0].rcbusnum = PCIE_BUS_0;
+			preinfo.num[0].rcdevnum = PCIE_DEV_0;
+			preinfo.num[1].rcbusnum = PCIE_BUS_0;
+			preinfo.num[1].rcdevnum = PCIE_DEV_1;
+			preinfo.num[0].epbusnum = PCIE_BUS_3;
+			preinfo.num[0].epdevnum = PCIE_DEV_0;
+			pre_config_RC_S = &pcie_config_table_WiFi_RC1_Special[MODE2RCBASEADDR];
+			preconfigtemp =  RegConfigFunc(&preinfo,pre_config_RC_S);
+			break;
+		#endif
+		default:
+		#ifdef PRE_CONFIG_DEBUG	
+			printk("\r\nflag not support:%d",preconfigflag);
+		#endif
+			preconfigtemp = -2;
+			break;
+	}
+
+#ifdef PRE_CONFIG_DEBUG	
+		printk("\r\nreturn preconfigflag =%d\n",preconfigflag);
+#endif
+
+	return preconfigtemp;
+}
+
+void SetLDO()
+{
+	
+	unsigned int Value1 = 0;
+	unsigned int Value2 = 0;
+	int cnt = 10;
+	unsigned char *baseAddr = (unsigned char *)wifi_csr_addr;
+	
+	while(cnt--){
+		GlobalCRWrite(baseAddr, 0x50012498, 0x5);
+		GlobalCRRead(baseAddr, 0x50012498, &Value1);
+		if(Value1 == 0x5) //Setting success
+			break;		
+	}
+
+	if(Value1 != 0x5){
+		printk("Wifi CR 0x%x value setting fail(Value=0x%x)\n", 0x50012498, Value1);
+	}
+
+	while(cnt--){
+		GlobalCRWrite(baseAddr, 0x50012040, 0x80);
+		GlobalCRRead(baseAddr, 0x50012040, &Value2);
+		if(Value2 == 0x80) //Setting success
+			break;		
+	}
+
+	if(Value2 != 0x80){
+		printk("Wifi CR 0x%x value setting fail(Value=0x%x)\n", 0x50012040, Value2);
+	}
+
+	printk("CR 0x%x value is 0x%x\n", 0x50012498, Value1);
+	printk("CR 0x%x value is 0x%x\n", 0x50012040, Value2);		
+}
+
+void preConfigLDO()
+{	
+	int i,preconfigflag;
+	for(i = 0;i < MAX_PRE_CONFIG_NUM; i++)
+	{	
+		memset(&pcie_config_table_temp[i],0,sizeof(struct pci_access_s ));
+	}
+	preconfigflag = pciePreConfigReg();
+	if(!preconfigflag)
+	{
+#ifdef TCSUPPORT_BONDING
+		wifi_csr_addr = (unsigned long)ioremap(mappingaddr,0x100000);
+#else
+		wifi_csr_addr = (unsigned long)ioremap(0x20000000,0x100000);
+#endif
+		SetLDO();
+		RecoverInitialValue();
+		iounmap((char *)wifi_csr_addr);
+	}
+}
+#endif
+
+struct pci_config_s *save_pcie_config(char bus, char dev){	
+	int reco_reg[] = {0x4, 0xc, 0x10, 0x18, 0x1c, 0x20, 0x24, 0x30, 0x3c, 0x50, 0x54, 0x5c, 0x154, 0x160, -1};
+	int i, num_reg;	
+	struct pci_config_s * ret_p;
+#ifdef ESD_DEBUG	
+	printk("save pcie config bus %d dev %d\n",bus,dev);
+#endif	
+	i = 0;	
+	num_reg = 0;
+
+	if(pcie_read_config_word(PCIE_TYPE_RC, bus, dev, 0) == 0xffffffff)//means no device 
+		return NULL;
+	
+	while(reco_reg[num_reg++] != -1){}; // caclute total reg_num	
+	ret_p = (struct pci_config_s *)kzalloc(sizeof(struct pci_config_s) * num_reg ,GFP_KERNEL);	
+	if(ret_p == NULL)			
+		return NULL;	
+	for(i=0; i<num_reg; i++){		
+		(*(ret_p + i)).reg = reco_reg[i];		
+		if(reco_reg[i] != -1){				
+			(*(ret_p + i)).value= pcie_read_config_word(PCIE_TYPE_RC, bus, dev, reco_reg[i]);
+#ifdef ESD_DEBUG						
+			printk("reg %x value %lx\n",(*(ret_p + i)).reg,(*(ret_p + i)).value);
+#endif		
+		}		
+	}			
+	return ret_p;	
+}
+void restore_pcie_config(char bus, char dev, struct pci_config_s* restore_p){	
+	int i;
+#ifdef ESD_DEBUG	
+	printk("restore pcie config bus %d dev %d\n", bus, dev);
+#endif	
+	if(restore_p == NULL){		
+		printk("Recover BUS %d DEV %d Faill !!\n",bus,dev);		
+		return;	
+	}		
+	i = 0;	
+	while((*(restore_p + (i))).reg != -1){		
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, (*(restore_p + i)).reg, (*(restore_p + i)).value);
+#ifdef ESD_DEBUG				
+		printk("restore reg %x value %lx \n", (*(restore_p + i)).reg, (*(restore_p + i)).value);
+#endif		
+		i++;	
+	}	
+
+}
+void pcie_int_enable(char enable, char rc_num){
+	unsigned long int tmp;
+	
+	if(enable == ENABLE){
+		if(rc_num == 0){//Enable Interrupt
+		#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+			if(isMT751020 || isMT7505 || isRT63368){
+		#else
+			if(isMT751020 || isMT7505 || isEN751221){
+		#endif
+				tmp = regRead32(0xbfb8000c);
+#if defined(TCSUPPORT_BONDING)
+				/* slave dmt, error interrupt, slave gdma */
+				tmp |= ((1<<23) | (1<<24) | (1<<25));
+#else
+				tmp |= (1<<20);
+#endif
+				regWrite32(0xbfb8000c, tmp);
+			}	
+		}else{//only need rc0 or 1
+			if(isMT751020 || isEN751221){
+				tmp = regRead32(0xbfb8000c);
+				tmp |= (1<<26);
+				regWrite32(0xbfb8000c, tmp);
+			}	
+			#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+			else if(isRT63368){
+				tmp = regRead32(0xbfb8000c);
+				tmp |= (1<<21);
+				regWrite32(0xbfb8000c, tmp);
+			}
+			#endif
+		}
+	}else{//Disable Interrupt
+		if(rc_num == 0){
+		#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+			if(isMT751020 || isMT7505 || isRT63368){
+		#else
+			if(isMT751020 || isMT7505 || isEN751221){
+		#endif
+				tmp = regRead32(0xbfb8000c);
+#if defined(TCSUPPORT_BONDING)
+				/* slave dmt, error interrupt, slave gdma */
+				tmp &= ~((1<<23) | (1<<24) | (1<<25));
+#else
+				tmp &= ~(1<<20);
+#endif
+				regWrite32(0xbfb8000c, tmp);
+			}
+		}else{
+			if(isMT751020 || isEN751221){
+				tmp = regRead32(0xbfb8000c);
+				tmp &= ~(1<<26);
+				regWrite32(0xbfb8000c, tmp);
+			}
+			#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+			else if(isRT63368){
+				tmp = regRead32(0xbfb8000c);
+				tmp &= ~(1<<21);
+				regWrite32(0xbfb8000c, tmp);
+			}
+			#endif
+		}	
+	}
+}
+
+int pcie_reset_handler(char rc_num){
+		int wifi_dev_bus_id = 1;
+    #if defined(TCSUPPORT_BONDING)
+        int i;
+    #endif
+	
+		if((rc_num == 0) || (rc_num == 2)){		
+			pcie_reset_count ++;
+			aer_config(0);
+			pcieResetRC0();
+			if(isRC0_LINKUP){
+				restore_pcie_config(PCIE_BUS_0, PCIE_DEV_0, pcie_config_temp[PCIE_BUS_0][PCIE_DEV_0]);
+				restore_pcie_config(PCIE_BUS_1, PCIE_DEV_0, pcie_config_temp[PCIE_BUS_1][PCIE_DEV_0]);
+                                
+#ifdef TCSUPPORT_BONDING
+#ifdef TCSUPPORT_CPU_EN7512
+
+                                   printk(" pcie_reset_handler function is not implement in chip 7512.");
+#else
+				if(isSLAVERC_LINKUP){
+					wifi_dev_bus_id++;
+					restore_pcie_config(PCIE_BUS_1, PCIE_DEV_1, pcie_config_temp[PCIE_BUS_1][PCIE_DEV_1]);//slave RC
+					restore_pcie_config(wifi_dev_bus_id, PCIE_DEV_0, pcie_config_temp[wifi_dev_bus_id][PCIE_DEV_0]);//slave WIFI
+				}else{
+					wifi_dev_bus_id = -1; //no wifi
+				}
+				
+                for (i = 0; i < MAX_REG_CONFIG; i++)
+                    regWrite32(reg_config_temp[i].reg, reg_config_temp[i].value);
+#endif /*TCSUPPORT_CPU_EN7512*/
+#endif/*TCSUPPORT_BONDING*/
+				if(wifi_dev_bus_id != -1){
+					wifiDeviceId = pcie_read_config_word(PCIE_TYPE_DEV, wifi_dev_bus_id, PCIE_DEV_0, 0) >> 16;
+#ifdef ESD_DEBUG					
+					printk("wifi DeviceID %x\n",wifiDeviceId);
+#endif
+				}	
+				pcie_int_enable(ENABLE, 0);
+				pcie_timeout_disable();
+				aer_status_clear();
+				aer_config(1);
+			}else{
+				printk("RC0 Dead\n");
+				return -1;
+			}	
+
+			#if defined(TCSUPPORT_CPU_RT63368) ||defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7510)|| defined(TCSUPPORT_CPU_MT7505)
+			#if 0/*def TCSUPPORT_WLAN_MT7592_PCIE*/
+			if(0x7603 == wifiDeviceId)
+				preConfigLDO();
+			#endif
+			#endif
+
+		}else if(rc_num == 1){		
+			pcie_reset_count ++;
+			aer_config(0);
+			pcieResetRC1();
+			if(isRC1_LINKUP){
+				restore_pcie_config(PCIE_BUS_0, PCIE_DEV_1, pcie_config_temp[PCIE_BUS_0][PCIE_DEV_1]);
+				if(isRC0_LINKUP){
+					wifi_dev_bus_id++;
+                                        
+#ifdef TCSUPPORT_BONDING
+#ifdef TCSUPPORT_CPU_EN7512
+                                /*pcie_reset_handler function is not implement in chip 7512.*/
+#else
+					if(isSLAVERC_LINKUP){
+						wifi_dev_bus_id++;
+						restore_pcie_config(wifi_dev_bus_id, PCIE_DEV_0, pcie_config_temp[wifi_dev_bus_id][PCIE_DEV_0]);
+					}else
+#endif   /*TCSUPPORT_CPU_EN7512*/
+#endif	/*TCSUPPORT_BONDING*/				
+					{
+						restore_pcie_config(wifi_dev_bus_id, PCIE_DEV_0, pcie_config_temp[wifi_dev_bus_id][PCIE_DEV_0]);
+					}
+				}else{
+					restore_pcie_config(wifi_dev_bus_id, PCIE_DEV_0, pcie_config_temp[wifi_dev_bus_id][PCIE_DEV_0]);
+				}
+				if(wifi_dev_bus_id != -1){
+					wifiDeviceId = pcie_read_config_word(PCIE_TYPE_DEV, wifi_dev_bus_id, PCIE_DEV_0, 0) >> 16;
+#ifdef ESD_DEBUG					
+					printk("wifi DeviceID %x\n",wifiDeviceId);
+#endif
+				}
+				pcie_int_enable(ENABLE, 1);
+				pcie_timeout_disable();
+				aer_status_clear();
+				aer_config(1);
+			}else{
+				printk("RC1 Dead\n");
+				
+				return -1;
+			}	
+			#if defined(TCSUPPORT_CPU_RT63368) ||defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7510)|| defined(TCSUPPORT_CPU_MT7505)
+			#if 0/*def TCSUPPORT_WLAN_MT7592_PCIE*/
+			if(0x7603 == wifiDeviceId)
+				preConfigLDO();
+			#endif
+			#endif
+			
+		}else{
+			printk("RC ID %d Fail\n",rc_num);
+			return -1;
+		}
+
+
+		return 0;
+}	
+
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+/*______________________________________________________________________________
+**function name:pcie_reset_handler_o
+**
+**description:
+*    63368 reset handler
+**parameters:
+*    none
+**global:
+*    none
+**return:
+*    0:success
+*    -1:fail
+**call:
+*    start_cc()
+**revision:
+*     Brian.shi
+**____________________________________________________________________________*/
+int pcie_reset_handler_o()
+{
+	int wifi_dev_bus_id = 1;
+	int ret = 0;
+	prom_printf("\r\n======pcie_reset_handler_o=======");	
+	pcieReset();
+	if(isRC0_LINKUP){
+		restore_pcie_config(PCIE_BUS_0, PCIE_DEV_0, pcie_config_temp[PCIE_BUS_0][PCIE_DEV_0]);
+		restore_pcie_config(PCIE_BUS_1, PCIE_DEV_0, pcie_config_temp[PCIE_BUS_1][PCIE_DEV_0]);
+		if(wifi_dev_bus_id != -1){
+			wifiDeviceId = pcie_read_config_word(PCIE_TYPE_DEV, wifi_dev_bus_id, PCIE_DEV_0, 0) >> 16;
+#ifdef ESD_DEBUG					
+			prom_printf("wifi DeviceID %x\n",wifiDeviceId);
+#endif
+		}	
+		pcie_int_enable(ENABLE, 0);
+		pcie_timeout_disable();
+	}else{
+		printk("RC0 Dead\n");
+		ret += 1;
+	}	
+
+	if(isRC1_LINKUP){
+		if(isRC0_LINKUP)
+		{
+			wifi_dev_bus_id++;
+			restore_pcie_config(PCIE_BUS_0, PCIE_DEV_1, pcie_config_temp[PCIE_BUS_0][PCIE_DEV_1]);
+			
+		}else
+		{
+			restore_pcie_config(PCIE_BUS_0, PCIE_DEV_0, pcie_config_temp[PCIE_BUS_0][PCIE_DEV_0]);
+		}
+		restore_pcie_config(wifi_dev_bus_id, PCIE_DEV_0, pcie_config_temp[wifi_dev_bus_id][PCIE_DEV_0]);
+		
+		if(wifi_dev_bus_id != -1){
+			wifiDeviceId = pcie_read_config_word(PCIE_TYPE_DEV, wifi_dev_bus_id, PCIE_DEV_0, 0) >> 16;
+#ifdef ESD_DEBUG					
+			prom_printf("wifi 5g DeviceID %x\n",wifiDeviceId);
+#endif
+		}
+		pcie_int_enable(ENABLE, 1);
+		pcie_timeout_disable();
+	}else{
+		printk("RC1 Dead\n");
+		ret += 1;
+	}	
+
+	if(ret > 1)
+		return -1;
+	
+	return 0;
+}
+#endif
+
+void pcie_check(char force){
+	uint32 val, addr;
+	unsigned long flags;
+	char need_reset = 0;
+
+	if(pcie_soft_patch == 0){
+		return;
+	}
+
+	spin_lock_irqsave(&pcie_esd_lock, flags);	
+	if(pcie_reset_condiction == PCIE_RESET_CON_BUSTIMEOUT){
+		//Read Config 0 for RC0/RC1 to generate Bustime out
+		if(force == 0){
+			if(rc0_is_exist){
+				val = regRead32(0xbfb82034);
+			}	
+			if(rc1_is_exist){
+				val = regRead32(0xbfb83034);	
+			}
+			if(regRead32(CR_PRATIR)){
+				//bus timeout happened
+				addr = regRead32(CR_ERR_ADDR);
+				if(((addr >= 0x1fb80000) && (addr <= 0x1fb83fff)) 
+					|| ((addr >= 0x20000000) && (addr <= 0x2fffffff)) )
+				{
+					#if defined(TCSUPPORT_CPU_MT7505)
+					if(isMT7505 || isEN751221){
+						regWrite32(CR_PRATIR, 1);
+					}
+					else
+					#endif
+					{
+					regWrite32(CR_PRATIR, 0);
+					}
+					printk("check bustimeout and reset %lx\n",addr);
+					need_reset = 1;
+				}
+			}	
+		}else{
+			addr = regRead32(CR_ERR_ADDR);
+			if(((addr >= 0x1fb80000) && (addr <= 0x1fb83fff)) 
+				|| ((addr >= 0x20000000) && (addr <= 0x2fffffff)) )
+			{
+				#if defined(TCSUPPORT_CPU_MT7505)
+				if(isMT7505 || isEN751221){
+					regWrite32(CR_PRATIR, 1);
+				}
+				else
+				#endif
+				{
+				regWrite32(CR_PRATIR, 0);
+				}
+				printk("bustimeout int and reset %lx\n",addr);
+				need_reset = 1;
+			}
+		}	
+
+		if(need_reset){	
+			if(rc0_is_exist){
+				if(pcie_reset_handler(0) == 0){
+					ahb_status = 1;
+				}
+			}	
+			if(rc1_is_exist){
+				if(pcie_reset_handler(1) == 0){
+					ahb_status = 1;
+				}
+			}	
+		}
+	}else if(pcie_reset_condiction == PCIE_RESET_CON_PCIEERROR){
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER	
+		/*use pcie_reset_handler_o() do reset(63368 reset rc0 & rc1 using one register one bit)*/
+		if(pcie_reset_handler_o() == 0){
+			ahb_status = 1;
+		}
+#else
+		val = regRead32(0xbfb80060);
+		if((val & (1<<1)) != 0){
+			regWrite32(0xbfb82070, 1); //clear interrupt status
+			regWrite32(0xbfb82070, 0); //set interrupt status
+		
+			if(pcie_reset_handler(0) == 0){
+				ahb_status = 1;
+			}
+		}
+		if((val & (1<<2)) != 0){
+			regWrite32(0xbfb83070, 1); //clear interrupt status
+			regWrite32(0xbfb83070, 0); //set interrupt status
+
+			if(pcie_reset_handler(1) == 0){
+				ahb_status = 1;
+			}
+			
+		}
+#if defined(TCSUPPORT_BONDING)	
+		if((val & (1<<0)) != 0){
+			if(slaveVirBaseAddr == 0){
+				spin_unlock_irqrestore(&pcie_esd_lock, flags);
+				printk("No slaveVirBaseAddr\n");
+				return;
+			}	
+			regWrite32(slaveVirBaseAddr + 0xb83070, 1); //clear interrupt status
+			regWrite32(slaveVirBaseAddr + 0xb83070, 0); //set interrupt status
+		
+			if(pcie_reset_handler(2) == 0){
+				ahb_status = 1;
+			}
+		}
+#endif
+#endif
+	}
+	spin_unlock_irqrestore(&pcie_esd_lock, flags);
+	return;
+}
+
+void setahbstat(int val){
+		ahb_status = val;
+}
+EXPORT_SYMBOL(setahbstat);
+
+void pcieReset(void){	
+	int i;
+	unsigned long tmp;
+	
+	if(isRT63165){
+		return;		
+	}
+	if(isRT63365){
+		//disable interrupt
+		if(dual_band_support){
+			tmp = regRead32(0xbfb8000c);
+			regWrite32(0xbfb8000c, (tmp & (~((1<<20) | (1<<21)) )));
+		}else{
+			tmp = regRead32(0xbfb8000c);
+			regWrite32(0xbfb8000c, (tmp & ~(1<<20)));
+		}	
+		mdelay(5);
+		//PCI-E reset
+		if (isFPGA) {		
+			//FPGA mode
+			tmp = regRead32(0xbfb00834);
+			regWrite32(0xbfb00834, (tmp & ~(1<<26)));
+			mdelay(1);
+			tmp = regRead32(0xbfb00834);
+			regWrite32(0xbfb00834, (tmp | (1<<26)));
+			mdelay(1);
+		}else{	
+			//rt63368 enable pci-e port1 and port1 do not have power will cause hang. shnwind.
+			if(dual_band_support){
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp &  (~((1<<26) | (1<<27) | (1<<29)))));
+				mdelay(1);
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp | ((1<<26) | (1<<27) | (1<<29))));
+				#ifdef MT7592
+				mdelay(100);
+				#else
+				mdelay(1);
+				#endif
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp &  (~((1<<26) | (1<<27) | (1<<29)))));
+				mdelay(1);
+			}else{
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<29)))));
+				mdelay(1);
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp | ((1<<26) | (1<<29))));
+				#ifdef MT7592
+				mdelay(100);
+				#else
+				mdelay(1);
+				#endif
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<29)))));
+				mdelay(1);
+			}	
+		}		
+
+		tmp = regRead32(0xbfb80000);
+		regWrite32(0xbfb80000, (tmp | (1<<1)));
+		mdelay(1);
+		tmp = regRead32(0xbfb80000);
+		regWrite32(0xbfb80000, (tmp & ~(1<<1)));
+		mdelay(1);
+		//wait device link up
+		for(i=0 ; i<1000 ; i++){
+			mdelay(1);
+			if(dual_band_support){
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+				/*need to dualband all up*/
+				if(isRC0_LINKUP && isRC1_LINKUP){
+#else
+				if(isRC0_LINKUP || isRC1_LINKUP){
+#endif
+					break;
+				}	
+			}else{
+				if(isRC0_LINKUP){
+					break;
+				}
+			}	
+		}
+		if(i == 1000){
+			printk("PCI-E RC can not link up\n");
+			return ;
+		}
+		if(dual_band_support){		
+			if(isRC0_LINKUP){
+				//config PCI-E RC
+				regWrite32(0xbfb82010, 0xffff0001); //disable support BAR0
+
+				//change class PCI-PCI Bridge
+				regWrite32(0xbfb82034, 0x06040001);
+			}else{
+				//disable port 0
+				tmp = regRead32(0xbfb00088);
+				regWrite32(0xbfb00088, (tmp & ~(1<<23)));
+				mdelay(1);
+			}
+
+			if(isRC1_LINKUP){
+				//config PCI-E RC
+				regWrite32(0xbfb83010, 0xffff0001); //disable support BAR0
+
+				//change class PCI-PCI Bridge
+				regWrite32(0xbfb83034, 0x06040001);
+			}else{
+				//disable port 1
+				tmp = regRead32(0xbfb00088);
+				regWrite32(0xbfb00088, (tmp & ~(1<<22)));
+				mdelay(1);
+			}
+		}else{
+			//config PCI-E RC
+			regWrite32(0xbfb82010, 0xffff0001); //disable support BAR0
+
+			//change class PCI-PCI Bridge
+			regWrite32(0xbfb82034, 0x06040001);
+		}	
+		
+		//Enable CRC count .
+		regWrite32(KSEG1ADDR(pcie_config_addr), 0x118);
+		tmp = regRead32(KSEG1ADDR(pcie_config_data));
+		regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+
+	}else{
+		tmp = regRead32(CR_AHB_PCIC);
+		regWrite32(CR_AHB_PCIC, (tmp & ~(1<<29)));
+		mdelay(5);
+		tmp = regRead32(CR_AHB_PCIC);
+		regWrite32(CR_AHB_PCIC, (tmp & ~(1<<30)));
+		mdelay(5);
+		tmp = regRead32(CR_AHB_PCIC);
+		regWrite32(CR_AHB_PCIC, (tmp | (1<<29)));
+		mdelay(5);
+		tmp = regRead32(CR_AHB_PCIC);
+		regWrite32(CR_AHB_PCIC, (tmp | (1<<30)));
+		mdelay(5);
+		/*force link up, workaround the pcie hardware problems.*/
+		if(isTC3162U){
+			regWrite32(KSEG1ADDR(pcie_config_addr), 0x40);
+			regWrite32(KSEG1ADDR(pcie_config_data), 0x20);
+		}
+	}
+}
+
+EXPORT_SYMBOL(pcieReset);
+
+
+void pcieResetRC0(void){
+	unsigned long tmp;
+
+	if(!isMT751020 && !isMT7505 && !isEN751221){
+		return;
+	}
+
+	pcie_int_enable(DISABLE, 0);
+	mdelay(5);
+
+	//PCI-E reset
+	tmp = regRead32(0xbfb00834);
+	regWrite32(0xbfb00834, (tmp & (~(1<<26))));
+	mdelay(1);
+	regWrite32(0xbfb00834, (tmp | (1<<26)));
+#ifdef MT7592
+			mdelay(100);
+#else
+			mdelay(1);
+#endif
+	regWrite32(0xbfb00834, (tmp & (~(1<<26))));
+	mdelay(1);
+
+#if defined(TCSUPPORT_BONDING)
+	//printk("reset slave chip \n");
+	tmp = regRead32(0xbfbf0214);
+	regWrite32(0xbfbf0214, (tmp | (1<<6)));
+	tmp = regRead32(0xbfbf0234);
+	regWrite32(0xbfbf0234, (tmp & ~(1<<6)));
+	tmp = regRead32(0xbfbf021c);
+	regWrite32(0xbfbf021c, (tmp & (~((1<<12) | (1<<13)))));
+	tmp = regRead32(0xbfbf0200);
+	regWrite32(0xbfbf0200, (tmp & ~(1<<13)));
+	tmp = regRead32(0xbfbf0200);
+	regWrite32(0xbfbf0200, (tmp | (1<<12)));
+	if (isFPGA) {
+		//printk("isFPGA \n");
+		tmp = regRead32(0xbfbf0204);
+		regWrite32(0xbfbf0204, (tmp | (1<<6)));
+		mdelay(1);
+		tmp = regRead32(0xbfbf0204);
+		regWrite32(0xbfbf0204, (tmp & ~(1<<6)));
+	}else{
+		tmp = regRead32(0xbfbf0204);
+		regWrite32(0xbfbf0204, (tmp & ~(1<<6)));
+		mdelay(1);
+		tmp = regRead32(0xbfbf0204);
+		regWrite32(0xbfbf0204, (tmp | (1<<6)));
+	}
+	tmp = regRead32(0xbfbf0214);
+	regWrite32(0xbfbf0214, (tmp & ~(1<<6)));
+
+	//disable VC1
+	regWrite32(0xbfb80020, 0x160);
+	regWrite32(0xbfb80024, 0x0);
+#endif
+        if(isMT7505 || isEN751221)
+        {
+                tmp = regRead32(0xbfb00088);
+                regWrite32(0xbfb00088, (tmp | ((1<<29) | (1<<26))));
+        }	
+        else
+        {
+	        tmp = regRead32(0xbfb80000);
+	        regWrite32(0xbfb80000, (tmp & (~((1<<1) | (1<<2)))));
+        }
+	//wait device link up
+	mdelay(250);
+	//printk("#isRC0_LINKUP=%x \n", isRC0_LINKUP);
+#if defined(TCSUPPORT_BONDING)
+	//printk("isSLAVERC_LINKUP=%x \n", isSLAVERC_LINKUP);
+#endif
+
+	if(isRC0_LINKUP){
+		//config PCI-E RC
+		regWrite32(0xbfb82010, 0xffff0001); //disable support BAR0
+
+		//change class PCI-PCI Bridge
+		regWrite32(0xbfb82034, 0x06040001);
+
+		//Enable CRC count .
+		regWrite32(KSEG1ADDR(pcie_config_addr), 0x118);
+		tmp = regRead32(KSEG1ADDR(pcie_config_data));
+		regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+		pcie_phy_force_mode_en(ENABLE, 0);
+	}else{
+		//disable port 0
+		tmp = regRead32(0xbfb00088);
+		regWrite32(0xbfb00088, (tmp & ~(1<<23)));
+		mdelay(1);
+	}
+
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+	if(isSLAVERC_LINKUP){
+		pcie_phy_force_mode_en(ENABLE, 2);
+	}
+	else{
+		//disable slave RC
+		tmp = regRead32(0xbfb00088);
+		regWrite32(0xbfb00088, (tmp & ~(1<<24)));
+		mdelay(1);
+	}
+#endif
+
+
+	return;
+}
+EXPORT_SYMBOL(pcieResetRC0);
+
+void pcieResetRC1(void){
+	unsigned long tmp;
+
+	if(!isMT751020){
+		return;
+	}
+
+	pcie_int_enable(DISABLE, 1);
+	mdelay(5);
+
+	//PCI-E reset
+	tmp = regRead32(0xbfb00834);
+	regWrite32(0xbfb00834, (tmp & ~(1<<27)));
+	mdelay(1);
+	regWrite32(0xbfb00834, (tmp | (1<<27)));
+#ifdef MT7592
+			mdelay(100);
+#else
+			mdelay(1);
+#endif
+	regWrite32(0xbfb00834, (tmp & ~(1<<27)));
+	mdelay(1);
+
+	tmp = regRead32(0xbfb80000);
+	regWrite32(0xbfb80000, (tmp & (~((1<<1) | (1<<2)))));
+	//wait device link up
+	mdelay(250);
+	//printk("isRC1_LINKUP=%d \n", isRC1_LINKUP);;
+	if(isRC1_LINKUP){
+		//config PCI-E RC
+		regWrite32(0xbfb83010, 0xffff0001); //disable support BAR0
+
+		//change class PCI-PCI Bridge
+		regWrite32(0xbfb83034, 0x06040001);
+
+		//Enable RC1 ECRC count . //bus0, dev1
+		regWrite32(KSEG1ADDR(pcie_config_addr), 0x80118);
+		tmp = regRead32(KSEG1ADDR(pcie_config_data));
+		regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+		pcie_phy_force_mode_en(ENABLE, 1);
+	}else{
+		//disable port 1
+		tmp = regRead32(0xbfb00088);
+		regWrite32(0xbfb00088, (tmp & ~(1<<22)));
+		mdelay(1);
+	}
+
+	return;
+}
+
+
+extern spinlock_t pcie_lock;
+
+int mt7512_pcie_is_slave()
+{
+	if (isFPGA)
+		return (regRead32(0xbfb0008c) & (1 << 30)) == (1 << 30)?1:0;
+
+	return (regRead32(0xbfb0008c) & (1 << 5)) == 0?1:0;
+}
+
+static int get_rc_port(unsigned char bus,unsigned char dev)
+{
+	int rc = 2;
+
+	if (mt7512_pcie_is_slave())
+	{
+		if ((bus == 0) && (dev < 2))
+			rc = dev ;
+		 else if ((bus == 1) && (dev == 0) && isRC1_LINKUP)
+			rc = 1 ;
+	}
+	else
+	{
+                	if ((bus == 0) && (dev < 2))
+                  {
+                		rc = dev;
+                	}
+                  else if ((bus == 1) && (dev == 0) && isRC0_LINKUP)
+                  {           
+                	         rc = 0;
+                	}
+                  else if ((bus == 2) && (dev == 0) && isRC1_LINKUP)
+                  {
+                		rc = 1;
+                	}
+	}
+	return rc;
+}
+
+int pcie_write_config_word_extend(unsigned char bus, unsigned char dev,unsigned char func, unsigned int reg, unsigned long int value)
+{
+	unsigned int val,rc,offset = 0;
+	unsigned long flags;
+
+	rc = get_rc_port(bus,dev);
+
+	if (rc == 0){
+		offset = 0x1000;
+	}else if(rc == 1){
+		offset = 0x3000;
+	}else{
+		printk("pcie_write err: rc = %d",rc);
+		return 0;
+	}	
+
+	spin_lock_irqsave(&pcie_lock, flags);
+
+	/*mt=2|type=4|length=1 */
+	val = (2 << 29) | (4 << 24) | 1;  
+
+	 /* write TLP Header offset 0-3 */
+	regWrite32(0xbfb80460+offset, val);   
+
+	/*write requester ID */
+	val = (rc<<19) | 0x070f;						
+
+	/*write TLP Header offset 4-7 */
+	regWrite32(0xbfb80464+offset, val);    
+	
+	val = (bus << 24) | (dev << 19) |(func << 16) | reg;
+
+	 /*write TLP Header offset 8-11 */
+	regWrite32(0xbfb80468+offset, val);  
+
+	/*write TLP data */
+	regWrite32(0xbfb80470+offset, value);    
+
+	/*start TLP Requuest */
+	regWrite32(0xbfb80488+offset, 1);   
+
+	mdelay(1);
+
+	val = 0;
+
+	/*polling TLP Request status */
+	while((val++)<10)             
+	{
+	 	/*TLP Request finished or timeout */
+		if ((regRead32(0xbfb80488+offset)&0x1)==0) 
+			break;
+		mdelay(1);
+	}
+	
+	spin_unlock_irqrestore(&pcie_lock, flags);
+
+	if (val==10)
+		printk("\nPCIE Write Err: bus = %d, dev = %d Reg = %d",bus,dev,reg);
+
+ 	return 0;
+
+}
+EXPORT_SYMBOL(pcie_write_config_word_extend);
+
+
+unsigned int pcie_read_config_word_extend(unsigned char bus,unsigned char dev,unsigned char func ,unsigned int reg)
+{
+	unsigned long flags;
+	unsigned int val,rc, offset = 0;
+	if (mt7512_pcie_is_slave()){
+		if ((bus == 0) && (dev == 0) && (reg == 0))
+			return 0xffffffff;
+	}
+	
+	rc = get_rc_port(bus,dev);
+
+	
+	if (rc == 0){
+		offset = 0x1000;
+	}else if(rc == 1){
+		offset = 0x3000;
+	}else{
+		return 0xffffffff;
+	}
+	spin_lock_irqsave(&pcie_lock, flags);
+
+	/* iniitialize the data reg */
+	regWrite32(0xbfb8048c+offset, 0xffffffff);	
+
+	/*fmt=2|type=4|length=1 */
+	val = (4 << 24) | 1;  
+
+	/*write TLP Header offset 0-3 */
+	regWrite32(0xbfb80460+offset, val);
+	
+	/*write requester ID */
+	val = (rc << 19) | 0x070f;					
+
+	/*write TLP Header offset 4-7*/
+	regWrite32(0xbfb80464+offset, val);	
+
+	val = (bus << 24) | (dev << 19) | (func << 16) | reg;
+
+	/*write TLP Header offset 8-11*/
+	regWrite32(0xbfb80468+offset, val);	
+
+	/*start TLP Requuest*/
+	regWrite32(0xbfb80488+offset, 1);	
+
+	mdelay(1);
+
+	val = 0;
+
+	/*polling TLP Request status */
+	while((val++)<10)           
+	{
+		/*TLP Request finished or timeout*/
+		if ((regRead32(0xbfb80488+offset)&0x1)==0)  
+			break;
+		mdelay(1);
+	}
+
+	if (val==10)
+	{
+		printk("\n pcie_read_timeout: bus = %d, dev = %d, func = %d,reg = %d val = %x",bus,dev,func,reg,0xffffffff);
+		return 0xffffffff;
+	}
+
+	/*return the data from data reg*/
+	val = regRead32(0xbfb8048c+offset);      
+	
+	spin_unlock_irqrestore(&pcie_lock, flags);
+	
+	return val;
+}
+
+EXPORT_SYMBOL(pcie_read_config_word_extend);
+
+
+void mt7512_pcie_reset(void)
+{
+	unsigned int tmp;
+
+	/* enabled PCIe port 1 */
+	tmp = regRead32(0xbfb00088);
+	regWrite32(0xbfb00088, (tmp | (1<<22)));
+	mdelay(1);
+	
+	/*first reset to default*/
+         if(mt7512_pcie_is_slave() == 0)
+         {
+                	tmp = regRead32(0xbfb00834);
+                	regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<27) | (1<<29)))));
+                	mdelay(1);
+                	tmp = regRead32(0xbfb00834);
+                	regWrite32(0xbfb00834, (tmp | ((1<<26) | (1<<27) | (1<<29))));
+                	mdelay(100);
+                	tmp = regRead32(0xbfb00834);
+                	regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<27) | (1<<29)))));
+                	mdelay(1);
+         }
+         else
+         {
+                  
+                  tmp = regRead32(0xbfb00834);
+                	regWrite32(0xbfb00834, (tmp & (~((1<<27) ))));
+                	mdelay(1);
+                	tmp = regRead32(0xbfb00834);
+                	regWrite32(0xbfb00834, (tmp | ((1<<27) )));
+                	mdelay(100);
+                	tmp = regRead32(0xbfb00834);
+                	regWrite32(0xbfb00834, (tmp & (~((1<<27) ))));
+                	mdelay(1);
+                  
+         }
+         /*release device*/
+         tmp = regRead32(0xbfb00088);
+         regWrite32(0xbfb00088, (tmp & (~((1<<29) | (1<<26)))));
+         mdelay(1);
+         tmp = regRead32(0xbfb00088);
+         regWrite32(0xbfb00088, (tmp | ((1<<29) | (1<<26))));
+         /*
+	if(mt7512_pcie_is_slave() == 0)
+         {
+                	tmp = regRead32(0xbfb00088);
+                	regWrite32(0xbfb00088, (tmp & (~((1<<29) | (1<<26)))));
+                	mdelay(1);
+                	tmp = regRead32(0xbfb00088);
+                	regWrite32(0xbfb00088, (tmp | ((1<<29) | (1<<26))));
+         }
+         else
+         {
+
+                tmp = regRead32(0xbfb00088);
+                regWrite32(0xbfb00088, (tmp & (~((1<<29)))));
+                mdelay(1);
+                tmp = regRead32(0xbfb00088);
+                regWrite32(0xbfb00088, (tmp | ((1<<29))));
+                
+         }
+	*/
+	/*wait link up*/
+	mdelay(250);
+
+
+	if (mt7512_pcie_is_slave() == 0)
+	{
+	        /*change RC0 class to pci-pci class*/
+		regWrite32(0xbfb81104, 0x06040001);
+		mdelay(1);	
+
+		/*set pcie host mode*/
+		regWrite32(0xbfb81000, 0x804201);
+		mdelay(1);	
+	}	
+	/*change RC1 class to pci-pci class */
+	regWrite32(0xbfb83104, 0x06040001);
+	mdelay(1);	
+
+	/*set pcie host mode*/
+	regWrite32(0xbfb83000, 0x804201);
+	mdelay(1);
+	
+	return ;
+}
+
+EXPORT_SYMBOL(mt7512_pcie_reset);
+
+
+void mt7512_pcie_set_mac(void)
+{
+	unsigned int tmp;
+
+	if(isRC0_LINKUP && (mt7512_pcie_is_slave() == 0) ){
+			
+		/*disable MSI interrupt*/
+		tmp = regRead32(0xbfb8111c);
+		regWrite32(0xbfb8111c, tmp & (~(1<<5)));
+		mdelay(1);
+					
+		/*Enable Interrupt*/
+		tmp = regRead32(0xbfb81420);
+		regWrite32(0xbfb81420, tmp & (~(1<<16)));
+		mdelay(1);
+
+		/* Enable PCIE Error Interrupt */
+		tmp = regRead32(0xbfb80040);
+		regWrite32(0xbfb80040, tmp | 0x03);
+		mdelay(1);
+
+	}
+	
+	if(isRC1_LINKUP){		
+		/*disable MSI interrupt*/
+		tmp = regRead32(0xbfb8311c);
+		regWrite32(0xbfb8311c, tmp & (~(1<<5)));
+		mdelay(1);
+					
+		/*Enable Interrupt*/
+		tmp = regRead32(0xbfb83420);
+		regWrite32(0xbfb83420, tmp & (~(1<<16)));
+		mdelay(1);
+
+		/*Enable PCIE Error Interrupt */
+		tmp = regRead32(0xbfb80040);
+		regWrite32(0xbfb80040, tmp | 0x0c);
+		mdelay(1);
+
+	}
+	
+	return;
+}
+EXPORT_SYMBOL(mt7512_pcie_set_mac);
+
+int pcie_write_config_word(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum, unsigned long int value)
+{
+	if (isEN751221)
+		return pcie_write_config_word_extend(bus,devnum,0,regnum,value);
+
+	if(isRT63165 || isRT63365 || isMT751020 || isMT7505){
+		regWrite32(KSEG1ADDR(pcie_config_addr), (bus<<24 |devnum<<19|regnum));
+	}else{
+		regWrite32(KSEG1ADDR(pcie_config_addr), (type<<31|bus<<20 |devnum<<15|regnum));
+	}	
+	regWrite32(KSEG1ADDR(pcie_config_data), value);
+
+	return 0;
+}
+int pcie_write_config_byte(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum, unsigned char value)
+{
+	if(isRT63165 || isRT63365 || isMT751020 || isMT7505){
+		regWrite32(KSEG1ADDR(pcie_config_addr), (bus<<24 |devnum<<19|regnum));
+	}else{
+		regWrite32(KSEG1ADDR(pcie_config_addr), (type<<31|bus<<20 |devnum<<15|regnum));
+	}	
+	regWrite32(KSEG1ADDR(pcie_config_data), value);
+
+	return 0;
+}
+unsigned long int pcie_read_config_word(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum)
+{
+
+	if (isEN751221)
+			return pcie_read_config_word_extend(bus,devnum,0,regnum);
+
+	if(isRT63165 || isRT63365 || isMT751020 || isMT7505){
+		regWrite32(KSEG1ADDR(pcie_config_addr), (bus<<24 |devnum<<19|regnum));
+	}else{	
+		regWrite32(KSEG1ADDR(pcie_config_addr), (type<<31|bus<<20|devnum<<15|regnum));
+	}
+	return regRead32(KSEG1ADDR(pcie_config_data));
+}
+#if (defined(TCSUPPORT_POWERSAVE_ENABLE) && (defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7505)))
+EXPORT_SYMBOL(pcie_write_config_word);
+EXPORT_SYMBOL(pcie_read_config_word);
+#endif
+int pcieRegInitConfig(void)
+{
+	unsigned int reg1_val, reg2_val;
+	unsigned int reg_val = 0;
+	int i = 0;
+	int slot;
+	int pci_device_exist = 0;
+	unsigned long tmp;
+
+	if(isRT63165){
+		return 0;		
+	}
+
+	/* PCIe init module */
+	/* reset PCIe module */
+	/*
+	 * From: TC/Li Fengbo 
+	 * To: 'krammer' ; 'Marshall Yen \
+	 * Cc: 'Liu, Shuenn-Ren' ; 'Graham Fan\
+	 * Sent: Friday, May 22, 2009 2:49 PM
+	 * Subject: new pof for software reboot
+	 *
+	 * Dear both,
+	 * I have generated a new pof for software reboot, the pof file name is 
+	 * software_reboot_20090522.pof
+	 * It has been transported to Hsingchu, please help to check it
+	 * Software Reset User Guide:
+	 * After power on, there are two steps to active PCIe System
+	 * 1 Wait for minimum 50us, Write 隆搂1隆篓 to bit 29 of Register bfb0_0088, then
+	 * 2 Wait for minimum 3.5us, write 隆搂1隆篓 to bit 30 of Register bfb0_0088
+	 * 
+	 * Before do software reboot, 
+	 * 1 Write 隆搂0隆篓 to bit 29 and bit 30 of Register bfb0_0088
+	 * Then reset for PCIE system is completed, you can reboot system
+	 * Don隆娄t forget to release PCIe reset
+	 * 2 Wait for minimum 50us , Write 隆搂1隆篓 to bit 29 of bfb0_0088, then
+	 * 3 Wait for minimum 3.5us, write 隆搂1隆篓 to bit 30 of bfb0_0088
+	 *
+	 * Best regards
+	 * Fengbo Li
+	 *
+	 */
+	/* pcie fixup start */
+	/* setup COMMAND register */
+	pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x04, 0x00100007);
+
+	/* setup CACHE_LINE_SIZE register */
+	if(isRT63365){
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x0c, 0x00010000);
+	}else{	
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x0c/*PCI_CACHE_LINE_SIZE*/, 0x00000008);//duoduo_20090701
+	}	
+	/* setup LATENCY_TIMER register */
+	/* pcie fixup end */
+	/*setup secondary bus number*/
+	/*setup subordinate bus number*/
+	pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x18, 0x00010100);
+	/*setup I/O Base register*/
+	if(isRT63365){
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x30, 0x0);
+	}else{	
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x30, 0x0000FFFF);
+	}
+	pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x1C, 0x000000F0);
+	/*setup memory base register*/
+	if(isRT63365){
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x20, 0x20002000);
+	}else{	
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x20, 0x1F701F70);
+	}	
+	/*setup prefetchable memory base register */
+	pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x24, 0x0000FFF0);
+	/*setup I/O Base upper 16 bits register*/
+	/*setup interrupt line register*/
+	/*setup bridge control*/
+	if(isRT63365){
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x3C, 0x00040119);
+	}else{	
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x3C, 0x0004010B);
+	}	
+
+	/* pci register 0x10 config needed or not? Linos for L2H will configure it */
+	if(isRT63365){
+		for(i = 0; i < 10; i++){
+			reg1_val = pcie_read_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x0);
+			mdelay(1);
+			//reg2_val = pcie_read_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_1, 0x0);
+			//mdelay(1);
+		}	
+		reg2_val = 0xffffffff;
+		//Enable Interrupt
+		if(isRC0_LINKUP){
+			tmp = regRead32(0xbfb8000c);
+			regWrite32(0xbfb8000c, (tmp | (1<<20)));
+		}	
+		//second band
+		if(dual_band_support){
+			if(isRC1_LINKUP){
+				tmp = regRead32(0xbfb8000c);
+				regWrite32(0xbfb8000c, (tmp | (1<<21)));
+			}	
+		}	
+	}else{	
+		do
+		{
+			mdelay(30);
+			reg_val = pcie_read_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0xe0);
+			i++;
+		}
+		while((reg_val & 0x03f00000) != 0x00100000 && i <= 10);//check the if the dev has been link up
+		for(i = 0; i < 10; i++){
+			reg1_val = pcie_read_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x0);
+			mdelay(1);
+			reg2_val = pcie_read_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_1, 0x0);
+			mdelay(1);
+		}
+	}
+	if( (reg1_val != 0xffffffff) &&
+			( (reg1_val == ((NIC3090_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID)) //duoduo_20090702
+			  || (reg1_val == ((NIC3091_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC3092_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID)) 
+			  || (reg1_val == ((NIC3390_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC5390_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))//xyyou_20101111
+			  || (reg1_val == ((NIC539F_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC7603_PCIe_DEVICE_ID <<16) |MTK_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC5392_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))) ){//xyyou wait to do
+		pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x04, 0x00100006);
+		if(isRT63365)
+			pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x10, 0x20000000);
+		else	
+			pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x10, PHYSADDR(PCI_DEVICE_MEM1)); 
+		pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x14, 0); 
+		pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x18, 0); 
+		pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x1C, 0); 
+		pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x20, 0); 
+		pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x24, 0); 
+		pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x30, 0); 
+		if(isRT63365)
+			pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x3C, 0x00000119);
+		else	
+			pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x3C, 0x0000010B); 
+
+		slot = PCIE_DEVNUM_0;		
+		pci_device_exist++;
+	}
+	else if( (reg2_val != 0xffffffff) &&
+			( (reg2_val == ((NIC3090_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID)) 
+			  || (reg2_val == ((NIC3091_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg2_val == ((NIC3092_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC3390_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC5390_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC539F_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC7603_PCIe_DEVICE_ID <<16) |MTK_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC5392_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))) ){
+		slot=PCIE_DEVNUM_1;
+		pci_device_exist++;
+	}
+	else{
+		printk("no_pci_found error case\n");
+		return -1;
+	}
+	return slot;
+}
+EXPORT_SYMBOL(pcieRegInitConfig);
+
+
+
+void pcie_init(void)
+{
+	int i, j;
+#if defined(TCSUPPORT_BONDING)
+    unsigned int regs[] = {0xbfb8200c, 0xbfb82090, 0xbfb82094};
+#endif
+	
+	/*63368 use new recover mechanism ,so need to save pcie info*/
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+	if(isRT63365 && !isRT63368){
+#else
+	if(isRT63365){
+#endif
+		return;
+	}
+
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+	if(isMT751020 || isMT7505 || isRT63368){
+#else
+	if(isMT751020 || isMT7505 || isEN751221){
+#endif
+		//Save all configuration
+		for(i=0; i<PCIE_SAVE_BUS_NUM;i++){
+			for(j=0;j<PCIE_SAVE_DEVICE_NUM;j++){
+				if(pcie_config_temp[i][j] == NULL){
+					pcie_config_temp[i][j] = save_pcie_config(i, j);
+				}	
+			}
+		}
+    #if defined(TCSUPPORT_BONDING)
+        for (i = 0; i < MAX_REG_CONFIG; i++)
+        {
+            reg_config_temp[i].reg = regs[i];
+            reg_config_temp[i].value = regRead32(regs[i]);
+        }
+    #endif
+		pcie_soft_patch = ENABLE;
+	}else{
+		pcieReset();
+		pcieRegInitConfig();
+	}	
+}
+EXPORT_SYMBOL(pcie_init);
+
+int pcie_timeout_disable(void)
+{
+	unsigned int val = 0x10;
+	unsigned int reg = 0x98;
+	unsigned int dev = 0x0;
+	unsigned int bus;
+
+	bus = 0x1;
+	if(isRC0_LINKUP){
+		//disable RC0's device timeout
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, reg, val);
+	}
+
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+	if(isSLAVERC_LINKUP){
+		bus += 1;
+
+		//disable slave RC's device timeout
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, reg, val);
+	}
+#endif
+
+	if(isRC1_LINKUP){
+		bus += 1;
+
+		//disable RC1's device timeout
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, reg, val);
+	}
+	
+	return 0;
+}
+
+#if defined(TCSUPPORT_BONDING)
+void pcie_virBaseAddr_set(unsigned long addr)
+{
+	slaveVirBaseAddr = addr;
+}
+EXPORT_SYMBOL(pcie_virBaseAddr_set);
+#endif
+
+
+void aer_config(int aerEnable)
+{
+	unsigned int advRcErrReg = 0x12c, advRcErrVal = 0x7, disAdvRcErr = 0x0;
+	unsigned int briCtrlReg = 0x3c, briCtrlVal = 0x60119, disBriCtrl = 0x40119;
+	unsigned int devCtrlReg = 0x78, devCtrlVal = 0x201f, disDevCtrl = 0x2010;
+	unsigned int dev = 0x0;
+	unsigned int bus = 0x0;
+
+
+	if(aerEnable){ // Enable AER
+		// configure RC
+		bus = 0x0;
+		dev = 0x0;
+		if(isRC0_LINKUP){
+			//Enable RC0 interrupt
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, advRcErrReg, advRcErrVal);
+			regWrite32(KSEG1ADDR(pcie_config_data), advRcErrVal);
+			//Enable RC0 error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, briCtrlReg, briCtrlVal);
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, devCtrlVal);
+		}
+		if(isRC1_LINKUP){
+			dev += 1;
+
+			//Enable RC1 interrupt
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, advRcErrReg, advRcErrVal);
+
+			//Enable RC1 error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, briCtrlReg, briCtrlVal);
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, devCtrlVal);
+		}
+
+		// configure device
+		dev = 0x0;
+		if(isRC0_LINKUP){
+			bus += 1;
+
+			//Enable EP0 error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, devCtrlVal);
+		}
+
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+		// configure slave RC & device
+		if(isSLAVERC_LINKUP){
+			dev += 1;
+
+			//Enable slave RC interrupt
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, advRcErrReg, advRcErrVal);
+
+			//Enable slave RC error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, briCtrlReg, briCtrlVal);
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, devCtrlVal);
+
+			dev = 0x0;
+			bus += 1;
+			//Enable slave wifi error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, devCtrlVal);
+		}
+#endif
+
+		// configure device
+		dev = 0x0;
+		if(isRC1_LINKUP){
+			bus += 1;
+
+			//Enable EP1 error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, devCtrlVal);
+		}
+
+	}else{ // Disable AER
+		// configure RC
+		bus = 0x0;
+		dev = 0x0;
+		if(isRC0_LINKUP){
+			//Disable RC0 interrupt
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, advRcErrReg, disAdvRcErr);
+
+			//Disable RC0 error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, briCtrlReg, disBriCtrl);
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, disDevCtrl);
+
+		}
+		if(isRC1_LINKUP){
+			dev = 0x1;
+
+			//Disable RC1 interrupt
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, advRcErrReg, disAdvRcErr);
+			
+			//Disable RC1 error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, briCtrlReg, disBriCtrl);
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, disDevCtrl);
+
+		}
+
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+		if(isSLAVERC_LINKUP){
+			bus += 1;
+			dev = 0x1;
+
+			//Disable slave RC interrupt
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, advRcErrReg, disAdvRcErr);
+
+			//Disable slave RC interrupt
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, briCtrlReg, disBriCtrl);
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, disDevCtrl);
+
+		}
+#endif
+	}
+}
+
+static void aer_status_dump(void)
+{
+	unsigned int rootErrReg = 0x130;
+	unsigned int errSrcIdReg = 0x134;
+	unsigned int unCorErrReg = 0x104;
+	unsigned int corErrReg = 0x110;
+	unsigned int dev = 0x0;
+	unsigned int bus = 0x0;
+
+
+	if(isRC0_LINKUP){
+		printk("### RC0 ###\n");
+		//check root error status
+		printk("root error status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg));
+		//check error source ID
+		printk("error source ID=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, errSrcIdReg));
+		//check uncorrectable error status
+		printk("UN-correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg));
+		//check correctable error status
+		printk("Correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg));
+		//check error counter
+		printk("RC0 LCRC counter: 0x%x         RC0 ECRC counter: 0x%x\n",(unsigned int)regRead32(0xbfb82060),(unsigned int)regRead32(0xbfb82064));
+		printk("EP correctable counter: 0x%x   EP non-fatal counter: 0x%x \n\n",(unsigned int)regRead32(0xbfb82068),(unsigned int)regRead32(0xbfb8206c));
+	}
+
+	if(isRC1_LINKUP){
+		bus = 0x0;
+		dev = 0x1;
+
+		printk("### RC1 ###\n");
+		//check root error status
+		printk("root error status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg));
+		//check error source ID
+		printk("error source ID=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, errSrcIdReg));
+		//check uncorrectable error status
+		printk("UN-correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg));
+		//check correctable error status
+		printk("Correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg));
+		//check error counter
+		printk("RC1 LCRC counter: 0x%x         RC1 ECRC counter: 0x%x\n",(unsigned int)regRead32(0xbfb83060),(unsigned int)regRead32(0xbfb83064));
+		printk("EP correctable counter: 0x%x   EP non-fatal counter: 0x%x \n\n",(unsigned int)regRead32(0xbfb83068),(unsigned int)regRead32(0xbfb8306c));
+	}
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+
+	if(isSLAVERC_LINKUP){
+		bus = 0x0;
+		if(isRC0_LINKUP){
+			bus += 1;
+		}
+		dev = 0x1;
+
+		printk("### slave RC ###\n");
+		//check root error status
+		printk("root error status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg));
+		//check error source ID
+		printk("error source ID=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, errSrcIdReg));
+		//check uncorrectable error status
+		printk("UN-correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg));
+		//check correctable error status
+		printk("Correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg));
+		//check error counter
+		if(slaveVirBaseAddr != 0){
+			printk("slaveRC LCRC counter: 0x%x         slaveRC ECRC counter: 0x%x\n",(unsigned int)regRead32(slaveVirBaseAddr + 0xb83060),(unsigned int)regRead32(slaveVirBaseAddr + 0xb83064));
+			printk("EP correctable counter: 0x%x   EP non-fatal counter: 0x%x \n\n",(unsigned int)regRead32(slaveVirBaseAddr + 0xb83068),(unsigned int)regRead32(slaveVirBaseAddr + 0xb8306c));
+		}
+	}
+#endif
+}
+
+static void aer_status_clear(void)
+{
+	unsigned int unCorErrReg = 0x104;
+	unsigned int corErrReg = 0x110;
+	unsigned int rootErrReg = 0x130;
+	unsigned int dev = 0x0;
+	unsigned int bus = 0x0;
+	unsigned long int errStatus;
+
+	if(isRC0_LINKUP){
+		//printk("RC0\n");
+		//clear UN-correctable error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg, errStatus);
+		//printk("Clear UN-orrectable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg));
+		//clear correctable error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg, errStatus);
+		//printk("Clear Correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg));
+		//clear root error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg, errStatus);
+		//printk("Clear root error status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg));
+	}
+
+	if(isRC1_LINKUP){
+		bus = 0x0;
+		dev = 0x1;
+
+		//printk("RC1\n");
+		//clear UN-correctable error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg, errStatus);
+		//printk("Clear UN-orrectable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg));
+		//clear correctable error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg, errStatus);
+		//printk("Clear Correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg));
+		//clear root error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg, errStatus);
+		//printk("Clear root error status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg));
+	}
+
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+	if(isSLAVERC_LINKUP){
+		bus = 0x0;
+		if(isRC0_LINKUP){
+			bus += 1;
+		}
+		dev = 0x1;
+
+		//printk("slave RC\n");
+		//clear UN-correctable error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg, errStatus);
+		//printk("Clear UN-orrectable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg));
+		//clear correctable error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg, errStatus);
+		//printk("Clear Correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg));
+		//clear root error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg, errStatus);
+		//printk("Clear root error status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg));
+	}
+#endif
+}
+
+
+void
+ahbErrChk(void){
+	register uint32 status=0;
+	unsigned long flags;
+
+	if(pcie_soft_patch == 0){
+		return;
+	}
+	
+	if(isRT63365 ||  isMT7505 || isEN751221)
+		return;
+	
+	
+	if(isMT751020 || isMT7505){
+		pcie_check(0);
+	}else
+	{
+		status=regRead32(CR_AHB_AACS);
+		if((status & AHB_BUS_TIMEOUT_ERR)||(status & AHB_BUS_ADDR_ERR)){	
+			printk("CR_AHB_AACS:0x%08lx\n", status);
+			printk("CR_AHB_ABEM:0x%08lx\n", regRead32(CR_AHB_ABEM));
+			printk("CR_AHB_ABEA:0x%08lx\n", regRead32(CR_AHB_ABEA));
+			local_irq_save(flags);
+			ahb_status=1;
+			pcieReset();
+			pcieRegInitConfig();
+			local_irq_restore(flags);
+		}
+	}
+	
+
+}
+EXPORT_SYMBOL(ahbErrChk);
+
+#ifdef CONFIG_MIPS_TC3162U
+static irqreturn_t ahbErrIsr(int irq, void *dev){
+	ahbErrChk();	
+	return IRQ_HANDLED;
+}
+#endif
+
+void chkAhbErr(int force){
+	uint32 val=0;
+	unsigned long flags;
+	uint32 lcrc, ecrc;
+
+	if(pcie_soft_patch == 0){
+		return;
+	}
+
+	if(isTC3162U){
+		local_irq_save(flags);
+		/*check the pcie bus crc error counter*/
+		val= pcie_read_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x54);
+		if((val!=0x0) || (force==0x1) ){
+			/*Reset pcie and refill pcie-registers*/
+			pcieReset();
+			pcieRegInitConfig();
+			ahb_status = 1;
+		}
+		local_irq_restore(flags);
+	}
+
+	else if(isRT63365){
+		local_irq_save(flags);
+		/*check the pcie bus crc error counter*/
+		lcrc = regRead32(0xbfb82060);
+		ecrc = regRead32(0xbfb82064);
+		if((lcrc != 0xdeadbeaf) || (ecrc != 0xdeadbeaf)){
+			if((lcrc != 0x0) || (ecrc != 0x0) || (force == 0x1)){
+				#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+				/*add a new mechanism*/
+				if((lcrc+ecrc) >= pcie_error_detect_count)
+				{
+                      	                printk("PCI-E L-crc %lx E-crc %lx!!\n", lcrc, ecrc);
+					pcie_reset_condiction = PCIE_RESET_CON_PCIEERROR;
+					ahb_status = 1;
+				}
+				#else
+				printk("RC0 PCI-E L-crc %lx E-crc %lx!!\n", lcrc, ecrc);
+				/*Reset pcie and refill pcie-registers*/
+				pcieReset();
+				pcieRegInitConfig();
+				ahb_status = 1;
+				#endif
+				
+			}
+		}
+		local_irq_restore(flags);
+	}
+	
+
+}
+EXPORT_SYMBOL(chkAhbErr);
+
+static int ahb_status_read_proc(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "%d %d %d", pcie_soft_patch, ahb_status, wifiDeviceId);
+	len -= off;
+	*start = page + off;
+
+	if (len > count)
+		len = count;
+	else
+		*eof = 1;
+
+	if (len < 0)
+		len = 0;
+	
+	chkAhbErr(0);
+	return len;
+}
+
+static int ahb_status_write_proc(struct file *file, const char *buffer,
+	unsigned long count, void *data)
+{
+	char val_string[8];
+	int val=0;
+	unsigned long flags;
+
+	if (count > sizeof(val_string) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+	if(sscanf(val_string,"%d %d", &pcie_soft_patch, &val)!=2){
+		printk("usage: <onoff> <type>\n");
+		return count;
+	}
+	if(val==0x2){
+		/*Reset pcie and refill pcie-registers*/
+		local_irq_save(flags);
+		#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+		/*63368 use new mechanism*/
+		if(isMT751020 || isMT7505 || isRT63368){
+		#else
+		if(isMT751020 || isMT7505 || isEN751221){
+		#endif
+			pcie_check(0);
+		}else{	
+			pcieReset();
+			pcieRegInitConfig();
+		}
+		local_irq_restore(flags);
+	}
+	if (val == 0) /*Disable wifi interface down to up*/{
+		ahb_status = 0;
+		wifiDeviceId = 0;
+	}else{
+		ahb_status = 1;
+	}
+	return count;
+}
+
+
+
+static int pcie_rcnum_read_proc(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+	
+	
+	return 0;
+}
+
+static int pcie_rcnum_write_proc(struct file *file, const char *buffer,
+	unsigned long count, void *data)
+{
+	char val_string[8];
+	int reset_rc = -1;
+	unsigned long flags;
+
+	if (count > sizeof(val_string) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+	if(sscanf(val_string,"%d", &reset_rc)!=1){
+		printk("usage: <RC reset Number> \n");
+		return count;
+	}
+
+	if(reset_rc != -1){
+		printk("reset and recover start RC %d\n",reset_rc);
+		spin_lock_irqsave(&pcie_esd_lock, flags);	
+		pcie_reset_handler(reset_rc);
+		spin_unlock_irqrestore(&pcie_esd_lock, flags);	
+		
+		ahb_status = 1;
+	}
+	
+	return count;
+}
+static int pcie_reset_con_read_proc(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "currect pcie_reset_con %d", pcie_reset_condiction);
+	len -= off;
+	*start = page + off;
+
+	if (len > count)
+		len = count;
+	else
+		*eof = 1;
+
+	if (len < 0)
+		len = 0;
+	
+	return len;
+}
+
+static int pcie_reset_con_write_proc(struct file *file, const char *buffer,
+	unsigned long count, void *data)
+{
+	char val_string[8];
+	int value;
+
+	if (count > sizeof(val_string) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+	if(sscanf(val_string,"%d", &value)!=1){
+		printk("usage: <pcie_reset_condiction 0:bustime out 1:pcie error> \n");
+		return count;
+	}
+	pcie_reset_condiction = (char)value;
+	return count;
+}
+static int pcie_reset_count_read_proc(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "pcie_reset_count %d\n", pcie_reset_count);
+	len -= off;
+	*start = page + off;
+
+	if (len > count)
+		len = count;
+	else
+		*eof = 1;
+
+	if (len < 0)
+		len = 0;
+	
+	return len;
+}
+static int aer_status_read_proc(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+	aer_status_dump();
+
+	return 0;
+}
+
+static int aer_status_write_proc(struct file *file, const char *buffer,
+	unsigned long count, void *data)
+{
+	char val_string[5];
+	int clear=0;
+
+	if (count > sizeof(val_string) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+	sscanf(val_string,"%d", &clear);
+
+	if(clear == 1){
+		aer_status_dump();
+		aer_status_clear();
+	}
+
+	return count;
+}
+
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+/*______________________________________________________________________________
+**function name:pcie_error_detect_count_read_proc
+**
+**description:
+*   get error detect count 
+**parameters:
+*   char *page
+*   char **start
+*	off_t off
+*	int count
+*	int *eof
+*	void *data
+**global:
+*    pcie_error_detect_count
+**return:
+*    len
+**call:
+*    
+**revision:
+*     Brian.shi
+**____________________________________________________________________________*/
+
+static int pcie_error_detect_count_read_proc(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "currect pcie_error_detect_count %d", pcie_error_detect_count);
+	len -= off;
+	*start = page + off;
+
+	if (len > count)
+		len = count;
+	else
+		*eof = 1;
+
+	if (len < 0)
+		len = 0;
+	
+	return len;
+}
+/*______________________________________________________________________________
+**function name:pcie_error_detect_count_write_proc
+**
+**description:
+*   set error detect count 
+**parameters:
+*   char *page
+*   char **start
+*	off_t off
+*	int count
+*	int *eof
+*	void *data
+**global:
+*    pcie_error_detect_count
+**return:
+*    len
+**call:
+*    
+**revision:
+*     Brian.shi
+**____________________________________________________________________________*/
+
+static int pcie_error_detect_count_write_proc(struct file *file, const char *buffer,
+	unsigned long count, void *data)
+{
+	char val_string[8];
+	int value;
+
+	if (count > sizeof(val_string) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+	if(sscanf(val_string,"%d", &value)!=1){
+		printk("usage: <count:overflow will do pcie reset> \n");
+		return count;
+	}
+	pcie_error_detect_count = (char)value;
+	return count;
+}
+
+/*______________________________________________________________________________
+**function name:ahb_status_value_count_read_proc
+**
+**description:
+*   get ahb status 
+**parameters:
+*   char *page
+*   char **start
+*	off_t off
+*	int count
+*	int *eof
+*	void *data
+**global:
+*    ahb_status
+**return:
+*    len
+**call:
+*    
+**revision:
+*     Brian.shi
+**____________________________________________________________________________*/
+
+static int ahb_status_value_count_read_proc(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "currect pcie_error_detect_count %d", ahb_status);
+	len -= off;
+	*start = page + off;
+
+	if (len > count)
+		len = count;
+	else
+		*eof = 1;
+
+	if (len < 0)
+		len = 0;
+	
+	return len;
+}
+
+/*______________________________________________________________________________
+**function name:ahb_status_value_count_write_proc
+**
+**description:
+*   set ahb status 
+**parameters:
+*   char *page
+*   char **start
+*	off_t off
+*	int count
+*	int *eof
+*	void *data
+**global:
+*    ahb_status
+**return:
+*    len
+**call:
+*    
+**revision:
+*     Brian.shi
+**____________________________________________________________________________*/
+
+static int ahb_status_value_count_write_proc(struct file *file, const char *buffer,
+	unsigned long count, void *data)
+{
+	char val_string[8];
+	int value;
+
+	if (count > sizeof(val_string) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+	if(sscanf(val_string,"%d", &value)!=1){
+		printk("usage: <count:overflow will do pcie reset> \n");
+		return count;
+	}
+	ahb_status = (char)value;
+	return count;
+}
+#endif
+
+
+#if defined(TCSUPPORT_BONDING)
+static void reset_slave_chip(void){
+	uint32 tmp;
+
+	tmp = regRead32(CR_GPIO_CTRL);
+	tmp &= ~(0x3 << (6<<1));
+	tmp |=  (0x1 << (6<<1));
+	regWrite32(CR_GPIO_CTRL, tmp);
+	tmp = regRead32(CR_GPIO_ODRAIN);
+	regWrite32(CR_GPIO_ODRAIN, (tmp | (1<<6)));
+	tmp = regRead32(CR_GPIO_DATA);
+	regWrite32(CR_GPIO_DATA, (tmp | (1<<6)));
+	udelay(1);
+	regWrite32(CR_GPIO_DATA, (tmp & (~(1<<6))));
+	udelay(1);
+	regWrite32(CR_GPIO_DATA, (tmp | (1<<6)));
+	udelay(1);
+
+}
+#endif
+int pcie_api_init(void);
+
+static __init int tc3162_pcie_init(void)
+{
+	struct proc_dir_entry *ahb_status_proc;
+	struct proc_dir_entry *aer_status_proc;
+	int i;
+	uint32 tmp;
+
+
+#ifdef TCSUPPORT_DMT_CO
+	return 0;
+#endif
+
+	if(isMT7505 || isEN751221){	
+		/*before reset host,need to pull device low*/
+		tmp = regRead32(0xbfb00088);
+		regWrite32(0xbfb00088, (tmp & (~((1<<29) | (1<<26)))));
+		mdelay(1);
+	}
+#ifdef TCSUPPORT_MT7510_E1	
+	if(isMT751020){
+		#ifndef TCSUPPORT_MT7520_PCIE
+		if (!isFPGA)
+			return -1;
+		#endif
+		/* enabled PCIe port 0,1 */
+		tmp = regRead32(0xbfb00088);
+		regWrite32(0xbfb00088, (tmp | (0x1<<22)));
+		mdelay(1);
+	}
+#endif
+	if (!isFPGA){
+#if defined(TCSUPPORT_BONDING)
+		printk("slave chip reset\n");
+		reset_slave_chip();
+#endif
+		pciePhyInit();
+	}
+	if (isEN751221){   
+
+		printk("MT7512_pcie_init\n");
+
+		tc3162_pcie_mem_resource.start = 0x20000000;
+		tc3162_pcie_mem_resource.end   = 0x2FFFFFFF;
+
+		mt7512_pcie_reset();
+		
+		printk("check pcie link up status: \n");
+		printk("isRC0_LINKUP=%d \n",isRC0_LINKUP);
+		printk("isRC1_LINKUP=%d \n",isRC1_LINKUP);
+		if((!isRC0_LINKUP) && (!isRC1_LINKUP)){
+			printk("PCI-E RC0 & RC1 can not link up\n");
+			return -1;
+		}
+		mt7512_pcie_set_mac();
+
+	}else	if(isRT63365 || isMT751020 || isMT7505){
+		if(isMT751020){
+			dual_band_support = 1;
+			printk("MT7510_pcie_init\n");
+		}
+		else if(isRT63368){
+#if defined(TCSUPPORT_DUAL_WLAN)
+			//rt63368 enable pci-e port1 and port1 do not have power will cause hang. shnwind.
+			dual_band_support = 1;
+#else
+			dual_band_support = 0;
+#endif			
+			printk("RT63368_pcie_init:%d\n",dual_band_support);
+		} else if(isMT7505){
+			printk("MT7505_pcie_init\n");
+		} else{	
+			printk("RT63365_pcie_init\n");
+		}	
+
+		//change memory mapping affress.
+		tc3162_pcie_mem_resource.start = 0x20000000;
+		tc3162_pcie_mem_resource.end   = 0x2FFFFFFF;
+
+		//change pcie addr and data window.
+		pcie_config_addr = 0x1fb80020;
+		pcie_config_data = 0x1fb80024;
+
+		//PCI-E reset
+		if(isMT751020 || isMT7505){
+			/* enabled PCIe port 1 */
+			tmp = regRead32(0xbfb00088);
+			regWrite32(0xbfb00088, (tmp | (1<<22)));
+			mdelay(1);
+#if !defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_MT7505)
+#if !defined(TCSUPPORT_XPON_HAL_API_EXT) 
+			if (!isFPGA)
+#endif
+			{
+				//set GPIO share scheme reg for PERST output
+				tmp = regRead32(0xbfb00860);
+				regWrite32(0xbfb00860, (tmp | ((1<<19) | (1<<20))));
+			}
+#endif
+			/*first reset to default*/
+			tmp = regRead32(0xbfb00834);
+			regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<27) | (1<<29)))));
+			mdelay(1);
+			tmp = regRead32(0xbfb00834);
+			regWrite32(0xbfb00834, (tmp | ((1<<26) | (1<<27) | (1<<29))));
+			#ifdef MT7592
+			mdelay(100);
+			#else
+			mdelay(1);
+			#endif
+			tmp = regRead32(0xbfb00834);
+			regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<27) | (1<<29)))));
+			mdelay(1);
+		}else{
+			if (isFPGA) {
+				//FPGA mode
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp & ~(1<<26)));
+				mdelay(1);
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp | (1<<26)));
+				mdelay(1);
+			}else{
+				if(dual_band_support){
+					/* enabled PCIe port 1 */
+					tmp = regRead32(0xbfb00088);
+					regWrite32(0xbfb00088, (tmp | (1<<22)));
+					mdelay(1);
+					tmp = regRead32(0xbfb00834);
+					regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<27) | (1<<29)))));
+					mdelay(1);
+					tmp = regRead32(0xbfb00834);
+					regWrite32(0xbfb00834, (tmp | ((1<<26) | (1<<27) | (1<<29))));
+					#ifdef MT7592
+					mdelay(100);
+					#else
+					mdelay(1);
+					#endif
+					tmp = regRead32(0xbfb00834);
+					regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<27) | (1<<29)))));
+					mdelay(1);
+				}else{
+					/* disabled PCIe port 1 */
+					tmp = regRead32(0xbfb00088);
+					regWrite32(0xbfb00088, (tmp & ~(1<<22)));
+					mdelay(1);
+					tmp = regRead32(0xbfb00834);
+					regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<29)))));
+					mdelay(1);
+					tmp = regRead32(0xbfb00834);
+					regWrite32(0xbfb00834, (tmp | ((1<<26) | (1<<29))));
+					#ifdef MT7592
+					mdelay(100);
+					#else
+					mdelay(1);
+					#endif
+					tmp = regRead32(0xbfb00834);
+					regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<29)))));
+					mdelay(1);
+				}
+			}
+		}
+		if(isMT751020 || isMT7505){
+			//relese pcie device reset
+#ifndef TCSUPPORT_CPU_MT7505
+			tmp = regRead32(0xbfb80000);
+			regWrite32(0xbfb80000, (tmp & (~((1<<1) | (1<<2)))));
+			mdelay(1);
+#else
+			tmp = regRead32(0xbfb00088);
+			regWrite32(0xbfb00088, (tmp | ((1<<29) | (1<<26))));
+			mdelay(1);
+#endif
+		}else{
+			tmp = regRead32(0xbfb80000);
+			regWrite32(0xbfb80000, (tmp | (1<<1)));
+			mdelay(1);
+			tmp = regRead32(0xbfb80000);
+			regWrite32(0xbfb80000, (tmp & ~(1<<1)));
+			mdelay(1);
+		}
+
+		if (isRT63365 && (isFPGA)) {
+			//FPGA mode
+			tmp = regRead32(0xbfbc0028);
+			regWrite32(0xbfbc0028, 0x60068880);
+			regWrite32(0xbfbc0004, 0x08000002);
+			regWrite32(0xbfbc0008, 0x00000700);
+			regWrite32(0xbfbc0000, 0x00160106);
+			regWrite32(0xbfbc0028, tmp);
+		}
+
+		//wait device link up
+		mdelay(250);
+		printk("check pcie link up status: \n");
+		printk("isRC0_LINKUP=%d \n",isRC0_LINKUP);
+		if(isMT751020){
+			printk("isRC1_LINKUP=%d \n",isRC1_LINKUP);
+                        
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+			printk("isSLAVERC_LINKUP=%d \n",isSLAVERC_LINKUP);
+#endif
+			if((!isRC0_LINKUP) && (!isRC1_LINKUP)){
+				printk("PCI-E RC0 & RC1 can not link up\n");
+				return -1;
+			}
+		}else{
+			if(dual_band_support){
+				printk("isRC1_LINKUP=%d \n",isRC1_LINKUP);
+				if((!isRC0_LINKUP) && (!isRC1_LINKUP)){
+					printk("PCI-E RC can not link up\n");
+					return -1;
+				}
+			}else{
+				if(!isRC0_LINKUP){
+					printk("PCI-E RC can not link up\n");
+					return -1;
+				}
+			}
+		}
+
+
+		if(isMT751020 || isMT7505){
+			pcie_soft_patch = DISABLE; //Enable after temp all config
+			if(isRC0_LINKUP){
+				//config PCI-E RC
+				regWrite32(0xbfb82010, 0xffff0001); //disable support BAR0
+
+				//change class PCI-PCI Bridge
+				regWrite32(0xbfb82034, 0x06040001);
+
+				//Enable CRC count .
+				regWrite32(KSEG1ADDR(pcie_config_addr), 0x118);
+				tmp = regRead32(KSEG1ADDR(pcie_config_data));
+				regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+				pcie_phy_force_mode_en(ENABLE, 0);
+				rc0_is_exist = 1;
+			}else{
+				//disable port 0
+				tmp = regRead32(0xbfb00088);
+				regWrite32(0xbfb00088, (tmp & ~(1<<23)));
+				mdelay(1);
+			}
+
+			if(isRC1_LINKUP){
+				//config PCI-E RC
+				regWrite32(0xbfb83010, 0xffff0001); //disable support BAR0
+
+				//change class PCI-PCI Bridge
+				regWrite32(0xbfb83034, 0x06040001);
+
+				//Enable RC1 ECRC count . //bus0, dev1
+				regWrite32(KSEG1ADDR(pcie_config_addr), 0x80118);
+				tmp = regRead32(KSEG1ADDR(pcie_config_data));
+				regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+				pcie_phy_force_mode_en(ENABLE, 1);
+				rc1_is_exist = 1;
+			}else{
+				//disable port 1
+				tmp = regRead32(0xbfb00088);
+				regWrite32(0xbfb00088, (tmp & ~(1<<22)));
+				mdelay(1);
+			}
+
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+			if(isSLAVERC_LINKUP){
+				pcie_phy_force_mode_en(ENABLE, 2);
+			}else{
+				//disable slave RC
+				tmp = regRead32(0xbfb00088);
+				regWrite32(0xbfb00088, (tmp & ~(1<<24)));
+				mdelay(1);
+			}
+#endif
+		}else{
+			if(dual_band_support){
+				if(isRC0_LINKUP){
+					//config PCI-E RC
+					regWrite32(0xbfb82010, 0xffff0001); //disable support BAR0
+
+					//change class PCI-PCI Bridge
+					regWrite32(0xbfb82034, 0x06040001);
+
+					//Enable CRC count .
+					regWrite32(KSEG1ADDR(pcie_config_addr), 0x118);
+					tmp = regRead32(KSEG1ADDR(pcie_config_data));
+					regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+				}else{
+					//disable port 0
+					tmp = regRead32(0xbfb00088);
+					regWrite32(0xbfb00088, (tmp & ~(1<<23)));
+					mdelay(1);
+				}
+
+				if(isRC1_LINKUP){
+					//config PCI-E RC
+					regWrite32(0xbfb83010, 0xffff0001); //disable support BAR0
+
+					//change class PCI-PCI Bridge
+					regWrite32(0xbfb83034, 0x06040001);
+
+					//Enable RC1 ECRC count . //bus0, dev1
+					regWrite32(KSEG1ADDR(pcie_config_addr), 0x80118);
+					tmp = regRead32(KSEG1ADDR(pcie_config_data));
+					regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+				}else{
+					//disable port 1
+					tmp = regRead32(0xbfb00088);
+					regWrite32(0xbfb00088, (tmp & ~(1<<22)));
+					mdelay(1);
+				}
+			}else{
+				//config PCI-E RC
+				regWrite32(0xbfb82010, 0xffff0001); //disable support BAR0
+
+				//change class PCI-PCI Bridge
+				regWrite32(0xbfb82034, 0x06040001);
+
+				//Enable CRC count .
+				regWrite32(KSEG1ADDR(pcie_config_addr), 0x118);
+				tmp = regRead32(KSEG1ADDR(pcie_config_data));
+				regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+			}
+		}
+#if defined(TCSUPPORT_CPU_RT63368) ||defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7510)|| defined(TCSUPPORT_CPU_MT7505)
+#ifdef TCSUPPORT_WLAN_MT7592_PCIE
+	preConfigLDO();
+#endif
+#endif
+	}
+	else if(isRT63165){
+		
+		printk("RT63165_pcie_init\n");
+		tmp = regRead32(CR_AHB_PCIC);
+		regWrite32(CR_AHB_PCIC, (tmp | (1<<29)));
+		mdelay(1);
+		tmp = regRead32(CR_AHB_PCIC);
+		regWrite32(CR_AHB_PCIC, (tmp | (1<<30)));
+		mdelay(1);
+		//wait device link up
+		for(i=0 ; i<1000 ; i++){
+			mdelay(1);
+			if((regRead32(0xbfb81050) & 0x1) != 0){
+				break;
+			}	
+		}
+		if(i == 1000){
+			printk("PCI-E RC can not link up\n");
+			return -1;
+		}
+		regWrite32(0xbfb81cf8, 0x0);
+		if((regRead32(0xbfb81cfc) & 0xffff) == 0xffff){
+			printk("No PCI-E device found\n");
+			return -1;
+		}
+
+		//config PCI-E RC
+		regWrite32(0xbfb81010, 0xffff0001); //not support BAR0
+		//check has device or not 
+		regWrite32(0xbfb81034, 0x06040001); //change class PCI-PCI Bridge
+		//set pci-e burst size
+		//regWrite32(0xbfb81060, 0x3);
+		//Enable CRC count .
+		regWrite32(KSEG1ADDR(pcie_config_addr), 0x118);
+		tmp = regRead32(KSEG1ADDR(pcie_config_data));
+		regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+	}else{
+	printk("tc3162_pcie_init\n");
+#ifdef CONFIG_MIPS_TC3262
+	regWrite32(0xbfb000b8, 0x00000001);
+#endif 
+
+#if defined(CONFIG_MIPS_TC3162U) || defined(CONFIG_MIPS_TC3262)
+	/*pcie relate clock setting*/
+	tmp = regRead32(CR_AHB_SSR);
+	//tmp &= ~(1<<0 | 1<<2 | 1<<3 | 1<<4);
+	//tmp |= (1<<0 | 1<<2 | 1<<3 | 1<<4);
+	/*use internal clock,*/
+	tmp &= ~(1<<0 | 1<<2 | 1<<3);
+	tmp |= (1<<0 | 1<<2 | 1<<3);
+	regWrite32(CR_AHB_SSR, tmp);
+	mdelay(1);
+#endif
+
+	//tmp = regRead32(CR_AHB_PCIC);
+	//regWrite32(CR_AHB_PCIC), (tmp & ~(1<<29)));
+	//mdelay(5);
+	//tmp = regRead32(CR_AHB_PCIC);
+	//regWrite32(CR_AHB_PCIC), (tmp & ~(1<<30)));
+	//mdelay(5);
+
+	tmp = regRead32(CR_AHB_PCIC);
+	regWrite32(CR_AHB_PCIC, (tmp | (1<<29)));
+	mdelay(5);
+	tmp = regRead32(CR_AHB_PCIC);
+	regWrite32(CR_AHB_PCIC, (tmp | (1<<30)));
+	mdelay(5);
+
+#ifdef CONFIG_MIPS_TC3162U
+	/*work arround for pcie link up*/
+	regWrite32(PCIE_CONFIG_ADDR, 0x40);
+	regWrite32(PCIE_CONFIG_DATA, 0x20);
+#endif	
+	/* PCI memory byte swap enable */
+	/*
+	tmp = regRead32(CR_AHB_PCIC);
+	regWrite32(CR_AHB_PCIC, (tmp | ((1<<24) | (1<<25))));
+	*/
+	}
+
+	/* Set I/O resource limits.  */
+	ioport_resource.end = 0x1fffffff;
+	iomem_resource.end = 0xffffffff;
+
+	if (isEN751221)
+	{
+		register_pci_controller(&mt7512_pcie_controller);
+		pcie_api_init();
+
+	}
+	else
+		register_pci_controller(&tc3162_pcie_controller);
+	
+#ifdef CONFIG_MIPS_TC3162U
+	/*Add AHB error monitor check*/
+	if(request_irq(ARBITER_ERR_INT, ahbErrIsr, 0, "AHB ERR", ahbErrIsr) != 0) {
+		printk("request ARBITER err isr error.\n");
+	}
+#endif
+	/*create a proc to check wifi dead or not*/
+	ahb_status_proc = create_proc_entry("tc3162/ahb_status", 0, NULL);
+	ahb_status_proc->read_proc = ahb_status_read_proc;
+	ahb_status_proc->write_proc = ahb_status_write_proc;
+
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+/*add two proc file,ahb_status_value only for test*/
+if(isRT63368){
+		/*create a proc to check AER*/
+		aer_status_proc = create_proc_entry("tc3162/pcie_error_detect_count", 0, NULL);
+		if(aer_status_proc != NULL){
+			aer_status_proc->read_proc = pcie_error_detect_count_read_proc;
+			aer_status_proc->write_proc = pcie_error_detect_count_write_proc;
+		}	
+		//for test
+		/*create a proc to check AER*/
+		aer_status_proc = create_proc_entry("tc3162/ahb_status_value", 0, NULL);
+		if(aer_status_proc != NULL){
+			aer_status_proc->read_proc = ahb_status_value_count_read_proc;
+			aer_status_proc->write_proc = ahb_status_value_count_write_proc;
+		}
+	}
+#endif
+	if(isMT751020 || isMT7505 || isEN751221){
+
+		/*create a proc to check AER*/
+		aer_status_proc = create_proc_entry("tc3162/aer_status", 0, NULL);
+		if(aer_status_proc != NULL){
+			aer_status_proc->read_proc = aer_status_read_proc;
+			aer_status_proc->write_proc = aer_status_write_proc;
+		}	
+		aer_status_proc = create_proc_entry("tc3162/pcie_reset", 0, NULL);
+		if(aer_status_proc != NULL){
+			aer_status_proc->read_proc = pcie_rcnum_read_proc;
+			aer_status_proc->write_proc = pcie_rcnum_write_proc;
+		}
+		aer_status_proc = create_proc_entry("tc3162/pcie_reset_cond", 0, NULL);
+		if(aer_status_proc != NULL){
+			aer_status_proc->read_proc = pcie_reset_con_read_proc;
+			aer_status_proc->write_proc = pcie_reset_con_write_proc;
+		}
+		create_proc_read_entry("tc3162/pcie_reset_count", 0, NULL, pcie_reset_count_read_proc, NULL);
+		
+	}
+	return 0;
+}
+
+arch_initcall(tc3162_pcie_init);
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/softfloat/dp-bits.c tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/dp-bits.c
--- linux-2.6.36/arch/mips/softfloat/dp-bits.c	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/dp-bits.c	2019-03-07 05:05:24.000000000 +0200
@@ -0,0 +1,1643 @@
+/* This is a software floating point library which can be used
+   for targets without hardware floating point. 
+   Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003
+   Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file with other programs, and to distribute
+those programs without any restriction coming from the use of this
+file.  (The General Public License restrictions do apply in other
+respects; for example, they cover modification of the file, and
+distribution when not linked into another program.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, if you link this library with other files,
+   some of which are compiled with GCC, to produce an executable,
+   this library does not by itself cause the resulting executable
+   to be covered by the GNU General Public License.
+   This exception does not however invalidate any other reasons why
+   the executable file might be covered by the GNU General Public License.  */
+
+/* This implements IEEE 754 format arithmetic, but does not provide a
+   mechanism for setting the rounding mode, or for generating or handling
+   exceptions.
+
+   The original code by Steve Chamberlain, hacked by Mark Eichin and Jim
+   Wilson, all of Cygnus Support.  */
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+/* The intended way to use this file is to make two copies, add `#define FLOAT'
+   to one copy, then compile both copies and add them to libgcc.a.  */
+#ifndef CONFIG_MIPS_TC3262
+#define US_SOFTWARE_GOFAST
+#endif
+#include "tconfig.h"
+#include "fp-bit.h"
+
+/* The following macros can be defined to change the behavior of this file:
+   FLOAT: Implement a `float', aka SFmode, fp library.  If this is not
+     defined, then this file implements a `double', aka DFmode, fp library.
+   FLOAT_ONLY: Used with FLOAT, to implement a `float' only library, i.e.
+     don't include float->double conversion which requires the double library.
+     This is useful only for machines which can't support doubles, e.g. some
+     8-bit processors.
+   CMPtype: Specify the type that floating point compares should return.
+     This defaults to SItype, aka int.
+   US_SOFTWARE_GOFAST: This makes all entry points use the same names as the
+     US Software goFast library.
+   _DEBUG_BITFLOAT: This makes debugging the code a little easier, by adding
+     two integers to the FLO_union_type.
+   NO_DENORMALS: Disable handling of denormals.
+   NO_NANS: Disable nan and infinity handling
+   SMALL_MACHINE: Useful when operations on QIs and HIs are faster
+     than on an SI */
+
+/* We don't currently support extended floats (long doubles) on machines
+   without hardware to deal with them.
+
+   These stubs are just to keep the linker from complaining about unresolved
+   references which can be pulled in from libio & libstdc++, even if the
+   user isn't using long doubles.  However, they may generate an unresolved
+   external to abort if abort is not used by the function, and the stubs
+   are referenced from within libc, since libgcc goes before and after the
+   system library.  */
+
+#ifdef DECLARE_LIBRARY_RENAMES
+  DECLARE_LIBRARY_RENAMES
+#endif
+
+#ifdef EXTENDED_FLOAT_STUBS
+extern void abort (void);
+void __extendsfxf2 (void) { abort(); }
+void __extenddfxf2 (void) { abort(); }
+void __truncxfdf2 (void) { abort(); }
+void __truncxfsf2 (void) { abort(); }
+void __fixxfsi (void) { abort(); }
+void __floatsixf (void) { abort(); }
+void __addxf3 (void) { abort(); }
+void __subxf3 (void) { abort(); }
+void __mulxf3 (void) { abort(); }
+void __divxf3 (void) { abort(); }
+void __negxf2 (void) { abort(); }
+void __eqxf2 (void) { abort(); }
+void __nexf2 (void) { abort(); }
+void __gtxf2 (void) { abort(); }
+void __gexf2 (void) { abort(); }
+void __lexf2 (void) { abort(); }
+void __ltxf2 (void) { abort(); }
+
+void __extendsftf2 (void) { abort(); }
+void __extenddftf2 (void) { abort(); }
+void __trunctfdf2 (void) { abort(); }
+void __trunctfsf2 (void) { abort(); }
+void __fixtfsi (void) { abort(); }
+void __floatsitf (void) { abort(); }
+void __addtf3 (void) { abort(); }
+void __subtf3 (void) { abort(); }
+void __multf3 (void) { abort(); }
+void __divtf3 (void) { abort(); }
+void __negtf2 (void) { abort(); }
+void __eqtf2 (void) { abort(); }
+void __netf2 (void) { abort(); }
+void __gttf2 (void) { abort(); }
+void __getf2 (void) { abort(); }
+void __letf2 (void) { abort(); }
+void __lttf2 (void) { abort(); }
+#else	/* !EXTENDED_FLOAT_STUBS, rest of file */
+
+/* IEEE "special" number predicates */
+
+#ifdef NO_NANS
+
+#define nan() 0
+#define isnan(x) 0
+#define isinf(x) 0
+#else
+
+#if   defined L_thenan_sf
+const fp_number_type __thenan_sf = { CLASS_SNAN, 0, 0, {(fractype) 0} };
+#elif defined L_thenan_df
+const fp_number_type __thenan_df = { CLASS_SNAN, 0, 0, {(fractype) 0} };
+#elif defined L_thenan_tf
+const fp_number_type __thenan_tf = { CLASS_SNAN, 0, 0, {(fractype) 0} };
+#elif defined TFLOAT
+extern const fp_number_type __thenan_tf;
+#elif defined FLOAT
+extern const fp_number_type __thenan_sf;
+#else
+extern const fp_number_type __thenan_df;
+#endif
+
+INLINE
+static fp_number_type *
+nan (void)
+{
+  /* Discard the const qualifier...  */
+#ifdef TFLOAT
+  return (fp_number_type *) (& __thenan_tf);
+#elif defined FLOAT  
+  return (fp_number_type *) (& __thenan_sf);
+#else
+  return (fp_number_type *) (& __thenan_df);
+#endif
+}
+
+INLINE
+static int
+isnan ( fp_number_type *  x)
+{
+  return x->class == CLASS_SNAN || x->class == CLASS_QNAN;
+}
+
+INLINE
+static int
+isinf ( fp_number_type *  x)
+{
+  return x->class == CLASS_INFINITY;
+}
+
+#endif /* NO_NANS */
+
+INLINE
+static int
+iszero ( fp_number_type *  x)
+{
+  return x->class == CLASS_ZERO;
+}
+
+INLINE 
+static void
+flip_sign ( fp_number_type *  x)
+{
+  x->sign = !x->sign;
+}
+
+extern FLO_type pack_d ( fp_number_type * );
+
+#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
+FLO_type
+pack_d ( fp_number_type *  src)
+{
+  FLO_union_type dst;
+  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
+  int sign = src->sign;
+  int exp = 0;
+
+  if (LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS) && (isnan (src) || isinf (src)))
+    {
+      /* We can't represent these values accurately.  By using the
+	 largest possible magnitude, we guarantee that the conversion
+	 of infinity is at least as big as any finite number.  */
+      exp = EXPMAX;
+      fraction = ((fractype) 1 << FRACBITS) - 1;
+    }
+  else if (isnan (src))
+    {
+      exp = EXPMAX;
+      if (src->class == CLASS_QNAN || 1)
+	{
+	  fraction |= QUIET_NAN;
+	}
+    }
+  else if (isinf (src))
+    {
+      exp = EXPMAX;
+      fraction = 0;
+    }
+  else if (iszero (src))
+    {
+      exp = 0;
+      fraction = 0;
+    }
+  else if (fraction == 0)
+    {
+      exp = 0;
+    }
+  else
+    {
+      if (src->normal_exp < NORMAL_EXPMIN)
+	{
+#ifdef NO_DENORMALS
+	  /* Go straight to a zero representation if denormals are not
+ 	     supported.  The denormal handling would be harmless but
+ 	     isn't unnecessary.  */
+	  exp = 0;
+	  fraction = 0;
+#else /* NO_DENORMALS */
+	  /* This number's exponent is too low to fit into the bits
+	     available in the number, so we'll store 0 in the exponent and
+	     shift the fraction to the right to make up for it.  */
+
+	  int shift = NORMAL_EXPMIN - src->normal_exp;
+
+	  exp = 0;
+
+	  if (shift > FRAC_NBITS - NGARDS)
+	    {
+	      /* No point shifting, since it's more that 64 out.  */
+	      fraction = 0;
+	    }
+	  else
+	    {
+	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
+	      fraction = (fraction >> shift) | lowbit;
+	    }
+	  if ((fraction & GARDMASK) == GARDMSB)
+	    {
+	      if ((fraction & (1 << NGARDS)))
+		fraction += GARDROUND + 1;
+	    }
+	  else
+	    {
+	      /* Add to the guards to round up.  */
+	      fraction += GARDROUND;
+	    }
+	  /* Perhaps the rounding means we now need to change the
+             exponent, because the fraction is no longer denormal.  */
+	  if (fraction >= IMPLICIT_1)
+	    {
+	      exp += 1;
+	    }
+	  fraction >>= NGARDS;
+#endif /* NO_DENORMALS */
+	}
+      else if (!LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS)
+	       && src->normal_exp > EXPBIAS)
+	{
+	  exp = EXPMAX;
+	  fraction = 0;
+	}
+      else
+	{
+	  exp = src->normal_exp + EXPBIAS;
+	  if (!ROUND_TOWARDS_ZERO)
+	    {
+	      /* IF the gard bits are the all zero, but the first, then we're
+		 half way between two numbers, choose the one which makes the
+		 lsb of the answer 0.  */
+	      if ((fraction & GARDMASK) == GARDMSB)
+		{
+		  if (fraction & (1 << NGARDS))
+		    fraction += GARDROUND + 1;
+		}
+	      else
+		{
+		  /* Add a one to the guards to round up */
+		  fraction += GARDROUND;
+		}
+	      if (fraction >= IMPLICIT_2)
+		{
+		  fraction >>= 1;
+		  exp += 1;
+		}
+	    }
+	  fraction >>= NGARDS;
+
+	  if (LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS) && exp > EXPMAX)
+	    {
+	      /* Saturate on overflow.  */
+	      exp = EXPMAX;
+	      fraction = ((fractype) 1 << FRACBITS) - 1;
+	    }
+	}
+    }
+
+  /* We previously used bitfields to store the number, but this doesn't
+     handle little/big endian systems conveniently, so use shifts and
+     masks */
+#ifdef FLOAT_BIT_ORDER_MISMATCH
+  dst.bits.fraction = fraction;
+  dst.bits.exp = exp;
+  dst.bits.sign = sign;
+#else
+# if defined TFLOAT && defined HALFFRACBITS
+ {
+   halffractype high, low;
+
+   high = (fraction >> (FRACBITS - HALFFRACBITS));
+   high &= (((fractype)1) << HALFFRACBITS) - 1;
+   high |= ((fractype) (exp & ((1 << EXPBITS) - 1))) << HALFFRACBITS;
+   high |= ((fractype) (sign & 1)) << (HALFFRACBITS | EXPBITS);
+
+   low = (halffractype)fraction &
+     ((((halffractype)1) << (FRACBITS - HALFFRACBITS)) - 1);
+
+   if (exp == EXPMAX || exp == 0 || low == 0)
+     low = 0;
+   else
+     {
+       exp -= HALFFRACBITS + 1;
+
+       while (exp > 0
+	      && low < ((halffractype)1 << HALFFRACBITS))
+	 {
+	   low <<= 1;
+	   exp--;
+	 }
+
+       if (exp <= 0)
+	 {
+	   halffractype roundmsb, round;
+
+	   exp = -exp + 1;
+
+	   roundmsb = (1 << (exp - 1));
+	   round = low & ((roundmsb << 1) - 1);
+
+	   low >>= exp;
+	   exp = 0;
+
+	   if (round > roundmsb || (round == roundmsb && (low & 1)))
+	     {
+	       low++;
+	       if (low >= ((halffractype)1 << HALFFRACBITS))
+		 /* We don't shift left, since it has just become the
+		    smallest normal number, whose implicit 1 bit is
+		    now indicated by the non-zero exponent.  */
+		 exp++;
+	     }
+	 }
+
+       low &= ((halffractype)1 << HALFFRACBITS) - 1;
+       low |= ((fractype) (exp & ((1 << EXPBITS) - 1))) << HALFFRACBITS;
+       low |= ((fractype) (sign & 1)) << (HALFFRACBITS | EXPBITS);
+     }
+
+   dst.value_raw = (((fractype) high) << HALFSHIFT) | low;
+ }
+# else
+  dst.value_raw = fraction & ((((fractype)1) << FRACBITS) - (fractype)1);
+  dst.value_raw |= ((fractype) (exp & ((1 << EXPBITS) - 1))) << FRACBITS;
+  dst.value_raw |= ((fractype) (sign & 1)) << (FRACBITS | EXPBITS);
+# endif
+#endif
+
+#if defined(FLOAT_WORD_ORDER_MISMATCH) && !defined(FLOAT)
+#ifdef TFLOAT
+  {
+    qrtrfractype tmp1 = dst.words[0];
+    qrtrfractype tmp2 = dst.words[1];
+    dst.words[0] = dst.words[3];
+    dst.words[1] = dst.words[2];
+    dst.words[2] = tmp2;
+    dst.words[3] = tmp1;
+  }
+#else
+  {
+    halffractype tmp = dst.words[0];
+    dst.words[0] = dst.words[1];
+    dst.words[1] = tmp;
+  }
+#endif
+#endif
+
+  return dst.value;
+}
+#endif
+
+#if defined(L_unpack_df) || defined(L_unpack_sf) || defined(L_unpack_tf)
+void
+unpack_d (FLO_union_type * src, fp_number_type * dst)
+{
+  /* We previously used bitfields to store the number, but this doesn't
+     handle little/big endian systems conveniently, so use shifts and
+     masks */
+  fractype fraction;
+  int exp;
+  int sign;
+
+#if defined(FLOAT_WORD_ORDER_MISMATCH) && !defined(FLOAT)
+  FLO_union_type swapped;
+
+#ifdef TFLOAT
+  swapped.words[0] = src->words[3];
+  swapped.words[1] = src->words[2];
+  swapped.words[2] = src->words[1];
+  swapped.words[3] = src->words[0];
+#else
+  swapped.words[0] = src->words[1];
+  swapped.words[1] = src->words[0];
+#endif
+  src = &swapped;
+#endif
+  
+#ifdef FLOAT_BIT_ORDER_MISMATCH
+  fraction = src->bits.fraction;
+  exp = src->bits.exp;
+  sign = src->bits.sign;
+#else
+# if defined TFLOAT && defined HALFFRACBITS
+ {
+   halffractype high, low;
+   
+   high = src->value_raw >> HALFSHIFT;
+   low = src->value_raw & (((fractype)1 << HALFSHIFT) - 1);
+
+   fraction = high & ((((fractype)1) << HALFFRACBITS) - 1);
+   fraction <<= FRACBITS - HALFFRACBITS;
+   exp = ((int)(high >> HALFFRACBITS)) & ((1 << EXPBITS) - 1);
+   sign = ((int)(high >> (((HALFFRACBITS + EXPBITS))))) & 1;
+
+   if (exp != EXPMAX && exp != 0 && low != 0)
+     {
+       int lowexp = ((int)(low >> HALFFRACBITS)) & ((1 << EXPBITS) - 1);
+       int lowsign = ((int)(low >> (((HALFFRACBITS + EXPBITS))))) & 1;
+       int shift;
+       fractype xlow;
+
+       xlow = low & ((((fractype)1) << HALFFRACBITS) - 1);
+       if (lowexp)
+	 xlow |= (((halffractype)1) << HALFFRACBITS);
+       else
+	 lowexp = 1;
+       shift = (FRACBITS - HALFFRACBITS) - (exp - lowexp);
+       if (shift > 0)
+	 xlow <<= shift;
+       else if (shift < 0)
+	 xlow >>= -shift;
+       if (sign == lowsign)
+	 fraction += xlow;
+       else
+	 fraction -= xlow;
+     }
+ }
+# else
+  fraction = src->value_raw & ((((fractype)1) << FRACBITS) - 1);
+  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
+  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
+# endif
+#endif
+
+  dst->sign = sign;
+  if (exp == 0)
+    {
+      /* Hmm.  Looks like 0 */
+      if (fraction == 0
+#ifdef NO_DENORMALS
+	  || 1
+#endif
+	  )
+	{
+	  /* tastes like zero */
+	  dst->class = CLASS_ZERO;
+	}
+      else
+	{
+	  /* Zero exponent with nonzero fraction - it's denormalized,
+	     so there isn't a leading implicit one - we'll shift it so
+	     it gets one.  */
+	  dst->normal_exp = exp - EXPBIAS + 1;
+	  fraction <<= NGARDS;
+
+	  dst->class = CLASS_NUMBER;
+#if 1
+	  while (fraction < IMPLICIT_1)
+	    {
+	      fraction <<= 1;
+	      dst->normal_exp--;
+	    }
+#endif
+	  dst->fraction.ll = fraction;
+	}
+    }
+  else if (!LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS) && exp == EXPMAX)
+    {
+      /* Huge exponent*/
+      if (fraction == 0)
+	{
+	  /* Attached to a zero fraction - means infinity */
+	  dst->class = CLASS_INFINITY;
+	}
+      else
+	{
+	  /* Nonzero fraction, means nan */
+	  if (fraction & QUIET_NAN)
+	    {
+	      dst->class = CLASS_QNAN;
+	    }
+	  else
+	    {
+	      dst->class = CLASS_SNAN;
+	    }
+	  /* Keep the fraction part as the nan number */
+	  dst->fraction.ll = fraction;
+	}
+    }
+  else
+    {
+      /* Nothing strange about this number */
+      dst->normal_exp = exp - EXPBIAS;
+      dst->class = CLASS_NUMBER;
+      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
+    }
+}
+#endif /* L_unpack_df || L_unpack_sf */
+
+#if defined(L_addsub_sf) || defined(L_addsub_df) || defined(L_addsub_tf)
+static fp_number_type *
+_fpadd_parts (fp_number_type * a,
+	      fp_number_type * b,
+	      fp_number_type * tmp)
+{
+  intfrac tfraction;
+
+  /* Put commonly used fields in local variables.  */
+  int a_normal_exp;
+  int b_normal_exp;
+  fractype a_fraction;
+  fractype b_fraction;
+
+  if (isnan (a))
+    {
+      return a;
+    }
+  if (isnan (b))
+    {
+      return b;
+    }
+  if (isinf (a))
+    {
+      /* Adding infinities with opposite signs yields a NaN.  */
+      if (isinf (b) && a->sign != b->sign)
+	return nan ();
+      return a;
+    }
+  if (isinf (b))
+    {
+      return b;
+    }
+  if (iszero (b))
+    {
+      if (iszero (a))
+	{
+	  *tmp = *a;
+	  tmp->sign = a->sign & b->sign;
+	  return tmp;
+	}
+      return a;
+    }
+  if (iszero (a))
+    {
+      return b;
+    }
+
+  /* Got two numbers. shift the smaller and increment the exponent till
+     they're the same */
+  {
+    int diff;
+
+    a_normal_exp = a->normal_exp;
+    b_normal_exp = b->normal_exp;
+    a_fraction = a->fraction.ll;
+    b_fraction = b->fraction.ll;
+
+    diff = a_normal_exp - b_normal_exp;
+
+    if (diff < 0)
+      diff = -diff;
+    if (diff < FRAC_NBITS)
+      {
+	/* ??? This does shifts one bit at a time.  Optimize.  */
+	while (a_normal_exp > b_normal_exp)
+	  {
+	    b_normal_exp++;
+	    LSHIFT (b_fraction);
+	  }
+	while (b_normal_exp > a_normal_exp)
+	  {
+	    a_normal_exp++;
+	    LSHIFT (a_fraction);
+	  }
+      }
+    else
+      {
+	/* Somethings's up.. choose the biggest */
+	if (a_normal_exp > b_normal_exp)
+	  {
+	    b_normal_exp = a_normal_exp;
+	    b_fraction = 0;
+	  }
+	else
+	  {
+	    a_normal_exp = b_normal_exp;
+	    a_fraction = 0;
+	  }
+      }
+  }
+
+  if (a->sign != b->sign)
+    {
+      if (a->sign)
+	{
+	  tfraction = -a_fraction + b_fraction;
+	}
+      else
+	{
+	  tfraction = a_fraction - b_fraction;
+	}
+      if (tfraction >= 0)
+	{
+	  tmp->sign = 0;
+	  tmp->normal_exp = a_normal_exp;
+	  tmp->fraction.ll = tfraction;
+	}
+      else
+	{
+	  tmp->sign = 1;
+	  tmp->normal_exp = a_normal_exp;
+	  tmp->fraction.ll = -tfraction;
+	}
+      /* and renormalize it */
+
+      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
+	{
+	  tmp->fraction.ll <<= 1;
+	  tmp->normal_exp--;
+	}
+    }
+  else
+    {
+      tmp->sign = a->sign;
+      tmp->normal_exp = a_normal_exp;
+      tmp->fraction.ll = a_fraction + b_fraction;
+    }
+  tmp->class = CLASS_NUMBER;
+  /* Now the fraction is added, we have to shift down to renormalize the
+     number */
+
+  if (tmp->fraction.ll >= IMPLICIT_2)
+    {
+      LSHIFT (tmp->fraction.ll);
+      tmp->normal_exp++;
+    }
+  return tmp;
+
+}
+
+FLO_type
+add (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  fp_number_type tmp;
+  fp_number_type *res;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  res = _fpadd_parts (&a, &b, &tmp);
+
+  return pack_d (res);
+}
+EXPORT_SYMBOL(add);
+
+FLO_type
+sub (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  fp_number_type tmp;
+  fp_number_type *res;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  b.sign ^= 1;
+
+  res = _fpadd_parts (&a, &b, &tmp);
+
+  return pack_d (res);
+}
+EXPORT_SYMBOL(sub);
+#endif /* L_addsub_sf || L_addsub_df */
+
+#if defined(L_mul_sf) || defined(L_mul_df) || defined(L_mul_tf)
+static inline __attribute__ ((__always_inline__)) fp_number_type *
+_fpmul_parts ( fp_number_type *  a,
+	       fp_number_type *  b,
+	       fp_number_type * tmp)
+{
+  fractype low = 0;
+  fractype high = 0;
+
+  if (isnan (a))
+    {
+      a->sign = a->sign != b->sign;
+      return a;
+    }
+  if (isnan (b))
+    {
+      b->sign = a->sign != b->sign;
+      return b;
+    }
+  if (isinf (a))
+    {
+      if (iszero (b))
+	return nan ();
+      a->sign = a->sign != b->sign;
+      return a;
+    }
+  if (isinf (b))
+    {
+      if (iszero (a))
+	{
+	  return nan ();
+	}
+      b->sign = a->sign != b->sign;
+      return b;
+    }
+  if (iszero (a))
+    {
+      a->sign = a->sign != b->sign;
+      return a;
+    }
+  if (iszero (b))
+    {
+      b->sign = a->sign != b->sign;
+      return b;
+    }
+
+  /* Calculate the mantissa by multiplying both numbers to get a
+     twice-as-wide number.  */
+  {
+#if defined(NO_DI_MODE) || defined(TFLOAT)
+    {
+      fractype x = a->fraction.ll;
+      fractype ylow = b->fraction.ll;
+      fractype yhigh = 0;
+      int bit;
+
+      /* ??? This does multiplies one bit at a time.  Optimize.  */
+      for (bit = 0; bit < FRAC_NBITS; bit++)
+	{
+	  int carry;
+
+	  if (x & 1)
+	    {
+	      carry = (low += ylow) < ylow;
+	      high += yhigh + carry;
+	    }
+	  yhigh <<= 1;
+	  if (ylow & FRACHIGH)
+	    {
+	      yhigh |= 1;
+	    }
+	  ylow <<= 1;
+	  x >>= 1;
+	}
+    }
+#elif defined(FLOAT) 
+    /* Multiplying two USIs to get a UDI, we're safe.  */
+    {
+      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
+      
+      high = answer >> BITS_PER_SI;
+      low = answer;
+    }
+#else
+    /* fractype is DImode, but we need the result to be twice as wide.
+       Assuming a widening multiply from DImode to TImode is not
+       available, build one by hand.  */
+    {
+      USItype nl = a->fraction.ll;
+      USItype nh = a->fraction.ll >> BITS_PER_SI;
+      USItype ml = b->fraction.ll;
+      USItype mh = b->fraction.ll >> BITS_PER_SI;
+      UDItype pp_ll = (UDItype) ml * nl;
+      UDItype pp_hl = (UDItype) mh * nl;
+      UDItype pp_lh = (UDItype) ml * nh;
+      UDItype pp_hh = (UDItype) mh * nh;
+      UDItype res2 = 0;
+      UDItype res0 = 0;
+      UDItype ps_hh__ = pp_hl + pp_lh;
+      if (ps_hh__ < pp_hl)
+	res2 += (UDItype)1 << BITS_PER_SI;
+      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
+      res0 = pp_ll + pp_hl;
+      if (res0 < pp_ll)
+	res2++;
+      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
+      high = res2;
+      low = res0;
+    }
+#endif
+  }
+
+  tmp->normal_exp = a->normal_exp + b->normal_exp
+    + FRAC_NBITS - (FRACBITS + NGARDS);
+  tmp->sign = a->sign != b->sign;
+  while (high >= IMPLICIT_2)
+    {
+      tmp->normal_exp++;
+      if (high & 1)
+	{
+	  low >>= 1;
+	  low |= FRACHIGH;
+	}
+      high >>= 1;
+    }
+  while (high < IMPLICIT_1)
+    {
+      tmp->normal_exp--;
+
+      high <<= 1;
+      if (low & FRACHIGH)
+	high |= 1;
+      low <<= 1;
+    }
+  /* rounding is tricky. if we only round if it won't make us round later.  */
+#if 0
+  if (low & FRACHIGH2)
+    {
+      if (((high & GARDMASK) != GARDMSB)
+	  && (((high + 1) & GARDMASK) == GARDMSB))
+	{
+	  /* don't round, it gets done again later.  */
+	}
+      else
+	{
+	  high++;
+	}
+    }
+#endif
+  if (!ROUND_TOWARDS_ZERO && (high & GARDMASK) == GARDMSB)
+    {
+      if (high & (1 << NGARDS))
+	{
+	  /* half way, so round to even */
+	  high += GARDROUND + 1;
+	}
+      else if (low)
+	{
+	  /* but we really weren't half way */
+	  high += GARDROUND + 1;
+	}
+    }
+  tmp->fraction.ll = high;
+  tmp->class = CLASS_NUMBER;
+  return tmp;
+}
+
+FLO_type
+multiply (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  fp_number_type tmp;
+  fp_number_type *res;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  res = _fpmul_parts (&a, &b, &tmp);
+
+  return pack_d (res);
+}
+EXPORT_SYMBOL(multiply);
+#endif /* L_mul_sf || L_mul_df */
+
+#if defined(L_div_sf) || defined(L_div_df) || defined(L_div_tf)
+static inline __attribute__ ((__always_inline__)) fp_number_type *
+_fpdiv_parts (fp_number_type * a,
+	      fp_number_type * b)
+{
+  fractype bit;
+  fractype numerator;
+  fractype denominator;
+  fractype quotient;
+
+  if (isnan (a))
+    {
+      return a;
+    }
+  if (isnan (b))
+    {
+      return b;
+    }
+
+  a->sign = a->sign ^ b->sign;
+
+  if (isinf (a) || iszero (a))
+    {
+      if (a->class == b->class)
+	return nan ();
+      return a;
+    }
+
+  if (isinf (b))
+    {
+      a->fraction.ll = 0;
+      a->normal_exp = 0;
+      return a;
+    }
+  if (iszero (b))
+    {
+      a->class = CLASS_INFINITY;
+      return a;
+    }
+
+  /* Calculate the mantissa by multiplying both 64bit numbers to get a
+     128 bit number */
+  {
+    /* quotient =
+       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
+     */
+
+    a->normal_exp = a->normal_exp - b->normal_exp;
+    numerator = a->fraction.ll;
+    denominator = b->fraction.ll;
+
+    if (numerator < denominator)
+      {
+	/* Fraction will be less than 1.0 */
+	numerator *= 2;
+	a->normal_exp--;
+      }
+    bit = IMPLICIT_1;
+    quotient = 0;
+    /* ??? Does divide one bit at a time.  Optimize.  */
+    while (bit)
+      {
+	if (numerator >= denominator)
+	  {
+	    quotient |= bit;
+	    numerator -= denominator;
+	  }
+	bit >>= 1;
+	numerator *= 2;
+      }
+
+    if (!ROUND_TOWARDS_ZERO && (quotient & GARDMASK) == GARDMSB)
+      {
+	if (quotient & (1 << NGARDS))
+	  {
+	    /* half way, so round to even */
+	    quotient += GARDROUND + 1;
+	  }
+	else if (numerator)
+	  {
+	    /* but we really weren't half way, more bits exist */
+	    quotient += GARDROUND + 1;
+	  }
+      }
+
+    a->fraction.ll = quotient;
+    return (a);
+  }
+}
+
+FLO_type
+divide (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  fp_number_type *res;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  res = _fpdiv_parts (&a, &b);
+
+  return pack_d (res);
+}
+EXPORT_SYMBOL(divide);
+#endif /* L_div_sf || L_div_df */
+
+#if defined(L_fpcmp_parts_sf) || defined(L_fpcmp_parts_df) \
+    || defined(L_fpcmp_parts_tf)
+/* according to the demo, fpcmp returns a comparison with 0... thus
+   a<b -> -1
+   a==b -> 0
+   a>b -> +1
+ */
+
+int
+__fpcmp_parts (fp_number_type * a, fp_number_type * b)
+{
+#if 0
+  /* either nan -> unordered. Must be checked outside of this routine.  */
+  if (isnan (a) && isnan (b))
+    {
+      return 1;			/* still unordered! */
+    }
+#endif
+
+  if (isnan (a) || isnan (b))
+    {
+      return 1;			/* how to indicate unordered compare? */
+    }
+  if (isinf (a) && isinf (b))
+    {
+      /* +inf > -inf, but +inf != +inf */
+      /* b    \a| +inf(0)| -inf(1)
+       ______\+--------+--------
+       +inf(0)| a==b(0)| a<b(-1)
+       -------+--------+--------
+       -inf(1)| a>b(1) | a==b(0)
+       -------+--------+--------
+       So since unordered must be nonzero, just line up the columns...
+       */
+      return b->sign - a->sign;
+    }
+  /* but not both...  */
+  if (isinf (a))
+    {
+      return a->sign ? -1 : 1;
+    }
+  if (isinf (b))
+    {
+      return b->sign ? 1 : -1;
+    }
+  if (iszero (a) && iszero (b))
+    {
+      return 0;
+    }
+  if (iszero (a))
+    {
+      return b->sign ? 1 : -1;
+    }
+  if (iszero (b))
+    {
+      return a->sign ? -1 : 1;
+    }
+  /* now both are "normal".  */
+  if (a->sign != b->sign)
+    {
+      /* opposite signs */
+      return a->sign ? -1 : 1;
+    }
+  /* same sign; exponents? */
+  if (a->normal_exp > b->normal_exp)
+    {
+      return a->sign ? -1 : 1;
+    }
+  if (a->normal_exp < b->normal_exp)
+    {
+      return a->sign ? 1 : -1;
+    }
+  /* same exponents; check size.  */
+  if (a->fraction.ll > b->fraction.ll)
+    {
+      return a->sign ? -1 : 1;
+    }
+  if (a->fraction.ll < b->fraction.ll)
+    {
+      return a->sign ? 1 : -1;
+    }
+  /* after all that, they're equal.  */
+  return 0;
+}
+#endif
+
+#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
+CMPtype
+compare (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  return __fpcmp_parts (&a, &b);
+}
+EXPORT_SYMBOL(compare);
+#endif /* L_compare_sf || L_compare_df */
+
+#ifndef US_SOFTWARE_GOFAST
+
+/* These should be optimized for their specific tasks someday.  */
+
+#if defined(L_eq_sf) || defined(L_eq_df) || defined(L_eq_tf)
+CMPtype
+_eq_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return 1;			/* false, truth == 0 */
+
+  return __fpcmp_parts (&a, &b) ;
+}
+EXPORT_SYMBOL(_eq_f2);
+#endif /* L_eq_sf || L_eq_df */
+
+#if defined(L_ne_sf) || defined(L_ne_df) || defined(L_ne_tf)
+CMPtype
+_ne_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return 1;			/* true, truth != 0 */
+
+  return  __fpcmp_parts (&a, &b) ;
+}
+EXPORT_SYMBOL(_ne_f2);
+#endif /* L_ne_sf || L_ne_df */
+
+#if defined(L_gt_sf) || defined(L_gt_df) || defined(L_gt_tf)
+CMPtype
+_gt_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return -1;			/* false, truth > 0 */
+
+  return __fpcmp_parts (&a, &b);
+}
+EXPORT_SYMBOL(_gt_f2);
+#endif /* L_gt_sf || L_gt_df */
+
+#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
+CMPtype
+_ge_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return -1;			/* false, truth >= 0 */
+  return __fpcmp_parts (&a, &b) ;
+}
+EXPORT_SYMBOL(_ge_f2);
+#endif /* L_ge_sf || L_ge_df */
+
+#if defined(L_lt_sf) || defined(L_lt_df) || defined(L_lt_tf)
+CMPtype
+_lt_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return 1;			/* false, truth < 0 */
+
+  return __fpcmp_parts (&a, &b);
+}
+EXPORT_SYMBOL(_lt_f2);
+#endif /* L_lt_sf || L_lt_df */
+
+#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
+CMPtype
+_le_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return 1;			/* false, truth <= 0 */
+
+  return __fpcmp_parts (&a, &b) ;
+}
+EXPORT_SYMBOL(_le_f2);
+#endif /* L_le_sf || L_le_df */
+
+#endif /* ! US_SOFTWARE_GOFAST */
+
+#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
+CMPtype
+_unord_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  return (isnan (&a) || isnan (&b));
+}
+EXPORT_SYMBOL(_unord_f2);
+#endif /* L_unord_sf || L_unord_df */
+
+#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
+FLO_type
+si_to_float (SItype arg_a)
+{
+  fp_number_type in;
+
+  in.class = CLASS_NUMBER;
+  in.sign = arg_a < 0;
+  if (!arg_a)
+    {
+      in.class = CLASS_ZERO;
+    }
+  else
+    {
+      in.normal_exp = FRACBITS + NGARDS;
+      if (in.sign) 
+	{
+	  /* Special case for minint, since there is no +ve integer
+	     representation for it */
+	  if (arg_a == (- MAX_SI_INT - 1))
+	    {
+	      return (FLO_type)(- MAX_SI_INT - 1);
+	    }
+	  in.fraction.ll = (-arg_a);
+	}
+      else
+	in.fraction.ll = arg_a;
+
+      while (in.fraction.ll < ((fractype)1 << (FRACBITS + NGARDS)))
+	{
+	  in.fraction.ll <<= 1;
+	  in.normal_exp -= 1;
+	}
+    }
+  return pack_d (&in);
+}
+EXPORT_SYMBOL(si_to_float);
+#endif /* L_si_to_sf || L_si_to_df */
+
+#if defined(L_usi_to_sf) || defined(L_usi_to_df) || defined(L_usi_to_tf)
+FLO_type
+usi_to_float (USItype arg_a)
+{
+  fp_number_type in;
+
+  in.sign = 0;
+  if (!arg_a)
+    {
+      in.class = CLASS_ZERO;
+    }
+  else
+    {
+      in.class = CLASS_NUMBER;
+      in.normal_exp = FRACBITS + NGARDS;
+      in.fraction.ll = arg_a;
+
+      while (in.fraction.ll > ((fractype)1 << (FRACBITS + NGARDS)))
+        {
+          in.fraction.ll >>= 1;
+          in.normal_exp += 1;
+        }
+      while (in.fraction.ll < ((fractype)1 << (FRACBITS + NGARDS)))
+	{
+	  in.fraction.ll <<= 1;
+	  in.normal_exp -= 1;
+	}
+    }
+  return pack_d (&in);
+}
+EXPORT_SYMBOL(usi_to_float);
+#endif
+
+#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
+SItype
+float_to_si (FLO_type arg_a)
+{
+  fp_number_type a;
+  SItype tmp;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &a);
+
+  if (iszero (&a))
+    return 0;
+  if (isnan (&a))
+    return 0;
+  /* get reasonable MAX_SI_INT...  */
+  if (isinf (&a))
+    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
+  /* it is a number, but a small one */
+  if (a.normal_exp < 0)
+    return 0;
+  if (a.normal_exp > BITS_PER_SI - 2)
+    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
+  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
+  return a.sign ? (-tmp) : (tmp);
+}
+EXPORT_SYMBOL(float_to_si);
+#endif /* L_sf_to_si || L_df_to_si */
+
+#if defined(L_sf_to_usi) || defined(L_df_to_usi) || defined(L_tf_to_usi)
+#if defined US_SOFTWARE_GOFAST || defined(L_tf_to_usi)
+/* While libgcc2.c defines its own __fixunssfsi and __fixunsdfsi routines,
+   we also define them for GOFAST because the ones in libgcc2.c have the
+   wrong names and I'd rather define these here and keep GOFAST CYG-LOC's
+   out of libgcc2.c.  We can't define these here if not GOFAST because then
+   there'd be duplicate copies.  */
+
+USItype
+float_to_usi (FLO_type arg_a)
+{
+  fp_number_type a;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &a);
+
+  if (iszero (&a))
+    return 0;
+  if (isnan (&a))
+    return 0;
+  /* it is a negative number */
+  if (a.sign)
+    return 0;
+  /* get reasonable MAX_USI_INT...  */
+  if (isinf (&a))
+    return MAX_USI_INT;
+  /* it is a number, but a small one */
+  if (a.normal_exp < 0)
+    return 0;
+  if (a.normal_exp > BITS_PER_SI - 1)
+    return MAX_USI_INT;
+  else if (a.normal_exp > (FRACBITS + NGARDS))
+    return a.fraction.ll << (a.normal_exp - (FRACBITS + NGARDS));
+  else
+    return a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
+}
+EXPORT_SYMBOL(float_to_usi);
+#endif /* US_SOFTWARE_GOFAST */
+#endif /* L_sf_to_usi || L_df_to_usi */
+
+#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
+FLO_type
+negate (FLO_type arg_a)
+{
+  fp_number_type a;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &a);
+
+  flip_sign (&a);
+  return pack_d (&a);
+}
+EXPORT_SYMBOL(negate);
+#endif /* L_negate_sf || L_negate_df */
+
+#ifdef FLOAT
+
+#if defined(L_make_sf)
+SFtype
+__make_fp(fp_class_type class,
+	     unsigned int sign,
+	     int exp, 
+	     USItype frac)
+{
+  fp_number_type in;
+
+  in.class = class;
+  in.sign = sign;
+  in.normal_exp = exp;
+  in.fraction.ll = frac;
+  return pack_d (&in);
+}
+#endif /* L_make_sf */
+
+#ifndef FLOAT_ONLY
+
+/* This enables one to build an fp library that supports float but not double.
+   Otherwise, we would get an undefined reference to __make_dp.
+   This is needed for some 8-bit ports that can't handle well values that
+   are 8-bytes in size, so we just don't support double for them at all.  */
+
+#if defined(L_sf_to_df)
+DFtype
+sf_to_df (SFtype arg_a)
+{
+  fp_number_type in;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  return __make_dp (in.class, in.sign, in.normal_exp,
+		    ((UDItype) in.fraction.ll) << F_D_BITOFF);
+}
+EXPORT_SYMBOL(sf_to_df);
+#endif /* L_sf_to_df */
+
+#if defined(L_sf_to_tf) && defined(TMODES)
+TFtype
+sf_to_tf (SFtype arg_a)
+{
+  fp_number_type in;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  return __make_tp (in.class, in.sign, in.normal_exp,
+		    ((UTItype) in.fraction.ll) << F_T_BITOFF);
+}
+EXPORT_SYMBOL(sf_to_tf);
+#endif /* L_sf_to_df */
+
+#endif /* ! FLOAT_ONLY */
+#endif /* FLOAT */
+
+#ifndef FLOAT
+
+extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);
+
+#if defined(L_make_df)
+DFtype
+__make_dp (fp_class_type class, unsigned int sign, int exp, UDItype frac)
+{
+  fp_number_type in;
+
+  in.class = class;
+  in.sign = sign;
+  in.normal_exp = exp;
+  in.fraction.ll = frac;
+  return pack_d (&in);
+}
+#endif /* L_make_df */
+
+#if defined(L_df_to_sf)
+SFtype
+df_to_sf (DFtype arg_a)
+{
+  fp_number_type in;
+  USItype sffrac;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  sffrac = in.fraction.ll >> F_D_BITOFF;
+
+  /* We set the lowest guard bit in SFFRAC if we discarded any non
+     zero bits.  */
+  if ((in.fraction.ll & (((USItype) 1 << F_D_BITOFF) - 1)) != 0)
+    sffrac |= 1;
+
+  return __make_fp (in.class, in.sign, in.normal_exp, sffrac);
+}
+EXPORT_SYMBOL(df_to_sf);
+#endif /* L_df_to_sf */
+
+#if defined(L_df_to_tf) && defined(TMODES) \
+    && !defined(FLOAT) && !defined(TFLOAT)
+TFtype
+df_to_tf (DFtype arg_a)
+{
+  fp_number_type in;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  return __make_tp (in.class, in.sign, in.normal_exp,
+		    ((UTItype) in.fraction.ll) << D_T_BITOFF);
+}
+EXPORT_SYMBOL(df_to_tf);
+#endif /* L_sf_to_df */
+
+#ifdef TFLOAT
+#if defined(L_make_tf)
+TFtype
+__make_tp(fp_class_type class,
+	     unsigned int sign,
+	     int exp, 
+	     UTItype frac)
+{
+  fp_number_type in;
+
+  in.class = class;
+  in.sign = sign;
+  in.normal_exp = exp;
+  in.fraction.ll = frac;
+  return pack_d (&in);
+}
+#endif /* L_make_tf */
+
+#if defined(L_tf_to_df)
+DFtype
+tf_to_df (TFtype arg_a)
+{
+  fp_number_type in;
+  UDItype sffrac;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  sffrac = in.fraction.ll >> D_T_BITOFF;
+
+  /* We set the lowest guard bit in SFFRAC if we discarded any non
+     zero bits.  */
+  if ((in.fraction.ll & (((UTItype) 1 << D_T_BITOFF) - 1)) != 0)
+    sffrac |= 1;
+
+  return __make_dp (in.class, in.sign, in.normal_exp, sffrac);
+}
+EXPORT_SYMBOL(tf_to_df);
+#endif /* L_tf_to_df */
+
+#if defined(L_tf_to_sf)
+SFtype
+tf_to_sf (TFtype arg_a)
+{
+  fp_number_type in;
+  USItype sffrac;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  sffrac = in.fraction.ll >> F_T_BITOFF;
+
+  /* We set the lowest guard bit in SFFRAC if we discarded any non
+     zero bits.  */
+  if ((in.fraction.ll & (((UTItype) 1 << F_T_BITOFF) - 1)) != 0)
+    sffrac |= 1;
+
+  return __make_fp (in.class, in.sign, in.normal_exp, sffrac);
+}
+EXPORT_SYMBOL(tf_to_sf);
+#endif /* L_tf_to_sf */
+#endif /* TFLOAT */
+
+#endif /* ! FLOAT */
+#endif /* !EXTENDED_FLOAT_STUBS */
+
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/softfloat/fp-bit.c tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/fp-bit.c
--- linux-2.6.36/arch/mips/softfloat/fp-bit.c	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/fp-bit.c	2019-03-07 03:40:18.000000000 +0200
@@ -0,0 +1,1643 @@
+/* This is a software floating point library which can be used
+   for targets without hardware floating point. 
+   Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003
+   Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file with other programs, and to distribute
+those programs without any restriction coming from the use of this
+file.  (The General Public License restrictions do apply in other
+respects; for example, they cover modification of the file, and
+distribution when not linked into another program.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, if you link this library with other files,
+   some of which are compiled with GCC, to produce an executable,
+   this library does not by itself cause the resulting executable
+   to be covered by the GNU General Public License.
+   This exception does not however invalidate any other reasons why
+   the executable file might be covered by the GNU General Public License.  */
+
+/* This implements IEEE 754 format arithmetic, but does not provide a
+   mechanism for setting the rounding mode, or for generating or handling
+   exceptions.
+
+   The original code by Steve Chamberlain, hacked by Mark Eichin and Jim
+   Wilson, all of Cygnus Support.  */
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+/* The intended way to use this file is to make two copies, add `#define FLOAT'
+   to one copy, then compile both copies and add them to libgcc.a.  */
+#ifndef CONFIG_MIPS_TC3262
+#define US_SOFTWARE_GOFAST
+#endif
+#include "tconfig.h"
+#include "fp-bit.h"
+
+/* The following macros can be defined to change the behavior of this file:
+   FLOAT: Implement a `float', aka SFmode, fp library.  If this is not
+     defined, then this file implements a `double', aka DFmode, fp library.
+   FLOAT_ONLY: Used with FLOAT, to implement a `float' only library, i.e.
+     don't include float->double conversion which requires the double library.
+     This is useful only for machines which can't support doubles, e.g. some
+     8-bit processors.
+   CMPtype: Specify the type that floating point compares should return.
+     This defaults to SItype, aka int.
+   US_SOFTWARE_GOFAST: This makes all entry points use the same names as the
+     US Software goFast library.
+   _DEBUG_BITFLOAT: This makes debugging the code a little easier, by adding
+     two integers to the FLO_union_type.
+   NO_DENORMALS: Disable handling of denormals.
+   NO_NANS: Disable nan and infinity handling
+   SMALL_MACHINE: Useful when operations on QIs and HIs are faster
+     than on an SI */
+
+/* We don't currently support extended floats (long doubles) on machines
+   without hardware to deal with them.
+
+   These stubs are just to keep the linker from complaining about unresolved
+   references which can be pulled in from libio & libstdc++, even if the
+   user isn't using long doubles.  However, they may generate an unresolved
+   external to abort if abort is not used by the function, and the stubs
+   are referenced from within libc, since libgcc goes before and after the
+   system library.  */
+
+#ifdef DECLARE_LIBRARY_RENAMES
+  DECLARE_LIBRARY_RENAMES
+#endif
+
+#ifdef EXTENDED_FLOAT_STUBS
+extern void abort (void);
+void __extendsfxf2 (void) { abort(); }
+void __extenddfxf2 (void) { abort(); }
+void __truncxfdf2 (void) { abort(); }
+void __truncxfsf2 (void) { abort(); }
+void __fixxfsi (void) { abort(); }
+void __floatsixf (void) { abort(); }
+void __addxf3 (void) { abort(); }
+void __subxf3 (void) { abort(); }
+void __mulxf3 (void) { abort(); }
+void __divxf3 (void) { abort(); }
+void __negxf2 (void) { abort(); }
+void __eqxf2 (void) { abort(); }
+void __nexf2 (void) { abort(); }
+void __gtxf2 (void) { abort(); }
+void __gexf2 (void) { abort(); }
+void __lexf2 (void) { abort(); }
+void __ltxf2 (void) { abort(); }
+
+void __extendsftf2 (void) { abort(); }
+void __extenddftf2 (void) { abort(); }
+void __trunctfdf2 (void) { abort(); }
+void __trunctfsf2 (void) { abort(); }
+void __fixtfsi (void) { abort(); }
+void __floatsitf (void) { abort(); }
+void __addtf3 (void) { abort(); }
+void __subtf3 (void) { abort(); }
+void __multf3 (void) { abort(); }
+void __divtf3 (void) { abort(); }
+void __negtf2 (void) { abort(); }
+void __eqtf2 (void) { abort(); }
+void __netf2 (void) { abort(); }
+void __gttf2 (void) { abort(); }
+void __getf2 (void) { abort(); }
+void __letf2 (void) { abort(); }
+void __lttf2 (void) { abort(); }
+#else	/* !EXTENDED_FLOAT_STUBS, rest of file */
+
+/* IEEE "special" number predicates */
+
+#ifdef NO_NANS
+
+#define nan() 0
+#define isnan(x) 0
+#define isinf(x) 0
+#else
+
+#if   defined L_thenan_sf
+const fp_number_type __thenan_sf = { CLASS_SNAN, 0, 0, {(fractype) 0} };
+#elif defined L_thenan_df
+const fp_number_type __thenan_df = { CLASS_SNAN, 0, 0, {(fractype) 0} };
+#elif defined L_thenan_tf
+const fp_number_type __thenan_tf = { CLASS_SNAN, 0, 0, {(fractype) 0} };
+#elif defined TFLOAT
+extern const fp_number_type __thenan_tf;
+#elif defined FLOAT
+extern const fp_number_type __thenan_sf;
+#else
+extern const fp_number_type __thenan_df;
+#endif
+
+INLINE
+static fp_number_type *
+nan (void)
+{
+  /* Discard the const qualifier...  */
+#ifdef TFLOAT
+  return (fp_number_type *) (& __thenan_tf);
+#elif defined FLOAT  
+  return (fp_number_type *) (& __thenan_sf);
+#else
+  return (fp_number_type *) (& __thenan_df);
+#endif
+}
+
+INLINE
+static int
+isnan ( fp_number_type *  x)
+{
+  return x->class == CLASS_SNAN || x->class == CLASS_QNAN;
+}
+
+INLINE
+static int
+isinf ( fp_number_type *  x)
+{
+  return x->class == CLASS_INFINITY;
+}
+
+#endif /* NO_NANS */
+
+INLINE
+static int
+iszero ( fp_number_type *  x)
+{
+  return x->class == CLASS_ZERO;
+}
+
+INLINE 
+static void
+flip_sign ( fp_number_type *  x)
+{
+  x->sign = !x->sign;
+}
+
+extern FLO_type pack_d ( fp_number_type * );
+
+#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
+FLO_type
+pack_d ( fp_number_type *  src)
+{
+  FLO_union_type dst;
+  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
+  int sign = src->sign;
+  int exp = 0;
+
+  if (LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS) && (isnan (src) || isinf (src)))
+    {
+      /* We can't represent these values accurately.  By using the
+	 largest possible magnitude, we guarantee that the conversion
+	 of infinity is at least as big as any finite number.  */
+      exp = EXPMAX;
+      fraction = ((fractype) 1 << FRACBITS) - 1;
+    }
+  else if (isnan (src))
+    {
+      exp = EXPMAX;
+      if (src->class == CLASS_QNAN || 1)
+	{
+	  fraction |= QUIET_NAN;
+	}
+    }
+  else if (isinf (src))
+    {
+      exp = EXPMAX;
+      fraction = 0;
+    }
+  else if (iszero (src))
+    {
+      exp = 0;
+      fraction = 0;
+    }
+  else if (fraction == 0)
+    {
+      exp = 0;
+    }
+  else
+    {
+      if (src->normal_exp < NORMAL_EXPMIN)
+	{
+#ifdef NO_DENORMALS
+	  /* Go straight to a zero representation if denormals are not
+ 	     supported.  The denormal handling would be harmless but
+ 	     isn't unnecessary.  */
+	  exp = 0;
+	  fraction = 0;
+#else /* NO_DENORMALS */
+	  /* This number's exponent is too low to fit into the bits
+	     available in the number, so we'll store 0 in the exponent and
+	     shift the fraction to the right to make up for it.  */
+
+	  int shift = NORMAL_EXPMIN - src->normal_exp;
+
+	  exp = 0;
+
+	  if (shift > FRAC_NBITS - NGARDS)
+	    {
+	      /* No point shifting, since it's more that 64 out.  */
+	      fraction = 0;
+	    }
+	  else
+	    {
+	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
+	      fraction = (fraction >> shift) | lowbit;
+	    }
+	  if ((fraction & GARDMASK) == GARDMSB)
+	    {
+	      if ((fraction & (1 << NGARDS)))
+		fraction += GARDROUND + 1;
+	    }
+	  else
+	    {
+	      /* Add to the guards to round up.  */
+	      fraction += GARDROUND;
+	    }
+	  /* Perhaps the rounding means we now need to change the
+             exponent, because the fraction is no longer denormal.  */
+	  if (fraction >= IMPLICIT_1)
+	    {
+	      exp += 1;
+	    }
+	  fraction >>= NGARDS;
+#endif /* NO_DENORMALS */
+	}
+      else if (!LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS)
+	       && src->normal_exp > EXPBIAS)
+	{
+	  exp = EXPMAX;
+	  fraction = 0;
+	}
+      else
+	{
+	  exp = src->normal_exp + EXPBIAS;
+	  if (!ROUND_TOWARDS_ZERO)
+	    {
+	      /* IF the gard bits are the all zero, but the first, then we're
+		 half way between two numbers, choose the one which makes the
+		 lsb of the answer 0.  */
+	      if ((fraction & GARDMASK) == GARDMSB)
+		{
+		  if (fraction & (1 << NGARDS))
+		    fraction += GARDROUND + 1;
+		}
+	      else
+		{
+		  /* Add a one to the guards to round up */
+		  fraction += GARDROUND;
+		}
+	      if (fraction >= IMPLICIT_2)
+		{
+		  fraction >>= 1;
+		  exp += 1;
+		}
+	    }
+	  fraction >>= NGARDS;
+
+	  if (LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS) && exp > EXPMAX)
+	    {
+	      /* Saturate on overflow.  */
+	      exp = EXPMAX;
+	      fraction = ((fractype) 1 << FRACBITS) - 1;
+	    }
+	}
+    }
+
+  /* We previously used bitfields to store the number, but this doesn't
+     handle little/big endian systems conveniently, so use shifts and
+     masks */
+#ifdef FLOAT_BIT_ORDER_MISMATCH
+  dst.bits.fraction = fraction;
+  dst.bits.exp = exp;
+  dst.bits.sign = sign;
+#else
+# if defined TFLOAT && defined HALFFRACBITS
+ {
+   halffractype high, low;
+
+   high = (fraction >> (FRACBITS - HALFFRACBITS));
+   high &= (((fractype)1) << HALFFRACBITS) - 1;
+   high |= ((fractype) (exp & ((1 << EXPBITS) - 1))) << HALFFRACBITS;
+   high |= ((fractype) (sign & 1)) << (HALFFRACBITS | EXPBITS);
+
+   low = (halffractype)fraction &
+     ((((halffractype)1) << (FRACBITS - HALFFRACBITS)) - 1);
+
+   if (exp == EXPMAX || exp == 0 || low == 0)
+     low = 0;
+   else
+     {
+       exp -= HALFFRACBITS + 1;
+
+       while (exp > 0
+	      && low < ((halffractype)1 << HALFFRACBITS))
+	 {
+	   low <<= 1;
+	   exp--;
+	 }
+
+       if (exp <= 0)
+	 {
+	   halffractype roundmsb, round;
+
+	   exp = -exp + 1;
+
+	   roundmsb = (1 << (exp - 1));
+	   round = low & ((roundmsb << 1) - 1);
+
+	   low >>= exp;
+	   exp = 0;
+
+	   if (round > roundmsb || (round == roundmsb && (low & 1)))
+	     {
+	       low++;
+	       if (low >= ((halffractype)1 << HALFFRACBITS))
+		 /* We don't shift left, since it has just become the
+		    smallest normal number, whose implicit 1 bit is
+		    now indicated by the non-zero exponent.  */
+		 exp++;
+	     }
+	 }
+
+       low &= ((halffractype)1 << HALFFRACBITS) - 1;
+       low |= ((fractype) (exp & ((1 << EXPBITS) - 1))) << HALFFRACBITS;
+       low |= ((fractype) (sign & 1)) << (HALFFRACBITS | EXPBITS);
+     }
+
+   dst.value_raw = (((fractype) high) << HALFSHIFT) | low;
+ }
+# else
+  dst.value_raw = fraction & ((((fractype)1) << FRACBITS) - (fractype)1);
+  dst.value_raw |= ((fractype) (exp & ((1 << EXPBITS) - 1))) << FRACBITS;
+  dst.value_raw |= ((fractype) (sign & 1)) << (FRACBITS | EXPBITS);
+# endif
+#endif
+
+#if defined(FLOAT_WORD_ORDER_MISMATCH) && !defined(FLOAT)
+#ifdef TFLOAT
+  {
+    qrtrfractype tmp1 = dst.words[0];
+    qrtrfractype tmp2 = dst.words[1];
+    dst.words[0] = dst.words[3];
+    dst.words[1] = dst.words[2];
+    dst.words[2] = tmp2;
+    dst.words[3] = tmp1;
+  }
+#else
+  {
+    halffractype tmp = dst.words[0];
+    dst.words[0] = dst.words[1];
+    dst.words[1] = tmp;
+  }
+#endif
+#endif
+
+  return dst.value;
+}
+#endif
+
+#if defined(L_unpack_df) || defined(L_unpack_sf) || defined(L_unpack_tf)
+void
+unpack_d (FLO_union_type * src, fp_number_type * dst)
+{
+  /* We previously used bitfields to store the number, but this doesn't
+     handle little/big endian systems conveniently, so use shifts and
+     masks */
+  fractype fraction;
+  int exp;
+  int sign;
+
+#if defined(FLOAT_WORD_ORDER_MISMATCH) && !defined(FLOAT)
+  FLO_union_type swapped;
+
+#ifdef TFLOAT
+  swapped.words[0] = src->words[3];
+  swapped.words[1] = src->words[2];
+  swapped.words[2] = src->words[1];
+  swapped.words[3] = src->words[0];
+#else
+  swapped.words[0] = src->words[1];
+  swapped.words[1] = src->words[0];
+#endif
+  src = &swapped;
+#endif
+  
+#ifdef FLOAT_BIT_ORDER_MISMATCH
+  fraction = src->bits.fraction;
+  exp = src->bits.exp;
+  sign = src->bits.sign;
+#else
+# if defined TFLOAT && defined HALFFRACBITS
+ {
+   halffractype high, low;
+   
+   high = src->value_raw >> HALFSHIFT;
+   low = src->value_raw & (((fractype)1 << HALFSHIFT) - 1);
+
+   fraction = high & ((((fractype)1) << HALFFRACBITS) - 1);
+   fraction <<= FRACBITS - HALFFRACBITS;
+   exp = ((int)(high >> HALFFRACBITS)) & ((1 << EXPBITS) - 1);
+   sign = ((int)(high >> (((HALFFRACBITS + EXPBITS))))) & 1;
+
+   if (exp != EXPMAX && exp != 0 && low != 0)
+     {
+       int lowexp = ((int)(low >> HALFFRACBITS)) & ((1 << EXPBITS) - 1);
+       int lowsign = ((int)(low >> (((HALFFRACBITS + EXPBITS))))) & 1;
+       int shift;
+       fractype xlow;
+
+       xlow = low & ((((fractype)1) << HALFFRACBITS) - 1);
+       if (lowexp)
+	 xlow |= (((halffractype)1) << HALFFRACBITS);
+       else
+	 lowexp = 1;
+       shift = (FRACBITS - HALFFRACBITS) - (exp - lowexp);
+       if (shift > 0)
+	 xlow <<= shift;
+       else if (shift < 0)
+	 xlow >>= -shift;
+       if (sign == lowsign)
+	 fraction += xlow;
+       else
+	 fraction -= xlow;
+     }
+ }
+# else
+  fraction = src->value_raw & ((((fractype)1) << FRACBITS) - 1);
+  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
+  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
+# endif
+#endif
+
+  dst->sign = sign;
+  if (exp == 0)
+    {
+      /* Hmm.  Looks like 0 */
+      if (fraction == 0
+#ifdef NO_DENORMALS
+	  || 1
+#endif
+	  )
+	{
+	  /* tastes like zero */
+	  dst->class = CLASS_ZERO;
+	}
+      else
+	{
+	  /* Zero exponent with nonzero fraction - it's denormalized,
+	     so there isn't a leading implicit one - we'll shift it so
+	     it gets one.  */
+	  dst->normal_exp = exp - EXPBIAS + 1;
+	  fraction <<= NGARDS;
+
+	  dst->class = CLASS_NUMBER;
+#if 1
+	  while (fraction < IMPLICIT_1)
+	    {
+	      fraction <<= 1;
+	      dst->normal_exp--;
+	    }
+#endif
+	  dst->fraction.ll = fraction;
+	}
+    }
+  else if (!LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS) && exp == EXPMAX)
+    {
+      /* Huge exponent*/
+      if (fraction == 0)
+	{
+	  /* Attached to a zero fraction - means infinity */
+	  dst->class = CLASS_INFINITY;
+	}
+      else
+	{
+	  /* Nonzero fraction, means nan */
+	  if (fraction & QUIET_NAN)
+	    {
+	      dst->class = CLASS_QNAN;
+	    }
+	  else
+	    {
+	      dst->class = CLASS_SNAN;
+	    }
+	  /* Keep the fraction part as the nan number */
+	  dst->fraction.ll = fraction;
+	}
+    }
+  else
+    {
+      /* Nothing strange about this number */
+      dst->normal_exp = exp - EXPBIAS;
+      dst->class = CLASS_NUMBER;
+      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
+    }
+}
+#endif /* L_unpack_df || L_unpack_sf */
+
+#if defined(L_addsub_sf) || defined(L_addsub_df) || defined(L_addsub_tf)
+static fp_number_type *
+_fpadd_parts (fp_number_type * a,
+	      fp_number_type * b,
+	      fp_number_type * tmp)
+{
+  intfrac tfraction;
+
+  /* Put commonly used fields in local variables.  */
+  int a_normal_exp;
+  int b_normal_exp;
+  fractype a_fraction;
+  fractype b_fraction;
+
+  if (isnan (a))
+    {
+      return a;
+    }
+  if (isnan (b))
+    {
+      return b;
+    }
+  if (isinf (a))
+    {
+      /* Adding infinities with opposite signs yields a NaN.  */
+      if (isinf (b) && a->sign != b->sign)
+	return nan ();
+      return a;
+    }
+  if (isinf (b))
+    {
+      return b;
+    }
+  if (iszero (b))
+    {
+      if (iszero (a))
+	{
+	  *tmp = *a;
+	  tmp->sign = a->sign & b->sign;
+	  return tmp;
+	}
+      return a;
+    }
+  if (iszero (a))
+    {
+      return b;
+    }
+
+  /* Got two numbers. shift the smaller and increment the exponent till
+     they're the same */
+  {
+    int diff;
+
+    a_normal_exp = a->normal_exp;
+    b_normal_exp = b->normal_exp;
+    a_fraction = a->fraction.ll;
+    b_fraction = b->fraction.ll;
+
+    diff = a_normal_exp - b_normal_exp;
+
+    if (diff < 0)
+      diff = -diff;
+    if (diff < FRAC_NBITS)
+      {
+	/* ??? This does shifts one bit at a time.  Optimize.  */
+	while (a_normal_exp > b_normal_exp)
+	  {
+	    b_normal_exp++;
+	    LSHIFT (b_fraction);
+	  }
+	while (b_normal_exp > a_normal_exp)
+	  {
+	    a_normal_exp++;
+	    LSHIFT (a_fraction);
+	  }
+      }
+    else
+      {
+	/* Somethings's up.. choose the biggest */
+	if (a_normal_exp > b_normal_exp)
+	  {
+	    b_normal_exp = a_normal_exp;
+	    b_fraction = 0;
+	  }
+	else
+	  {
+	    a_normal_exp = b_normal_exp;
+	    a_fraction = 0;
+	  }
+      }
+  }
+
+  if (a->sign != b->sign)
+    {
+      if (a->sign)
+	{
+	  tfraction = -a_fraction + b_fraction;
+	}
+      else
+	{
+	  tfraction = a_fraction - b_fraction;
+	}
+      if (tfraction >= 0)
+	{
+	  tmp->sign = 0;
+	  tmp->normal_exp = a_normal_exp;
+	  tmp->fraction.ll = tfraction;
+	}
+      else
+	{
+	  tmp->sign = 1;
+	  tmp->normal_exp = a_normal_exp;
+	  tmp->fraction.ll = -tfraction;
+	}
+      /* and renormalize it */
+
+      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
+	{
+	  tmp->fraction.ll <<= 1;
+	  tmp->normal_exp--;
+	}
+    }
+  else
+    {
+      tmp->sign = a->sign;
+      tmp->normal_exp = a_normal_exp;
+      tmp->fraction.ll = a_fraction + b_fraction;
+    }
+  tmp->class = CLASS_NUMBER;
+  /* Now the fraction is added, we have to shift down to renormalize the
+     number */
+
+  if (tmp->fraction.ll >= IMPLICIT_2)
+    {
+      LSHIFT (tmp->fraction.ll);
+      tmp->normal_exp++;
+    }
+  return tmp;
+
+}
+
+FLO_type
+add (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  fp_number_type tmp;
+  fp_number_type *res;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  res = _fpadd_parts (&a, &b, &tmp);
+
+  return pack_d (res);
+}
+EXPORT_SYMBOL(add);
+
+FLO_type
+sub (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  fp_number_type tmp;
+  fp_number_type *res;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  b.sign ^= 1;
+
+  res = _fpadd_parts (&a, &b, &tmp);
+
+  return pack_d (res);
+}
+EXPORT_SYMBOL(sub);
+#endif /* L_addsub_sf || L_addsub_df */
+
+#if defined(L_mul_sf) || defined(L_mul_df) || defined(L_mul_tf)
+static inline __attribute__ ((__always_inline__)) fp_number_type *
+_fpmul_parts ( fp_number_type *  a,
+	       fp_number_type *  b,
+	       fp_number_type * tmp)
+{
+  fractype low = 0;
+  fractype high = 0;
+
+  if (isnan (a))
+    {
+      a->sign = a->sign != b->sign;
+      return a;
+    }
+  if (isnan (b))
+    {
+      b->sign = a->sign != b->sign;
+      return b;
+    }
+  if (isinf (a))
+    {
+      if (iszero (b))
+	return nan ();
+      a->sign = a->sign != b->sign;
+      return a;
+    }
+  if (isinf (b))
+    {
+      if (iszero (a))
+	{
+	  return nan ();
+	}
+      b->sign = a->sign != b->sign;
+      return b;
+    }
+  if (iszero (a))
+    {
+      a->sign = a->sign != b->sign;
+      return a;
+    }
+  if (iszero (b))
+    {
+      b->sign = a->sign != b->sign;
+      return b;
+    }
+
+  /* Calculate the mantissa by multiplying both numbers to get a
+     twice-as-wide number.  */
+  {
+#if defined(NO_DI_MODE) || defined(TFLOAT)
+    {
+      fractype x = a->fraction.ll;
+      fractype ylow = b->fraction.ll;
+      fractype yhigh = 0;
+      int bit;
+
+      /* ??? This does multiplies one bit at a time.  Optimize.  */
+      for (bit = 0; bit < FRAC_NBITS; bit++)
+	{
+	  int carry;
+
+	  if (x & 1)
+	    {
+	      carry = (low += ylow) < ylow;
+	      high += yhigh + carry;
+	    }
+	  yhigh <<= 1;
+	  if (ylow & FRACHIGH)
+	    {
+	      yhigh |= 1;
+	    }
+	  ylow <<= 1;
+	  x >>= 1;
+	}
+    }
+#elif defined(FLOAT) 
+    /* Multiplying two USIs to get a UDI, we're safe.  */
+    {
+      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
+      
+      high = answer >> BITS_PER_SI;
+      low = answer;
+    }
+#else
+    /* fractype is DImode, but we need the result to be twice as wide.
+       Assuming a widening multiply from DImode to TImode is not
+       available, build one by hand.  */
+    {
+      USItype nl = a->fraction.ll;
+      USItype nh = a->fraction.ll >> BITS_PER_SI;
+      USItype ml = b->fraction.ll;
+      USItype mh = b->fraction.ll >> BITS_PER_SI;
+      UDItype pp_ll = (UDItype) ml * nl;
+      UDItype pp_hl = (UDItype) mh * nl;
+      UDItype pp_lh = (UDItype) ml * nh;
+      UDItype pp_hh = (UDItype) mh * nh;
+      UDItype res2 = 0;
+      UDItype res0 = 0;
+      UDItype ps_hh__ = pp_hl + pp_lh;
+      if (ps_hh__ < pp_hl)
+	res2 += (UDItype)1 << BITS_PER_SI;
+      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
+      res0 = pp_ll + pp_hl;
+      if (res0 < pp_ll)
+	res2++;
+      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
+      high = res2;
+      low = res0;
+    }
+#endif
+  }
+
+  tmp->normal_exp = a->normal_exp + b->normal_exp
+    + FRAC_NBITS - (FRACBITS + NGARDS);
+  tmp->sign = a->sign != b->sign;
+  while (high >= IMPLICIT_2)
+    {
+      tmp->normal_exp++;
+      if (high & 1)
+	{
+	  low >>= 1;
+	  low |= FRACHIGH;
+	}
+      high >>= 1;
+    }
+  while (high < IMPLICIT_1)
+    {
+      tmp->normal_exp--;
+
+      high <<= 1;
+      if (low & FRACHIGH)
+	high |= 1;
+      low <<= 1;
+    }
+  /* rounding is tricky. if we only round if it won't make us round later.  */
+#if 0
+  if (low & FRACHIGH2)
+    {
+      if (((high & GARDMASK) != GARDMSB)
+	  && (((high + 1) & GARDMASK) == GARDMSB))
+	{
+	  /* don't round, it gets done again later.  */
+	}
+      else
+	{
+	  high++;
+	}
+    }
+#endif
+  if (!ROUND_TOWARDS_ZERO && (high & GARDMASK) == GARDMSB)
+    {
+      if (high & (1 << NGARDS))
+	{
+	  /* half way, so round to even */
+	  high += GARDROUND + 1;
+	}
+      else if (low)
+	{
+	  /* but we really weren't half way */
+	  high += GARDROUND + 1;
+	}
+    }
+  tmp->fraction.ll = high;
+  tmp->class = CLASS_NUMBER;
+  return tmp;
+}
+
+FLO_type
+multiply (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  fp_number_type tmp;
+  fp_number_type *res;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  res = _fpmul_parts (&a, &b, &tmp);
+
+  return pack_d (res);
+}
+EXPORT_SYMBOL(multiply);
+#endif /* L_mul_sf || L_mul_df */
+
+#if defined(L_div_sf) || defined(L_div_df) || defined(L_div_tf)
+static inline __attribute__ ((__always_inline__)) fp_number_type *
+_fpdiv_parts (fp_number_type * a,
+	      fp_number_type * b)
+{
+  fractype bit;
+  fractype numerator;
+  fractype denominator;
+  fractype quotient;
+
+  if (isnan (a))
+    {
+      return a;
+    }
+  if (isnan (b))
+    {
+      return b;
+    }
+
+  a->sign = a->sign ^ b->sign;
+
+  if (isinf (a) || iszero (a))
+    {
+      if (a->class == b->class)
+	return nan ();
+      return a;
+    }
+
+  if (isinf (b))
+    {
+      a->fraction.ll = 0;
+      a->normal_exp = 0;
+      return a;
+    }
+  if (iszero (b))
+    {
+      a->class = CLASS_INFINITY;
+      return a;
+    }
+
+  /* Calculate the mantissa by multiplying both 64bit numbers to get a
+     128 bit number */
+  {
+    /* quotient =
+       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
+     */
+
+    a->normal_exp = a->normal_exp - b->normal_exp;
+    numerator = a->fraction.ll;
+    denominator = b->fraction.ll;
+
+    if (numerator < denominator)
+      {
+	/* Fraction will be less than 1.0 */
+	numerator *= 2;
+	a->normal_exp--;
+      }
+    bit = IMPLICIT_1;
+    quotient = 0;
+    /* ??? Does divide one bit at a time.  Optimize.  */
+    while (bit)
+      {
+	if (numerator >= denominator)
+	  {
+	    quotient |= bit;
+	    numerator -= denominator;
+	  }
+	bit >>= 1;
+	numerator *= 2;
+      }
+
+    if (!ROUND_TOWARDS_ZERO && (quotient & GARDMASK) == GARDMSB)
+      {
+	if (quotient & (1 << NGARDS))
+	  {
+	    /* half way, so round to even */
+	    quotient += GARDROUND + 1;
+	  }
+	else if (numerator)
+	  {
+	    /* but we really weren't half way, more bits exist */
+	    quotient += GARDROUND + 1;
+	  }
+      }
+
+    a->fraction.ll = quotient;
+    return (a);
+  }
+}
+
+FLO_type
+divide (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  fp_number_type *res;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  res = _fpdiv_parts (&a, &b);
+
+  return pack_d (res);
+}
+EXPORT_SYMBOL(divide);
+#endif /* L_div_sf || L_div_df */
+
+#if defined(L_fpcmp_parts_sf) || defined(L_fpcmp_parts_df) \
+    || defined(L_fpcmp_parts_tf)
+/* according to the demo, fpcmp returns a comparison with 0... thus
+   a<b -> -1
+   a==b -> 0
+   a>b -> +1
+ */
+
+int
+__fpcmp_parts (fp_number_type * a, fp_number_type * b)
+{
+#if 0
+  /* either nan -> unordered. Must be checked outside of this routine.  */
+  if (isnan (a) && isnan (b))
+    {
+      return 1;			/* still unordered! */
+    }
+#endif
+
+  if (isnan (a) || isnan (b))
+    {
+      return 1;			/* how to indicate unordered compare? */
+    }
+  if (isinf (a) && isinf (b))
+    {
+      /* +inf > -inf, but +inf != +inf */
+      /* b    \a| +inf(0)| -inf(1)
+       ______\+--------+--------
+       +inf(0)| a==b(0)| a<b(-1)
+       -------+--------+--------
+       -inf(1)| a>b(1) | a==b(0)
+       -------+--------+--------
+       So since unordered must be nonzero, just line up the columns...
+       */
+      return b->sign - a->sign;
+    }
+  /* but not both...  */
+  if (isinf (a))
+    {
+      return a->sign ? -1 : 1;
+    }
+  if (isinf (b))
+    {
+      return b->sign ? 1 : -1;
+    }
+  if (iszero (a) && iszero (b))
+    {
+      return 0;
+    }
+  if (iszero (a))
+    {
+      return b->sign ? 1 : -1;
+    }
+  if (iszero (b))
+    {
+      return a->sign ? -1 : 1;
+    }
+  /* now both are "normal".  */
+  if (a->sign != b->sign)
+    {
+      /* opposite signs */
+      return a->sign ? -1 : 1;
+    }
+  /* same sign; exponents? */
+  if (a->normal_exp > b->normal_exp)
+    {
+      return a->sign ? -1 : 1;
+    }
+  if (a->normal_exp < b->normal_exp)
+    {
+      return a->sign ? 1 : -1;
+    }
+  /* same exponents; check size.  */
+  if (a->fraction.ll > b->fraction.ll)
+    {
+      return a->sign ? -1 : 1;
+    }
+  if (a->fraction.ll < b->fraction.ll)
+    {
+      return a->sign ? 1 : -1;
+    }
+  /* after all that, they're equal.  */
+  return 0;
+}
+#endif
+
+#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
+CMPtype
+compare (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  return __fpcmp_parts (&a, &b);
+}
+EXPORT_SYMBOL(compare);
+#endif /* L_compare_sf || L_compare_df */
+
+#ifndef US_SOFTWARE_GOFAST
+
+/* These should be optimized for their specific tasks someday.  */
+
+#if defined(L_eq_sf) || defined(L_eq_df) || defined(L_eq_tf)
+CMPtype
+_eq_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return 1;			/* false, truth == 0 */
+
+  return __fpcmp_parts (&a, &b) ;
+}
+EXPORT_SYMBOL(_eq_f2);
+#endif /* L_eq_sf || L_eq_df */
+
+#if defined(L_ne_sf) || defined(L_ne_df) || defined(L_ne_tf)
+CMPtype
+_ne_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return 1;			/* true, truth != 0 */
+
+  return  __fpcmp_parts (&a, &b) ;
+}
+EXPORT_SYMBOL(_ne_f2);
+#endif /* L_ne_sf || L_ne_df */
+
+#if defined(L_gt_sf) || defined(L_gt_df) || defined(L_gt_tf)
+CMPtype
+_gt_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return -1;			/* false, truth > 0 */
+
+  return __fpcmp_parts (&a, &b);
+}
+EXPORT_SYMBOL(_gt_f2);
+#endif /* L_gt_sf || L_gt_df */
+
+#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
+CMPtype
+_ge_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return -1;			/* false, truth >= 0 */
+  return __fpcmp_parts (&a, &b) ;
+}
+EXPORT_SYMBOL(_ge_f2);
+#endif /* L_ge_sf || L_ge_df */
+
+#if defined(L_lt_sf) || defined(L_lt_df) || defined(L_lt_tf)
+CMPtype
+_lt_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return 1;			/* false, truth < 0 */
+
+  return __fpcmp_parts (&a, &b);
+}
+EXPORT_SYMBOL(_lt_f2);
+#endif /* L_lt_sf || L_lt_df */
+
+#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
+CMPtype
+_le_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return 1;			/* false, truth <= 0 */
+
+  return __fpcmp_parts (&a, &b) ;
+}
+EXPORT_SYMBOL(_le_f2);
+#endif /* L_le_sf || L_le_df */
+
+#endif /* ! US_SOFTWARE_GOFAST */
+
+#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
+CMPtype
+_unord_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  return (isnan (&a) || isnan (&b));
+}
+EXPORT_SYMBOL(_unord_f2);
+#endif /* L_unord_sf || L_unord_df */
+
+#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
+FLO_type
+si_to_float (SItype arg_a)
+{
+  fp_number_type in;
+
+  in.class = CLASS_NUMBER;
+  in.sign = arg_a < 0;
+  if (!arg_a)
+    {
+      in.class = CLASS_ZERO;
+    }
+  else
+    {
+      in.normal_exp = FRACBITS + NGARDS;
+      if (in.sign) 
+	{
+	  /* Special case for minint, since there is no +ve integer
+	     representation for it */
+	  if (arg_a == (- MAX_SI_INT - 1))
+	    {
+	      return (FLO_type)(- MAX_SI_INT - 1);
+	    }
+	  in.fraction.ll = (-arg_a);
+	}
+      else
+	in.fraction.ll = arg_a;
+
+      while (in.fraction.ll < ((fractype)1 << (FRACBITS + NGARDS)))
+	{
+	  in.fraction.ll <<= 1;
+	  in.normal_exp -= 1;
+	}
+    }
+  return pack_d (&in);
+}
+EXPORT_SYMBOL(si_to_float);
+#endif /* L_si_to_sf || L_si_to_df */
+
+#if defined(L_usi_to_sf) || defined(L_usi_to_df) || defined(L_usi_to_tf)
+FLO_type
+usi_to_float (USItype arg_a)
+{
+  fp_number_type in;
+
+  in.sign = 0;
+  if (!arg_a)
+    {
+      in.class = CLASS_ZERO;
+    }
+  else
+    {
+      in.class = CLASS_NUMBER;
+      in.normal_exp = FRACBITS + NGARDS;
+      in.fraction.ll = arg_a;
+
+      while (in.fraction.ll > ((fractype)1 << (FRACBITS + NGARDS)))
+        {
+          in.fraction.ll >>= 1;
+          in.normal_exp += 1;
+        }
+      while (in.fraction.ll < ((fractype)1 << (FRACBITS + NGARDS)))
+	{
+	  in.fraction.ll <<= 1;
+	  in.normal_exp -= 1;
+	}
+    }
+  return pack_d (&in);
+}
+EXPORT_SYMBOL(usi_to_float);
+#endif
+
+#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
+SItype
+float_to_si (FLO_type arg_a)
+{
+  fp_number_type a;
+  SItype tmp;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &a);
+
+  if (iszero (&a))
+    return 0;
+  if (isnan (&a))
+    return 0;
+  /* get reasonable MAX_SI_INT...  */
+  if (isinf (&a))
+    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
+  /* it is a number, but a small one */
+  if (a.normal_exp < 0)
+    return 0;
+  if (a.normal_exp > BITS_PER_SI - 2)
+    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
+  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
+  return a.sign ? (-tmp) : (tmp);
+}
+EXPORT_SYMBOL(float_to_si);
+#endif /* L_sf_to_si || L_df_to_si */
+
+#if defined(L_sf_to_usi) || defined(L_df_to_usi) || defined(L_tf_to_usi)
+#if defined US_SOFTWARE_GOFAST || defined(L_tf_to_usi)
+/* While libgcc2.c defines its own __fixunssfsi and __fixunsdfsi routines,
+   we also define them for GOFAST because the ones in libgcc2.c have the
+   wrong names and I'd rather define these here and keep GOFAST CYG-LOC's
+   out of libgcc2.c.  We can't define these here if not GOFAST because then
+   there'd be duplicate copies.  */
+
+USItype
+float_to_usi (FLO_type arg_a)
+{
+  fp_number_type a;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &a);
+
+  if (iszero (&a))
+    return 0;
+  if (isnan (&a))
+    return 0;
+  /* it is a negative number */
+  if (a.sign)
+    return 0;
+  /* get reasonable MAX_USI_INT...  */
+  if (isinf (&a))
+    return MAX_USI_INT;
+  /* it is a number, but a small one */
+  if (a.normal_exp < 0)
+    return 0;
+  if (a.normal_exp > BITS_PER_SI - 1)
+    return MAX_USI_INT;
+  else if (a.normal_exp > (FRACBITS + NGARDS))
+    return a.fraction.ll << (a.normal_exp - (FRACBITS + NGARDS));
+  else
+    return a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
+}
+EXPORT_SYMBOL(float_to_usi);
+#endif /* US_SOFTWARE_GOFAST */
+#endif /* L_sf_to_usi || L_df_to_usi */
+
+#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
+FLO_type
+negate (FLO_type arg_a)
+{
+  fp_number_type a;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &a);
+
+  flip_sign (&a);
+  return pack_d (&a);
+}
+EXPORT_SYMBOL(negate);
+#endif /* L_negate_sf || L_negate_df */
+
+#ifdef FLOAT
+
+#if defined(L_make_sf)
+SFtype
+__make_fp(fp_class_type class,
+	     unsigned int sign,
+	     int exp, 
+	     USItype frac)
+{
+  fp_number_type in;
+
+  in.class = class;
+  in.sign = sign;
+  in.normal_exp = exp;
+  in.fraction.ll = frac;
+  return pack_d (&in);
+}
+#endif /* L_make_sf */
+
+#ifndef FLOAT_ONLY
+
+/* This enables one to build an fp library that supports float but not double.
+   Otherwise, we would get an undefined reference to __make_dp.
+   This is needed for some 8-bit ports that can't handle well values that
+   are 8-bytes in size, so we just don't support double for them at all.  */
+
+#if defined(L_sf_to_df)
+DFtype
+sf_to_df (SFtype arg_a)
+{
+  fp_number_type in;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  return __make_dp (in.class, in.sign, in.normal_exp,
+		    ((UDItype) in.fraction.ll) << F_D_BITOFF);
+}
+EXPORT_SYMBOL(sf_to_df);
+#endif /* L_sf_to_df */
+
+#if defined(L_sf_to_tf) && defined(TMODES)
+TFtype
+sf_to_tf (SFtype arg_a)
+{
+  fp_number_type in;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  return __make_tp (in.class, in.sign, in.normal_exp,
+		    ((UTItype) in.fraction.ll) << F_T_BITOFF);
+}
+EXPORT_SYMBOL(sf_to_tf);
+#endif /* L_sf_to_df */
+
+#endif /* ! FLOAT_ONLY */
+#endif /* FLOAT */
+
+#ifndef FLOAT
+
+extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);
+
+#if defined(L_make_df)
+DFtype
+__make_dp (fp_class_type class, unsigned int sign, int exp, UDItype frac)
+{
+  fp_number_type in;
+
+  in.class = class;
+  in.sign = sign;
+  in.normal_exp = exp;
+  in.fraction.ll = frac;
+  return pack_d (&in);
+}
+#endif /* L_make_df */
+
+#if defined(L_df_to_sf)
+SFtype
+df_to_sf (DFtype arg_a)
+{
+  fp_number_type in;
+  USItype sffrac;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  sffrac = in.fraction.ll >> F_D_BITOFF;
+
+  /* We set the lowest guard bit in SFFRAC if we discarded any non
+     zero bits.  */
+  if ((in.fraction.ll & (((USItype) 1 << F_D_BITOFF) - 1)) != 0)
+    sffrac |= 1;
+
+  return __make_fp (in.class, in.sign, in.normal_exp, sffrac);
+}
+EXPORT_SYMBOL(df_to_sf);
+#endif /* L_df_to_sf */
+
+#if defined(L_df_to_tf) && defined(TMODES) \
+    && !defined(FLOAT) && !defined(TFLOAT)
+TFtype
+df_to_tf (DFtype arg_a)
+{
+  fp_number_type in;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  return __make_tp (in.class, in.sign, in.normal_exp,
+		    ((UTItype) in.fraction.ll) << D_T_BITOFF);
+}
+EXPORT_SYMBOL(df_to_tf);
+#endif /* L_sf_to_df */
+
+#ifdef TFLOAT
+#if defined(L_make_tf)
+TFtype
+__make_tp(fp_class_type class,
+	     unsigned int sign,
+	     int exp, 
+	     UTItype frac)
+{
+  fp_number_type in;
+
+  in.class = class;
+  in.sign = sign;
+  in.normal_exp = exp;
+  in.fraction.ll = frac;
+  return pack_d (&in);
+}
+#endif /* L_make_tf */
+
+#if defined(L_tf_to_df)
+DFtype
+tf_to_df (TFtype arg_a)
+{
+  fp_number_type in;
+  UDItype sffrac;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  sffrac = in.fraction.ll >> D_T_BITOFF;
+
+  /* We set the lowest guard bit in SFFRAC if we discarded any non
+     zero bits.  */
+  if ((in.fraction.ll & (((UTItype) 1 << D_T_BITOFF) - 1)) != 0)
+    sffrac |= 1;
+
+  return __make_dp (in.class, in.sign, in.normal_exp, sffrac);
+}
+EXPORT_SYMBOL(tf_to_df);
+#endif /* L_tf_to_df */
+
+#if defined(L_tf_to_sf)
+SFtype
+tf_to_sf (TFtype arg_a)
+{
+  fp_number_type in;
+  USItype sffrac;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  sffrac = in.fraction.ll >> F_T_BITOFF;
+
+  /* We set the lowest guard bit in SFFRAC if we discarded any non
+     zero bits.  */
+  if ((in.fraction.ll & (((UTItype) 1 << F_T_BITOFF) - 1)) != 0)
+    sffrac |= 1;
+
+  return __make_fp (in.class, in.sign, in.normal_exp, sffrac);
+}
+EXPORT_SYMBOL(tf_to_sf);
+#endif /* L_tf_to_sf */
+#endif /* TFLOAT */
+
+#endif /* ! FLOAT */
+#endif /* !EXTENDED_FLOAT_STUBS */
+
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/softfloat/fp-bit.h tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/fp-bit.h
--- linux-2.6.36/arch/mips/softfloat/fp-bit.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/fp-bit.h	2019-03-07 03:40:18.000000000 +0200
@@ -0,0 +1,539 @@
+/* Header file for fp-bit.c.  */
+/* Copyright (C) 2000, 2002, 2003
+   Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, if you link this library with other files,
+   some of which are compiled with GCC, to produce an executable,
+   this library does not by itself cause the resulting executable
+   to be covered by the GNU General Public License.
+   This exception does not however invalidate any other reasons why
+   the executable file might be covered by the GNU General Public License.  */
+
+#ifndef GCC_FP_BIT_H
+#define GCC_FP_BIT_H
+
+/* Defining FINE_GRAINED_LIBRARIES allows one to select which routines
+   from this file are compiled via additional -D options.
+
+   This avoids the need to pull in the entire fp emulation library
+   when only a small number of functions are needed.
+
+   If FINE_GRAINED_LIBRARIES is not defined, then compile every
+   suitable routine.  */
+#ifndef FINE_GRAINED_LIBRARIES
+#define L_pack_df
+#define L_unpack_df
+#define L_pack_sf
+#define L_unpack_sf
+#define L_addsub_sf
+#define L_addsub_df
+#define L_mul_sf
+#define L_mul_df
+#define L_div_sf
+#define L_div_df
+#define L_fpcmp_parts_sf
+#define L_fpcmp_parts_df
+#define L_compare_sf
+#define L_compare_df
+#define L_eq_sf
+#define L_eq_df
+#define L_ne_sf
+#define L_ne_df
+#define L_gt_sf
+#define L_gt_df
+#define L_ge_sf
+#define L_ge_df
+#define L_lt_sf
+#define L_lt_df
+#define L_le_sf
+#define L_le_df
+#define L_unord_sf
+#define L_unord_df
+#define L_usi_to_sf
+#define L_usi_to_df
+#define L_si_to_sf
+#define L_si_to_df
+#define L_sf_to_si
+#define L_df_to_si
+#define L_f_to_usi
+#define L_df_to_usi
+#define L_negate_sf
+#define L_negate_df
+#define L_make_sf
+#define L_make_df
+#define L_sf_to_df
+#define L_df_to_sf
+#ifdef FLOAT
+#define L_thenan_sf
+#else
+#define L_thenan_df
+#endif
+#endif /* ! FINE_GRAINED_LIBRARIES */
+
+#if __LDBL_MANT_DIG__ == 113 || __LDBL_MANT_DIG__ == 106
+# define TMODES
+#endif
+
+typedef float SFtype __attribute__ ((mode (SF)));
+typedef float DFtype __attribute__ ((mode (DF)));
+#ifdef TMODES
+typedef float TFtype __attribute__ ((mode (TF)));
+#endif
+
+typedef int HItype __attribute__ ((mode (HI)));
+typedef int SItype __attribute__ ((mode (SI)));
+typedef int DItype __attribute__ ((mode (DI)));
+#ifdef TMODES
+typedef int TItype __attribute__ ((mode (TI)));
+#endif
+
+/* The type of the result of a fp compare */
+#ifndef CMPtype
+#define CMPtype SItype
+#endif
+
+typedef unsigned int UHItype __attribute__ ((mode (HI)));
+typedef unsigned int USItype __attribute__ ((mode (SI)));
+typedef unsigned int UDItype __attribute__ ((mode (DI)));
+#ifdef TMODES
+typedef unsigned int UTItype __attribute__ ((mode (TI)));
+#endif
+
+#define MAX_USI_INT  (~(USItype)0)
+#define MAX_SI_INT   ((SItype) (MAX_USI_INT >> 1))
+#define BITS_PER_SI  (4 * BITS_PER_UNIT)
+#ifdef TMODES
+#define MAX_UDI_INT  (~(UDItype)0)
+#define MAX_DI_INT   ((DItype) (MAX_UDI_INT >> 1))
+#define BITS_PER_DI  (8 * BITS_PER_UNIT)
+#endif
+
+#ifdef FLOAT_ONLY
+#define NO_DI_MODE
+#endif
+
+#ifdef TFLOAT
+# ifndef TMODES
+#  error "TFLOAT requires long double to have 113 bits of mantissa"
+# endif
+
+#	define PREFIXFPDP tp
+#	define PREFIXSFDF tf
+#	define NGARDS 10L /* Is this right? */
+#	define GARDROUND 0x1ff
+#	define GARDMASK  0x3ff
+#	define GARDMSB   0x200
+#	define FRAC_NBITS 128
+
+# if __LDBL_MANT_DIG__ == 113 /* IEEE quad */
+#	define EXPBITS 15
+#	define EXPBIAS 16383
+#	define EXPMAX (0x7fff)
+#	define QUIET_NAN ((TItype)0x8 << 108)
+#	define FRACHIGH  ((TItype)0x8 << 124)
+#	define FRACHIGH2 ((TItype)0xc << 124)
+#	define FRACBITS 112
+# endif
+
+# if __LDBL_MANT_DIG__ == 106 /* IBM extended (double+double) */
+#	define EXPBITS 11
+#	define EXPBIAS 1023
+#	define EXPMAX (0x7ff)
+#	define QUIET_NAN ((TItype)0x8 << (48 + 64))
+#	define FRACHIGH  ((TItype)0x8 << 124)
+#	define FRACHIGH2 ((TItype)0xc << 124)
+#	define FRACBITS 105
+#	define HALFFRACBITS 52
+#	define HALFSHIFT 64
+# endif
+
+#	define pack_d __pack_t
+#	define unpack_d __unpack_t
+#	define __fpcmp_parts __fpcmp_parts_t
+	typedef UTItype fractype;
+	typedef UDItype halffractype;
+	typedef USItype qrtrfractype;
+#define qrtrfractype qrtrfractype
+	typedef TFtype FLO_type;
+	typedef TItype intfrac;
+#elif defined FLOAT
+#	define NGARDS    7L
+#	define GARDROUND 0x3f
+#	define GARDMASK  0x7f
+#	define GARDMSB   0x40
+#	define EXPBITS 8
+#	define EXPBIAS 127
+#	define FRACBITS 23
+#	define EXPMAX (0xff)
+#	define QUIET_NAN 0x100000L
+#	define FRAC_NBITS 32
+#	define FRACHIGH  0x80000000L
+#	define FRACHIGH2 0xc0000000L
+#	define pack_d __pack_f
+#	define unpack_d __unpack_f
+#	define __fpcmp_parts __fpcmp_parts_f
+	typedef USItype fractype;
+	typedef UHItype halffractype;
+	typedef SFtype FLO_type;
+	typedef SItype intfrac;
+
+#else
+#	define PREFIXFPDP dp
+#	define PREFIXSFDF df
+#	define NGARDS 8L
+#	define GARDROUND 0x7f
+#	define GARDMASK  0xff
+#	define GARDMSB   0x80
+#	define EXPBITS 11
+#	define EXPBIAS 1023
+#	define FRACBITS 52
+#	define EXPMAX (0x7ff)
+#	define QUIET_NAN 0x8000000000000LL
+#	define FRAC_NBITS 64
+#	define FRACHIGH  0x8000000000000000LL
+#	define FRACHIGH2 0xc000000000000000LL
+#	define pack_d __pack_d
+#	define unpack_d __unpack_d
+#	define __fpcmp_parts __fpcmp_parts_d
+	typedef UDItype fractype;
+	typedef USItype halffractype;
+	typedef DFtype FLO_type;
+	typedef DItype intfrac;
+#endif /* FLOAT */
+
+#ifdef US_SOFTWARE_GOFAST
+#	ifdef TFLOAT
+#		error "GOFAST TFmode not supported"
+#	elif defined FLOAT
+#		define add 		fpadd
+#		define sub 		fpsub
+#		define multiply 	fpmul
+#		define divide 		fpdiv
+#		define compare 		fpcmp
+#		define _unord_f2	__unordsf2
+#		define usi_to_float 	__floatunsisf
+#		define si_to_float 	sitofp
+#		define float_to_si 	fptosi
+#		define float_to_usi 	fptoui
+#		define negate 		__negsf2
+#		define sf_to_df		fptodp
+#		define sf_to_tf		__extendsftf2
+#	else
+#		define add 		dpadd
+#		define sub 		dpsub
+#		define multiply 	dpmul
+#		define divide 		dpdiv
+#		define compare 		dpcmp
+#		define _unord_f2	__unorddf2
+#		define usi_to_float 	__floatunsidf
+#		define si_to_float 	litodp
+#		define float_to_si 	dptoli
+#		define float_to_usi 	dptoul
+#		define negate 		__negdf2
+#		define df_to_sf 	dptofp
+#		define df_to_tf 	__extenddftf2
+#	endif /* FLOAT */
+#else
+#	ifdef TFLOAT
+#		define add 		__addtf3
+#		define sub 		__subtf3
+#		define multiply 	__multf3
+#		define divide 		__divtf3
+#		define compare 		__cmptf2
+#		define _eq_f2 		__eqtf2
+#		define _ne_f2 		__netf2
+#		define _gt_f2 		__gttf2
+#		define _ge_f2 		__getf2
+#		define _lt_f2 		__lttf2
+#		define _le_f2 		__letf2
+#		define _unord_f2	__unordtf2
+#		define usi_to_float 	__floatunsitf
+#		define si_to_float 	__floatsitf
+#		define float_to_si 	__fixtfsi
+#		define float_to_usi 	__fixunstfsi
+#		define negate 		__negtf2
+#		define tf_to_sf		__trunctfsf2
+#		define tf_to_df		__trunctfdf2
+#	elif defined FLOAT
+#		define add 		__addsf3
+#		define sub 		__subsf3
+#		define multiply 	__mulsf3
+#		define divide 		__divsf3
+#		define compare 		__cmpsf2
+#		define _eq_f2 		__eqsf2
+#		define _ne_f2 		__nesf2
+#		define _gt_f2 		__gtsf2
+#		define _ge_f2 		__gesf2
+#		define _lt_f2 		__ltsf2
+#		define _le_f2 		__lesf2
+#		define _unord_f2	__unordsf2
+#		define usi_to_float 	__floatunsisf
+#		define si_to_float 	__floatsisf
+#		define float_to_si 	__fixsfsi
+#		define float_to_usi 	__fixunssfsi
+#		define negate 		__negsf2
+#		define sf_to_df		__extendsfdf2
+#		define sf_to_tf		__extendsftf2
+#	else
+#		define add 		__adddf3
+#		define sub 		__subdf3
+#		define multiply 	__muldf3
+#		define divide 		__divdf3
+#		define compare 		__cmpdf2
+#		define _eq_f2 		__eqdf2
+#		define _ne_f2 		__nedf2
+#		define _gt_f2 		__gtdf2
+#		define _ge_f2 		__gedf2
+#		define _lt_f2 		__ltdf2
+#		define _le_f2 		__ledf2
+#		define _unord_f2	__unorddf2
+#		define usi_to_float 	__floatunsidf
+#		define si_to_float 	__floatsidf
+#		define float_to_si 	__fixdfsi
+#		define float_to_usi 	__fixunsdfsi
+#		define negate 		__negdf2
+#		define df_to_sf		__truncdfsf2
+#		define df_to_tf		__extenddftf2
+#	endif /* FLOAT */
+#endif /* US_SOFTWARE_GOFAST */
+
+#ifndef INLINE
+#define INLINE __inline__
+#endif
+
+/* Preserve the sticky-bit when shifting fractions to the right.  */
+#define LSHIFT(a) { a = (a & 1) | (a >> 1); }
+
+/* numeric parameters */
+/* F_D_BITOFF is the number of bits offset between the MSB of the mantissa
+   of a float and of a double. Assumes there are only two float types.
+   (double::FRAC_BITS+double::NGARDS-(float::FRAC_BITS-float::NGARDS))
+ */
+#define F_D_BITOFF (52+8-(23+7))
+
+#ifdef TMODES
+# define F_T_BITOFF (__LDBL_MANT_DIG__-1+10-(23+7))
+# define D_T_BITOFF (__LDBL_MANT_DIG__-1+10-(52+8))
+#endif
+
+
+#define NORMAL_EXPMIN (-(EXPBIAS)+1)
+#define IMPLICIT_1 ((fractype)1<<(FRACBITS+NGARDS))
+#define IMPLICIT_2 ((fractype)1<<(FRACBITS+1+NGARDS))
+
+/* common types */
+
+typedef enum
+{
+  CLASS_SNAN,
+  CLASS_QNAN,
+  CLASS_ZERO,
+  CLASS_NUMBER,
+  CLASS_INFINITY
+} fp_class_type;
+
+typedef struct
+{
+#ifdef SMALL_MACHINE
+  char class;
+  unsigned char sign;
+  short normal_exp;
+#else
+  fp_class_type class;
+  unsigned int sign;
+  int normal_exp;
+#endif
+
+  union
+    {
+      fractype ll;
+      halffractype l[2];
+    } fraction;
+} fp_number_type;
+
+typedef union
+{
+  FLO_type value;
+  fractype value_raw;
+
+#ifndef FLOAT
+# ifdef qrtrfractype
+  qrtrfractype qwords[4];
+# else
+  halffractype words[2];
+# endif
+#endif
+
+#ifdef FLOAT_BIT_ORDER_MISMATCH
+  struct
+    {
+      fractype fraction:FRACBITS __attribute__ ((packed));
+      unsigned int exp:EXPBITS __attribute__ ((packed));
+      unsigned int sign:1 __attribute__ ((packed));
+    }
+  bits;
+#endif
+
+#ifdef _DEBUG_BITFLOAT
+  struct
+    {
+      unsigned int sign:1 __attribute__ ((packed));
+      unsigned int exp:EXPBITS __attribute__ ((packed));
+      fractype fraction:FRACBITS __attribute__ ((packed));
+    }
+  bits_big_endian;
+
+  struct
+    {
+      fractype fraction:FRACBITS __attribute__ ((packed));
+      unsigned int exp:EXPBITS __attribute__ ((packed));
+      unsigned int sign:1 __attribute__ ((packed));
+    }
+  bits_little_endian;
+#endif
+}
+FLO_union_type;
+
+/* Prototypes */
+
+#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
+extern FLO_type pack_d (fp_number_type *);
+#endif
+
+extern void unpack_d (FLO_union_type *, fp_number_type *);
+
+#if defined(L_addsub_sf) || defined(L_addsub_df) || defined(L_addsub_tf)
+extern FLO_type add (FLO_type, FLO_type);
+extern FLO_type sub (FLO_type, FLO_type);
+#endif
+
+#if defined(L_mul_sf) || defined(L_mul_df) || defined(L_mul_tf)
+extern FLO_type multiply (FLO_type, FLO_type);
+#endif
+
+#if defined(L_div_sf) || defined(L_div_df) || defined(L_div_tf)
+extern FLO_type divide (FLO_type, FLO_type);
+#endif
+
+extern int __fpcmp_parts (fp_number_type *, fp_number_type *);
+
+#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compare_tf)
+extern CMPtype compare (FLO_type, FLO_type);
+#endif
+
+#ifndef US_SOFTWARE_GOFAST
+
+#if defined(L_eq_sf) || defined(L_eq_df) || defined(L_eq_tf)
+extern CMPtype _eq_f2 (FLO_type, FLO_type);
+#endif
+
+#if defined(L_ne_sf) || defined(L_ne_df) || defined(L_ne_tf)
+extern CMPtype _ne_f2 (FLO_type, FLO_type);
+#endif
+
+#if defined(L_gt_sf) || defined(L_gt_df) || defined(L_gt_tf)
+extern CMPtype _gt_f2 (FLO_type, FLO_type);
+#endif
+
+#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
+extern CMPtype _ge_f2 (FLO_type, FLO_type);
+#endif
+
+#if defined(L_lt_sf) || defined(L_lt_df) || defined(L_lt_tf)
+extern CMPtype _lt_f2 (FLO_type, FLO_type);
+#endif
+
+#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
+extern CMPtype _le_f2 (FLO_type, FLO_type);
+#endif
+
+#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
+extern CMPtype _unord_f2 (FLO_type, FLO_type);
+#endif
+
+#endif /* ! US_SOFTWARE_GOFAST */
+
+#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
+extern FLO_type si_to_float (SItype);
+#endif
+
+#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
+extern SItype float_to_si (FLO_type);
+#endif
+
+#if defined(L_sf_to_usi) || defined(L_df_to_usi) || defined(L_tf_to_usi)
+#if defined(US_SOFTWARE_GOFAST) || defined(L_tf_to_usi)
+extern USItype float_to_usi (FLO_type);
+#endif
+#endif
+
+#if defined(L_usi_to_sf) || defined(L_usi_to_df) || defined(L_usi_to_tf)
+extern FLO_type usi_to_float (USItype);
+#endif
+
+#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
+extern FLO_type negate (FLO_type);
+#endif
+
+#ifdef FLOAT
+#if defined(L_make_sf)
+extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);
+#endif
+#ifndef FLOAT_ONLY
+extern DFtype __make_dp (fp_class_type, unsigned int, int, UDItype);
+#if defined(L_sf_to_df)
+extern DFtype sf_to_df (SFtype);
+#endif
+#if defined(L_sf_to_tf) && defined(TMODES)
+extern TFtype sf_to_tf (SFtype);
+#endif
+#endif /* ! FLOAT_ONLY */
+#endif /* FLOAT */
+
+#ifndef FLOAT
+extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);
+#if defined(L_make_df)
+extern DFtype __make_dp (fp_class_type, unsigned int, int, UDItype);
+#endif
+#if defined(L_df_to_sf)
+extern SFtype df_to_sf (DFtype);
+#endif
+#if defined(L_df_to_tf) && defined(TMODES)
+extern TFtype df_to_tf (DFtype);
+#endif
+#endif /* ! FLOAT */
+
+#ifdef TMODES
+extern DFtype __make_dp (fp_class_type, unsigned int, int, UDItype);
+extern TFtype __make_tp (fp_class_type, unsigned int, int, UTItype);
+#ifdef TFLOAT
+#if defined(L_tf_to_sf)
+extern SFtype tf_to_sf (TFtype);
+#endif
+#if defined(L_tf_to_df)
+extern DFtype tf_to_df (TFtype);
+#endif
+#if defined(L_di_to_tf)
+extern TFtype di_to_df (DItype);
+#endif
+#endif /* TFLOAT */
+#endif /* TMODES */
+
+#endif /* ! GCC_FP_BIT_H */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/softfloat/fp-bits.c tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/fp-bits.c
--- linux-2.6.36/arch/mips/softfloat/fp-bits.c	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/fp-bits.c	2019-03-07 05:05:24.000000000 +0200
@@ -0,0 +1,1644 @@
+#define FLOAT
+/* This is a software floating point library which can be used
+   for targets without hardware floating point. 
+   Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003
+   Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file with other programs, and to distribute
+those programs without any restriction coming from the use of this
+file.  (The General Public License restrictions do apply in other
+respects; for example, they cover modification of the file, and
+distribution when not linked into another program.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, if you link this library with other files,
+   some of which are compiled with GCC, to produce an executable,
+   this library does not by itself cause the resulting executable
+   to be covered by the GNU General Public License.
+   This exception does not however invalidate any other reasons why
+   the executable file might be covered by the GNU General Public License.  */
+
+/* This implements IEEE 754 format arithmetic, but does not provide a
+   mechanism for setting the rounding mode, or for generating or handling
+   exceptions.
+
+   The original code by Steve Chamberlain, hacked by Mark Eichin and Jim
+   Wilson, all of Cygnus Support.  */
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+/* The intended way to use this file is to make two copies, add `#define FLOAT'
+   to one copy, then compile both copies and add them to libgcc.a.  */
+#ifndef CONFIG_MIPS_TC3262
+#define US_SOFTWARE_GOFAST
+#endif
+#include "tconfig.h"
+#include "fp-bit.h"
+
+/* The following macros can be defined to change the behavior of this file:
+   FLOAT: Implement a `float', aka SFmode, fp library.  If this is not
+     defined, then this file implements a `double', aka DFmode, fp library.
+   FLOAT_ONLY: Used with FLOAT, to implement a `float' only library, i.e.
+     don't include float->double conversion which requires the double library.
+     This is useful only for machines which can't support doubles, e.g. some
+     8-bit processors.
+   CMPtype: Specify the type that floating point compares should return.
+     This defaults to SItype, aka int.
+   US_SOFTWARE_GOFAST: This makes all entry points use the same names as the
+     US Software goFast library.
+   _DEBUG_BITFLOAT: This makes debugging the code a little easier, by adding
+     two integers to the FLO_union_type.
+   NO_DENORMALS: Disable handling of denormals.
+   NO_NANS: Disable nan and infinity handling
+   SMALL_MACHINE: Useful when operations on QIs and HIs are faster
+     than on an SI */
+
+/* We don't currently support extended floats (long doubles) on machines
+   without hardware to deal with them.
+
+   These stubs are just to keep the linker from complaining about unresolved
+   references which can be pulled in from libio & libstdc++, even if the
+   user isn't using long doubles.  However, they may generate an unresolved
+   external to abort if abort is not used by the function, and the stubs
+   are referenced from within libc, since libgcc goes before and after the
+   system library.  */
+
+#ifdef DECLARE_LIBRARY_RENAMES
+  DECLARE_LIBRARY_RENAMES
+#endif
+
+#ifdef EXTENDED_FLOAT_STUBS
+extern void abort (void);
+void __extendsfxf2 (void) { abort(); }
+void __extenddfxf2 (void) { abort(); }
+void __truncxfdf2 (void) { abort(); }
+void __truncxfsf2 (void) { abort(); }
+void __fixxfsi (void) { abort(); }
+void __floatsixf (void) { abort(); }
+void __addxf3 (void) { abort(); }
+void __subxf3 (void) { abort(); }
+void __mulxf3 (void) { abort(); }
+void __divxf3 (void) { abort(); }
+void __negxf2 (void) { abort(); }
+void __eqxf2 (void) { abort(); }
+void __nexf2 (void) { abort(); }
+void __gtxf2 (void) { abort(); }
+void __gexf2 (void) { abort(); }
+void __lexf2 (void) { abort(); }
+void __ltxf2 (void) { abort(); }
+
+void __extendsftf2 (void) { abort(); }
+void __extenddftf2 (void) { abort(); }
+void __trunctfdf2 (void) { abort(); }
+void __trunctfsf2 (void) { abort(); }
+void __fixtfsi (void) { abort(); }
+void __floatsitf (void) { abort(); }
+void __addtf3 (void) { abort(); }
+void __subtf3 (void) { abort(); }
+void __multf3 (void) { abort(); }
+void __divtf3 (void) { abort(); }
+void __negtf2 (void) { abort(); }
+void __eqtf2 (void) { abort(); }
+void __netf2 (void) { abort(); }
+void __gttf2 (void) { abort(); }
+void __getf2 (void) { abort(); }
+void __letf2 (void) { abort(); }
+void __lttf2 (void) { abort(); }
+#else	/* !EXTENDED_FLOAT_STUBS, rest of file */
+
+/* IEEE "special" number predicates */
+
+#ifdef NO_NANS
+
+#define nan() 0
+#define isnan(x) 0
+#define isinf(x) 0
+#else
+
+#if   defined L_thenan_sf
+const fp_number_type __thenan_sf = { CLASS_SNAN, 0, 0, {(fractype) 0} };
+#elif defined L_thenan_df
+const fp_number_type __thenan_df = { CLASS_SNAN, 0, 0, {(fractype) 0} };
+#elif defined L_thenan_tf
+const fp_number_type __thenan_tf = { CLASS_SNAN, 0, 0, {(fractype) 0} };
+#elif defined TFLOAT
+extern const fp_number_type __thenan_tf;
+#elif defined FLOAT
+extern const fp_number_type __thenan_sf;
+#else
+extern const fp_number_type __thenan_df;
+#endif
+
+INLINE
+static fp_number_type *
+nan (void)
+{
+  /* Discard the const qualifier...  */
+#ifdef TFLOAT
+  return (fp_number_type *) (& __thenan_tf);
+#elif defined FLOAT  
+  return (fp_number_type *) (& __thenan_sf);
+#else
+  return (fp_number_type *) (& __thenan_df);
+#endif
+}
+
+INLINE
+static int
+isnan ( fp_number_type *  x)
+{
+  return x->class == CLASS_SNAN || x->class == CLASS_QNAN;
+}
+
+INLINE
+static int
+isinf ( fp_number_type *  x)
+{
+  return x->class == CLASS_INFINITY;
+}
+
+#endif /* NO_NANS */
+
+INLINE
+static int
+iszero ( fp_number_type *  x)
+{
+  return x->class == CLASS_ZERO;
+}
+
+INLINE 
+static void
+flip_sign ( fp_number_type *  x)
+{
+  x->sign = !x->sign;
+}
+
+extern FLO_type pack_d ( fp_number_type * );
+
+#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
+FLO_type
+pack_d ( fp_number_type *  src)
+{
+  FLO_union_type dst;
+  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
+  int sign = src->sign;
+  int exp = 0;
+
+  if (LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS) && (isnan (src) || isinf (src)))
+    {
+      /* We can't represent these values accurately.  By using the
+	 largest possible magnitude, we guarantee that the conversion
+	 of infinity is at least as big as any finite number.  */
+      exp = EXPMAX;
+      fraction = ((fractype) 1 << FRACBITS) - 1;
+    }
+  else if (isnan (src))
+    {
+      exp = EXPMAX;
+      if (src->class == CLASS_QNAN || 1)
+	{
+	  fraction |= QUIET_NAN;
+	}
+    }
+  else if (isinf (src))
+    {
+      exp = EXPMAX;
+      fraction = 0;
+    }
+  else if (iszero (src))
+    {
+      exp = 0;
+      fraction = 0;
+    }
+  else if (fraction == 0)
+    {
+      exp = 0;
+    }
+  else
+    {
+      if (src->normal_exp < NORMAL_EXPMIN)
+	{
+#ifdef NO_DENORMALS
+	  /* Go straight to a zero representation if denormals are not
+ 	     supported.  The denormal handling would be harmless but
+ 	     isn't unnecessary.  */
+	  exp = 0;
+	  fraction = 0;
+#else /* NO_DENORMALS */
+	  /* This number's exponent is too low to fit into the bits
+	     available in the number, so we'll store 0 in the exponent and
+	     shift the fraction to the right to make up for it.  */
+
+	  int shift = NORMAL_EXPMIN - src->normal_exp;
+
+	  exp = 0;
+
+	  if (shift > FRAC_NBITS - NGARDS)
+	    {
+	      /* No point shifting, since it's more that 64 out.  */
+	      fraction = 0;
+	    }
+	  else
+	    {
+	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
+	      fraction = (fraction >> shift) | lowbit;
+	    }
+	  if ((fraction & GARDMASK) == GARDMSB)
+	    {
+	      if ((fraction & (1 << NGARDS)))
+		fraction += GARDROUND + 1;
+	    }
+	  else
+	    {
+	      /* Add to the guards to round up.  */
+	      fraction += GARDROUND;
+	    }
+	  /* Perhaps the rounding means we now need to change the
+             exponent, because the fraction is no longer denormal.  */
+	  if (fraction >= IMPLICIT_1)
+	    {
+	      exp += 1;
+	    }
+	  fraction >>= NGARDS;
+#endif /* NO_DENORMALS */
+	}
+      else if (!LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS)
+	       && src->normal_exp > EXPBIAS)
+	{
+	  exp = EXPMAX;
+	  fraction = 0;
+	}
+      else
+	{
+	  exp = src->normal_exp + EXPBIAS;
+	  if (!ROUND_TOWARDS_ZERO)
+	    {
+	      /* IF the gard bits are the all zero, but the first, then we're
+		 half way between two numbers, choose the one which makes the
+		 lsb of the answer 0.  */
+	      if ((fraction & GARDMASK) == GARDMSB)
+		{
+		  if (fraction & (1 << NGARDS))
+		    fraction += GARDROUND + 1;
+		}
+	      else
+		{
+		  /* Add a one to the guards to round up */
+		  fraction += GARDROUND;
+		}
+	      if (fraction >= IMPLICIT_2)
+		{
+		  fraction >>= 1;
+		  exp += 1;
+		}
+	    }
+	  fraction >>= NGARDS;
+
+	  if (LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS) && exp > EXPMAX)
+	    {
+	      /* Saturate on overflow.  */
+	      exp = EXPMAX;
+	      fraction = ((fractype) 1 << FRACBITS) - 1;
+	    }
+	}
+    }
+
+  /* We previously used bitfields to store the number, but this doesn't
+     handle little/big endian systems conveniently, so use shifts and
+     masks */
+#ifdef FLOAT_BIT_ORDER_MISMATCH
+  dst.bits.fraction = fraction;
+  dst.bits.exp = exp;
+  dst.bits.sign = sign;
+#else
+# if defined TFLOAT && defined HALFFRACBITS
+ {
+   halffractype high, low;
+
+   high = (fraction >> (FRACBITS - HALFFRACBITS));
+   high &= (((fractype)1) << HALFFRACBITS) - 1;
+   high |= ((fractype) (exp & ((1 << EXPBITS) - 1))) << HALFFRACBITS;
+   high |= ((fractype) (sign & 1)) << (HALFFRACBITS | EXPBITS);
+
+   low = (halffractype)fraction &
+     ((((halffractype)1) << (FRACBITS - HALFFRACBITS)) - 1);
+
+   if (exp == EXPMAX || exp == 0 || low == 0)
+     low = 0;
+   else
+     {
+       exp -= HALFFRACBITS + 1;
+
+       while (exp > 0
+	      && low < ((halffractype)1 << HALFFRACBITS))
+	 {
+	   low <<= 1;
+	   exp--;
+	 }
+
+       if (exp <= 0)
+	 {
+	   halffractype roundmsb, round;
+
+	   exp = -exp + 1;
+
+	   roundmsb = (1 << (exp - 1));
+	   round = low & ((roundmsb << 1) - 1);
+
+	   low >>= exp;
+	   exp = 0;
+
+	   if (round > roundmsb || (round == roundmsb && (low & 1)))
+	     {
+	       low++;
+	       if (low >= ((halffractype)1 << HALFFRACBITS))
+		 /* We don't shift left, since it has just become the
+		    smallest normal number, whose implicit 1 bit is
+		    now indicated by the non-zero exponent.  */
+		 exp++;
+	     }
+	 }
+
+       low &= ((halffractype)1 << HALFFRACBITS) - 1;
+       low |= ((fractype) (exp & ((1 << EXPBITS) - 1))) << HALFFRACBITS;
+       low |= ((fractype) (sign & 1)) << (HALFFRACBITS | EXPBITS);
+     }
+
+   dst.value_raw = (((fractype) high) << HALFSHIFT) | low;
+ }
+# else
+  dst.value_raw = fraction & ((((fractype)1) << FRACBITS) - (fractype)1);
+  dst.value_raw |= ((fractype) (exp & ((1 << EXPBITS) - 1))) << FRACBITS;
+  dst.value_raw |= ((fractype) (sign & 1)) << (FRACBITS | EXPBITS);
+# endif
+#endif
+
+#if defined(FLOAT_WORD_ORDER_MISMATCH) && !defined(FLOAT)
+#ifdef TFLOAT
+  {
+    qrtrfractype tmp1 = dst.words[0];
+    qrtrfractype tmp2 = dst.words[1];
+    dst.words[0] = dst.words[3];
+    dst.words[1] = dst.words[2];
+    dst.words[2] = tmp2;
+    dst.words[3] = tmp1;
+  }
+#else
+  {
+    halffractype tmp = dst.words[0];
+    dst.words[0] = dst.words[1];
+    dst.words[1] = tmp;
+  }
+#endif
+#endif
+
+  return dst.value;
+}
+#endif
+
+#if defined(L_unpack_df) || defined(L_unpack_sf) || defined(L_unpack_tf)
+void
+unpack_d (FLO_union_type * src, fp_number_type * dst)
+{
+  /* We previously used bitfields to store the number, but this doesn't
+     handle little/big endian systems conveniently, so use shifts and
+     masks */
+  fractype fraction;
+  int exp;
+  int sign;
+
+#if defined(FLOAT_WORD_ORDER_MISMATCH) && !defined(FLOAT)
+  FLO_union_type swapped;
+
+#ifdef TFLOAT
+  swapped.words[0] = src->words[3];
+  swapped.words[1] = src->words[2];
+  swapped.words[2] = src->words[1];
+  swapped.words[3] = src->words[0];
+#else
+  swapped.words[0] = src->words[1];
+  swapped.words[1] = src->words[0];
+#endif
+  src = &swapped;
+#endif
+  
+#ifdef FLOAT_BIT_ORDER_MISMATCH
+  fraction = src->bits.fraction;
+  exp = src->bits.exp;
+  sign = src->bits.sign;
+#else
+# if defined TFLOAT && defined HALFFRACBITS
+ {
+   halffractype high, low;
+   
+   high = src->value_raw >> HALFSHIFT;
+   low = src->value_raw & (((fractype)1 << HALFSHIFT) - 1);
+
+   fraction = high & ((((fractype)1) << HALFFRACBITS) - 1);
+   fraction <<= FRACBITS - HALFFRACBITS;
+   exp = ((int)(high >> HALFFRACBITS)) & ((1 << EXPBITS) - 1);
+   sign = ((int)(high >> (((HALFFRACBITS + EXPBITS))))) & 1;
+
+   if (exp != EXPMAX && exp != 0 && low != 0)
+     {
+       int lowexp = ((int)(low >> HALFFRACBITS)) & ((1 << EXPBITS) - 1);
+       int lowsign = ((int)(low >> (((HALFFRACBITS + EXPBITS))))) & 1;
+       int shift;
+       fractype xlow;
+
+       xlow = low & ((((fractype)1) << HALFFRACBITS) - 1);
+       if (lowexp)
+	 xlow |= (((halffractype)1) << HALFFRACBITS);
+       else
+	 lowexp = 1;
+       shift = (FRACBITS - HALFFRACBITS) - (exp - lowexp);
+       if (shift > 0)
+	 xlow <<= shift;
+       else if (shift < 0)
+	 xlow >>= -shift;
+       if (sign == lowsign)
+	 fraction += xlow;
+       else
+	 fraction -= xlow;
+     }
+ }
+# else
+  fraction = src->value_raw & ((((fractype)1) << FRACBITS) - 1);
+  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
+  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
+# endif
+#endif
+
+  dst->sign = sign;
+  if (exp == 0)
+    {
+      /* Hmm.  Looks like 0 */
+      if (fraction == 0
+#ifdef NO_DENORMALS
+	  || 1
+#endif
+	  )
+	{
+	  /* tastes like zero */
+	  dst->class = CLASS_ZERO;
+	}
+      else
+	{
+	  /* Zero exponent with nonzero fraction - it's denormalized,
+	     so there isn't a leading implicit one - we'll shift it so
+	     it gets one.  */
+	  dst->normal_exp = exp - EXPBIAS + 1;
+	  fraction <<= NGARDS;
+
+	  dst->class = CLASS_NUMBER;
+#if 1
+	  while (fraction < IMPLICIT_1)
+	    {
+	      fraction <<= 1;
+	      dst->normal_exp--;
+	    }
+#endif
+	  dst->fraction.ll = fraction;
+	}
+    }
+  else if (!LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS) && exp == EXPMAX)
+    {
+      /* Huge exponent*/
+      if (fraction == 0)
+	{
+	  /* Attached to a zero fraction - means infinity */
+	  dst->class = CLASS_INFINITY;
+	}
+      else
+	{
+	  /* Nonzero fraction, means nan */
+	  if (fraction & QUIET_NAN)
+	    {
+	      dst->class = CLASS_QNAN;
+	    }
+	  else
+	    {
+	      dst->class = CLASS_SNAN;
+	    }
+	  /* Keep the fraction part as the nan number */
+	  dst->fraction.ll = fraction;
+	}
+    }
+  else
+    {
+      /* Nothing strange about this number */
+      dst->normal_exp = exp - EXPBIAS;
+      dst->class = CLASS_NUMBER;
+      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
+    }
+}
+#endif /* L_unpack_df || L_unpack_sf */
+
+#if defined(L_addsub_sf) || defined(L_addsub_df) || defined(L_addsub_tf)
+static fp_number_type *
+_fpadd_parts (fp_number_type * a,
+	      fp_number_type * b,
+	      fp_number_type * tmp)
+{
+  intfrac tfraction;
+
+  /* Put commonly used fields in local variables.  */
+  int a_normal_exp;
+  int b_normal_exp;
+  fractype a_fraction;
+  fractype b_fraction;
+
+  if (isnan (a))
+    {
+      return a;
+    }
+  if (isnan (b))
+    {
+      return b;
+    }
+  if (isinf (a))
+    {
+      /* Adding infinities with opposite signs yields a NaN.  */
+      if (isinf (b) && a->sign != b->sign)
+	return nan ();
+      return a;
+    }
+  if (isinf (b))
+    {
+      return b;
+    }
+  if (iszero (b))
+    {
+      if (iszero (a))
+	{
+	  *tmp = *a;
+	  tmp->sign = a->sign & b->sign;
+	  return tmp;
+	}
+      return a;
+    }
+  if (iszero (a))
+    {
+      return b;
+    }
+
+  /* Got two numbers. shift the smaller and increment the exponent till
+     they're the same */
+  {
+    int diff;
+
+    a_normal_exp = a->normal_exp;
+    b_normal_exp = b->normal_exp;
+    a_fraction = a->fraction.ll;
+    b_fraction = b->fraction.ll;
+
+    diff = a_normal_exp - b_normal_exp;
+
+    if (diff < 0)
+      diff = -diff;
+    if (diff < FRAC_NBITS)
+      {
+	/* ??? This does shifts one bit at a time.  Optimize.  */
+	while (a_normal_exp > b_normal_exp)
+	  {
+	    b_normal_exp++;
+	    LSHIFT (b_fraction);
+	  }
+	while (b_normal_exp > a_normal_exp)
+	  {
+	    a_normal_exp++;
+	    LSHIFT (a_fraction);
+	  }
+      }
+    else
+      {
+	/* Somethings's up.. choose the biggest */
+	if (a_normal_exp > b_normal_exp)
+	  {
+	    b_normal_exp = a_normal_exp;
+	    b_fraction = 0;
+	  }
+	else
+	  {
+	    a_normal_exp = b_normal_exp;
+	    a_fraction = 0;
+	  }
+      }
+  }
+
+  if (a->sign != b->sign)
+    {
+      if (a->sign)
+	{
+	  tfraction = -a_fraction + b_fraction;
+	}
+      else
+	{
+	  tfraction = a_fraction - b_fraction;
+	}
+      if (tfraction >= 0)
+	{
+	  tmp->sign = 0;
+	  tmp->normal_exp = a_normal_exp;
+	  tmp->fraction.ll = tfraction;
+	}
+      else
+	{
+	  tmp->sign = 1;
+	  tmp->normal_exp = a_normal_exp;
+	  tmp->fraction.ll = -tfraction;
+	}
+      /* and renormalize it */
+
+      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
+	{
+	  tmp->fraction.ll <<= 1;
+	  tmp->normal_exp--;
+	}
+    }
+  else
+    {
+      tmp->sign = a->sign;
+      tmp->normal_exp = a_normal_exp;
+      tmp->fraction.ll = a_fraction + b_fraction;
+    }
+  tmp->class = CLASS_NUMBER;
+  /* Now the fraction is added, we have to shift down to renormalize the
+     number */
+
+  if (tmp->fraction.ll >= IMPLICIT_2)
+    {
+      LSHIFT (tmp->fraction.ll);
+      tmp->normal_exp++;
+    }
+  return tmp;
+
+}
+
+FLO_type
+add (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  fp_number_type tmp;
+  fp_number_type *res;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  res = _fpadd_parts (&a, &b, &tmp);
+
+  return pack_d (res);
+}
+EXPORT_SYMBOL(add);
+
+FLO_type
+sub (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  fp_number_type tmp;
+  fp_number_type *res;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  b.sign ^= 1;
+
+  res = _fpadd_parts (&a, &b, &tmp);
+
+  return pack_d (res);
+}
+EXPORT_SYMBOL(sub);
+#endif /* L_addsub_sf || L_addsub_df */
+
+#if defined(L_mul_sf) || defined(L_mul_df) || defined(L_mul_tf)
+static inline __attribute__ ((__always_inline__)) fp_number_type *
+_fpmul_parts ( fp_number_type *  a,
+	       fp_number_type *  b,
+	       fp_number_type * tmp)
+{
+  fractype low = 0;
+  fractype high = 0;
+
+  if (isnan (a))
+    {
+      a->sign = a->sign != b->sign;
+      return a;
+    }
+  if (isnan (b))
+    {
+      b->sign = a->sign != b->sign;
+      return b;
+    }
+  if (isinf (a))
+    {
+      if (iszero (b))
+	return nan ();
+      a->sign = a->sign != b->sign;
+      return a;
+    }
+  if (isinf (b))
+    {
+      if (iszero (a))
+	{
+	  return nan ();
+	}
+      b->sign = a->sign != b->sign;
+      return b;
+    }
+  if (iszero (a))
+    {
+      a->sign = a->sign != b->sign;
+      return a;
+    }
+  if (iszero (b))
+    {
+      b->sign = a->sign != b->sign;
+      return b;
+    }
+
+  /* Calculate the mantissa by multiplying both numbers to get a
+     twice-as-wide number.  */
+  {
+#if defined(NO_DI_MODE) || defined(TFLOAT)
+    {
+      fractype x = a->fraction.ll;
+      fractype ylow = b->fraction.ll;
+      fractype yhigh = 0;
+      int bit;
+
+      /* ??? This does multiplies one bit at a time.  Optimize.  */
+      for (bit = 0; bit < FRAC_NBITS; bit++)
+	{
+	  int carry;
+
+	  if (x & 1)
+	    {
+	      carry = (low += ylow) < ylow;
+	      high += yhigh + carry;
+	    }
+	  yhigh <<= 1;
+	  if (ylow & FRACHIGH)
+	    {
+	      yhigh |= 1;
+	    }
+	  ylow <<= 1;
+	  x >>= 1;
+	}
+    }
+#elif defined(FLOAT) 
+    /* Multiplying two USIs to get a UDI, we're safe.  */
+    {
+      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
+      
+      high = answer >> BITS_PER_SI;
+      low = answer;
+    }
+#else
+    /* fractype is DImode, but we need the result to be twice as wide.
+       Assuming a widening multiply from DImode to TImode is not
+       available, build one by hand.  */
+    {
+      USItype nl = a->fraction.ll;
+      USItype nh = a->fraction.ll >> BITS_PER_SI;
+      USItype ml = b->fraction.ll;
+      USItype mh = b->fraction.ll >> BITS_PER_SI;
+      UDItype pp_ll = (UDItype) ml * nl;
+      UDItype pp_hl = (UDItype) mh * nl;
+      UDItype pp_lh = (UDItype) ml * nh;
+      UDItype pp_hh = (UDItype) mh * nh;
+      UDItype res2 = 0;
+      UDItype res0 = 0;
+      UDItype ps_hh__ = pp_hl + pp_lh;
+      if (ps_hh__ < pp_hl)
+	res2 += (UDItype)1 << BITS_PER_SI;
+      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
+      res0 = pp_ll + pp_hl;
+      if (res0 < pp_ll)
+	res2++;
+      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
+      high = res2;
+      low = res0;
+    }
+#endif
+  }
+
+  tmp->normal_exp = a->normal_exp + b->normal_exp
+    + FRAC_NBITS - (FRACBITS + NGARDS);
+  tmp->sign = a->sign != b->sign;
+  while (high >= IMPLICIT_2)
+    {
+      tmp->normal_exp++;
+      if (high & 1)
+	{
+	  low >>= 1;
+	  low |= FRACHIGH;
+	}
+      high >>= 1;
+    }
+  while (high < IMPLICIT_1)
+    {
+      tmp->normal_exp--;
+
+      high <<= 1;
+      if (low & FRACHIGH)
+	high |= 1;
+      low <<= 1;
+    }
+  /* rounding is tricky. if we only round if it won't make us round later.  */
+#if 0
+  if (low & FRACHIGH2)
+    {
+      if (((high & GARDMASK) != GARDMSB)
+	  && (((high + 1) & GARDMASK) == GARDMSB))
+	{
+	  /* don't round, it gets done again later.  */
+	}
+      else
+	{
+	  high++;
+	}
+    }
+#endif
+  if (!ROUND_TOWARDS_ZERO && (high & GARDMASK) == GARDMSB)
+    {
+      if (high & (1 << NGARDS))
+	{
+	  /* half way, so round to even */
+	  high += GARDROUND + 1;
+	}
+      else if (low)
+	{
+	  /* but we really weren't half way */
+	  high += GARDROUND + 1;
+	}
+    }
+  tmp->fraction.ll = high;
+  tmp->class = CLASS_NUMBER;
+  return tmp;
+}
+
+FLO_type
+multiply (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  fp_number_type tmp;
+  fp_number_type *res;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  res = _fpmul_parts (&a, &b, &tmp);
+
+  return pack_d (res);
+}
+EXPORT_SYMBOL(multiply);
+#endif /* L_mul_sf || L_mul_df */
+
+#if defined(L_div_sf) || defined(L_div_df) || defined(L_div_tf)
+static inline __attribute__ ((__always_inline__)) fp_number_type *
+_fpdiv_parts (fp_number_type * a,
+	      fp_number_type * b)
+{
+  fractype bit;
+  fractype numerator;
+  fractype denominator;
+  fractype quotient;
+
+  if (isnan (a))
+    {
+      return a;
+    }
+  if (isnan (b))
+    {
+      return b;
+    }
+
+  a->sign = a->sign ^ b->sign;
+
+  if (isinf (a) || iszero (a))
+    {
+      if (a->class == b->class)
+	return nan ();
+      return a;
+    }
+
+  if (isinf (b))
+    {
+      a->fraction.ll = 0;
+      a->normal_exp = 0;
+      return a;
+    }
+  if (iszero (b))
+    {
+      a->class = CLASS_INFINITY;
+      return a;
+    }
+
+  /* Calculate the mantissa by multiplying both 64bit numbers to get a
+     128 bit number */
+  {
+    /* quotient =
+       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
+     */
+
+    a->normal_exp = a->normal_exp - b->normal_exp;
+    numerator = a->fraction.ll;
+    denominator = b->fraction.ll;
+
+    if (numerator < denominator)
+      {
+	/* Fraction will be less than 1.0 */
+	numerator *= 2;
+	a->normal_exp--;
+      }
+    bit = IMPLICIT_1;
+    quotient = 0;
+    /* ??? Does divide one bit at a time.  Optimize.  */
+    while (bit)
+      {
+	if (numerator >= denominator)
+	  {
+	    quotient |= bit;
+	    numerator -= denominator;
+	  }
+	bit >>= 1;
+	numerator *= 2;
+      }
+
+    if (!ROUND_TOWARDS_ZERO && (quotient & GARDMASK) == GARDMSB)
+      {
+	if (quotient & (1 << NGARDS))
+	  {
+	    /* half way, so round to even */
+	    quotient += GARDROUND + 1;
+	  }
+	else if (numerator)
+	  {
+	    /* but we really weren't half way, more bits exist */
+	    quotient += GARDROUND + 1;
+	  }
+      }
+
+    a->fraction.ll = quotient;
+    return (a);
+  }
+}
+
+FLO_type
+divide (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  fp_number_type *res;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  res = _fpdiv_parts (&a, &b);
+
+  return pack_d (res);
+}
+EXPORT_SYMBOL(divide);
+#endif /* L_div_sf || L_div_df */
+
+#if defined(L_fpcmp_parts_sf) || defined(L_fpcmp_parts_df) \
+    || defined(L_fpcmp_parts_tf)
+/* according to the demo, fpcmp returns a comparison with 0... thus
+   a<b -> -1
+   a==b -> 0
+   a>b -> +1
+ */
+
+int
+__fpcmp_parts (fp_number_type * a, fp_number_type * b)
+{
+#if 0
+  /* either nan -> unordered. Must be checked outside of this routine.  */
+  if (isnan (a) && isnan (b))
+    {
+      return 1;			/* still unordered! */
+    }
+#endif
+
+  if (isnan (a) || isnan (b))
+    {
+      return 1;			/* how to indicate unordered compare? */
+    }
+  if (isinf (a) && isinf (b))
+    {
+      /* +inf > -inf, but +inf != +inf */
+      /* b    \a| +inf(0)| -inf(1)
+       ______\+--------+--------
+       +inf(0)| a==b(0)| a<b(-1)
+       -------+--------+--------
+       -inf(1)| a>b(1) | a==b(0)
+       -------+--------+--------
+       So since unordered must be nonzero, just line up the columns...
+       */
+      return b->sign - a->sign;
+    }
+  /* but not both...  */
+  if (isinf (a))
+    {
+      return a->sign ? -1 : 1;
+    }
+  if (isinf (b))
+    {
+      return b->sign ? 1 : -1;
+    }
+  if (iszero (a) && iszero (b))
+    {
+      return 0;
+    }
+  if (iszero (a))
+    {
+      return b->sign ? 1 : -1;
+    }
+  if (iszero (b))
+    {
+      return a->sign ? -1 : 1;
+    }
+  /* now both are "normal".  */
+  if (a->sign != b->sign)
+    {
+      /* opposite signs */
+      return a->sign ? -1 : 1;
+    }
+  /* same sign; exponents? */
+  if (a->normal_exp > b->normal_exp)
+    {
+      return a->sign ? -1 : 1;
+    }
+  if (a->normal_exp < b->normal_exp)
+    {
+      return a->sign ? 1 : -1;
+    }
+  /* same exponents; check size.  */
+  if (a->fraction.ll > b->fraction.ll)
+    {
+      return a->sign ? -1 : 1;
+    }
+  if (a->fraction.ll < b->fraction.ll)
+    {
+      return a->sign ? 1 : -1;
+    }
+  /* after all that, they're equal.  */
+  return 0;
+}
+#endif
+
+#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
+CMPtype
+compare (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  return __fpcmp_parts (&a, &b);
+}
+EXPORT_SYMBOL(compare);
+#endif /* L_compare_sf || L_compare_df */
+
+#ifndef US_SOFTWARE_GOFAST
+
+/* These should be optimized for their specific tasks someday.  */
+
+#if defined(L_eq_sf) || defined(L_eq_df) || defined(L_eq_tf)
+CMPtype
+_eq_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return 1;			/* false, truth == 0 */
+
+  return __fpcmp_parts (&a, &b) ;
+}
+EXPORT_SYMBOL(_eq_f2);
+#endif /* L_eq_sf || L_eq_df */
+
+#if defined(L_ne_sf) || defined(L_ne_df) || defined(L_ne_tf)
+CMPtype
+_ne_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return 1;			/* true, truth != 0 */
+
+  return  __fpcmp_parts (&a, &b) ;
+}
+EXPORT_SYMBOL(_ne_f2);
+#endif /* L_ne_sf || L_ne_df */
+
+#if defined(L_gt_sf) || defined(L_gt_df) || defined(L_gt_tf)
+CMPtype
+_gt_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return -1;			/* false, truth > 0 */
+
+  return __fpcmp_parts (&a, &b);
+}
+EXPORT_SYMBOL(_gt_f2);
+#endif /* L_gt_sf || L_gt_df */
+
+#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
+CMPtype
+_ge_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return -1;			/* false, truth >= 0 */
+  return __fpcmp_parts (&a, &b) ;
+}
+EXPORT_SYMBOL(_ge_f2);
+#endif /* L_ge_sf || L_ge_df */
+
+#if defined(L_lt_sf) || defined(L_lt_df) || defined(L_lt_tf)
+CMPtype
+_lt_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return 1;			/* false, truth < 0 */
+
+  return __fpcmp_parts (&a, &b);
+}
+EXPORT_SYMBOL(_lt_f2);
+#endif /* L_lt_sf || L_lt_df */
+
+#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
+CMPtype
+_le_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  if (isnan (&a) || isnan (&b))
+    return 1;			/* false, truth <= 0 */
+
+  return __fpcmp_parts (&a, &b) ;
+}
+EXPORT_SYMBOL(_le_f2);
+#endif /* L_le_sf || L_le_df */
+
+#endif /* ! US_SOFTWARE_GOFAST */
+
+#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
+CMPtype
+_unord_f2 (FLO_type arg_a, FLO_type arg_b)
+{
+  fp_number_type a;
+  fp_number_type b;
+  FLO_union_type au, bu;
+
+  au.value = arg_a;
+  bu.value = arg_b;
+
+  unpack_d (&au, &a);
+  unpack_d (&bu, &b);
+
+  return (isnan (&a) || isnan (&b));
+}
+EXPORT_SYMBOL(_unord_f2);
+#endif /* L_unord_sf || L_unord_df */
+
+#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
+FLO_type
+si_to_float (SItype arg_a)
+{
+  fp_number_type in;
+
+  in.class = CLASS_NUMBER;
+  in.sign = arg_a < 0;
+  if (!arg_a)
+    {
+      in.class = CLASS_ZERO;
+    }
+  else
+    {
+      in.normal_exp = FRACBITS + NGARDS;
+      if (in.sign) 
+	{
+	  /* Special case for minint, since there is no +ve integer
+	     representation for it */
+	  if (arg_a == (- MAX_SI_INT - 1))
+	    {
+	      return (FLO_type)(- MAX_SI_INT - 1);
+	    }
+	  in.fraction.ll = (-arg_a);
+	}
+      else
+	in.fraction.ll = arg_a;
+
+      while (in.fraction.ll < ((fractype)1 << (FRACBITS + NGARDS)))
+	{
+	  in.fraction.ll <<= 1;
+	  in.normal_exp -= 1;
+	}
+    }
+  return pack_d (&in);
+}
+EXPORT_SYMBOL(si_to_float);
+#endif /* L_si_to_sf || L_si_to_df */
+
+#if defined(L_usi_to_sf) || defined(L_usi_to_df) || defined(L_usi_to_tf)
+FLO_type
+usi_to_float (USItype arg_a)
+{
+  fp_number_type in;
+
+  in.sign = 0;
+  if (!arg_a)
+    {
+      in.class = CLASS_ZERO;
+    }
+  else
+    {
+      in.class = CLASS_NUMBER;
+      in.normal_exp = FRACBITS + NGARDS;
+      in.fraction.ll = arg_a;
+
+      while (in.fraction.ll > ((fractype)1 << (FRACBITS + NGARDS)))
+        {
+          in.fraction.ll >>= 1;
+          in.normal_exp += 1;
+        }
+      while (in.fraction.ll < ((fractype)1 << (FRACBITS + NGARDS)))
+	{
+	  in.fraction.ll <<= 1;
+	  in.normal_exp -= 1;
+	}
+    }
+  return pack_d (&in);
+}
+EXPORT_SYMBOL(usi_to_float);
+#endif
+
+#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
+SItype
+float_to_si (FLO_type arg_a)
+{
+  fp_number_type a;
+  SItype tmp;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &a);
+
+  if (iszero (&a))
+    return 0;
+  if (isnan (&a))
+    return 0;
+  /* get reasonable MAX_SI_INT...  */
+  if (isinf (&a))
+    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
+  /* it is a number, but a small one */
+  if (a.normal_exp < 0)
+    return 0;
+  if (a.normal_exp > BITS_PER_SI - 2)
+    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
+  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
+  return a.sign ? (-tmp) : (tmp);
+}
+EXPORT_SYMBOL(float_to_si);
+#endif /* L_sf_to_si || L_df_to_si */
+
+#if defined(L_sf_to_usi) || defined(L_df_to_usi) || defined(L_tf_to_usi)
+#if defined US_SOFTWARE_GOFAST || defined(L_tf_to_usi)
+/* While libgcc2.c defines its own __fixunssfsi and __fixunsdfsi routines,
+   we also define them for GOFAST because the ones in libgcc2.c have the
+   wrong names and I'd rather define these here and keep GOFAST CYG-LOC's
+   out of libgcc2.c.  We can't define these here if not GOFAST because then
+   there'd be duplicate copies.  */
+
+USItype
+float_to_usi (FLO_type arg_a)
+{
+  fp_number_type a;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &a);
+
+  if (iszero (&a))
+    return 0;
+  if (isnan (&a))
+    return 0;
+  /* it is a negative number */
+  if (a.sign)
+    return 0;
+  /* get reasonable MAX_USI_INT...  */
+  if (isinf (&a))
+    return MAX_USI_INT;
+  /* it is a number, but a small one */
+  if (a.normal_exp < 0)
+    return 0;
+  if (a.normal_exp > BITS_PER_SI - 1)
+    return MAX_USI_INT;
+  else if (a.normal_exp > (FRACBITS + NGARDS))
+    return a.fraction.ll << (a.normal_exp - (FRACBITS + NGARDS));
+  else
+    return a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
+}
+EXPORT_SYMBOL(float_to_usi);
+#endif /* US_SOFTWARE_GOFAST */
+#endif /* L_sf_to_usi || L_df_to_usi */
+
+#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
+FLO_type
+negate (FLO_type arg_a)
+{
+  fp_number_type a;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &a);
+
+  flip_sign (&a);
+  return pack_d (&a);
+}
+EXPORT_SYMBOL(negate);
+#endif /* L_negate_sf || L_negate_df */
+
+#ifdef FLOAT
+
+#if defined(L_make_sf)
+SFtype
+__make_fp(fp_class_type class,
+	     unsigned int sign,
+	     int exp, 
+	     USItype frac)
+{
+  fp_number_type in;
+
+  in.class = class;
+  in.sign = sign;
+  in.normal_exp = exp;
+  in.fraction.ll = frac;
+  return pack_d (&in);
+}
+#endif /* L_make_sf */
+
+#ifndef FLOAT_ONLY
+
+/* This enables one to build an fp library that supports float but not double.
+   Otherwise, we would get an undefined reference to __make_dp.
+   This is needed for some 8-bit ports that can't handle well values that
+   are 8-bytes in size, so we just don't support double for them at all.  */
+
+#if defined(L_sf_to_df)
+DFtype
+sf_to_df (SFtype arg_a)
+{
+  fp_number_type in;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  return __make_dp (in.class, in.sign, in.normal_exp,
+		    ((UDItype) in.fraction.ll) << F_D_BITOFF);
+}
+EXPORT_SYMBOL(sf_to_df);
+#endif /* L_sf_to_df */
+
+#if defined(L_sf_to_tf) && defined(TMODES)
+TFtype
+sf_to_tf (SFtype arg_a)
+{
+  fp_number_type in;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  return __make_tp (in.class, in.sign, in.normal_exp,
+		    ((UTItype) in.fraction.ll) << F_T_BITOFF);
+}
+EXPORT_SYMBOL(sf_to_tf);
+#endif /* L_sf_to_df */
+
+#endif /* ! FLOAT_ONLY */
+#endif /* FLOAT */
+
+#ifndef FLOAT
+
+extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);
+
+#if defined(L_make_df)
+DFtype
+__make_dp (fp_class_type class, unsigned int sign, int exp, UDItype frac)
+{
+  fp_number_type in;
+
+  in.class = class;
+  in.sign = sign;
+  in.normal_exp = exp;
+  in.fraction.ll = frac;
+  return pack_d (&in);
+}
+#endif /* L_make_df */
+
+#if defined(L_df_to_sf)
+SFtype
+df_to_sf (DFtype arg_a)
+{
+  fp_number_type in;
+  USItype sffrac;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  sffrac = in.fraction.ll >> F_D_BITOFF;
+
+  /* We set the lowest guard bit in SFFRAC if we discarded any non
+     zero bits.  */
+  if ((in.fraction.ll & (((USItype) 1 << F_D_BITOFF) - 1)) != 0)
+    sffrac |= 1;
+
+  return __make_fp (in.class, in.sign, in.normal_exp, sffrac);
+}
+EXPORT_SYMBOL(df_to_sf);
+#endif /* L_df_to_sf */
+
+#if defined(L_df_to_tf) && defined(TMODES) \
+    && !defined(FLOAT) && !defined(TFLOAT)
+TFtype
+df_to_tf (DFtype arg_a)
+{
+  fp_number_type in;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  return __make_tp (in.class, in.sign, in.normal_exp,
+		    ((UTItype) in.fraction.ll) << D_T_BITOFF);
+}
+EXPORT_SYMBOL(df_to_tf);
+#endif /* L_sf_to_df */
+
+#ifdef TFLOAT
+#if defined(L_make_tf)
+TFtype
+__make_tp(fp_class_type class,
+	     unsigned int sign,
+	     int exp, 
+	     UTItype frac)
+{
+  fp_number_type in;
+
+  in.class = class;
+  in.sign = sign;
+  in.normal_exp = exp;
+  in.fraction.ll = frac;
+  return pack_d (&in);
+}
+#endif /* L_make_tf */
+
+#if defined(L_tf_to_df)
+DFtype
+tf_to_df (TFtype arg_a)
+{
+  fp_number_type in;
+  UDItype sffrac;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  sffrac = in.fraction.ll >> D_T_BITOFF;
+
+  /* We set the lowest guard bit in SFFRAC if we discarded any non
+     zero bits.  */
+  if ((in.fraction.ll & (((UTItype) 1 << D_T_BITOFF) - 1)) != 0)
+    sffrac |= 1;
+
+  return __make_dp (in.class, in.sign, in.normal_exp, sffrac);
+}
+EXPORT_SYMBOL(tf_to_df);
+#endif /* L_tf_to_df */
+
+#if defined(L_tf_to_sf)
+SFtype
+tf_to_sf (TFtype arg_a)
+{
+  fp_number_type in;
+  USItype sffrac;
+  FLO_union_type au;
+
+  au.value = arg_a;
+  unpack_d (&au, &in);
+
+  sffrac = in.fraction.ll >> F_T_BITOFF;
+
+  /* We set the lowest guard bit in SFFRAC if we discarded any non
+     zero bits.  */
+  if ((in.fraction.ll & (((UTItype) 1 << F_T_BITOFF) - 1)) != 0)
+    sffrac |= 1;
+
+  return __make_fp (in.class, in.sign, in.normal_exp, sffrac);
+}
+EXPORT_SYMBOL(tf_to_sf);
+#endif /* L_tf_to_sf */
+#endif /* TFLOAT */
+
+#endif /* ! FLOAT */
+#endif /* !EXTENDED_FLOAT_STUBS */
+
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/softfloat/libgcc2.c tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/libgcc2.c
--- linux-2.6.36/arch/mips/softfloat/libgcc2.c	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/libgcc2.c	2019-03-07 03:40:18.000000000 +0200
@@ -0,0 +1,2036 @@
+/* More subroutines needed by GCC output code on some machines.  */
+/* Compile this one with gcc.  */
+/* Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+   2000, 2001, 2002  Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+/* It is incorrect to include config.h here, because this file is being
+   compiled for the target, and hence definitions concerning only the host
+   do not apply.  */
+//#include <linux/config.h>
+//#include <linux/slab.h>
+//#include <linux/module.h>
+//#ifdef CONFIG_KMOD
+//#include <linux/kmod.h>
+//#endif
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include "tconfig.h"
+//#include "tsystem.h"
+#include "stddef.h"
+#include "float.h"
+/* Don't use `fancy_abort' here even if config.h says to use it.  */
+#ifdef abort
+#undef abort
+#endif
+
+#define abort()  printk("libgcc2 abort.")
+
+#include "libgcc2.h"
+
+#ifdef DECLARE_LIBRARY_RENAMES
+  DECLARE_LIBRARY_RENAMES
+#endif
+
+#if defined (L_negdi2)
+DWtype
+__negdi2 (DWtype u)
+{
+  DWunion w;
+  DWunion uu;
+
+  uu.ll = u;
+
+  w.s.low = -uu.s.low;
+  w.s.high = -uu.s.high - ((UWtype) w.s.low > 0);
+
+  return w.ll;
+}
+#endif
+
+#ifdef L_addvsi3
+Wtype
+__addvsi3 (Wtype a, Wtype b)
+{
+  Wtype w;
+
+  w = a + b;
+
+  if (b >= 0 ? w < a : w > a)
+    abort ();
+
+  return w;
+}
+#endif
+
+#ifdef L_addvdi3
+DWtype
+__addvdi3 (DWtype a, DWtype b)
+{
+  DWtype w;
+
+  w = a + b;
+
+  if (b >= 0 ? w < a : w > a)
+    abort ();
+
+  return w;
+}
+#endif
+
+#ifdef L_subvsi3
+Wtype
+__subvsi3 (Wtype a, Wtype b)
+{
+#ifdef L_addvsi3
+  return __addvsi3 (a, (-b));
+#else
+  DWtype w;
+
+  w = a - b;
+
+  if (b >= 0 ? w > a : w < a)
+    abort ();
+
+  return w;
+#endif
+}
+#endif
+
+#ifdef L_subvdi3
+DWtype
+__subvdi3 (DWtype a, DWtype b)
+{
+#ifdef L_addvdi3
+  return (a, (-b));
+#else
+  DWtype w;
+
+  w = a - b;
+
+  if (b >= 0 ? w > a : w < a)
+    abort ();
+
+  return w;
+#endif
+}
+#endif
+
+#ifdef L_mulvsi3
+Wtype
+__mulvsi3 (Wtype a, Wtype b)
+{
+  DWtype w;
+
+  w = a * b;
+
+  if (((a >= 0) == (b >= 0)) ? w < 0 : w > 0)
+    abort ();
+
+  return w;
+}
+#endif
+
+#ifdef L_negvsi2
+Wtype
+__negvsi2 (Wtype a)
+{
+  Wtype w;
+
+  w  = -a;
+
+  if (a >= 0 ? w > 0 : w < 0)
+    abort ();
+
+   return w;
+}
+#endif
+
+#ifdef L_negvdi2
+DWtype
+__negvdi2 (DWtype a)
+{
+  DWtype w;
+
+  w  = -a;
+
+  if (a >= 0 ? w > 0 : w < 0)
+    abort ();
+
+  return w;
+}
+#endif
+
+#ifdef L_absvsi2
+Wtype
+__absvsi2 (Wtype a)
+{
+  Wtype w = a;
+
+  if (a < 0)
+#ifdef L_negvsi2
+    w = __negvsi2 (a);
+#else
+    w = -a;
+
+  if (w < 0)
+    abort ();
+#endif
+
+   return w;
+}
+#endif
+
+#ifdef L_absvdi2
+DWtype
+__absvdi2 (DWtype a)
+{
+  DWtype w = a;
+
+  if (a < 0)
+#ifdef L_negvsi2
+    w = __negvsi2 (a);
+#else
+    w = -a;
+
+  if (w < 0)
+    abort ();
+#endif
+
+  return w;
+}
+#endif
+
+#ifdef L_mulvdi3
+DWtype
+__mulvdi3 (DWtype u, DWtype v)
+{
+  DWtype w;
+
+  w = u * v;
+
+  if (((u >= 0) == (v >= 0)) ? w < 0 : w > 0)
+    abort ();
+
+  return w;
+}
+#endif
+
+
+/* Unless shift functions are defined whith full ANSI prototypes,
+   parameter b will be promoted to int if word_type is smaller than an int.  */
+#ifdef L_lshrdi3
+DWtype
+__lshrdi3 (DWtype u, word_type b)
+{
+  DWunion w;
+  word_type bm;
+  DWunion uu;
+
+  if (b == 0)
+    return u;
+
+  uu.ll = u;
+
+  bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;
+  if (bm <= 0)
+    {
+      w.s.high = 0;
+      w.s.low = (UWtype) uu.s.high >> -bm;
+    }
+  else
+    {
+      UWtype carries = (UWtype) uu.s.high << bm;
+
+      w.s.high = (UWtype) uu.s.high >> b;
+      w.s.low = ((UWtype) uu.s.low >> b) | carries;
+    }
+
+  return w.ll;
+}
+#endif
+
+#ifdef L_ashldi3
+DWtype
+__ashldi3 (DWtype u, word_type b)
+{
+  DWunion w;
+  word_type bm;
+  DWunion uu;
+
+  if (b == 0)
+    return u;
+
+  uu.ll = u;
+
+  bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;
+  if (bm <= 0)
+    {
+      w.s.low = 0;
+      w.s.high = (UWtype) uu.s.low << -bm;
+    }
+  else
+    {
+      UWtype carries = (UWtype) uu.s.low >> bm;
+
+      w.s.low = (UWtype) uu.s.low << b;
+      w.s.high = ((UWtype) uu.s.high << b) | carries;
+    }
+
+  return w.ll;
+}
+#endif
+
+#ifdef L_ashrdi3
+DWtype
+__ashrdi3 (DWtype u, word_type b)
+{
+  DWunion w;
+  word_type bm;
+  DWunion uu;
+
+  if (b == 0)
+    return u;
+
+  uu.ll = u;
+
+  bm = (sizeof (Wtype) * BITS_PER_UNIT) - b;
+  if (bm <= 0)
+    {
+      /* w.s.high = 1..1 or 0..0 */
+      w.s.high = uu.s.high >> (sizeof (Wtype) * BITS_PER_UNIT - 1);
+      w.s.low = uu.s.high >> -bm;
+    }
+  else
+    {
+      UWtype carries = (UWtype) uu.s.high << bm;
+
+      w.s.high = uu.s.high >> b;
+      w.s.low = ((UWtype) uu.s.low >> b) | carries;
+    }
+
+  return w.ll;
+}
+#endif
+
+#ifdef L_ffsdi2
+DWtype
+__ffsdi2 (DWtype u)
+{
+  DWunion uu;
+  UWtype word, count, add;
+
+  uu.ll = u;
+  if (uu.s.low != 0)
+    word = uu.s.low, add = 0;
+  else if (uu.s.high != 0)
+    word = uu.s.high, add = BITS_PER_UNIT * sizeof (Wtype);
+  else
+    return 0;
+
+  count_trailing_zeros (count, word);
+  return count + add + 1;
+}
+#endif
+
+#ifdef L_muldi3
+DWtype
+__muldi3 (DWtype u, DWtype v)
+{
+  DWunion w;
+  DWunion uu, vv;
+
+  uu.ll = u,
+  vv.ll = v;
+
+  w.ll = __umulsidi3 (uu.s.low, vv.s.low);
+  w.s.high += ((UWtype) uu.s.low * (UWtype) vv.s.high
+	       + (UWtype) uu.s.high * (UWtype) vv.s.low);
+
+  return w.ll;
+}
+#endif
+
+#if (defined (L_udivdi3) || defined (L_divdi3) || \
+     defined (L_umoddi3) || defined (L_moddi3))
+#if defined (sdiv_qrnnd)
+#define L_udiv_w_sdiv
+#endif
+#endif
+
+#ifdef L_udiv_w_sdiv
+#if defined (sdiv_qrnnd)
+#if (defined (L_udivdi3) || defined (L_divdi3) || \
+     defined (L_umoddi3) || defined (L_moddi3))
+static inline __attribute__ ((__always_inline__))
+#endif
+UWtype
+__udiv_w_sdiv (UWtype *rp, UWtype a1, UWtype a0, UWtype d)
+{
+  UWtype q, r;
+  UWtype c0, c1, b1;
+
+  if ((Wtype) d >= 0)
+    {
+      if (a1 < d - a1 - (a0 >> (W_TYPE_SIZE - 1)))
+	{
+	  /* dividend, divisor, and quotient are nonnegative */
+	  sdiv_qrnnd (q, r, a1, a0, d);
+	}
+      else
+	{
+	  /* Compute c1*2^32 + c0 = a1*2^32 + a0 - 2^31*d */
+	  sub_ddmmss (c1, c0, a1, a0, d >> 1, d << (W_TYPE_SIZE - 1));
+	  /* Divide (c1*2^32 + c0) by d */
+	  sdiv_qrnnd (q, r, c1, c0, d);
+	  /* Add 2^31 to quotient */
+	  q += (UWtype) 1 << (W_TYPE_SIZE - 1);
+	}
+    }
+  else
+    {
+      b1 = d >> 1;			/* d/2, between 2^30 and 2^31 - 1 */
+      c1 = a1 >> 1;			/* A/2 */
+      c0 = (a1 << (W_TYPE_SIZE - 1)) + (a0 >> 1);
+
+      if (a1 < b1)			/* A < 2^32*b1, so A/2 < 2^31*b1 */
+	{
+	  sdiv_qrnnd (q, r, c1, c0, b1); /* (A/2) / (d/2) */
+
+	  r = 2*r + (a0 & 1);		/* Remainder from A/(2*b1) */
+	  if ((d & 1) != 0)
+	    {
+	      if (r >= q)
+		r = r - q;
+	      else if (q - r <= d)
+		{
+		  r = r - q + d;
+		  q--;
+		}
+	      else
+		{
+		  r = r - q + 2*d;
+		  q -= 2;
+		}
+	    }
+	}
+      else if (c1 < b1)			/* So 2^31 <= (A/2)/b1 < 2^32 */
+	{
+	  c1 = (b1 - 1) - c1;
+	  c0 = ~c0;			/* logical NOT */
+
+	  sdiv_qrnnd (q, r, c1, c0, b1); /* (A/2) / (d/2) */
+
+	  q = ~q;			/* (A/2)/b1 */
+	  r = (b1 - 1) - r;
+
+	  r = 2*r + (a0 & 1);		/* A/(2*b1) */
+
+	  if ((d & 1) != 0)
+	    {
+	      if (r >= q)
+		r = r - q;
+	      else if (q - r <= d)
+		{
+		  r = r - q + d;
+		  q--;
+		}
+	      else
+		{
+		  r = r - q + 2*d;
+		  q -= 2;
+		}
+	    }
+	}
+      else				/* Implies c1 = b1 */
+	{				/* Hence a1 = d - 1 = 2*b1 - 1 */
+	  if (a0 >= -d)
+	    {
+	      q = -1;
+	      r = a0 + d;
+	    }
+	  else
+	    {
+	      q = -2;
+	      r = a0 + 2*d;
+	    }
+	}
+    }
+
+  *rp = r;
+  return q;
+}
+#else
+/* If sdiv_qrnnd doesn't exist, define dummy __udiv_w_sdiv.  */
+UWtype
+__udiv_w_sdiv (UWtype *rp __attribute__ ((__unused__)),
+	       UWtype a1 __attribute__ ((__unused__)),
+	       UWtype a0 __attribute__ ((__unused__)),
+	       UWtype d __attribute__ ((__unused__)))
+{
+  return 0;
+}
+#endif
+#endif
+
+#if (defined (L_udivdi3) || defined (L_divdi3) || \
+     defined (L_umoddi3) || defined (L_moddi3))
+#define L_udivmoddi4
+#endif
+
+#ifdef L_clz
+const UQItype __clz_tab[] =
+{
+  0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+};
+#endif
+
+#ifdef L_udivmoddi4
+
+#if (defined (L_udivdi3) || defined (L_divdi3) || \
+     defined (L_umoddi3) || defined (L_moddi3))
+static inline __attribute__ ((__always_inline__))
+#endif
+UDWtype
+__udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)
+{
+  DWunion ww;
+  DWunion nn, dd;
+  DWunion rr;
+  UWtype d0, d1, n0, n1, n2;
+  UWtype q0, q1;
+  UWtype b, bm;
+
+  nn.ll = n;
+  dd.ll = d;
+
+  d0 = dd.s.low;
+  d1 = dd.s.high;
+  n0 = nn.s.low;
+  n1 = nn.s.high;
+
+#if !UDIV_NEEDS_NORMALIZATION
+  if (d1 == 0)
+    {
+      if (d0 > n1)
+	{
+	  /* 0q = nn / 0D */
+
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+	  q1 = 0;
+
+	  /* Remainder in n0.  */
+	}
+      else
+	{
+	  /* qq = NN / 0d */
+
+	  if (d0 == 0)
+	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
+
+	  udiv_qrnnd (q1, n1, 0, n1, d0);
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+
+	  /* Remainder in n0.  */
+	}
+
+      if (rp != 0)
+	{
+	  rr.s.low = n0;
+	  rr.s.high = 0;
+	  *rp = rr.ll;
+	}
+    }
+
+#else /* UDIV_NEEDS_NORMALIZATION */
+
+  if (d1 == 0)
+    {
+      if (d0 > n1)
+	{
+	  /* 0q = nn / 0D */
+
+	  count_leading_zeros (bm, d0);
+
+	  if (bm != 0)
+	    {
+	      /* Normalize, i.e. make the most significant bit of the
+		 denominator set.  */
+
+	      d0 = d0 << bm;
+	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
+	      n0 = n0 << bm;
+	    }
+
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+	  q1 = 0;
+
+	  /* Remainder in n0 >> bm.  */
+	}
+      else
+	{
+	  /* qq = NN / 0d */
+
+	  if (d0 == 0)
+	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
+
+	  count_leading_zeros (bm, d0);
+
+	  if (bm == 0)
+	    {
+	      /* From (n1 >= d0) /\ (the most significant bit of d0 is set),
+		 conclude (the most significant bit of n1 is set) /\ (the
+		 leading quotient digit q1 = 1).
+
+		 This special case is necessary, not an optimization.
+		 (Shifts counts of W_TYPE_SIZE are undefined.)  */
+
+	      n1 -= d0;
+	      q1 = 1;
+	    }
+	  else
+	    {
+	      /* Normalize.  */
+
+	      b = W_TYPE_SIZE - bm;
+
+	      d0 = d0 << bm;
+	      n2 = n1 >> b;
+	      n1 = (n1 << bm) | (n0 >> b);
+	      n0 = n0 << bm;
+
+	      udiv_qrnnd (q1, n1, n2, n1, d0);
+	    }
+
+	  /* n1 != d0...  */
+
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+
+	  /* Remainder in n0 >> bm.  */
+	}
+
+      if (rp != 0)
+	{
+	  rr.s.low = n0 >> bm;
+	  rr.s.high = 0;
+	  *rp = rr.ll;
+	}
+    }
+#endif /* UDIV_NEEDS_NORMALIZATION */
+
+  else
+    {
+      if (d1 > n1)
+	{
+	  /* 00 = nn / DD */
+
+	  q0 = 0;
+	  q1 = 0;
+
+	  /* Remainder in n1n0.  */
+	  if (rp != 0)
+	    {
+	      rr.s.low = n0;
+	      rr.s.high = n1;
+	      *rp = rr.ll;
+	    }
+	}
+      else
+	{
+	  /* 0q = NN / dd */
+
+	  count_leading_zeros (bm, d1);
+	  if (bm == 0)
+	    {
+	      /* From (n1 >= d1) /\ (the most significant bit of d1 is set),
+		 conclude (the most significant bit of n1 is set) /\ (the
+		 quotient digit q0 = 0 or 1).
+
+		 This special case is necessary, not an optimization.  */
+
+	      /* The condition on the next line takes advantage of that
+		 n1 >= d1 (true due to program flow).  */
+	      if (n1 > d1 || n0 >= d0)
+		{
+		  q0 = 1;
+		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
+		}
+	      else
+		q0 = 0;
+
+	      q1 = 0;
+
+	      if (rp != 0)
+		{
+		  rr.s.low = n0;
+		  rr.s.high = n1;
+		  *rp = rr.ll;
+		}
+	    }
+	  else
+	    {
+	      UWtype m1, m0;
+	      /* Normalize.  */
+
+	      b = W_TYPE_SIZE - bm;
+
+	      d1 = (d1 << bm) | (d0 >> b);
+	      d0 = d0 << bm;
+	      n2 = n1 >> b;
+	      n1 = (n1 << bm) | (n0 >> b);
+	      n0 = n0 << bm;
+
+	      udiv_qrnnd (q0, n1, n2, n1, d1);
+	      umul_ppmm (m1, m0, q0, d0);
+
+	      if (m1 > n1 || (m1 == n1 && m0 > n0))
+		{
+		  q0--;
+		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
+		}
+
+	      q1 = 0;
+
+	      /* Remainder in (n1n0 - m1m0) >> bm.  */
+	      if (rp != 0)
+		{
+		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
+		  rr.s.low = (n1 << b) | (n0 >> bm);
+		  rr.s.high = n1 >> bm;
+		  *rp = rr.ll;
+		}
+	    }
+	}
+    }
+
+  ww.s.low = q0;
+  ww.s.high = q1;
+  return ww.ll;
+}
+#endif
+
+#ifdef L_divdi3
+DWtype
+__divdi3 (DWtype u, DWtype v)
+{
+  word_type c = 0;
+  DWunion uu, vv;
+  DWtype w;
+
+  uu.ll = u;
+  vv.ll = v;
+
+  if (uu.s.high < 0)
+    c = ~c,
+    uu.ll = -uu.ll;
+  if (vv.s.high < 0)
+    c = ~c,
+    vv.ll = -vv.ll;
+
+  w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);
+  if (c)
+    w = -w;
+
+  return w;
+}
+#endif
+
+#ifdef L_moddi3
+DWtype
+__moddi3 (DWtype u, DWtype v)
+{
+  word_type c = 0;
+  DWunion uu, vv;
+  DWtype w;
+
+  uu.ll = u;
+  vv.ll = v;
+
+  if (uu.s.high < 0)
+    c = ~c,
+    uu.ll = -uu.ll;
+  if (vv.s.high < 0)
+    vv.ll = -vv.ll;
+
+  (void) __udivmoddi4 (uu.ll, vv.ll, &w);
+  if (c)
+    w = -w;
+
+  return w;
+}
+#endif
+
+#ifdef L_umoddi3
+UDWtype
+__umoddi3 (UDWtype u, UDWtype v)
+{
+  UDWtype w;
+
+  (void) __udivmoddi4 (u, v, &w);
+
+  return w;
+}
+#endif
+
+#ifdef L_udivdi3
+UDWtype
+__udivdi3 (UDWtype n, UDWtype d)
+{
+  return __udivmoddi4 (n, d, (UDWtype *) 0);
+}
+#endif
+
+#ifdef L_cmpdi2
+word_type
+__cmpdi2 (DWtype a, DWtype b)
+{
+  DWunion au, bu;
+
+  au.ll = a, bu.ll = b;
+
+  if (au.s.high < bu.s.high)
+    return 0;
+  else if (au.s.high > bu.s.high)
+    return 2;
+  if ((UWtype) au.s.low < (UWtype) bu.s.low)
+    return 0;
+  else if ((UWtype) au.s.low > (UWtype) bu.s.low)
+    return 2;
+  return 1;
+}
+#endif
+
+#ifdef L_ucmpdi2
+word_type
+__ucmpdi2 (DWtype a, DWtype b)
+{
+  DWunion au, bu;
+
+  au.ll = a, bu.ll = b;
+
+  if ((UWtype) au.s.high < (UWtype) bu.s.high)
+    return 0;
+  else if ((UWtype) au.s.high > (UWtype) bu.s.high)
+    return 2;
+  if ((UWtype) au.s.low < (UWtype) bu.s.low)
+    return 0;
+  else if ((UWtype) au.s.low > (UWtype) bu.s.low)
+    return 2;
+  return 1;
+}
+#endif
+
+#if defined(L_fixunstfdi) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)
+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)
+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)
+
+DWtype
+__fixunstfDI (TFtype a)
+{
+  TFtype b;
+  UDWtype v;
+
+  if (a < 0)
+    return 0;
+
+  /* Compute high word of result, as a flonum.  */
+  b = (a / HIGH_WORD_COEFF);
+  /* Convert that to fixed (but not to DWtype!),
+     and shift it into the high word.  */
+  v = (UWtype) b;
+  v <<= WORD_SIZE;
+  /* Remove high part from the TFtype, leaving the low part as flonum.  */
+  a -= (TFtype)v;
+  /* Convert that to fixed (but not to DWtype!) and add it in.
+     Sometimes A comes out negative.  This is significant, since
+     A has more bits than a long int does.  */
+  if (a < 0)
+    v -= (UWtype) (- a);
+  else
+    v += (UWtype) a;
+  return v;
+}
+#endif
+
+#if defined(L_fixtfdi) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)
+DWtype
+__fixtfdi (TFtype a)
+{
+  if (a < 0)
+    return - __fixunstfDI (-a);
+  return __fixunstfDI (a);
+}
+#endif
+
+#if defined(L_fixunsxfdi) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96)
+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)
+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)
+
+DWtype
+__fixunsxfDI (XFtype a)
+{
+  XFtype b;
+  UDWtype v;
+
+  if (a < 0)
+    return 0;
+
+  /* Compute high word of result, as a flonum.  */
+  b = (a / HIGH_WORD_COEFF);
+  /* Convert that to fixed (but not to DWtype!),
+     and shift it into the high word.  */
+  v = (UWtype) b;
+  v <<= WORD_SIZE;
+  /* Remove high part from the XFtype, leaving the low part as flonum.  */
+  a -= (XFtype)v;
+  /* Convert that to fixed (but not to DWtype!) and add it in.
+     Sometimes A comes out negative.  This is significant, since
+     A has more bits than a long int does.  */
+  if (a < 0)
+    v -= (UWtype) (- a);
+  else
+    v += (UWtype) a;
+  return v;
+}
+#endif
+
+#if defined(L_fixxfdi) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96)
+DWtype
+__fixxfdi (XFtype a)
+{
+  if (a < 0)
+    return - __fixunsxfDI (-a);
+  return __fixunsxfDI (a);
+}
+#endif
+
+#ifdef L_fixunsdfdi
+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)
+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)
+
+DWtype
+__fixunsdfDI (DFtype a)
+{
+  DFtype b;
+  UDWtype v;
+
+  if (a < 0)
+    return 0;
+
+  /* Compute high word of result, as a flonum.  */
+  b = (a / HIGH_WORD_COEFF);
+  /* Convert that to fixed (but not to DWtype!),
+     and shift it into the high word.  */
+  v = (UWtype) b;
+  v <<= WORD_SIZE;
+  /* Remove high part from the DFtype, leaving the low part as flonum.  */
+  a -= (DFtype)v;
+  /* Convert that to fixed (but not to DWtype!) and add it in.
+     Sometimes A comes out negative.  This is significant, since
+     A has more bits than a long int does.  */
+  if (a < 0)
+    v -= (UWtype) (- a);
+  else
+    v += (UWtype) a;
+  return v;
+}
+#endif
+
+#ifdef L_fixdfdi
+DWtype
+__fixdfdi (DFtype a)
+{
+  if (a < 0)
+    return - __fixunsdfDI (-a);
+  return __fixunsdfDI (a);
+}
+#endif
+
+#ifdef L_fixunssfdi
+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)
+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)
+
+DWtype
+__fixunssfDI (SFtype original_a)
+{
+  /* Convert the SFtype to a DFtype, because that is surely not going
+     to lose any bits.  Some day someone else can write a faster version
+     that avoids converting to DFtype, and verify it really works right.  */
+  DFtype a = original_a;
+  DFtype b;
+  UDWtype v;
+
+  if (a < 0)
+    return 0;
+
+  /* Compute high word of result, as a flonum.  */
+  b = (a / HIGH_WORD_COEFF);
+  /* Convert that to fixed (but not to DWtype!),
+     and shift it into the high word.  */
+  v = (UWtype) b;
+  v <<= WORD_SIZE;
+  /* Remove high part from the DFtype, leaving the low part as flonum.  */
+  a -= (DFtype) v;
+  /* Convert that to fixed (but not to DWtype!) and add it in.
+     Sometimes A comes out negative.  This is significant, since
+     A has more bits than a long int does.  */
+  if (a < 0)
+    v -= (UWtype) (- a);
+  else
+    v += (UWtype) a;
+  return v;
+}
+#endif
+
+#ifdef L_fixsfdi
+DWtype
+__fixsfdi (SFtype a)
+{
+  if (a < 0)
+    return - __fixunssfDI (-a);
+  return __fixunssfDI (a);
+}
+#endif
+
+#if defined(L_floatdixf) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96)
+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)
+#define HIGH_HALFWORD_COEFF (((UDWtype) 1) << (WORD_SIZE / 2))
+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)
+
+XFtype
+__floatdixf (DWtype u)
+{
+  XFtype d;
+
+  d = (Wtype) (u >> WORD_SIZE);
+  d *= HIGH_HALFWORD_COEFF;
+  d *= HIGH_HALFWORD_COEFF;
+  d += (UWtype) (u & (HIGH_WORD_COEFF - 1));
+
+  return d;
+}
+#endif
+
+#if defined(L_floatditf) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)
+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)
+#define HIGH_HALFWORD_COEFF (((UDWtype) 1) << (WORD_SIZE / 2))
+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)
+
+TFtype
+__floatditf (DWtype u)
+{
+  TFtype d;
+
+  d = (Wtype) (u >> WORD_SIZE);
+  d *= HIGH_HALFWORD_COEFF;
+  d *= HIGH_HALFWORD_COEFF;
+  d += (UWtype) (u & (HIGH_WORD_COEFF - 1));
+
+  return d;
+}
+#endif
+
+#ifdef L_floatdidf
+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)
+#define HIGH_HALFWORD_COEFF (((UDWtype) 1) << (WORD_SIZE / 2))
+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)
+
+DFtype
+__floatdidf (DWtype u)
+{
+  DFtype d;
+
+  d = (Wtype) (u >> WORD_SIZE);
+  d *= HIGH_HALFWORD_COEFF;
+  d *= HIGH_HALFWORD_COEFF;
+  d += (UWtype) (u & (HIGH_WORD_COEFF - 1));
+
+  return d;
+}
+#endif
+
+#ifdef L_floatundidf
+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)
+#define HIGH_HALFWORD_COEFF (((UDWtype) 1) << (WORD_SIZE / 2))
+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)
+
+DFtype
+__floatundidf (UDWtype u)
+{
+  DFtype d;
+
+  d = (UWtype) (u >> WORD_SIZE);
+  d *= HIGH_HALFWORD_COEFF;
+  d *= HIGH_HALFWORD_COEFF;
+  d += (UWtype) (u & (HIGH_WORD_COEFF - 1));
+
+  return d;
+}
+#endif
+
+#ifdef L_floatdisf
+#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)
+#define HIGH_HALFWORD_COEFF (((UDWtype) 1) << (WORD_SIZE / 2))
+#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)
+
+#define DI_SIZE (sizeof (DWtype) * BITS_PER_UNIT)
+#define DF_SIZE DBL_MANT_DIG
+#define SF_SIZE FLT_MANT_DIG
+
+SFtype
+__floatdisf (DWtype u)
+{
+  /* Do the calculation in DFmode
+     so that we don't lose any of the precision of the high word
+     while multiplying it.  */
+  DFtype f;
+
+  /* Protect against double-rounding error.
+     Represent any low-order bits, that might be truncated in DFmode,
+     by a bit that won't be lost.  The bit can go in anywhere below the
+     rounding position of the SFmode.  A fixed mask and bit position
+     handles all usual configurations.  It doesn't handle the case
+     of 128-bit DImode, however.  */
+  if (DF_SIZE < DI_SIZE
+      && DF_SIZE > (DI_SIZE - DF_SIZE + SF_SIZE))
+    {
+#define REP_BIT ((UDWtype) 1 << (DI_SIZE - DF_SIZE))
+      if (! (- ((DWtype) 1 << DF_SIZE) < u
+	     && u < ((DWtype) 1 << DF_SIZE)))
+	{
+	  if ((UDWtype) u & (REP_BIT - 1))
+	    {
+	      u &= ~ (REP_BIT - 1);
+	      u |= REP_BIT;
+	    }
+	}
+    }
+  f = (Wtype) (u >> WORD_SIZE);
+  f *= HIGH_HALFWORD_COEFF;
+  f *= HIGH_HALFWORD_COEFF;
+  f += (UWtype) (u & (HIGH_WORD_COEFF - 1));
+
+  return (SFtype) f;
+}
+#endif
+
+#if defined(L_fixunsxfsi) && LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96
+/* Reenable the normal types, in case limits.h needs them.  */
+#undef char
+#undef short
+#undef int
+#undef long
+#undef unsigned
+#undef float
+#undef double
+#undef MIN
+#undef MAX
+#include <limits.h>
+
+UWtype
+__fixunsxfSI (XFtype a)
+{
+  if (a >= - (DFtype) Wtype_MIN)
+    return (Wtype) (a + Wtype_MIN) - Wtype_MIN;
+  return (Wtype) a;
+}
+#endif
+
+#ifdef L_fixunsdfsi
+/* Reenable the normal types, in case limits.h needs them.  */
+#undef char
+#undef short
+#undef int
+#undef long
+#undef unsigned
+#undef float
+#undef double
+#undef MIN
+#undef MAX
+//#include <limits.h>
+
+UWtype
+__fixunsdfSI (DFtype a)
+{
+  if (a >= - (DFtype) Wtype_MIN)
+    return (Wtype) (a + Wtype_MIN) - Wtype_MIN;
+  return (Wtype) a;
+}
+EXPORT_SYMBOL(__fixunsdfSI);
+#endif
+
+#ifdef L_fixunssfsi
+/* Reenable the normal types, in case limits.h needs them.  */
+#undef char
+#undef short
+#undef int
+#undef long
+#undef unsigned
+#undef float
+#undef double
+#undef MIN
+#undef MAX
+//#include <limits.h>
+
+UWtype
+__fixunssfSI (SFtype a)
+{
+  if (a >= - (SFtype) Wtype_MIN)
+    return (Wtype) (a + Wtype_MIN) - Wtype_MIN;
+  return (Wtype) a;
+}
+EXPORT_SYMBOL(__fixunssfSI);
+#endif
+
+/* From here on down, the routines use normal data types.  */
+
+#define SItype bogus_type
+#define USItype bogus_type
+#define DItype bogus_type
+#define UDItype bogus_type
+#define SFtype bogus_type
+#define DFtype bogus_type
+#undef Wtype
+#undef UWtype
+#undef HWtype
+#undef UHWtype
+#undef DWtype
+#undef UDWtype
+
+#undef char
+#undef short
+#undef int
+#undef long
+#undef unsigned
+#undef float
+#undef double
+
+#ifdef L_divdi3
+EXPORT_SYMBOL(__divdi3);
+#endif
+#ifdef L_moddi3
+EXPORT_SYMBOL(__moddi3);
+#endif
+#ifdef L_udivdi3
+EXPORT_SYMBOL(__udivdi3);
+#endif
+#ifdef L__gcc_bcmp
+
+/* Like bcmp except the sign is meaningful.
+   Result is negative if S1 is less than S2,
+   positive if S1 is greater, 0 if S1 and S2 are equal.  */
+
+int
+__gcc_bcmp (const unsigned char *s1, const unsigned char *s2, size_t size)
+{
+  while (size > 0)
+    {
+      unsigned char c1 = *s1++, c2 = *s2++;
+      if (c1 != c2)
+	return c1 - c2;
+      size--;
+    }
+  return 0;
+}
+
+#endif
+
+/* __eprintf used to be used by GCC's private version of <assert.h>.
+   We no longer provide that header, but this routine remains in libgcc.a
+   for binary backward compatibility.  Note that it is not included in
+   the shared version of libgcc.  */
+#ifdef L_eprintf
+#ifndef inhibit_libc
+
+#undef NULL /* Avoid errors if stdio.h and our stddef.h mismatch.  */
+#include <stdio.h>
+
+void
+__eprintf (const char *string, const char *expression,
+	   unsigned int line, const char *filename)
+{
+  fprintf (stderr, string, expression, line, filename);
+  fflush (stderr);
+  abort ();
+}
+
+#endif
+#endif
+
+#ifdef L_bb
+
+struct bb_function_info {
+  long checksum;
+  int arc_count;
+  const char *name;
+};
+
+/* Structure emitted by --profile-arcs  */
+struct bb
+{
+  long zero_word;
+  const char *filename;
+  gcov_type *counts;
+  long ncounts;
+  struct bb *next;
+
+  /* Older GCC's did not emit these fields.  */
+  long sizeof_bb;
+  struct bb_function_info *function_infos;
+};
+
+#ifndef inhibit_libc
+
+/* Arc profile dumper. Requires atexit and stdio.  */
+
+#undef NULL /* Avoid errors if stdio.h and our stddef.h mismatch.  */
+#include <stdio.h>
+
+#include "gcov-io.h"
+#include <string.h>
+#ifdef TARGET_HAS_F_SETLKW
+#include <fcntl.h>
+#include <errno.h>
+#endif
+
+/* Chain of per-object file bb structures.  */
+static struct bb *bb_head;
+
+/* Dump the coverage counts. We merge with existing counts when
+   possible, to avoid growing the .da files ad infinitum.  */
+
+void
+__bb_exit_func (void)
+{
+  struct bb *ptr;
+  int i;
+  gcov_type program_sum = 0;
+  gcov_type program_max = 0;
+  long program_arcs = 0;
+  gcov_type merged_sum = 0;
+  gcov_type merged_max = 0;
+  long merged_arcs = 0;
+  
+#if defined (TARGET_HAS_F_SETLKW)
+  struct flock s_flock;
+
+  s_flock.l_type = F_WRLCK;
+  s_flock.l_whence = SEEK_SET;
+  s_flock.l_start = 0;
+  s_flock.l_len = 0; /* Until EOF.  */
+  s_flock.l_pid = getpid ();
+#endif
+
+  /* Non-merged stats for this program.  */
+  for (ptr = bb_head; ptr; ptr = ptr->next)
+    {
+      for (i = 0; i < ptr->ncounts; i++)
+	{
+	  program_sum += ptr->counts[i];
+
+	  if (ptr->counts[i] > program_max)
+	    program_max = ptr->counts[i];
+	}
+      program_arcs += ptr->ncounts;
+    }
+  
+  for (ptr = bb_head; ptr; ptr = ptr->next)
+    {
+      FILE *da_file;
+      gcov_type object_max = 0;
+      gcov_type object_sum = 0;
+      long object_functions = 0;
+      int merging = 0;
+      int error = 0;
+      struct bb_function_info *fn_info;
+      gcov_type *count_ptr;
+      
+      /* Open for modification */
+      da_file = fopen (ptr->filename, "r+b");
+      
+      if (da_file)
+	merging = 1;
+      else
+	{
+	  /* Try for appending */
+	  da_file = fopen (ptr->filename, "ab");
+	  /* Some old systems might not allow the 'b' mode modifier.
+             Therefore, try to open without it.  This can lead to a
+             race condition so that when you delete and re-create the
+             file, the file might be opened in text mode, but then,
+             you shouldn't delete the file in the first place.  */
+	  if (!da_file)
+	    da_file = fopen (ptr->filename, "a");
+	}
+      
+      if (!da_file)
+	{
+	  fprintf (stderr, "arc profiling: Can't open output file %s.\n",
+		   ptr->filename);
+	  ptr->filename = 0;
+	  continue;
+	}
+
+#if defined (TARGET_HAS_F_SETLKW)
+      /* After a fork, another process might try to read and/or write
+         the same file simultanously.  So if we can, lock the file to
+         avoid race conditions.  */
+      while (fcntl (fileno (da_file), F_SETLKW, &s_flock)
+	     && errno == EINTR)
+	continue;
+#endif
+      for (fn_info = ptr->function_infos; fn_info->arc_count != -1; fn_info++)
+	object_functions++;
+
+      if (merging)
+	{
+	  /* Merge data from file.  */
+	  long tmp_long;
+	  gcov_type tmp_gcov;
+	  
+	  if (/* magic */
+	      (__read_long (&tmp_long, da_file, 4) || tmp_long != -123l)
+	      /* functions in object file.  */
+	      || (__read_long (&tmp_long, da_file, 4)
+		  || tmp_long != object_functions)
+	      /* extension block, skipped */
+	      || (__read_long (&tmp_long, da_file, 4)
+		  || fseek (da_file, tmp_long, SEEK_CUR)))
+	    {
+	    read_error:;
+	      fprintf (stderr, "arc profiling: Error merging output file %s.\n",
+		       ptr->filename);
+	      clearerr (da_file);
+	    }
+	  else
+	    {
+	      /* Merge execution counts for each function.  */
+	      count_ptr = ptr->counts;
+	      
+	      for (fn_info = ptr->function_infos; fn_info->arc_count != -1;
+		   fn_info++)
+		{
+		  if (/* function name delim */
+		      (__read_long (&tmp_long, da_file, 4)
+		       || tmp_long != -1)
+		      /* function name length */
+		      || (__read_long (&tmp_long, da_file, 4)
+			  || tmp_long != (long) strlen (fn_info->name))
+		      /* skip string */
+		      || fseek (da_file, ((tmp_long + 1) + 3) & ~3, SEEK_CUR)
+		      /* function name delim */
+		      || (__read_long (&tmp_long, da_file, 4)
+			  || tmp_long != -1))
+		    goto read_error;
+
+		  if (/* function checksum */
+		      (__read_long (&tmp_long, da_file, 4)
+		       || tmp_long != fn_info->checksum)
+		      /* arc count */
+		      || (__read_long (&tmp_long, da_file, 4)
+			  || tmp_long != fn_info->arc_count))
+		    goto read_error;
+		  
+		  for (i = fn_info->arc_count; i > 0; i--, count_ptr++)
+		    if (__read_gcov_type (&tmp_gcov, da_file, 8))
+		      goto read_error;
+		    else
+		      *count_ptr += tmp_gcov;
+		}
+	    }
+	  fseek (da_file, 0, SEEK_SET);
+	}
+      
+      /* Calculate the per-object statistics.  */
+      for (i = 0; i < ptr->ncounts; i++)
+	{
+	  object_sum += ptr->counts[i];
+
+	  if (ptr->counts[i] > object_max)
+	    object_max = ptr->counts[i];
+	}
+      merged_sum += object_sum;
+      if (merged_max < object_max)
+	merged_max = object_max;
+      merged_arcs += ptr->ncounts;
+      
+      /* Write out the data.  */
+      if (/* magic */
+	  __write_long (-123, da_file, 4)
+	  /* number of functions in object file.  */
+	  || __write_long (object_functions, da_file, 4)
+	  /* length of extra data in bytes.  */
+	  || __write_long ((4 + 8 + 8) + (4 + 8 + 8), da_file, 4)
+
+	  /* whole program statistics. If merging write per-object
+	     now, rewrite later */
+	  /* number of instrumented arcs.  */
+	  || __write_long (merging ? ptr->ncounts : program_arcs, da_file, 4)
+	  /* sum of counters.  */
+	  || __write_gcov_type (merging ? object_sum : program_sum, da_file, 8)
+	  /* maximal counter.  */
+	  || __write_gcov_type (merging ? object_max : program_max, da_file, 8)
+
+	  /* per-object statistics.  */
+	  /* number of counters.  */
+	  || __write_long (ptr->ncounts, da_file, 4)
+	  /* sum of counters.  */
+	  || __write_gcov_type (object_sum, da_file, 8)
+	  /* maximal counter.  */
+	  || __write_gcov_type (object_max, da_file, 8))
+	{
+	write_error:;
+	  fprintf (stderr, "arc profiling: Error writing output file %s.\n",
+		   ptr->filename);
+	  error = 1;
+	}
+      else
+	{
+	  /* Write execution counts for each function.  */
+	  count_ptr = ptr->counts;
+
+	  for (fn_info = ptr->function_infos; fn_info->arc_count != -1;
+	       fn_info++)
+	    {
+	      if (__write_gcov_string (fn_info->name,
+				       strlen (fn_info->name), da_file, -1)
+		  || __write_long (fn_info->checksum, da_file, 4)
+		  || __write_long (fn_info->arc_count, da_file, 4))
+		goto write_error;
+	      
+	      for (i = fn_info->arc_count; i > 0; i--, count_ptr++)
+		if (__write_gcov_type (*count_ptr, da_file, 8))
+		  goto write_error; /* RIP Edsger Dijkstra */
+	    }
+	}
+
+      if (fclose (da_file))
+	{
+	  fprintf (stderr, "arc profiling: Error closing output file %s.\n",
+		   ptr->filename);
+	  error = 1;
+	}
+      if (error || !merging)
+	ptr->filename = 0;
+    }
+
+  /* Upate whole program statistics.  */
+  for (ptr = bb_head; ptr; ptr = ptr->next)
+    if (ptr->filename)
+      {
+	FILE *da_file;
+	
+	da_file = fopen (ptr->filename, "r+b");
+	if (!da_file)
+	  {
+	    fprintf (stderr, "arc profiling: Cannot reopen %s.\n",
+		     ptr->filename);
+	    continue;
+	  }
+	
+#if defined (TARGET_HAS_F_SETLKW)
+	while (fcntl (fileno (da_file), F_SETLKW, &s_flock)
+	       && errno == EINTR)
+	  continue;
+#endif
+	
+	if (fseek (da_file, 4 * 3, SEEK_SET)
+	    /* number of instrumented arcs.  */
+	    || __write_long (merged_arcs, da_file, 4)
+	    /* sum of counters.  */
+	    || __write_gcov_type (merged_sum, da_file, 8)
+	    /* maximal counter.  */
+	    || __write_gcov_type (merged_max, da_file, 8))
+	  fprintf (stderr, "arc profiling: Error updating program header %s.\n",
+		   ptr->filename);
+	if (fclose (da_file))
+	  fprintf (stderr, "arc profiling: Error reclosing %s\n",
+		   ptr->filename);
+      }
+}
+
+/* Add a new object file onto the bb chain.  Invoked automatically
+   when running an object file's global ctors.  */
+
+void
+__bb_init_func (struct bb *blocks)
+{
+  if (blocks->zero_word)
+    return;
+
+  /* Initialize destructor and per-thread data.  */
+  if (!bb_head)
+    atexit (__bb_exit_func);
+
+  /* Set up linked list.  */
+  blocks->zero_word = 1;
+  blocks->next = bb_head;
+  bb_head = blocks;
+}
+
+/* Called before fork or exec - write out profile information gathered so
+   far and reset it to zero.  This avoids duplication or loss of the
+   profile information gathered so far.  */
+
+void
+__bb_fork_func (void)
+{
+  struct bb *ptr;
+
+  __bb_exit_func ();
+  for (ptr = bb_head; ptr != (struct bb *) 0; ptr = ptr->next)
+    {
+      long i;
+      for (i = ptr->ncounts - 1; i >= 0; i--)
+	ptr->counts[i] = 0;
+    }
+}
+
+#endif /* not inhibit_libc */
+#endif /* L_bb */
+
+#ifdef L_clear_cache
+/* Clear part of an instruction cache.  */
+
+#define INSN_CACHE_PLANE_SIZE (INSN_CACHE_SIZE / INSN_CACHE_DEPTH)
+
+void
+__clear_cache (char *beg __attribute__((__unused__)),
+	       char *end __attribute__((__unused__)))
+{
+#ifdef CLEAR_INSN_CACHE
+  CLEAR_INSN_CACHE (beg, end);
+#else
+#ifdef INSN_CACHE_SIZE
+  static char array[INSN_CACHE_SIZE + INSN_CACHE_PLANE_SIZE + INSN_CACHE_LINE_WIDTH];
+  static int initialized;
+  int offset;
+  void *start_addr
+  void *end_addr;
+  typedef (*function_ptr) (void);
+
+#if (INSN_CACHE_SIZE / INSN_CACHE_LINE_WIDTH) < 16
+  /* It's cheaper to clear the whole cache.
+     Put in a series of jump instructions so that calling the beginning
+     of the cache will clear the whole thing.  */
+
+  if (! initialized)
+    {
+      int ptr = (((int) array + INSN_CACHE_LINE_WIDTH - 1)
+		 & -INSN_CACHE_LINE_WIDTH);
+      int end_ptr = ptr + INSN_CACHE_SIZE;
+
+      while (ptr < end_ptr)
+	{
+	  *(INSTRUCTION_TYPE *)ptr
+	    = JUMP_AHEAD_INSTRUCTION + INSN_CACHE_LINE_WIDTH;
+	  ptr += INSN_CACHE_LINE_WIDTH;
+	}
+      *(INSTRUCTION_TYPE *) (ptr - INSN_CACHE_LINE_WIDTH) = RETURN_INSTRUCTION;
+
+      initialized = 1;
+    }
+
+  /* Call the beginning of the sequence.  */
+  (((function_ptr) (((int) array + INSN_CACHE_LINE_WIDTH - 1)
+		    & -INSN_CACHE_LINE_WIDTH))
+   ());
+
+#else /* Cache is large.  */
+
+  if (! initialized)
+    {
+      int ptr = (((int) array + INSN_CACHE_LINE_WIDTH - 1)
+		 & -INSN_CACHE_LINE_WIDTH);
+
+      while (ptr < (int) array + sizeof array)
+	{
+	  *(INSTRUCTION_TYPE *)ptr = RETURN_INSTRUCTION;
+	  ptr += INSN_CACHE_LINE_WIDTH;
+	}
+
+      initialized = 1;
+    }
+
+  /* Find the location in array that occupies the same cache line as BEG.  */
+
+  offset = ((int) beg & -INSN_CACHE_LINE_WIDTH) & (INSN_CACHE_PLANE_SIZE - 1);
+  start_addr = (((int) (array + INSN_CACHE_PLANE_SIZE - 1)
+		 & -INSN_CACHE_PLANE_SIZE)
+		+ offset);
+
+  /* Compute the cache alignment of the place to stop clearing.  */
+#if 0  /* This is not needed for gcc's purposes.  */
+  /* If the block to clear is bigger than a cache plane,
+     we clear the entire cache, and OFFSET is already correct.  */
+  if (end < beg + INSN_CACHE_PLANE_SIZE)
+#endif
+    offset = (((int) (end + INSN_CACHE_LINE_WIDTH - 1)
+	       & -INSN_CACHE_LINE_WIDTH)
+	      & (INSN_CACHE_PLANE_SIZE - 1));
+
+#if INSN_CACHE_DEPTH > 1
+  end_addr = (start_addr & -INSN_CACHE_PLANE_SIZE) + offset;
+  if (end_addr <= start_addr)
+    end_addr += INSN_CACHE_PLANE_SIZE;
+
+  for (plane = 0; plane < INSN_CACHE_DEPTH; plane++)
+    {
+      int addr = start_addr + plane * INSN_CACHE_PLANE_SIZE;
+      int stop = end_addr + plane * INSN_CACHE_PLANE_SIZE;
+
+      while (addr != stop)
+	{
+	  /* Call the return instruction at ADDR.  */
+	  ((function_ptr) addr) ();
+
+	  addr += INSN_CACHE_LINE_WIDTH;
+	}
+    }
+#else /* just one plane */
+  do
+    {
+      /* Call the return instruction at START_ADDR.  */
+      ((function_ptr) start_addr) ();
+
+      start_addr += INSN_CACHE_LINE_WIDTH;
+    }
+  while ((start_addr % INSN_CACHE_SIZE) != offset);
+#endif /* just one plane */
+#endif /* Cache is large */
+#endif /* Cache exists */
+#endif /* CLEAR_INSN_CACHE */
+}
+
+#endif /* L_clear_cache */
+
+#ifdef L_trampoline
+
+/* Jump to a trampoline, loading the static chain address.  */
+
+#if defined(WINNT) && ! defined(__CYGWIN__) && ! defined (_UWIN)
+
+long
+getpagesize (void)
+{
+#ifdef _ALPHA_
+  return 8192;
+#else
+  return 4096;
+#endif
+}
+
+#ifdef __i386__
+extern int VirtualProtect (char *, int, int, int *) __attribute__((stdcall));
+#endif
+
+int
+mprotect (char *addr, int len, int prot)
+{
+  int np, op;
+
+  if (prot == 7)
+    np = 0x40;
+  else if (prot == 5)
+    np = 0x20;
+  else if (prot == 4)
+    np = 0x10;
+  else if (prot == 3)
+    np = 0x04;
+  else if (prot == 1)
+    np = 0x02;
+  else if (prot == 0)
+    np = 0x01;
+
+  if (VirtualProtect (addr, len, np, &op))
+    return 0;
+  else
+    return -1;
+}
+
+#endif /* WINNT && ! __CYGWIN__ && ! _UWIN */
+
+#ifdef TRANSFER_FROM_TRAMPOLINE
+TRANSFER_FROM_TRAMPOLINE
+#endif
+
+#ifdef __sysV68__
+
+#include <sys/signal.h>
+#include <errno.h>
+
+/* Motorola forgot to put memctl.o in the libp version of libc881.a,
+   so define it here, because we need it in __clear_insn_cache below */
+/* On older versions of this OS, no memctl or MCT_TEXT are defined;
+   hence we enable this stuff only if MCT_TEXT is #define'd.  */
+
+#ifdef MCT_TEXT
+asm("\n\
+	global memctl\n\
+memctl:\n\
+	movq &75,%d0\n\
+	trap &0\n\
+	bcc.b noerror\n\
+	jmp cerror%\n\
+noerror:\n\
+	movq &0,%d0\n\
+	rts");
+#endif
+
+/* Clear instruction cache so we can call trampolines on stack.
+   This is called from FINALIZE_TRAMPOLINE in mot3300.h.  */
+
+void
+__clear_insn_cache (void)
+{
+#ifdef MCT_TEXT
+  int save_errno;
+
+  /* Preserve errno, because users would be surprised to have
+  errno changing without explicitly calling any system-call.  */
+  save_errno = errno;
+
+  /* Keep it simple : memctl (MCT_TEXT) always fully clears the insn cache.
+     No need to use an address derived from _start or %sp, as 0 works also.  */
+  memctl(0, 4096, MCT_TEXT);
+  errno = save_errno;
+#endif
+}
+
+#endif /* __sysV68__ */
+#endif /* L_trampoline */
+
+#ifndef __CYGWIN__
+#ifdef L__main
+
+#include "gbl-ctors.h"
+/* Some systems use __main in a way incompatible with its use in gcc, in these
+   cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to
+   give the same symbol without quotes for an alternative entry point.  You
+   must define both, or neither.  */
+#ifndef NAME__MAIN
+#define NAME__MAIN "__main"
+#define SYMBOL__MAIN __main
+#endif
+
+#ifdef INIT_SECTION_ASM_OP
+#undef HAS_INIT_SECTION
+#define HAS_INIT_SECTION
+#endif
+
+#if !defined (HAS_INIT_SECTION) || !defined (OBJECT_FORMAT_ELF)
+
+/* Some ELF crosses use crtstuff.c to provide __CTOR_LIST__, but use this
+   code to run constructors.  In that case, we need to handle EH here, too.  */
+
+#ifdef EH_FRAME_SECTION_NAME
+#include "unwind-dw2-fde.h"
+extern unsigned char __EH_FRAME_BEGIN__[];
+#endif
+
+/* Run all the global destructors on exit from the program.  */
+
+void
+__do_global_dtors (void)
+{
+#ifdef DO_GLOBAL_DTORS_BODY
+  DO_GLOBAL_DTORS_BODY;
+#else
+  static func_ptr *p = __DTOR_LIST__ + 1;
+  while (*p)
+    {
+      p++;
+      (*(p-1)) ();
+    }
+#endif
+#if defined (EH_FRAME_SECTION_NAME) && !defined (HAS_INIT_SECTION)
+  {
+    static int completed = 0;
+    if (! completed)
+      {
+	completed = 1;
+	__deregister_frame_info (__EH_FRAME_BEGIN__);
+      }
+  }
+#endif
+}
+#endif
+
+#ifndef HAS_INIT_SECTION
+/* Run all the global constructors on entry to the program.  */
+
+void
+__do_global_ctors (void)
+{
+#ifdef EH_FRAME_SECTION_NAME
+  {
+    static struct object object;
+    __register_frame_info (__EH_FRAME_BEGIN__, &object);
+  }
+#endif
+  DO_GLOBAL_CTORS_BODY;
+  atexit (__do_global_dtors);
+}
+#endif /* no HAS_INIT_SECTION */
+
+#if !defined (HAS_INIT_SECTION) || defined (INVOKE__main)
+/* Subroutine called automatically by `main'.
+   Compiling a global function named `main'
+   produces an automatic call to this function at the beginning.
+
+   For many systems, this routine calls __do_global_ctors.
+   For systems which support a .init section we use the .init section
+   to run __do_global_ctors, so we need not do anything here.  */
+
+void
+SYMBOL__MAIN ()
+{
+  /* Support recursive calls to `main': run initializers just once.  */
+  static int initialized;
+  if (! initialized)
+    {
+      initialized = 1;
+      __do_global_ctors ();
+    }
+}
+#endif /* no HAS_INIT_SECTION or INVOKE__main */
+
+#endif /* L__main */
+#endif /* __CYGWIN__ */
+
+#ifdef L_ctors
+
+#include "gbl-ctors.h"
+
+/* Provide default definitions for the lists of constructors and
+   destructors, so that we don't get linker errors.  These symbols are
+   intentionally bss symbols, so that gld and/or collect will provide
+   the right values.  */
+
+/* We declare the lists here with two elements each,
+   so that they are valid empty lists if no other definition is loaded.
+
+   If we are using the old "set" extensions to have the gnu linker
+   collect ctors and dtors, then we __CTOR_LIST__ and __DTOR_LIST__
+   must be in the bss/common section.
+
+   Long term no port should use those extensions.  But many still do.  */
+#if !defined(INIT_SECTION_ASM_OP) && !defined(CTOR_LISTS_DEFINED_EXTERNALLY)
+#if defined (TARGET_ASM_CONSTRUCTOR) || defined (USE_COLLECT2)
+func_ptr __CTOR_LIST__[2] = {0, 0};
+func_ptr __DTOR_LIST__[2] = {0, 0};
+#else
+func_ptr __CTOR_LIST__[2];
+func_ptr __DTOR_LIST__[2];
+#endif
+#endif /* no INIT_SECTION_ASM_OP and not CTOR_LISTS_DEFINED_EXTERNALLY */
+#endif /* L_ctors */
+
+#ifdef L_exit
+
+#include "gbl-ctors.h"
+
+#ifdef NEED_ATEXIT
+
+#ifndef ON_EXIT
+
+# include <errno.h>
+
+static func_ptr *atexit_chain = 0;
+static long atexit_chain_length = 0;
+static volatile long last_atexit_chain_slot = -1;
+
+int
+atexit (func_ptr func)
+{
+  if (++last_atexit_chain_slot == atexit_chain_length)
+    {
+      atexit_chain_length += 32;
+      if (atexit_chain)
+	atexit_chain = (func_ptr *) realloc (atexit_chain, atexit_chain_length
+					     * sizeof (func_ptr));
+      else
+	atexit_chain = (func_ptr *) malloc (atexit_chain_length
+					    * sizeof (func_ptr));
+      if (! atexit_chain)
+	{
+	  atexit_chain_length = 0;
+	  last_atexit_chain_slot = -1;
+	  errno = ENOMEM;
+	  return (-1);
+	}
+    }
+  atexit_chain[last_atexit_chain_slot] = func;
+  return (0);
+}
+
+extern void _cleanup (void);
+extern void _exit (int) __attribute__ ((__noreturn__));
+
+void
+exit (int status)
+{
+  if (atexit_chain)
+    {
+      for ( ; last_atexit_chain_slot-- >= 0; )
+	{
+	  (*atexit_chain[last_atexit_chain_slot + 1]) ();
+	  atexit_chain[last_atexit_chain_slot + 1] = 0;
+	}
+      free (atexit_chain);
+      atexit_chain = 0;
+    }
+#ifdef EXIT_BODY
+  EXIT_BODY;
+#else
+  _cleanup ();
+#endif
+  _exit (status);
+}
+
+#else /* ON_EXIT */
+
+/* Simple; we just need a wrapper for ON_EXIT.  */
+int
+atexit (func_ptr func)
+{
+  return ON_EXIT (func);
+}
+
+#endif /* ON_EXIT */
+#endif /* NEED_ATEXIT */
+
+#endif /* L_exit */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/softfloat/libgcc2.h tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/libgcc2.h
--- linux-2.6.36/arch/mips/softfloat/libgcc2.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/libgcc2.h	2019-03-07 03:40:18.000000000 +0200
@@ -0,0 +1,314 @@
+/* Header file for libgcc2.c.  */
+/* Copyright (C) 2000, 2001
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+/* As a special exception, if you link this library with other files,
+   some of which are compiled with GCC, to produce an executable,
+   this library does not by itself cause the resulting executable
+   to be covered by the GNU General Public License.
+   This exception does not however invalidate any other reasons why
+   the executable file might be covered by the GNU General Public License.  */
+
+
+#ifndef GCC_LIBGCC2_H
+#define GCC_LIBGCC2_H
+
+extern int __gcc_bcmp (const unsigned char *, const unsigned char *, size_t);
+extern void __clear_cache (char *, char *);
+extern void __eprintf (const char *, const char *, unsigned int, const char *)
+  __attribute__ ((__noreturn__));
+
+struct bb;
+extern void __bb_exit_func (void);
+extern void __bb_init_func (struct bb *);
+extern void __bb_fork_func (void);
+
+#if LONG_TYPE_SIZE == GCOV_TYPE_SIZE
+typedef long gcov_type;
+#else
+typedef long long gcov_type;
+#endif
+
+extern gcov_type *__bb_find_arc_counters (void);
+
+struct exception_descriptor;
+extern short int __get_eh_table_language (struct exception_descriptor *);
+extern short int __get_eh_table_version (struct exception_descriptor *);
+
+/* Permit the tm.h file to select the endianness to use just for this
+   file.  This is used when the endianness is determined when the
+   compiler is run.  */
+
+#ifndef LIBGCC2_WORDS_BIG_ENDIAN
+#define LIBGCC2_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN
+#endif
+
+#ifndef LIBGCC2_LONG_DOUBLE_TYPE_SIZE
+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE LONG_DOUBLE_TYPE_SIZE
+#endif
+
+#ifndef MIN_UNITS_PER_WORD
+#define MIN_UNITS_PER_WORD UNITS_PER_WORD
+#endif
+
+/* In the first part of this file, we are interfacing to calls generated
+   by the compiler itself.  These calls pass values into these routines
+   which have very specific modes (rather than very specific types), and
+   these compiler-generated calls also expect any return values to have
+   very specific modes (rather than very specific types).  Thus, we need
+   to avoid using regular C language type names in this part of the file
+   because the sizes for those types can be configured to be anything.
+   Instead we use the following special type names.  */
+
+typedef		 int QItype	__attribute__ ((mode (QI)));
+typedef unsigned int UQItype	__attribute__ ((mode (QI)));
+typedef		 int HItype	__attribute__ ((mode (HI)));
+typedef unsigned int UHItype	__attribute__ ((mode (HI)));
+#if MIN_UNITS_PER_WORD > 1
+/* These typedefs are usually forbidden on dsp's with UNITS_PER_WORD 1 */
+typedef 	 int SItype	__attribute__ ((mode (SI)));
+typedef unsigned int USItype	__attribute__ ((mode (SI)));
+#if LONG_LONG_TYPE_SIZE > 32
+/* These typedefs are usually forbidden on archs with UNITS_PER_WORD 2 */
+typedef		 int DItype	__attribute__ ((mode (DI)));
+typedef unsigned int UDItype	__attribute__ ((mode (DI)));
+#if MIN_UNITS_PER_WORD > 4
+/* These typedefs are usually forbidden on archs with UNITS_PER_WORD 4 */
+typedef		 int TItype	__attribute__ ((mode (TI)));
+typedef unsigned int UTItype	__attribute__ ((mode (TI)));
+#endif
+#endif
+#endif
+
+#if BITS_PER_UNIT == 8
+
+typedef 	float SFtype	__attribute__ ((mode (SF)));
+typedef		float DFtype	__attribute__ ((mode (DF)));
+
+#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96
+typedef		float XFtype	__attribute__ ((mode (XF)));
+#endif
+#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128
+typedef		float TFtype	__attribute__ ((mode (TF)));
+#endif
+
+#else /* BITS_PER_UNIT != 8 */
+
+/* On dsp's there are usually qf/hf/tqf modes used instead of the above.
+   For now we don't support them in libgcc2.c.  */
+
+#undef L_fixdfdi
+#undef L_fixsfdi
+#undef L_fixtfdi
+#undef L_fixunsdfdi
+#undef L_fixunsdfsi
+#undef L_fixunssfdi
+#undef L_fixunssfsi
+#undef L_fixunstfdi
+#undef L_fixunsxfdi
+#undef L_fixunsxfsi
+#undef L_fixxfdi
+#undef L_floatdidf
+#undef L_floatdisf
+#undef L_floatditf
+#undef L_floatdixf
+
+#endif /* BITS_PER_UNIT != 8 */
+
+typedef int word_type __attribute__ ((mode (__word__)));
+
+/* Make sure that we don't accidentally use any normal C language built-in
+   type names in the first part of this file.  Instead we want to use *only*
+   the type names defined above.  The following macro definitions insure
+   that if we *do* accidentally use some normal C language built-in type name,
+   we will get a syntax error.  */
+
+#define char bogus_type
+#define short bogus_type
+#define int bogus_type
+#define long bogus_type
+#define unsigned bogus_type
+#define float bogus_type
+#define double bogus_type
+
+#if MIN_UNITS_PER_WORD > 4
+#define W_TYPE_SIZE (8 * BITS_PER_UNIT)
+#define Wtype	DItype
+#define UWtype	UDItype
+#define HWtype	DItype
+#define UHWtype	UDItype
+#define DWtype	TItype
+#define UDWtype	UTItype
+#define __NW(a,b)	__ ## a ## di ## b
+#define __NDW(a,b)	__ ## a ## ti ## b
+#elif MIN_UNITS_PER_WORD > 2 \
+      || (MIN_UNITS_PER_WORD > 1 && LONG_LONG_TYPE_SIZE > 32)
+#define W_TYPE_SIZE (4 * BITS_PER_UNIT)
+#define Wtype	SItype
+#define UWtype	USItype
+#define HWtype	SItype
+#define UHWtype	USItype
+#define DWtype	DItype
+#define UDWtype	UDItype
+#define __NW(a,b)	__ ## a ## si ## b
+#define __NDW(a,b)	__ ## a ## di ## b
+#elif MIN_UNITS_PER_WORD > 1
+#define W_TYPE_SIZE (2 * BITS_PER_UNIT)
+#define Wtype	HItype
+#define UWtype	UHItype
+#define HWtype	HItype
+#define UHWtype	UHItype
+#define DWtype	SItype
+#define UDWtype	USItype
+#define __NW(a,b)	__ ## a ## hi ## b
+#define __NDW(a,b)	__ ## a ## si ## b
+#else
+#define W_TYPE_SIZE BITS_PER_UNIT
+#define Wtype	QItype
+#define UWtype  UQItype
+#define HWtype	QItype
+#define UHWtype	UQItype
+#define DWtype	HItype
+#define UDWtype	UHItype
+#define __NW(a,b)	__ ## a ## qi ## b
+#define __NDW(a,b)	__ ## a ## hi ## b
+#endif
+
+#define Wtype_MAX ((Wtype)(((UWtype)1 << (W_TYPE_SIZE - 1)) - 1))
+#define Wtype_MIN (- Wtype_MAX - 1)
+
+#define __muldi3	__NDW(mul,3)
+#define __divdi3	__NDW(div,3)
+#define __udivdi3	__NDW(udiv,3)
+#define __moddi3	__NDW(mod,3)
+#define __umoddi3	__NDW(umod,3)
+#define __negdi2	__NDW(neg,2)
+#define __lshrdi3	__NDW(lshr,3)
+#define __ashldi3	__NDW(ashl,3)
+#define __ashrdi3	__NDW(ashr,3)
+#define __ffsdi2	__NDW(ffs,2)
+#define __cmpdi2	__NDW(cmp,2)
+#define __ucmpdi2	__NDW(ucmp,2)
+#define __udivmoddi4	__NDW(udivmod,4)
+#define __fixunstfDI	__NDW(fixunstf,)
+#define __fixtfdi	__NDW(fixtf,)
+#define __fixunsxfDI	__NDW(fixunsxf,)
+#define __fixxfdi	__NDW(fixxf,)
+#define __fixunsdfDI	__NDW(fixunsdf,)
+#define __fixdfdi	__NDW(fixdf,)
+#define __fixunssfDI	__NDW(fixunssf,)
+#define __fixsfdi	__NDW(fixsf,)
+#define __floatdixf	__NDW(float,xf)
+#define __floatditf	__NDW(float,tf)
+#define __floatdidf	__NDW(float,df)
+#define __floatdisf	__NDW(float,sf)
+#define __fixunsxfSI	__NW(fixunsxf,)
+#define __fixunstfSI	__NW(fixunstf,)
+#define __fixunsdfSI	__NW(fixunsdf,)
+#define __fixunssfSI	__NW(fixunssf,)
+
+extern DWtype __muldi3 (DWtype, DWtype);
+extern DWtype __divdi3 (DWtype, DWtype);
+extern UDWtype __udivdi3 (UDWtype, UDWtype);
+extern UDWtype __umoddi3 (UDWtype, UDWtype);
+extern DWtype __moddi3 (DWtype, DWtype);
+
+/* __udivmoddi4 is static inline when building other libgcc2 portions.  */
+#if (!defined (L_udivdi3) && !defined (L_divdi3) && \
+     !defined (L_umoddi3) && !defined (L_moddi3))
+extern UDWtype __udivmoddi4 (UDWtype, UDWtype, UDWtype *);
+#endif
+
+/* __negdi2 is static inline when building other libgcc2 portions.  */
+#if !defined(L_divdi3) && !defined(L_moddi3)
+extern DWtype __negdi2 (DWtype);
+#endif
+
+extern DWtype __lshrdi3 (DWtype, word_type);
+extern DWtype __ashldi3 (DWtype, word_type);
+extern DWtype __ashrdi3 (DWtype, word_type);
+extern DWtype __ffsdi2 (DWtype);
+
+/* __udiv_w_sdiv is static inline when building other libgcc2 portions.  */
+#if (!defined(L_udivdi3) && !defined(L_divdi3) && \
+     !defined(L_umoddi3) && !defined(L_moddi3))
+extern UWtype __udiv_w_sdiv (UWtype *, UWtype, UWtype, UWtype);
+#endif
+
+extern word_type __cmpdi2 (DWtype, DWtype);
+extern word_type __ucmpdi2 (DWtype, DWtype);
+
+extern Wtype __absvsi2 (Wtype);
+extern DWtype __absvdi2 (DWtype);
+extern Wtype __addvsi3 (Wtype, Wtype);
+extern DWtype __addvdi3 (DWtype, DWtype);
+extern Wtype __subvsi3 (Wtype, Wtype);
+extern DWtype __subvdi3 (DWtype, DWtype);
+extern Wtype __mulvsi3 (Wtype, Wtype);
+extern DWtype __mulvdi3 (DWtype, DWtype);
+extern Wtype __negvsi2 (Wtype);
+extern DWtype __negvdi2 (DWtype);
+
+#if BITS_PER_UNIT == 8
+extern DWtype __fixdfdi (DFtype);
+extern DWtype __fixsfdi (SFtype);
+extern DFtype __floatdidf (DWtype);
+extern SFtype __floatdisf (DWtype);
+extern UWtype __fixunsdfSI (DFtype);
+extern UWtype __fixunssfSI (SFtype);
+extern DWtype __fixunsdfDI (DFtype);
+extern DWtype __fixunssfDI (SFtype);
+
+#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96
+extern DWtype __fixxfdi (XFtype);
+extern DWtype __fixunsxfDI (XFtype);
+extern XFtype __floatdixf (DWtype);
+extern UWtype __fixunsxfSI (XFtype);
+#endif
+
+#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128
+extern DWtype __fixunstfDI (TFtype);
+extern DWtype __fixtfdi (TFtype);
+extern TFtype __floatditf (DWtype);
+#endif
+#endif /* BITS_PER_UNIT == 8 */
+
+/* DWstructs are pairs of Wtype values in the order determined by
+   LIBGCC2_WORDS_BIG_ENDIAN.  */
+
+#if LIBGCC2_WORDS_BIG_ENDIAN
+  struct DWstruct {Wtype high, low;};
+#else
+  struct DWstruct {Wtype low, high;};
+#endif
+
+/* We need this union to unpack/pack DImode values, since we don't have
+   any arithmetic yet.  Incoming DImode parameters are stored into the
+   `ll' field, and the unpacked result is read from the struct `s'.  */
+
+typedef union
+{
+  struct DWstruct s;
+  DWtype ll;
+} DWunion;
+
+#include "longlong.h"
+
+#endif /* ! GCC_LIBGCC2_H */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/softfloat/longlong.h tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/longlong.h
--- linux-2.6.36/arch/mips/softfloat/longlong.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/longlong.h	2019-03-07 03:40:18.000000000 +0200
@@ -0,0 +1,1328 @@
+/* longlong.h -- definitions for mixed size 32/64 bit arithmetic.
+   Copyright (C) 1991, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000
+   Free Software Foundation, Inc.
+
+   This definition file is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 2, or (at your option) any later version.
+
+   This definition file is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied
+   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+   See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* You have to define the following before including this file:
+
+   UWtype -- An unsigned type, default type for operations (typically a "word")
+   UHWtype -- An unsigned type, at least half the size of UWtype.
+   UDWtype -- An unsigned type, at least twice as large a UWtype
+   W_TYPE_SIZE -- size in bits of UWtype
+
+   UQItype -- Unsigned 8 bit type.
+   SItype, USItype -- Signed and unsigned 32 bit types.
+   DItype, UDItype -- Signed and unsigned 64 bit types.
+
+   On a 32 bit machine UWtype should typically be USItype;
+   on a 64 bit machine, UWtype should typically be UDItype.
+*/
+
+#define __BITS4 (W_TYPE_SIZE / 4)
+#define __ll_B ((UWtype) 1 << (W_TYPE_SIZE / 2))
+#define __ll_lowpart(t) ((UWtype) (t) & (__ll_B - 1))
+#define __ll_highpart(t) ((UWtype) (t) >> (W_TYPE_SIZE / 2))
+
+#ifndef W_TYPE_SIZE
+#define W_TYPE_SIZE	32
+#define UWtype		USItype
+#define UHWtype		USItype
+#define UDWtype		UDItype
+#endif
+
+/* Define auxiliary asm macros.
+
+   1) umul_ppmm(high_prod, low_prod, multipler, multiplicand) multiplies two
+   UWtype integers MULTIPLER and MULTIPLICAND, and generates a two UWtype
+   word product in HIGH_PROD and LOW_PROD.
+
+   2) __umulsidi3(a,b) multiplies two UWtype integers A and B, and returns a
+   UDWtype product.  This is just a variant of umul_ppmm.
+
+   3) udiv_qrnnd(quotient, remainder, high_numerator, low_numerator,
+   denominator) divides a UDWtype, composed by the UWtype integers
+   HIGH_NUMERATOR and LOW_NUMERATOR, by DENOMINATOR and places the quotient
+   in QUOTIENT and the remainder in REMAINDER.  HIGH_NUMERATOR must be less
+   than DENOMINATOR for correct operation.  If, in addition, the most
+   significant bit of DENOMINATOR must be 1, then the pre-processor symbol
+   UDIV_NEEDS_NORMALIZATION is defined to 1.
+
+   4) sdiv_qrnnd(quotient, remainder, high_numerator, low_numerator,
+   denominator).  Like udiv_qrnnd but the numbers are signed.  The quotient
+   is rounded towards 0.
+
+   5) count_leading_zeros(count, x) counts the number of zero-bits from the
+   msb to the first nonzero bit in the UWtype X.  This is the number of
+   steps X needs to be shifted left to set the msb.  Undefined for X == 0,
+   unless the symbol COUNT_LEADING_ZEROS_0 is defined to some value.
+
+   6) count_trailing_zeros(count, x) like count_leading_zeros, but counts
+   from the least significant end.
+
+   7) add_ssaaaa(high_sum, low_sum, high_addend_1, low_addend_1,
+   high_addend_2, low_addend_2) adds two UWtype integers, composed by
+   HIGH_ADDEND_1 and LOW_ADDEND_1, and HIGH_ADDEND_2 and LOW_ADDEND_2
+   respectively.  The result is placed in HIGH_SUM and LOW_SUM.  Overflow
+   (i.e. carry out) is not stored anywhere, and is lost.
+
+   8) sub_ddmmss(high_difference, low_difference, high_minuend, low_minuend,
+   high_subtrahend, low_subtrahend) subtracts two two-word UWtype integers,
+   composed by HIGH_MINUEND_1 and LOW_MINUEND_1, and HIGH_SUBTRAHEND_2 and
+   LOW_SUBTRAHEND_2 respectively.  The result is placed in HIGH_DIFFERENCE
+   and LOW_DIFFERENCE.  Overflow (i.e. carry out) is not stored anywhere,
+   and is lost.
+
+   If any of these macros are left undefined for a particular CPU,
+   C macros are used.  */
+
+/* The CPUs come in alphabetical order below.
+
+   Please add support for more CPUs here, or improve the current support
+   for the CPUs below!
+   (E.g. WE32100, IBM360.)  */
+
+#if defined (__GNUC__) && !defined (NO_ASM)
+
+/* We sometimes need to clobber "cc" with gcc2, but that would not be
+   understood by gcc1.  Use cpp to avoid major code duplication.  */
+#if __GNUC__ < 2
+#define __CLOBBER_CC
+#define __AND_CLOBBER_CC
+#else /* __GNUC__ >= 2 */
+#define __CLOBBER_CC : "cc"
+#define __AND_CLOBBER_CC , "cc"
+#endif /* __GNUC__ < 2 */
+
+#if defined (__alpha) && W_TYPE_SIZE == 64
+#define umul_ppmm(ph, pl, m0, m1) \
+  do {									\
+    UDItype __m0 = (m0), __m1 = (m1);					\
+    __asm__ ("umulh %r1,%2,%0"						\
+	     : "=r" ((UDItype) ph)					\
+	     : "%rJ" (__m0),						\
+	       "rI" (__m1));						\
+    (pl) = __m0 * __m1;							\
+  } while (0)
+#define UMUL_TIME 46
+#ifndef LONGLONG_STANDALONE
+#define udiv_qrnnd(q, r, n1, n0, d) \
+  do { UDItype __r;							\
+    (q) = __udiv_qrnnd (&__r, (n1), (n0), (d));				\
+    (r) = __r;								\
+  } while (0)
+extern UDItype __udiv_qrnnd (UDItype *, UDItype, UDItype, UDItype);
+#define UDIV_TIME 220
+#endif /* LONGLONG_STANDALONE */
+#ifdef __alpha_cix__
+#define count_leading_zeros(COUNT,X) \
+  __asm__("ctlz %1,%0" : "=r"(COUNT) : "r"(X))
+#define count_trailing_zeros(COUNT,X) \
+  __asm__("cttz %1,%0" : "=r"(COUNT) : "r"(X))
+#define COUNT_LEADING_ZEROS_0 64
+#else
+extern const UQItype __clz_tab[];
+#define count_leading_zeros(COUNT,X) \
+  do {									\
+    UDItype __xr = (X), __t, __a;					\
+    __asm__("cmpbge $31,%1,%0" : "=r"(__t) : "r"(__xr));		\
+    __a = __clz_tab[__t ^ 0xff] - 1;					\
+    __asm__("extbl %1,%2,%0" : "=r"(__t) : "r"(__xr), "r"(__a));	\
+    (COUNT) = 64 - (__clz_tab[__t] + __a*8);				\
+  } while (0)
+#define count_trailing_zeros(COUNT,X) \
+  do {									\
+    UDItype __xr = (X), __t, __a;					\
+    __asm__("cmpbge $31,%1,%0" : "=r"(__t) : "r"(__xr));		\
+    __t = ~__t & -~__t;							\
+    __a = ((__t & 0xCC) != 0) * 2;					\
+    __a += ((__t & 0xF0) != 0) * 4;					\
+    __a += ((__t & 0xAA) != 0);						\
+    __asm__("extbl %1,%2,%0" : "=r"(__t) : "r"(__xr), "r"(__a));	\
+    __a <<= 3;								\
+    __t &= -__t;							\
+    __a += ((__t & 0xCC) != 0) * 2;					\
+    __a += ((__t & 0xF0) != 0) * 4;					\
+    __a += ((__t & 0xAA) != 0);						\
+    (COUNT) = __a;							\
+  } while (0)
+#endif /* __alpha_cix__ */
+#endif /* __alpha */
+
+#if defined (__arc__) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("add.f	%1, %4, %5\n\tadc	%0, %2, %3"		\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%r" ((USItype) (ah)),					\
+	     "rIJ" ((USItype) (bh)),					\
+	     "%r" ((USItype) (al)),					\
+	     "rIJ" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("sub.f	%1, %4, %5\n\tsbc	%0, %2, %3"		\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "r" ((USItype) (ah)),					\
+	     "rIJ" ((USItype) (bh)),					\
+	     "r" ((USItype) (al)),					\
+	     "rIJ" ((USItype) (bl)))
+/* Call libgcc routine.  */
+#define umul_ppmm(w1, w0, u, v) \
+do {									\
+  DWunion __w;								\
+  __w.ll = __umulsidi3 (u, v);						\
+  w1 = __w.s.high;							\
+  w0 = __w.s.low;							\
+} while (0)
+#define __umulsidi3 __umulsidi3
+UDItype __umulsidi3 (USItype, USItype);
+#endif
+
+#if defined (__arm__) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("adds	%1, %4, %5\n\tadc	%0, %2, %3"		\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%r" ((USItype) (ah)),					\
+	     "rI" ((USItype) (bh)),					\
+	     "%r" ((USItype) (al)),					\
+	     "rI" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("subs	%1, %4, %5\n\tsbc	%0, %2, %3"		\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "r" ((USItype) (ah)),					\
+	     "rI" ((USItype) (bh)),					\
+	     "r" ((USItype) (al)),					\
+	     "rI" ((USItype) (bl)))
+#define umul_ppmm(xh, xl, a, b) \
+{register USItype __t0, __t1, __t2;					\
+  __asm__ ("%@ Inlined umul_ppmm\n"					\
+	   "	mov	%2, %5, lsr #16\n"				\
+	   "	mov	%0, %6, lsr #16\n"				\
+	   "	bic	%3, %5, %2, lsl #16\n"				\
+	   "	bic	%4, %6, %0, lsl #16\n"				\
+	   "	mul	%1, %3, %4\n"					\
+	   "	mul	%4, %2, %4\n"					\
+	   "	mul	%3, %0, %3\n"					\
+	   "	mul	%0, %2, %0\n"					\
+	   "	adds	%3, %4, %3\n"					\
+	   "	addcs	%0, %0, #65536\n"				\
+	   "	adds	%1, %1, %3, lsl #16\n"				\
+	   "	adc	%0, %0, %3, lsr #16"				\
+	   : "=&r" ((USItype) (xh)),					\
+	     "=r" ((USItype) (xl)),					\
+	     "=&r" (__t0), "=&r" (__t1), "=r" (__t2)			\
+	   : "r" ((USItype) (a)),					\
+	     "r" ((USItype) (b)));}
+#define UMUL_TIME 20
+#define UDIV_TIME 100
+#endif /* __arm__ */
+
+#if defined (__hppa) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("add %4,%5,%1\n\taddc %2,%3,%0"				\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%rM" ((USItype) (ah)),					\
+	     "rM" ((USItype) (bh)),					\
+	     "%rM" ((USItype) (al)),					\
+	     "rM" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("sub %4,%5,%1\n\tsubb %2,%3,%0"				\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "rM" ((USItype) (ah)),					\
+	     "rM" ((USItype) (bh)),					\
+	     "rM" ((USItype) (al)),					\
+	     "rM" ((USItype) (bl)))
+#if defined (_PA_RISC1_1)
+#define umul_ppmm(w1, w0, u, v) \
+  do {									\
+    union								\
+      {									\
+	UDItype __f;							\
+	struct {USItype __w1, __w0;} __w1w0;				\
+      } __t;								\
+    __asm__ ("xmpyu %1,%2,%0"						\
+	     : "=x" (__t.__f)						\
+	     : "x" ((USItype) (u)),					\
+	       "x" ((USItype) (v)));					\
+    (w1) = __t.__w1w0.__w1;						\
+    (w0) = __t.__w1w0.__w0;						\
+     } while (0)
+#define UMUL_TIME 8
+#else
+#define UMUL_TIME 30
+#endif
+#define UDIV_TIME 40
+#define count_leading_zeros(count, x) \
+  do {									\
+    USItype __tmp;							\
+    __asm__ (								\
+       "ldi		1,%0\n"						\
+"	extru,=		%1,15,16,%%r0		; Bits 31..16 zero?\n"	\
+"	extru,tr	%1,15,16,%1		; No.  Shift down, skip add.\n"\
+"	ldo		16(%0),%0		; Yes.  Perform add.\n"	\
+"	extru,=		%1,23,8,%%r0		; Bits 15..8 zero?\n"	\
+"	extru,tr	%1,23,8,%1		; No.  Shift down, skip add.\n"\
+"	ldo		8(%0),%0		; Yes.  Perform add.\n"	\
+"	extru,=		%1,27,4,%%r0		; Bits 7..4 zero?\n"	\
+"	extru,tr	%1,27,4,%1		; No.  Shift down, skip add.\n"\
+"	ldo		4(%0),%0		; Yes.  Perform add.\n"	\
+"	extru,=		%1,29,2,%%r0		; Bits 3..2 zero?\n"	\
+"	extru,tr	%1,29,2,%1		; No.  Shift down, skip add.\n"\
+"	ldo		2(%0),%0		; Yes.  Perform add.\n"	\
+"	extru		%1,30,1,%1		; Extract bit 1.\n"	\
+"	sub		%0,%1,%0		; Subtract it.\n"	\
+	: "=r" (count), "=r" (__tmp) : "1" (x));			\
+  } while (0)
+#endif
+
+#if (defined (__i370__) || defined (__s390__) || defined (__mvs__)) && W_TYPE_SIZE == 32
+#define smul_ppmm(xh, xl, m0, m1) \
+  do {									\
+    union {DItype __ll;							\
+	   struct {USItype __h, __l;} __i;				\
+	  } __x;							\
+    __asm__ ("lr %N0,%1\n\tmr %0,%2"					\
+	     : "=&r" (__x.__ll)						\
+	     : "r" (m0), "r" (m1));					\
+    (xh) = __x.__i.__h; (xl) = __x.__i.__l;				\
+  } while (0)
+#define sdiv_qrnnd(q, r, n1, n0, d) \
+  do {									\
+    union {DItype __ll;							\
+	   struct {USItype __h, __l;} __i;				\
+	  } __x;							\
+    __x.__i.__h = n1; __x.__i.__l = n0;					\
+    __asm__ ("dr %0,%2"							\
+	     : "=r" (__x.__ll)						\
+	     : "0" (__x.__ll), "r" (d));				\
+    (q) = __x.__i.__l; (r) = __x.__i.__h;				\
+  } while (0)
+#endif
+
+#if (defined (__i386__) || defined (__i486__)) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("addl %5,%1\n\tadcl %3,%0"					\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%0" ((USItype) (ah)),					\
+	     "g" ((USItype) (bh)),					\
+	     "%1" ((USItype) (al)),					\
+	     "g" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("subl %5,%1\n\tsbbl %3,%0"					\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "0" ((USItype) (ah)),					\
+	     "g" ((USItype) (bh)),					\
+	     "1" ((USItype) (al)),					\
+	     "g" ((USItype) (bl)))
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("mull %3"							\
+	   : "=a" ((USItype) (w0)),					\
+	     "=d" ((USItype) (w1))					\
+	   : "%0" ((USItype) (u)),					\
+	     "rm" ((USItype) (v)))
+#define udiv_qrnnd(q, r, n1, n0, dv) \
+  __asm__ ("divl %4"							\
+	   : "=a" ((USItype) (q)),					\
+	     "=d" ((USItype) (r))					\
+	   : "0" ((USItype) (n0)),					\
+	     "1" ((USItype) (n1)),					\
+	     "rm" ((USItype) (dv)))
+#define count_leading_zeros(count, x) \
+  do {									\
+    USItype __cbtmp;							\
+    __asm__ ("bsrl %1,%0"						\
+	     : "=r" (__cbtmp) : "rm" ((USItype) (x)));			\
+    (count) = __cbtmp ^ 31;						\
+  } while (0)
+#define count_trailing_zeros(count, x) \
+  __asm__ ("bsfl %1,%0" : "=r" (count) : "rm" ((USItype)(x)))
+#define UMUL_TIME 40
+#define UDIV_TIME 40
+#endif /* 80x86 */
+
+#if defined (__i960__) && W_TYPE_SIZE == 32
+#define umul_ppmm(w1, w0, u, v) \
+  ({union {UDItype __ll;						\
+	   struct {USItype __l, __h;} __i;				\
+	  } __xx;							\
+  __asm__ ("emul	%2,%1,%0"					\
+	   : "=d" (__xx.__ll)						\
+	   : "%dI" ((USItype) (u)),					\
+	     "dI" ((USItype) (v)));					\
+  (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})
+#define __umulsidi3(u, v) \
+  ({UDItype __w;							\
+    __asm__ ("emul	%2,%1,%0"					\
+	     : "=d" (__w)						\
+	     : "%dI" ((USItype) (u)),					\
+	       "dI" ((USItype) (v)));					\
+    __w; })
+#endif /* __i960__ */
+
+#if defined (__M32R__) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  /* The cmp clears the condition bit.  */ \
+  __asm__ ("cmp %0,%0\n\taddx %%5,%1\n\taddx %%3,%0"			\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%0" ((USItype) (ah)),					\
+	     "r" ((USItype) (bh)),					\
+	     "%1" ((USItype) (al)),					\
+	     "r" ((USItype) (bl))					\
+	   : "cbit")
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  /* The cmp clears the condition bit.  */ \
+  __asm__ ("cmp %0,%0\n\tsubx %5,%1\n\tsubx %3,%0"			\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "0" ((USItype) (ah)),					\
+	     "r" ((USItype) (bh)),					\
+	     "1" ((USItype) (al)),					\
+	     "r" ((USItype) (bl))					\
+	   : "cbit")
+#endif /* __M32R__ */
+
+#if defined (__mc68000__) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("add%.l %5,%1\n\taddx%.l %3,%0"				\
+	   : "=d" ((USItype) (sh)),					\
+	     "=&d" ((USItype) (sl))					\
+	   : "%0" ((USItype) (ah)),					\
+	     "d" ((USItype) (bh)),					\
+	     "%1" ((USItype) (al)),					\
+	     "g" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("sub%.l %5,%1\n\tsubx%.l %3,%0"				\
+	   : "=d" ((USItype) (sh)),					\
+	     "=&d" ((USItype) (sl))					\
+	   : "0" ((USItype) (ah)),					\
+	     "d" ((USItype) (bh)),					\
+	     "1" ((USItype) (al)),					\
+	     "g" ((USItype) (bl)))
+
+/* The '020, '030, '040 and CPU32 have 32x32->64 and 64/32->32q-32r.  */
+#if defined (__mc68020__) || defined(mc68020) \
+	|| defined(__mc68030__) || defined(mc68030) \
+	|| defined(__mc68040__) || defined(mc68040) \
+	|| defined(__mcpu32__) || defined(mcpu32)
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("mulu%.l %3,%1:%0"						\
+	   : "=d" ((USItype) (w0)),					\
+	     "=d" ((USItype) (w1))					\
+	   : "%0" ((USItype) (u)),					\
+	     "dmi" ((USItype) (v)))
+#define UMUL_TIME 45
+#define udiv_qrnnd(q, r, n1, n0, d) \
+  __asm__ ("divu%.l %4,%1:%0"						\
+	   : "=d" ((USItype) (q)),					\
+	     "=d" ((USItype) (r))					\
+	   : "0" ((USItype) (n0)),					\
+	     "1" ((USItype) (n1)),					\
+	     "dmi" ((USItype) (d)))
+#define UDIV_TIME 90
+#define sdiv_qrnnd(q, r, n1, n0, d) \
+  __asm__ ("divs%.l %4,%1:%0"						\
+	   : "=d" ((USItype) (q)),					\
+	     "=d" ((USItype) (r))					\
+	   : "0" ((USItype) (n0)),					\
+	     "1" ((USItype) (n1)),					\
+	     "dmi" ((USItype) (d)))
+
+#else /* not mc68020 */
+#if !defined(__mcf5200__)
+/* %/ inserts REGISTER_PREFIX, %# inserts IMMEDIATE_PREFIX.  */
+#define umul_ppmm(xh, xl, a, b) \
+  __asm__ ("| Inlined umul_ppmm\n"					\
+	   "	move%.l	%2,%/d0\n"					\
+	   "	move%.l	%3,%/d1\n"					\
+	   "	move%.l	%/d0,%/d2\n"					\
+	   "	swap	%/d0\n"						\
+	   "	move%.l	%/d1,%/d3\n"					\
+	   "	swap	%/d1\n"						\
+	   "	move%.w	%/d2,%/d4\n"					\
+	   "	mulu	%/d3,%/d4\n"					\
+	   "	mulu	%/d1,%/d2\n"					\
+	   "	mulu	%/d0,%/d3\n"					\
+	   "	mulu	%/d0,%/d1\n"					\
+	   "	move%.l	%/d4,%/d0\n"					\
+	   "	eor%.w	%/d0,%/d0\n"					\
+	   "	swap	%/d0\n"						\
+	   "	add%.l	%/d0,%/d2\n"					\
+	   "	add%.l	%/d3,%/d2\n"					\
+	   "	jcc	1f\n"						\
+	   "	add%.l	%#65536,%/d1\n"					\
+	   "1:	swap	%/d2\n"						\
+	   "	moveq	%#0,%/d0\n"					\
+	   "	move%.w	%/d2,%/d0\n"					\
+	   "	move%.w	%/d4,%/d2\n"					\
+	   "	move%.l	%/d2,%1\n"					\
+	   "	add%.l	%/d1,%/d0\n"					\
+	   "	move%.l	%/d0,%0"					\
+	   : "=g" ((USItype) (xh)),					\
+	     "=g" ((USItype) (xl))					\
+	   : "g" ((USItype) (a)),					\
+	     "g" ((USItype) (b))					\
+	   : "d0", "d1", "d2", "d3", "d4")
+#define UMUL_TIME 100
+#define UDIV_TIME 400
+#endif /* not mcf5200 */
+#endif /* not mc68020 */
+
+/* The '020, '030, '040 and '060 have bitfield insns.  */
+#if defined (__mc68020__) || defined(mc68020) \
+	|| defined(__mc68030__) || defined(mc68030) \
+	|| defined(__mc68040__) || defined(mc68040) \
+	|| defined(__mc68060__) || defined(mc68060)
+#define count_leading_zeros(count, x) \
+  __asm__ ("bfffo %1{%b2:%b2},%0"					\
+	   : "=d" ((USItype) (count))					\
+	   : "od" ((USItype) (x)), "n" (0))
+#endif
+#endif /* mc68000 */
+
+#if defined (__m88000__) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("addu.co %1,%r4,%r5\n\taddu.ci %0,%r2,%r3"			\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%rJ" ((USItype) (ah)),					\
+	     "rJ" ((USItype) (bh)),					\
+	     "%rJ" ((USItype) (al)),					\
+	     "rJ" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("subu.co %1,%r4,%r5\n\tsubu.ci %0,%r2,%r3"			\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "rJ" ((USItype) (ah)),					\
+	     "rJ" ((USItype) (bh)),					\
+	     "rJ" ((USItype) (al)),					\
+	     "rJ" ((USItype) (bl)))
+#define count_leading_zeros(count, x) \
+  do {									\
+    USItype __cbtmp;							\
+    __asm__ ("ff1 %0,%1"						\
+	     : "=r" (__cbtmp)						\
+	     : "r" ((USItype) (x)));					\
+    (count) = __cbtmp ^ 31;						\
+  } while (0)
+#define COUNT_LEADING_ZEROS_0 63 /* sic */
+#if defined (__mc88110__)
+#define umul_ppmm(wh, wl, u, v) \
+  do {									\
+    union {UDItype __ll;						\
+	   struct {USItype __h, __l;} __i;				\
+	  } __xx;							\
+    __asm__ ("mulu.d	%0,%1,%2"					\
+	     : "=r" (__xx.__ll)						\
+	     : "r" ((USItype) (u)),					\
+	       "r" ((USItype) (v)));					\
+    (wh) = __xx.__i.__h;						\
+    (wl) = __xx.__i.__l;						\
+  } while (0)
+#define udiv_qrnnd(q, r, n1, n0, d) \
+  ({union {UDItype __ll;						\
+	   struct {USItype __h, __l;} __i;				\
+	  } __xx;							\
+  USItype __q;								\
+  __xx.__i.__h = (n1); __xx.__i.__l = (n0);				\
+  __asm__ ("divu.d %0,%1,%2"						\
+	   : "=r" (__q)							\
+	   : "r" (__xx.__ll),						\
+	     "r" ((USItype) (d)));					\
+  (r) = (n0) - __q * (d); (q) = __q; })
+#define UMUL_TIME 5
+#define UDIV_TIME 25
+#else
+#define UMUL_TIME 17
+#define UDIV_TIME 150
+#endif /* __mc88110__ */
+#endif /* __m88000__ */
+
+#if defined (__mips__) && W_TYPE_SIZE == 32
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("multu %2,%3"						\
+	   : "=l" ((USItype) (w0)),					\
+	     "=h" ((USItype) (w1))					\
+	   : "d" ((USItype) (u)),					\
+	     "d" ((USItype) (v)))
+#define UMUL_TIME 10
+#define UDIV_TIME 100
+#endif /* __mips__ */
+
+#if defined (__ns32000__) && W_TYPE_SIZE == 32
+#define umul_ppmm(w1, w0, u, v) \
+  ({union {UDItype __ll;						\
+	   struct {USItype __l, __h;} __i;				\
+	  } __xx;							\
+  __asm__ ("meid %2,%0"							\
+	   : "=g" (__xx.__ll)						\
+	   : "%0" ((USItype) (u)),					\
+	     "g" ((USItype) (v)));					\
+  (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})
+#define __umulsidi3(u, v) \
+  ({UDItype __w;							\
+    __asm__ ("meid %2,%0"						\
+	     : "=g" (__w)						\
+	     : "%0" ((USItype) (u)),					\
+	       "g" ((USItype) (v)));					\
+    __w; })
+#define udiv_qrnnd(q, r, n1, n0, d) \
+  ({union {UDItype __ll;						\
+	   struct {USItype __l, __h;} __i;				\
+	  } __xx;							\
+  __xx.__i.__h = (n1); __xx.__i.__l = (n0);				\
+  __asm__ ("deid %2,%0"							\
+	   : "=g" (__xx.__ll)						\
+	   : "0" (__xx.__ll),						\
+	     "g" ((USItype) (d)));					\
+  (r) = __xx.__i.__l; (q) = __xx.__i.__h; })
+#define count_trailing_zeros(count,x) \
+  do {									\
+    __asm__ ("ffsd     %2,%0"						\
+            : "=r" ((USItype) (count))					\
+            : "0" ((USItype) 0),					\
+              "r" ((USItype) (x)));					\
+  } while (0)
+#endif /* __ns32000__ */
+
+/* FIXME: We should test _IBMR2 here when we add assembly support for the
+   system vendor compilers.
+   FIXME: What's needed for gcc PowerPC VxWorks?  __vxworks__ is not good
+   enough, since that hits ARM and m68k too.  */
+#if (defined (_ARCH_PPC)	/* AIX */				\
+     || defined (_ARCH_PWR)	/* AIX */				\
+     || defined (_ARCH_COM)	/* AIX */				\
+     || defined (__powerpc__)	/* gcc */				\
+     || defined (__POWERPC__)	/* BEOS */				\
+     || defined (__ppc__)	/* Darwin */				\
+     || defined (PPC)		/* GNU/Linux, SysV */			\
+     ) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  do {									\
+    if (__builtin_constant_p (bh) && (bh) == 0)				\
+      __asm__ ("{a%I4|add%I4c} %1,%3,%4\n\t{aze|addze} %0,%2"		\
+	     : "=r" (sh), "=&r" (sl) : "r" (ah), "%r" (al), "rI" (bl));\
+    else if (__builtin_constant_p (bh) && (bh) == ~(USItype) 0)		\
+      __asm__ ("{a%I4|add%I4c} %1,%3,%4\n\t{ame|addme} %0,%2"		\
+	     : "=r" (sh), "=&r" (sl) : "r" (ah), "%r" (al), "rI" (bl));\
+    else								\
+      __asm__ ("{a%I5|add%I5c} %1,%4,%5\n\t{ae|adde} %0,%2,%3"		\
+	     : "=r" (sh), "=&r" (sl)					\
+	     : "%r" (ah), "r" (bh), "%r" (al), "rI" (bl));		\
+  } while (0)
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  do {									\
+    if (__builtin_constant_p (ah) && (ah) == 0)				\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{sfze|subfze} %0,%2"	\
+	       : "=r" (sh), "=&r" (sl) : "r" (bh), "rI" (al), "r" (bl));\
+    else if (__builtin_constant_p (ah) && (ah) == ~(USItype) 0)		\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{sfme|subfme} %0,%2"	\
+	       : "=r" (sh), "=&r" (sl) : "r" (bh), "rI" (al), "r" (bl));\
+    else if (__builtin_constant_p (bh) && (bh) == 0)			\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{ame|addme} %0,%2"		\
+	       : "=r" (sh), "=&r" (sl) : "r" (ah), "rI" (al), "r" (bl));\
+    else if (__builtin_constant_p (bh) && (bh) == ~(USItype) 0)		\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{aze|addze} %0,%2"		\
+	       : "=r" (sh), "=&r" (sl) : "r" (ah), "rI" (al), "r" (bl));\
+    else								\
+      __asm__ ("{sf%I4|subf%I4c} %1,%5,%4\n\t{sfe|subfe} %0,%3,%2"	\
+	       : "=r" (sh), "=&r" (sl)					\
+	       : "r" (ah), "r" (bh), "rI" (al), "r" (bl));		\
+  } while (0)
+#define count_leading_zeros(count, x) \
+  __asm__ ("{cntlz|cntlzw} %0,%1" : "=r" (count) : "r" (x))
+#define COUNT_LEADING_ZEROS_0 32
+#if defined (_ARCH_PPC) || defined (__powerpc__) || defined (__POWERPC__) \
+  || defined (__ppc__) || defined (PPC) || defined (__vxworks__)
+#define umul_ppmm(ph, pl, m0, m1) \
+  do {									\
+    USItype __m0 = (m0), __m1 = (m1);					\
+    __asm__ ("mulhwu %0,%1,%2" : "=r" (ph) : "%r" (m0), "r" (m1));	\
+    (pl) = __m0 * __m1;							\
+  } while (0)
+#define UMUL_TIME 15
+#define smul_ppmm(ph, pl, m0, m1) \
+  do {									\
+    SItype __m0 = (m0), __m1 = (m1);					\
+    __asm__ ("mulhw %0,%1,%2" : "=r" (ph) : "%r" (m0), "r" (m1));	\
+    (pl) = __m0 * __m1;							\
+  } while (0)
+#define SMUL_TIME 14
+#define UDIV_TIME 120
+#elif defined (_ARCH_PWR)
+#define UMUL_TIME 8
+#define smul_ppmm(xh, xl, m0, m1) \
+  __asm__ ("mul %0,%2,%3" : "=r" (xh), "=q" (xl) : "r" (m0), "r" (m1))
+#define SMUL_TIME 4
+#define sdiv_qrnnd(q, r, nh, nl, d) \
+  __asm__ ("div %0,%2,%4" : "=r" (q), "=q" (r) : "r" (nh), "1" (nl), "r" (d))
+#define UDIV_TIME 100
+#endif
+#endif /* 32-bit POWER architecture variants.  */
+
+/* We should test _IBMR2 here when we add assembly support for the system
+   vendor compilers.  */
+#if (defined (_ARCH_PPC64) || defined (__powerpc64__)) && W_TYPE_SIZE == 64
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  do {									\
+    if (__builtin_constant_p (bh) && (bh) == 0)				\
+      __asm__ ("{a%I4|add%I4c} %1,%3,%4\n\t{aze|addze} %0,%2"		\
+	     : "=r" (sh), "=&r" (sl) : "r" (ah), "%r" (al), "rI" (bl));\
+    else if (__builtin_constant_p (bh) && (bh) == ~(UDItype) 0)		\
+      __asm__ ("{a%I4|add%I4c} %1,%3,%4\n\t{ame|addme} %0,%2"		\
+	     : "=r" (sh), "=&r" (sl) : "r" (ah), "%r" (al), "rI" (bl));\
+    else								\
+      __asm__ ("{a%I5|add%I5c} %1,%4,%5\n\t{ae|adde} %0,%2,%3"		\
+	     : "=r" (sh), "=&r" (sl)					\
+	     : "%r" (ah), "r" (bh), "%r" (al), "rI" (bl));		\
+  } while (0)
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  do {									\
+    if (__builtin_constant_p (ah) && (ah) == 0)				\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{sfze|subfze} %0,%2"	\
+	       : "=r" (sh), "=&r" (sl) : "r" (bh), "rI" (al), "r" (bl));\
+    else if (__builtin_constant_p (ah) && (ah) == ~(UDItype) 0)		\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{sfme|subfme} %0,%2"	\
+	       : "=r" (sh), "=&r" (sl) : "r" (bh), "rI" (al), "r" (bl));\
+    else if (__builtin_constant_p (bh) && (bh) == 0)			\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{ame|addme} %0,%2"		\
+	       : "=r" (sh), "=&r" (sl) : "r" (ah), "rI" (al), "r" (bl));\
+    else if (__builtin_constant_p (bh) && (bh) == ~(UDItype) 0)		\
+      __asm__ ("{sf%I3|subf%I3c} %1,%4,%3\n\t{aze|addze} %0,%2"		\
+	       : "=r" (sh), "=&r" (sl) : "r" (ah), "rI" (al), "r" (bl));\
+    else								\
+      __asm__ ("{sf%I4|subf%I4c} %1,%5,%4\n\t{sfe|subfe} %0,%3,%2"	\
+	       : "=r" (sh), "=&r" (sl)					\
+	       : "r" (ah), "r" (bh), "rI" (al), "r" (bl));		\
+  } while (0)
+#define count_leading_zeros(count, x) \
+  __asm__ ("cntlzd %0,%1" : "=r" (count) : "r" (x))
+#define COUNT_LEADING_ZEROS_0 64
+#define umul_ppmm(ph, pl, m0, m1) \
+  do {									\
+    UDItype __m0 = (m0), __m1 = (m1);					\
+    __asm__ ("mulhdu %0,%1,%2" : "=r" (ph) : "%r" (m0), "r" (m1));	\
+    (pl) = __m0 * __m1;							\
+  } while (0)
+#define UMUL_TIME 15
+#define smul_ppmm(ph, pl, m0, m1) \
+  do {									\
+    DItype __m0 = (m0), __m1 = (m1);					\
+    __asm__ ("mulhd %0,%1,%2" : "=r" (ph) : "%r" (m0), "r" (m1));	\
+    (pl) = __m0 * __m1;							\
+  } while (0)
+#define SMUL_TIME 14  /* ??? */
+#define UDIV_TIME 120 /* ??? */
+#endif /* 64-bit PowerPC.  */
+
+#if defined (__ibm032__) /* RT/ROMP */ && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("a %1,%5\n\tae %0,%3"					\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%0" ((USItype) (ah)),					\
+	     "r" ((USItype) (bh)),					\
+	     "%1" ((USItype) (al)),					\
+	     "r" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("s %1,%5\n\tse %0,%3"					\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "0" ((USItype) (ah)),					\
+	     "r" ((USItype) (bh)),					\
+	     "1" ((USItype) (al)),					\
+	     "r" ((USItype) (bl)))
+#define umul_ppmm(ph, pl, m0, m1) \
+  do {									\
+    USItype __m0 = (m0), __m1 = (m1);					\
+    __asm__ (								\
+       "s	r2,r2\n"						\
+"	mts	r10,%2\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	m	r2,%3\n"						\
+"	cas	%0,r2,r0\n"						\
+"	mfs	r10,%1"							\
+	     : "=r" ((USItype) (ph)),					\
+	       "=r" ((USItype) (pl))					\
+	     : "%r" (__m0),						\
+		"r" (__m1)						\
+	     : "r2");							\
+    (ph) += ((((SItype) __m0 >> 31) & __m1)				\
+	     + (((SItype) __m1 >> 31) & __m0));				\
+  } while (0)
+#define UMUL_TIME 20
+#define UDIV_TIME 200
+#define count_leading_zeros(count, x) \
+  do {									\
+    if ((x) >= 0x10000)							\
+      __asm__ ("clz	%0,%1"						\
+	       : "=r" ((USItype) (count))				\
+	       : "r" ((USItype) (x) >> 16));				\
+    else								\
+      {									\
+	__asm__ ("clz	%0,%1"						\
+		 : "=r" ((USItype) (count))				\
+		 : "r" ((USItype) (x)));					\
+	(count) += 16;							\
+      }									\
+  } while (0)
+#endif
+
+#if defined (__sh2__) && W_TYPE_SIZE == 32
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ (								\
+       "dmulu.l	%2,%3\n\tsts	macl,%1\n\tsts	mach,%0"		\
+	   : "=r" ((USItype)(w1)),					\
+	     "=r" ((USItype)(w0))					\
+	   : "r" ((USItype)(u)),					\
+	     "r" ((USItype)(v))						\
+	   : "macl", "mach")
+#define UMUL_TIME 5
+#endif
+
+#if defined (__SH5__) && __SHMEDIA__ && W_TYPE_SIZE == 32
+#define __umulsidi3(u,v) ((UDItype)(USItype)u*(USItype)v)
+#define count_leading_zeros(count, x) \
+  do									\
+    {									\
+      UDItype x_ = (USItype)(x);					\
+      SItype c_;							\
+									\
+      __asm__ ("nsb %1, %0" : "=r" (c_) : "r" (x_));			\
+      (count) = c_ - 31;						\
+    }									\
+  while (0)
+#define COUNT_LEADING_ZEROS_0 32
+#endif
+
+#if defined (__sparc__) && !defined (__arch64__) && !defined (__sparcv9) \
+    && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("addcc %r4,%5,%1\n\taddx %r2,%3,%0"				\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "%rJ" ((USItype) (ah)),					\
+	     "rI" ((USItype) (bh)),					\
+	     "%rJ" ((USItype) (al)),					\
+	     "rI" ((USItype) (bl))					\
+	   __CLOBBER_CC)
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("subcc %r4,%5,%1\n\tsubx %r2,%3,%0"				\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "rJ" ((USItype) (ah)),					\
+	     "rI" ((USItype) (bh)),					\
+	     "rJ" ((USItype) (al)),					\
+	     "rI" ((USItype) (bl))					\
+	   __CLOBBER_CC)
+#if defined (__sparc_v8__)
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("umul %2,%3,%1;rd %%y,%0"					\
+	   : "=r" ((USItype) (w1)),					\
+	     "=r" ((USItype) (w0))					\
+	   : "r" ((USItype) (u)),					\
+	     "r" ((USItype) (v)))
+#define udiv_qrnnd(__q, __r, __n1, __n0, __d) \
+  __asm__ ("mov %2,%%y;nop;nop;nop;udiv %3,%4,%0;umul %0,%4,%1;sub %3,%1,%1"\
+	   : "=&r" ((USItype) (__q)),					\
+	     "=&r" ((USItype) (__r))					\
+	   : "r" ((USItype) (__n1)),					\
+	     "r" ((USItype) (__n0)),					\
+	     "r" ((USItype) (__d)))
+#else
+#if defined (__sparclite__)
+/* This has hardware multiply but not divide.  It also has two additional
+   instructions scan (ffs from high bit) and divscc.  */
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("umul %2,%3,%1;rd %%y,%0"					\
+	   : "=r" ((USItype) (w1)),					\
+	     "=r" ((USItype) (w0))					\
+	   : "r" ((USItype) (u)),					\
+	     "r" ((USItype) (v)))
+#define udiv_qrnnd(q, r, n1, n0, d) \
+  __asm__ ("! Inlined udiv_qrnnd\n"					\
+"	wr	%%g0,%2,%%y	! Not a delayed write for sparclite\n"	\
+"	tst	%%g0\n"							\
+"	divscc	%3,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%%g1\n"						\
+"	divscc	%%g1,%4,%0\n"						\
+"	rd	%%y,%1\n"						\
+"	bl,a 1f\n"							\
+"	add	%1,%4,%1\n"						\
+"1:	! End of inline udiv_qrnnd"					\
+	   : "=r" ((USItype) (q)),					\
+	     "=r" ((USItype) (r))					\
+	   : "r" ((USItype) (n1)),					\
+	     "r" ((USItype) (n0)),					\
+	     "rI" ((USItype) (d))					\
+	   : "g1" __AND_CLOBBER_CC)
+#define UDIV_TIME 37
+#define count_leading_zeros(count, x) \
+  do {                                                                  \
+  __asm__ ("scan %1,1,%0"                                               \
+           : "=r" ((USItype) (count))                                   \
+           : "r" ((USItype) (x)));					\
+  } while (0)
+/* Early sparclites return 63 for an argument of 0, but they warn that future
+   implementations might change this.  Therefore, leave COUNT_LEADING_ZEROS_0
+   undefined.  */
+#else
+/* SPARC without integer multiplication and divide instructions.
+   (i.e. at least Sun4/20,40,60,65,75,110,260,280,330,360,380,470,490) */
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("! Inlined umul_ppmm\n"					\
+"	wr	%%g0,%2,%%y	! SPARC has 0-3 delay insn after a wr\n"\
+"	sra	%3,31,%%o5	! Don't move this insn\n"		\
+"	and	%2,%%o5,%%o5	! Don't move this insn\n"		\
+"	andcc	%%g0,0,%%g1	! Don't move this insn\n"		\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,%3,%%g1\n"						\
+"	mulscc	%%g1,0,%%g1\n"						\
+"	add	%%g1,%%o5,%0\n"						\
+"	rd	%%y,%1"							\
+	   : "=r" ((USItype) (w1)),					\
+	     "=r" ((USItype) (w0))					\
+	   : "%rI" ((USItype) (u)),					\
+	     "r" ((USItype) (v))						\
+	   : "g1", "o5" __AND_CLOBBER_CC)
+#define UMUL_TIME 39		/* 39 instructions */
+/* It's quite necessary to add this much assembler for the sparc.
+   The default udiv_qrnnd (in C) is more than 10 times slower!  */
+#define udiv_qrnnd(__q, __r, __n1, __n0, __d) \
+  __asm__ ("! Inlined udiv_qrnnd\n"					\
+"	mov	32,%%g1\n"						\
+"	subcc	%1,%2,%%g0\n"						\
+"1:	bcs	5f\n"							\
+"	 addxcc %0,%0,%0	! shift n1n0 and a q-bit in lsb\n"	\
+"	sub	%1,%2,%1	! this kills msb of n\n"		\
+"	addx	%1,%1,%1	! so this can't give carry\n"		\
+"	subcc	%%g1,1,%%g1\n"						\
+"2:	bne	1b\n"							\
+"	 subcc	%1,%2,%%g0\n"						\
+"	bcs	3f\n"							\
+"	 addxcc %0,%0,%0	! shift n1n0 and a q-bit in lsb\n"	\
+"	b	3f\n"							\
+"	 sub	%1,%2,%1	! this kills msb of n\n"		\
+"4:	sub	%1,%2,%1\n"						\
+"5:	addxcc	%1,%1,%1\n"						\
+"	bcc	2b\n"							\
+"	 subcc	%%g1,1,%%g1\n"						\
+"! Got carry from n.  Subtract next step to cancel this carry.\n"	\
+"	bne	4b\n"							\
+"	 addcc	%0,%0,%0	! shift n1n0 and a 0-bit in lsb\n"	\
+"	sub	%1,%2,%1\n"						\
+"3:	xnor	%0,0,%0\n"						\
+"	! End of inline udiv_qrnnd"					\
+	   : "=&r" ((USItype) (__q)),					\
+	     "=&r" ((USItype) (__r))					\
+	   : "r" ((USItype) (__d)),					\
+	     "1" ((USItype) (__n1)),					\
+	     "0" ((USItype) (__n0)) : "g1" __AND_CLOBBER_CC)
+#define UDIV_TIME (3+7*32)	/* 7 instructions/iteration. 32 iterations.  */
+#endif /* __sparclite__ */
+#endif /* __sparc_v8__ */
+#endif /* sparc32 */
+
+#if ((defined (__sparc__) && defined (__arch64__)) || defined (__sparcv9)) \
+    && W_TYPE_SIZE == 64
+#define add_ssaaaa(sh, sl, ah, al, bh, bl)				\
+  __asm__ ("addcc %r4,%5,%1\n\t"					\
+   	   "add %r2,%3,%0\n\t"						\
+   	   "bcs,a,pn %%xcc, 1f\n\t"					\
+   	   "add %0, 1, %0\n"						\
+	   "1:"								\
+	   : "=r" ((UDItype)(sh)),				      	\
+	     "=&r" ((UDItype)(sl))				      	\
+	   : "%rJ" ((UDItype)(ah)),				     	\
+	     "rI" ((UDItype)(bh)),				      	\
+	     "%rJ" ((UDItype)(al)),				     	\
+	     "rI" ((UDItype)(bl))				       	\
+	   __CLOBBER_CC)
+
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) 				\
+  __asm__ ("subcc %r4,%5,%1\n\t"					\
+   	   "sub %r2,%3,%0\n\t"						\
+   	   "bcs,a,pn %%xcc, 1f\n\t"					\
+   	   "sub %0, 1, %0\n\t"						\
+	   "1:"								\
+	   : "=r" ((UDItype)(sh)),				      	\
+	     "=&r" ((UDItype)(sl))				      	\
+	   : "rJ" ((UDItype)(ah)),				     	\
+	     "rI" ((UDItype)(bh)),				      	\
+	     "rJ" ((UDItype)(al)),				     	\
+	     "rI" ((UDItype)(bl))				       	\
+	   __CLOBBER_CC)
+
+#define umul_ppmm(wh, wl, u, v)						\
+  do {									\
+	  UDItype tmp1, tmp2, tmp3, tmp4;				\
+	  __asm__ __volatile__ (					\
+		   "srl %7,0,%3\n\t"					\
+		   "mulx %3,%6,%1\n\t"					\
+		   "srlx %6,32,%2\n\t"					\
+		   "mulx %2,%3,%4\n\t"					\
+		   "sllx %4,32,%5\n\t"					\
+		   "srl %6,0,%3\n\t"					\
+		   "sub %1,%5,%5\n\t"					\
+		   "srlx %5,32,%5\n\t"					\
+		   "addcc %4,%5,%4\n\t"					\
+		   "srlx %7,32,%5\n\t"					\
+		   "mulx %3,%5,%3\n\t"					\
+		   "mulx %2,%5,%5\n\t"					\
+		   "sethi %%hi(0x80000000),%2\n\t"			\
+		   "addcc %4,%3,%4\n\t"					\
+		   "srlx %4,32,%4\n\t"					\
+		   "add %2,%2,%2\n\t"					\
+		   "movcc %%xcc,%%g0,%2\n\t"				\
+		   "addcc %5,%4,%5\n\t"					\
+		   "sllx %3,32,%3\n\t"					\
+		   "add %1,%3,%1\n\t"					\
+		   "add %5,%2,%0"					\
+	   : "=r" ((UDItype)(wh)),					\
+	     "=&r" ((UDItype)(wl)),					\
+	     "=&r" (tmp1), "=&r" (tmp2), "=&r" (tmp3), "=&r" (tmp4)	\
+	   : "r" ((UDItype)(u)),					\
+	     "r" ((UDItype)(v))						\
+	   __CLOBBER_CC);						\
+  } while (0)
+#define UMUL_TIME 96
+#define UDIV_TIME 230
+#endif /* sparc64 */
+
+#if defined (__vax__) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("addl2 %5,%1\n\tadwc %3,%0"					\
+	   : "=g" ((USItype) (sh)),					\
+	     "=&g" ((USItype) (sl))					\
+	   : "%0" ((USItype) (ah)),					\
+	     "g" ((USItype) (bh)),					\
+	     "%1" ((USItype) (al)),					\
+	     "g" ((USItype) (bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("subl2 %5,%1\n\tsbwc %3,%0"					\
+	   : "=g" ((USItype) (sh)),					\
+	     "=&g" ((USItype) (sl))					\
+	   : "0" ((USItype) (ah)),					\
+	     "g" ((USItype) (bh)),					\
+	     "1" ((USItype) (al)),					\
+	     "g" ((USItype) (bl)))
+#define umul_ppmm(xh, xl, m0, m1) \
+  do {									\
+    union {								\
+	UDItype __ll;							\
+	struct {USItype __l, __h;} __i;					\
+      } __xx;								\
+    USItype __m0 = (m0), __m1 = (m1);					\
+    __asm__ ("emul %1,%2,$0,%0"						\
+	     : "=r" (__xx.__ll)						\
+	     : "g" (__m0),						\
+	       "g" (__m1));						\
+    (xh) = __xx.__i.__h;						\
+    (xl) = __xx.__i.__l;						\
+    (xh) += ((((SItype) __m0 >> 31) & __m1)				\
+	     + (((SItype) __m1 >> 31) & __m0));				\
+  } while (0)
+#define sdiv_qrnnd(q, r, n1, n0, d) \
+  do {									\
+    union {DItype __ll;							\
+	   struct {SItype __l, __h;} __i;				\
+	  } __xx;							\
+    __xx.__i.__h = n1; __xx.__i.__l = n0;				\
+    __asm__ ("ediv %3,%2,%0,%1"						\
+	     : "=g" (q), "=g" (r)					\
+	     : "g" (__xx.__ll), "g" (d));				\
+  } while (0)
+#endif /* __vax__ */
+
+#if defined (__z8000__) && W_TYPE_SIZE == 16
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("add	%H1,%H5\n\tadc	%H0,%H3"				\
+	   : "=r" ((unsigned int)(sh)),					\
+	     "=&r" ((unsigned int)(sl))					\
+	   : "%0" ((unsigned int)(ah)),					\
+	     "r" ((unsigned int)(bh)),					\
+	     "%1" ((unsigned int)(al)),					\
+	     "rQR" ((unsigned int)(bl)))
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("sub	%H1,%H5\n\tsbc	%H0,%H3"				\
+	   : "=r" ((unsigned int)(sh)),					\
+	     "=&r" ((unsigned int)(sl))					\
+	   : "0" ((unsigned int)(ah)),					\
+	     "r" ((unsigned int)(bh)),					\
+	     "1" ((unsigned int)(al)),					\
+	     "rQR" ((unsigned int)(bl)))
+#define umul_ppmm(xh, xl, m0, m1) \
+  do {									\
+    union {long int __ll;						\
+	   struct {unsigned int __h, __l;} __i;				\
+	  } __xx;							\
+    unsigned int __m0 = (m0), __m1 = (m1);				\
+    __asm__ ("mult	%S0,%H3"					\
+	     : "=r" (__xx.__i.__h),					\
+	       "=r" (__xx.__i.__l)					\
+	     : "%1" (__m0),						\
+	       "rQR" (__m1));						\
+    (xh) = __xx.__i.__h; (xl) = __xx.__i.__l;				\
+    (xh) += ((((signed int) __m0 >> 15) & __m1)				\
+	     + (((signed int) __m1 >> 15) & __m0));			\
+  } while (0)
+#endif /* __z8000__ */
+
+#endif /* __GNUC__ */
+
+/* If this machine has no inline assembler, use C macros.  */
+
+#if !defined (add_ssaaaa)
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  do {									\
+    UWtype __x;								\
+    __x = (al) + (bl);							\
+    (sh) = (ah) + (bh) + (__x < (al));					\
+    (sl) = __x;								\
+  } while (0)
+#endif
+
+#if !defined (sub_ddmmss)
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  do {									\
+    UWtype __x;								\
+    __x = (al) - (bl);							\
+    (sh) = (ah) - (bh) - (__x > (al));					\
+    (sl) = __x;								\
+  } while (0)
+#endif
+
+/* If we lack umul_ppmm but have smul_ppmm, define umul_ppmm in terms of
+   smul_ppmm.  */
+#if !defined (umul_ppmm) && defined (smul_ppmm)
+#define umul_ppmm(w1, w0, u, v)						\
+  do {									\
+    UWtype __w1;							\
+    UWtype __xm0 = (u), __xm1 = (v);					\
+    smul_ppmm (__w1, w0, __xm0, __xm1);					\
+    (w1) = __w1 + (-(__xm0 >> (W_TYPE_SIZE - 1)) & __xm1)		\
+		+ (-(__xm1 >> (W_TYPE_SIZE - 1)) & __xm0);		\
+  } while (0)
+#endif
+
+/* If we still don't have umul_ppmm, define it using plain C.  */
+#if !defined (umul_ppmm)
+#define umul_ppmm(w1, w0, u, v)						\
+  do {									\
+    UWtype __x0, __x1, __x2, __x3;					\
+    UHWtype __ul, __vl, __uh, __vh;					\
+									\
+    __ul = __ll_lowpart (u);						\
+    __uh = __ll_highpart (u);						\
+    __vl = __ll_lowpart (v);						\
+    __vh = __ll_highpart (v);						\
+									\
+    __x0 = (UWtype) __ul * __vl;					\
+    __x1 = (UWtype) __ul * __vh;					\
+    __x2 = (UWtype) __uh * __vl;					\
+    __x3 = (UWtype) __uh * __vh;					\
+									\
+    __x1 += __ll_highpart (__x0);/* this can't give carry */		\
+    __x1 += __x2;		/* but this indeed can */		\
+    if (__x1 < __x2)		/* did we get it? */			\
+      __x3 += __ll_B;		/* yes, add it in the proper pos.  */	\
+									\
+    (w1) = __x3 + __ll_highpart (__x1);					\
+    (w0) = __ll_lowpart (__x1) * __ll_B + __ll_lowpart (__x0);		\
+  } while (0)
+#endif
+
+#if !defined (__umulsidi3)
+#define __umulsidi3(u, v) \
+  ({DWunion __w;							\
+    umul_ppmm (__w.s.high, __w.s.low, u, v);				\
+    __w.ll; })
+#endif
+
+/* Define this unconditionally, so it can be used for debugging.  */
+#define __udiv_qrnnd_c(q, r, n1, n0, d) \
+  do {									\
+    UWtype __d1, __d0, __q1, __q0;					\
+    UWtype __r1, __r0, __m;						\
+    __d1 = __ll_highpart (d);						\
+    __d0 = __ll_lowpart (d);						\
+									\
+    __r1 = (n1) % __d1;							\
+    __q1 = (n1) / __d1;							\
+    __m = (UWtype) __q1 * __d0;						\
+    __r1 = __r1 * __ll_B | __ll_highpart (n0);				\
+    if (__r1 < __m)							\
+      {									\
+	__q1--, __r1 += (d);						\
+	if (__r1 >= (d)) /* i.e. we didn't get carry when adding to __r1 */\
+	  if (__r1 < __m)						\
+	    __q1--, __r1 += (d);					\
+      }									\
+    __r1 -= __m;							\
+									\
+    __r0 = __r1 % __d1;							\
+    __q0 = __r1 / __d1;							\
+    __m = (UWtype) __q0 * __d0;						\
+    __r0 = __r0 * __ll_B | __ll_lowpart (n0);				\
+    if (__r0 < __m)							\
+      {									\
+	__q0--, __r0 += (d);						\
+	if (__r0 >= (d))						\
+	  if (__r0 < __m)						\
+	    __q0--, __r0 += (d);					\
+      }									\
+    __r0 -= __m;							\
+									\
+    (q) = (UWtype) __q1 * __ll_B | __q0;				\
+    (r) = __r0;								\
+  } while (0)
+
+/* If the processor has no udiv_qrnnd but sdiv_qrnnd, go through
+   __udiv_w_sdiv (defined in libgcc or elsewhere).  */
+#if !defined (udiv_qrnnd) && defined (sdiv_qrnnd)
+#define udiv_qrnnd(q, r, nh, nl, d) \
+  do {									\
+    USItype __r;							\
+    (q) = __udiv_w_sdiv (&__r, nh, nl, d);				\
+    (r) = __r;								\
+  } while (0)
+#endif
+
+/* If udiv_qrnnd was not defined for this processor, use __udiv_qrnnd_c.  */
+#if !defined (udiv_qrnnd)
+#define UDIV_NEEDS_NORMALIZATION 1
+#define udiv_qrnnd __udiv_qrnnd_c
+#endif
+
+#if !defined (count_leading_zeros)
+extern const UQItype __clz_tab[];
+#define count_leading_zeros(count, x) \
+  do {									\
+    UWtype __xr = (x);							\
+    UWtype __a;								\
+									\
+    if (W_TYPE_SIZE <= 32)						\
+      {									\
+	__a = __xr < ((UWtype)1<<2*__BITS4)				\
+	  ? (__xr < ((UWtype)1<<__BITS4) ? 0 : __BITS4)			\
+	  : (__xr < ((UWtype)1<<3*__BITS4) ?  2*__BITS4 : 3*__BITS4);	\
+      }									\
+    else								\
+      {									\
+	for (__a = W_TYPE_SIZE - 8; __a > 0; __a -= 8)			\
+	  if (((__xr >> __a) & 0xff) != 0)				\
+	    break;							\
+      }									\
+									\
+    (count) = W_TYPE_SIZE - (__clz_tab[__xr >> __a] + __a);		\
+  } while (0)
+#define COUNT_LEADING_ZEROS_0 W_TYPE_SIZE
+#endif
+
+#if !defined (count_trailing_zeros)
+/* Define count_trailing_zeros using count_leading_zeros.  The latter might be
+   defined in asm, but if it is not, the C version above is good enough.  */
+#define count_trailing_zeros(count, x) \
+  do {									\
+    UWtype __ctz_x = (x);						\
+    UWtype __ctz_c;							\
+    count_leading_zeros (__ctz_c, __ctz_x & -__ctz_x);			\
+    (count) = W_TYPE_SIZE - 1 - __ctz_c;				\
+  } while (0)
+#endif
+
+#ifndef UDIV_NEEDS_NORMALIZATION
+#define UDIV_NEEDS_NORMALIZATION 0
+#endif
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/softfloat/Makefile tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/Makefile
--- linux-2.6.36/arch/mips/softfloat/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/Makefile	2019-03-07 03:40:18.000000000 +0200
@@ -0,0 +1,62 @@
+#
+# Makefile for MIPS-specific library files..
+#
+obj-y := softfloat.o
+
+# soft-float 
+FPBIT_FUNCS = _pack_sf _unpack_sf _addsub_sf _mul_sf _div_sf \
+    _fpcmp_parts_sf _compare_sf _eq_sf _ne_sf _gt_sf _ge_sf \
+    _lt_sf _le_sf _unord_sf _si_to_sf _sf_to_si _negate_sf _make_sf \
+    _sf_to_df _sf_to_tf _thenan_sf _sf_to_usi _usi_to_sf
+
+DPBIT_FUNCS = _pack_df _unpack_df _addsub_df _mul_df _div_df \
+    _fpcmp_parts_df _compare_df _eq_df _ne_df _gt_df _ge_df \
+    _lt_df _le_df _unord_df _si_to_df _df_to_si _negate_df _make_df \
+    _df_to_sf _df_to_tf _thenan_df _df_to_usi _usi_to_df
+
+#LIB2FUNCS_1 = _muldi3 _negdi2 _lshrdi3 _ashldi3 _ashrdi3 _ffsdi2 _clz \
+#    _cmpdi2 _ucmpdi2 _floatdidf _floatdisf _fixunsdfsi _fixunssfsi \
+#    _fixunsdfdi _fixdfdi _fixunssfdi _fixsfdi _fixxfdi _fixunsxfdi
+LIB2FUNCS_1 = _muldi3 _negdi2 _ffsdi2 _clz \
+    _floatdidf _floatundidf _floatdisf _fixunsdfsi _fixunssfsi \
+    _fixunsdfdi _fixdfdi _fixunssfdi _fixsfdi _fixxfdi _fixunsxfdi
+
+
+LIB2FUNCS_2 = _floatdixf _fixunsxfsi _fixtfdi _fixunstfdi _floatditf \
+    _trampoline _absvsi2 _absvdi2 _addvsi3 \
+    _addvdi3 _subvsi3 _subvdi3 _mulvsi3 _mulvdi3 _negvsi2 _negvdi2
+# These might cause a divide overflow trap and so are compiled with
+# unwinder info.
+LIB2_DIVMOD_FUNCS = _divdi3 _moddi3 _udivdi3 _umoddi3 _udiv_w_sdiv _udivmoddi4
+
+DP_OBJS := $(patsubst %,%.o, $(DPBIT_FUNCS))
+FP_OBJS := $(patsubst %,%.o, $(FPBIT_FUNCS))
+GCC_OBJS := $(patsubst %,%.o, $(LIB2FUNCS_1)) $(patsubst %,%.o, $(LIB2FUNCS_2)) $(patsubst %,%.o, $(LIB2_DIVMOD_FUNCS))
+softfloat-objs := $(DP_OBJS) $(FP_OBJS) $(GCC_OBJS) 
+clean-files := dp-bits.c fp-bits.c
+# end softfloat
+
+# soft-float 
+$(addprefix $(obj)/,$(patsubst %,%.o, $(DPBIT_FUNCS))): $(obj)/dp-bits.c
+	$(CC) $(c_flags) -c $(NOSTDINC_FLAGS) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) -DFINE_GRAINED_LIBRARIES -DL$(notdir $(patsubst %.o,%, $@)) $(obj)/dp-bits.c -o $@
+
+$(addprefix $(obj)/,$(patsubst %,%.o, $(FPBIT_FUNCS))): $(obj)/fp-bits.c
+	$(CC) $(c_flags) -c $(NOSTDINC_FLAGS) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) -DFINE_GRAINED_LIBRARIES -DL$(notdir $(patsubst %.o,%, $@)) $(obj)/fp-bits.c -o $@
+
+$(addprefix $(obj)/,$(patsubst %,%.o, $(LIB2FUNCS_1))): $(obj)/libgcc2.c
+	$(CC) $(c_flags) -c $(NOSTDINC_FLAGS) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) -DFINE_GRAINED_LIBRARIES -DL$(notdir $(patsubst %.o,%, $@)) $(obj)/libgcc2.c -o $@
+
+$(addprefix $(obj)/,$(patsubst %,%.o, $(LIB2FUNCS_2))): $(obj)/libgcc2.c
+	$(CC) $(c_flags) -c $(NOSTDINC_FLAGS) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) -DFINE_GRAINED_LIBRARIES -DL$(notdir $(patsubst %.o,%, $@)) $(obj)/libgcc2.c -o $@
+$(addprefix $(obj)/,$(patsubst %,%.o, $(LIB2_DIVMOD_FUNCS))): $(obj)/libgcc2.c
+	$(CC) $(c_flags) -c $(NOSTDINC_FLAGS) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) -DFINE_GRAINED_LIBRARIES -DL$(notdir $(patsubst %.o,%, $@)) $(obj)/libgcc2.c -o $@	
+$(obj)/dp-bits.c: $(src)/fp-bit.c
+	cp $(src)/fp-bit.c $(obj)/dp-bits.c
+
+$(obj)/fp-bits.c: $(src)/fp-bit.c
+	-echo '#define FLOAT' > $@
+	cat $< >> $@
+
+# end softfloat
+
+
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*usb*' -x '*ralink*' -x .gitignore -upN linux-2.6.36/arch/mips/softfloat/tconfig.h tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/tconfig.h
--- linux-2.6.36/arch/mips/softfloat/tconfig.h	1970-01-01 03:00:00.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/arch/mips/softfloat/tconfig.h	2019-03-07 03:40:18.000000000 +0200
@@ -0,0 +1,26 @@
+#define WORDS_BIG_ENDIAN 1
+#define BYTES_BIG_ENDIAN 1
+
+#define UNITS_PER_WORD 4
+#define MIN_UNITS_PER_WORD 4
+
+#define MIN_UNITS_PER_WORD 4
+#define LONG_TYPE_SIZE 32
+
+#define LONG_LONG_TYPE_SIZE 64
+
+#define BITS_PER_UNIT 8
+#define ROUND_TOWARDS_ZERO 0
+#ifndef LARGEST_EXPONENT_IS_NORMAL
+#define LARGEST_EXPONENT_IS_NORMAL(SIZE) 0
+#define BITS_PER_WORD (BITS_PER_UNIT * UNITS_PER_WORD)
+
+#if  (defined _ABIN32 && _MIPS_SIM == _ABIN32) \
+  || (defined _ABI64 && _MIPS_SIM == _ABI64)
+#  define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 128
+# else
+#  define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 64
+# endif
+
+/*typedef unsigned int size_t;*/
+#endif
