diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/cpu.h vr300-linux/arch/mips/include/asm/cpu.h
--- linux-2.6.36/arch/mips/include/asm/cpu.h	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/cpu.h	2019-03-07 03:40:17.000000000 +0200
@@ -72,6 +72,8 @@
 #define PRID_IMP_R5500		0x5500
 #define PRID_IMP_LOONGSON2	0x6300
 
+#define PRID_IMP_TC3162		0xcd00
+
 #define PRID_IMP_UNKNOWN	0xff00
 
 /*
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/mipsregs.h vr300-linux/arch/mips/include/asm/mipsregs.h
--- linux-2.6.36/arch/mips/include/asm/mipsregs.h	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/mipsregs.h	2019-03-07 03:40:17.000000000 +0200
@@ -111,6 +111,27 @@
 #define CP0_TX39_CACHE	$7
 
 /*
+ * TrendChip cache control register 
+ */
+#define CP0_CCTL 		$20		/* Lexra Cache Control Register */
+
+/*
+ * Lexra Cache Control Register fields
+ */
+#define CCTL_DINVAL	   	0x00000001
+#define CCTL_IINVAL		0x00000002
+#define CCTL_ILOCK		0x0000000c
+#define CCTL_IRAMFILL4 	0x00000010
+#define CCTL_IRAMOFF	0x00000020
+
+#define CCTL_IMEMFILL4 	0x00000010
+#define CCTL_IMEMOFF	0x00000020
+#define CCTL_DWB		0x00000100
+#define CCTL_DWBINVAL	0x00000200
+#define CCTL_DMEMON 	0x00000400
+#define CCTL_DMEMOFF 	0x00000800
+
+/*
  * Coprocessor 1 (FPU) register names
  */
 #define CP1_REVISION   $0
@@ -822,6 +843,10 @@
 	local_irq_restore(__flags);					\
 } while (0)
 
+/* TrendChip cache control register */
+#define read_c0_cctl()		__read_32bit_c0_register($20, 0)
+#define write_c0_cctl(val)	__write_32bit_c0_register($20, 0, val)
+
 #define read_c0_index()		__read_32bit_c0_register($0, 0)
 #define write_c0_index(val)	__write_32bit_c0_register($0, 0, val)
 
@@ -1037,12 +1062,18 @@
 #define read_c0_taglo()		__read_32bit_c0_register($28, 0)
 #define write_c0_taglo(val)	__write_32bit_c0_register($28, 0, val)
 
+#define read_c0_idatalo()		__read_32bit_c0_register($28, 1)
+#define write_c0_idatalo(val)	__write_32bit_c0_register($28, 1, val)
+
 #define read_c0_dtaglo()	__read_32bit_c0_register($28, 2)
 #define write_c0_dtaglo(val)	__write_32bit_c0_register($28, 2, val)
 
 #define read_c0_taghi()		__read_32bit_c0_register($29, 0)
 #define write_c0_taghi(val)	__write_32bit_c0_register($29, 0, val)
 
+#define read_c0_idatahi()		__read_32bit_c0_register($29, 1)
+#define write_c0_idatahi(val)	__write_32bit_c0_register($29, 1, val)
+
 #define read_c0_errorepc()	__read_ulong_c0_register($30, 0)
 #define write_c0_errorepc(val)	__write_ulong_c0_register($30, 0, val)
 
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/pgtable-32.h vr300-linux/arch/mips/include/asm/pgtable-32.h
--- linux-2.6.36/arch/mips/include/asm/pgtable-32.h	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/pgtable-32.h	2019-03-07 03:40:17.000000000 +0200
@@ -159,7 +159,7 @@
 #define pte_unmap(pte) ((void)(pte))
 #define pte_unmap_nested(pte) ((void)(pte))
 
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 
 /* Swap entries must have VALID bit cleared. */
 #define __swp_type(x)		(((x).val >> 10) & 0x1f)
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/pgtable-bits.h vr300-linux/arch/mips/include/asm/pgtable-bits.h
--- linux-2.6.36/arch/mips/include/asm/pgtable-bits.h	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/pgtable-bits.h	2019-03-07 03:40:17.000000000 +0200
@@ -50,7 +50,7 @@
 #define _CACHE_SHIFT                3
 #define _CACHE_MASK                 (7<<3)
 
-#elif defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#elif defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 
 #define _PAGE_PRESENT               (1<<0)  /* implemented in software */
 #define _PAGE_READ                  (1<<1)  /* implemented in software */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/pgtable.h vr300-linux/arch/mips/include/asm/pgtable.h
--- linux-2.6.36/arch/mips/include/asm/pgtable.h	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/pgtable.h	2019-03-07 03:40:17.000000000 +0200
@@ -146,7 +146,7 @@
 static inline void set_pte(pte_t *ptep, pte_t pteval)
 {
 	*ptep = pteval;
-#if !defined(CONFIG_CPU_R3000) && !defined(CONFIG_CPU_TX39XX)
+#if !defined(CONFIG_CPU_R3000) && !defined(CONFIG_CPU_TX39XX) && !defined(CONFIG_CPU_TC3162)
 	if (pte_val(pteval) & _PAGE_GLOBAL) {
 		pte_t *buddy = ptep_buddy(ptep);
 		/*
@@ -162,7 +162,7 @@
 
 static inline void pte_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
 {
-#if !defined(CONFIG_CPU_R3000) && !defined(CONFIG_CPU_TX39XX)
+#if !defined(CONFIG_CPU_R3000) && !defined(CONFIG_CPU_TX39XX) && !defined(CONFIG_CPU_TC3162)
 	/* Preserve global status for the pair */
 	if (pte_val(*ptep_buddy(ptep)) & _PAGE_GLOBAL)
 		set_pte_at(mm, addr, ptep, __pte(_PAGE_GLOBAL));
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/spram.h vr300-linux/arch/mips/include/asm/spram.h
--- linux-2.6.36/arch/mips/include/asm/spram.h	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/spram.h	2019-03-07 03:40:17.000000000 +0200
@@ -7,4 +7,8 @@
 static inline void spram_config(void) { };
 #endif /* CONFIG_CPU_MIPSR2 */
 
+extern int is_sram_addr(void *p);
+extern void *alloc_sram(int n);
+extern void free_sram(void *p, int n);
+
 #endif /* _MIPS_SPRAM_H */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/stackframe.h vr300-linux/arch/mips/include/asm/stackframe.h
--- linux-2.6.36/arch/mips/include/asm/stackframe.h	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/stackframe.h	2019-03-07 03:40:17.000000000 +0200
@@ -24,7 +24,7 @@
  */
 #ifdef CONFIG_MIPS_MT_SMTC
 #define STATMASK 0x1e
-#elif defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#elif defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 #define STATMASK 0x3f
 #else
 #define STATMASK 0x1f
@@ -187,8 +187,6 @@
 		 * need it to operate correctly
 		 */
 		LONG_S	$0, PT_R0(sp)
-		mfc0	v1, CP0_STATUS
-		LONG_S	$2, PT_R2(sp)
 #ifdef CONFIG_MIPS_MT_SMTC
 		/*
 		 * Ideally, these instructions would be shuffled in
@@ -199,6 +197,8 @@
 		.set	mips0
 		LONG_S	v1, PT_TCSTATUS(sp)
 #endif /* CONFIG_MIPS_MT_SMTC */
+		mfc0	v1, CP0_STATUS
+		LONG_S	$2, PT_R2(sp)
 		LONG_S	$4, PT_R4(sp)
 		LONG_S	$5, PT_R5(sp)
 		LONG_S	v1, PT_STATUS(sp)
@@ -286,7 +286,7 @@
 		LONG_L	$30, PT_R30(sp)
 		.endm
 
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 
 		.macro	RESTORE_SOME
 		.set	push
@@ -386,6 +386,7 @@
 		andi	v1, TCSTATUS_IXMT
 		bnez	v1, 0f
 
+//#ifndef CONFIG_MIPS_TC3262
 /*
  * We'd like to detect any IPIs queued in the tiny window
  * above and request an software interrupt to service them
@@ -408,6 +409,8 @@
 		mfc0	v0, CP0_CAUSE
 		ori	v0, v0, C_SW1
 		mtc0	v0, CP0_CAUSE
+//#endif
+
 0:
 		/*
 		 * This test should really never branch but
@@ -581,7 +584,7 @@
 #endif /* CONFIG_MIPS_MT_SMTC */
 		mfc0	t0, CP0_STATUS
 		li	t1, ST0_CU0 | (STATMASK & ~1)
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 		andi	t2, t0, ST0_IEP
 		srl	t2, 2
 		or	t0, t2
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/string.h vr300-linux/arch/mips/include/asm/string.h
--- linux-2.6.36/arch/mips/include/asm/string.h	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/string.h	2019-03-07 03:40:17.000000000 +0200
@@ -84,7 +84,7 @@
 	"addiu\t%1,1\n\t"
 	"bnez\t%2,1b\n\t"
 	"lbu\t%2,(%0)\n\t"
-#if defined(CONFIG_CPU_R3000)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TC3162)
 	"nop\n\t"
 #endif
 	"move\t%2,$1\n"
@@ -117,7 +117,7 @@
 	"bnez\t%3,1b\n\t"
 	"addiu\t%1,1\n"
 	"2:\n\t"
-#if defined(CONFIG_CPU_R3000)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TC3162)
 	"nop\n\t"
 #endif
 	"move\t%3,$1\n"
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/tc3162/cmdparse.h vr300-linux/arch/mips/include/asm/tc3162/cmdparse.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/cmdparse.h	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/tc3162/cmdparse.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,32 @@
+#ifndef _CMDPARSE_H_
+#define _CMDPARSE_H_
+/************************************************************************
+ *
+ *	Copyright (C) 2006 Trendchip Technologies, Corp.
+ *	All Rights Reserved.
+ *
+ * Trendchip Confidential; Need to Know only.
+ * Protected as an unpublished work.
+ *
+ * The computer program listings, specifications and documentation
+ * herein are the property of Trendchip Technologies, Co. and shall
+ * not be reproduced, copied, disclosed, or used in whole or in part
+ * for any reason without the prior express written permission of
+ * Trendchip Technologeis, Co.
+ *
+ *************************************************************************/
+
+typedef	struct {
+	char *name;		
+	int	(*func)(int argc,char *argv[],void *p);
+	int	flags;	
+	int	argcmin;
+	char *argc_errmsg;	
+} cmds_t;
+
+extern int cmd_reg_add(char *cmd_name, cmds_t *cmds_p);
+extern int cmd_register(cmds_t *cmds_p);
+extern int cmd_unregister(char *name);
+extern int subcmd(const cmds_t tab[], int argc, char *argv[], void *p);
+
+#endif /* _CMDPARSE_ */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/tc3162/cpu-feature-overrides.h vr300-linux/arch/mips/include/asm/tc3162/cpu-feature-overrides.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/cpu-feature-overrides.h	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/tc3162/cpu-feature-overrides.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,68 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003, 2004 Chris Dearman
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
+ */
+#ifndef __ASM_MACH_RALINK_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_RALINK_CPU_FEATURE_OVERRIDES_H
+
+
+/*
+ * CPU feature overrides for MIPS boards
+ */
+#ifdef CONFIG_CPU_MIPS32
+#define cpu_has_tlb		1
+#define cpu_has_4kex		1
+#define cpu_has_4k_cache	1
+/* #define cpu_has_fpu		? */
+/* #define cpu_has_32fpr	? */
+#define cpu_has_counter		1
+/* #define cpu_has_watch	? */
+#define cpu_has_divec		1
+#define cpu_has_vce		0
+/* #define cpu_has_cache_cdex_p	? */
+/* #define cpu_has_cache_cdex_s	? */
+/* #define cpu_has_prefetch	? */
+#define cpu_has_mcheck		1
+/* #define cpu_has_ejtag	? */
+#define cpu_has_llsc		1
+/* #define cpu_has_vtag_icache	? */
+/* #define cpu_has_dc_aliases	? */
+/* #define cpu_has_ic_fills_f_dc ? */
+#define cpu_has_nofpuex		0
+/* #define cpu_has_64bits	? */
+/* #define cpu_has_64bit_zero_reg ? */
+/* #define cpu_has_inclusive_pcaches ? */
+#define cpu_icache_snoops_remote_store 1
+#endif
+
+#ifdef CONFIG_CPU_MIPS64
+#define cpu_has_tlb		1
+#define cpu_has_4kex		1
+#define cpu_has_4k_cache	1
+/* #define cpu_has_fpu		? */
+/* #define cpu_has_32fpr	? */
+#define cpu_has_counter		1
+/* #define cpu_has_watch	? */
+#define cpu_has_divec		1
+#define cpu_has_vce		0
+/* #define cpu_has_cache_cdex_p	? */
+/* #define cpu_has_cache_cdex_s	? */
+/* #define cpu_has_prefetch	? */
+#define cpu_has_mcheck		1
+/* #define cpu_has_ejtag	? */
+#define cpu_has_llsc		1
+/* #define cpu_has_vtag_icache	? */
+/* #define cpu_has_dc_aliases	? */
+/* #define cpu_has_ic_fills_f_dc ? */
+#define cpu_has_nofpuex		0
+/* #define cpu_has_64bits	? */
+/* #define cpu_has_64bit_zero_reg ? */
+/* #define cpu_has_inclusive_pcaches ? */
+#define cpu_icache_snoops_remote_store 1
+#endif
+
+#endif /* __ASM_MACH_MIPS_CPU_FEATURE_OVERRIDES_H */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/tc3162/int_source.h vr300-linux/arch/mips/include/asm/tc3162/int_source.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/int_source.h	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/tc3162/int_source.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,101 @@
+/************************************************************************
+ *
+ *	Copyright (C) 2006 Trendchip Technologies, Corp.
+ *	All Rights Reserved.
+ *
+ * Trendchip Confidential; Need to Know only.
+ * Protected as an unpublished work.
+ *
+ * The computer program listings, specifications and documentation
+ * herein are the property of Trendchip Technologies, Co. and shall
+ * not be reproduced, copied, disclosed, or used in whole or in part
+ * for any reason without the prior express written permission of
+ * Trendchip Technologeis, Co.
+ *
+ *************************************************************************/
+
+#ifndef _INT_SOURCE_H_
+#define _INT_SOURCE_H_
+
+enum
+interrupt_source
+	{
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		DUMMY_INT,
+#endif
+		UART_INT,		//0 	IPL10
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		PTM_B0_INT,		//1
+		SI_SWINT1_INT0,	//2
+		SI_SWINT1_INT1,	//3
+#else
+		RTC_ALARM_INT,	//1 	IPL29
+		RTC_TICK_INT,	//2 	IPL31
+		RESERVED0,		//3 	IPL30
+#endif
+		TIMER0_INT, 	//4 	IPL1
+		TIMER1_INT, 	//5 	IPL5
+		TIMER2_INT, 	//6 	IPL6
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		SI_SWINT_INT0, 	//7
+		SI_SWINT_INT1, 	//8
+#else
+		TIMER3_INT, 	//7 	IPL7
+		TIMER4_INT, 	//8 	IPL8
+#endif
+		TIMER5_INT, 	//9 	IPL9
+		GPIO_INT,		//10	IPL11
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		RESERVED1,		//11	IPL20
+		SI_PC1_INT, 	//12
+		SI_PC_INT, 		//13
+#else
+		PCIE_A_INT,		//11	IPL20
+		PCIE_SERR_INT,	//12	IPL21
+		RESERVED3,		//13	IPL22
+#endif
+		APB_DMA0_INT,	//14	IPL12
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		MAC1_INT,		//15	IPL13
+#else
+		APB_DMA1_INT,	//15	IPL13
+#endif
+		HSUART_INT,		//16	IPL23
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+
+		PTM_B1_INT,		//17
+#else
+		RESERVED5,		//17	IPL24
+#endif
+		DYINGGASP_INT,	//18	IPL25
+		DMT_INT,		//19	IPL26
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		USB20_INT,
+#else
+		ARBITER_ERR_INT,//20	IPL0
+#endif
+		MAC_INT,		//21	IPL3
+		SAR_INT,		//22	IPL2
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		USB11_INT,
+#else
+		USB_INT,		//23	IPL14
+#endif
+		PCI_A_INT,		//24
+		PCI_B_INT,		//25
+//		  RESERVED8,	  //24	  IPL27
+//		  RESERVED9,	  //25	  IPL28
+		XSLV0_INT,		//26	IPL15
+		XSLV1_INT,		//27	IPL16
+		XSLV2_INT,		//28	IPL17
+#if defined(CONFIG_MIPS_TC3262) && defined(TCSUPPORT_CT)
+		SI_TIMER1_INT,	//29
+		SI_TIMER_INT,	//30
+#else
+		XAPB0_INT,		//29	IPL18
+		XAPB1_INT,		//30	IPL19
+#endif
+		SWR_INT 		//31	IPL4
+	};
+
+#endif /* _INT_SOURCE_H_ */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/tc3162/irq.h vr300-linux/arch/mips/include/asm/tc3162/irq.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/irq.h	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/tc3162/irq.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,13 @@
+#ifndef __ASM_MACH_MIPS_IRQ_H
+#define __ASM_MACH_MIPS_IRQ_H
+
+
+#ifdef CONFIG_MIPS_TC3262
+#define NR_IRQS 64
+#else
+#define NR_IRQS 32
+#endif
+
+#include_next <irq.h>
+
+#endif /* __ASM_MACH_MIPS_IRQ_H */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/tc3162/kprofile_hook.h vr300-linux/arch/mips/include/asm/tc3162/kprofile_hook.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/kprofile_hook.h	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/tc3162/kprofile_hook.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,42 @@
+#ifndef __KPROFILE_HOOK_H
+#define __KPROFILE_HOOK_H
+
+extern void (*profilingSetupHook)(unsigned int tbl_size);
+extern void (*profilingEventHook)(unsigned int cntr, unsigned int event, unsigned int count, 
+						unsigned int kernel, unsigned int user, unsigned int exl);
+extern void (*profilingStartHook)(void);
+extern void (*profilingStopHook)(void);
+extern void (*profilingLogHook)(unsigned int label, unsigned int usr_data);
+
+static inline void kprofileSetup(unsigned int tbl_size)
+{
+	if (profilingSetupHook)
+		profilingSetupHook(tbl_size);
+}
+
+static inline void kprofileEvent(unsigned int cntr, unsigned int event, unsigned int count, 
+						unsigned int kernel, unsigned int user, unsigned int exl)
+{
+	if (profilingEventHook)
+		profilingEventHook(cntr, event, count, kernel, user, exl);
+}
+
+static inline void kprofileStart(void)
+{
+	if (profilingStartHook)
+		profilingStartHook();
+}
+
+static inline void kprofileStop(void)
+{
+	if (profilingStopHook)
+		profilingStopHook();
+}
+
+static inline void kprofileLog(unsigned int label, unsigned int usr_data)
+{
+	if (profilingLogHook)
+		profilingLogHook(label, usr_data);
+}
+
+#endif
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/tc3162/ledcetrl.h vr300-linux/arch/mips/include/asm/tc3162/ledcetrl.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/ledcetrl.h	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/tc3162/ledcetrl.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,352 @@
+/*
+** $Id: ledcetrl.h,v 1.4 2011/01/07 04:05:20 pork Exp $
+*/
+/************************************************************************
+ *
+ *	Copyright (C) 2006 Trendchip Technologies, Corp.
+ *	All Rights Reserved.
+ *
+ * Trendchip Confidential; Need to Know only.
+ * Protected as an unpublished work.
+ *
+ * The computer program listings, specifications and documentation
+ * herein are the property of Trendchip Technologies, Co. and shall
+ * not be reproduced, copied, disclosed, or used in whole or in part
+ * for any reason without the prior express written permission of
+ * Trendchip Technologeis, Co.
+ *
+ *************************************************************************/
+/*
+** $Log: ledcetrl.h,v $
+** Revision 1.4  2011/01/07 04:05:20  pork
+** commit TDI layer with Zarlink 2S1O
+**
+** Revision 1.3  2010/10/15 05:02:10  xmdai_nj
+** #7017:add function for wlan button(main trunk)
+**
+** Revision 1.2  2010/06/11 00:31:06  xhshi
+** #5964 support dare's new led and key requests
+**
+** Revision 1.1.1.1  2010/04/09 09:39:21  feiyan
+** New TC Linux Make Flow Trunk
+**
+** Revision 1.3  2010/03/22 14:15:16  yzwang_nj
+** [Bug#5128] Implement TR068 LED
+**
+** Revision 1.2  2010/03/19 07:16:59  xyyou
+** # 5213 Add  RT3390 11n Webpage
+** Support RT3390 AutoChannel feature
+** Support RT3390 WMM feature
+** # 5214 Support RT3390 wps feature
+**      Add wps led spec&not spec
+**
+** Revision 1.1.1.1  2009/12/17 01:42:47  josephxu
+** 20091217, from Hinchu ,with VoIP
+**
+** Revision 1.1.1.1  2007/04/12 09:42:03  ian
+** TCLinuxTurnkey2007
+**
+** Revision 1.2  2006/07/06 07:24:57  lino
+** update copyright year
+**
+** Revision 1.1.1.1  2005/11/02 05:45:38  lino
+** no message
+**
+** Revision 1.3  2004/10/12 08:33:45  lino
+** add 10M/100M ethernet led define
+**
+*/
+
+#ifndef _LEDCETRL_H
+#define _LEDCETRL_H
+
+/*__________________________________________________________________________
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%%      constant definition
+%%________________________________________________________________________*/
+
+
+
+#ifdef TCSUPPORT_GPIO_ECM
+#define LED_TYPE_MAX_NO		16
+	//define led flash peroid parameter
+#define MAX_LED_FLASH_PERIOD		128
+#define LED_FLASH_PERIOD_LOW		1
+#define LED_FLASH_PERIOD_HIGH		0
+#define MAX_LED_FLASH_MAP			8
+	//define serial gpio control status
+#define SLED_STATUS_REDAY			0x1<<31
+	// define led interface type
+#define LED_SERIAL					1
+#define LED_PARALLEL				0
+#endif
+
+#ifdef TCSUPPORT_USB_HOST_LED
+#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7505)
+#define USBPHYPORT1 1
+#define USBPHYPORT2 2
+
+#define USB_DISCONNECT 1
+#define USB_CONNECT 2
+#define USB_BLINK 3
+#define USB_DEFAULT 4
+#endif
+#endif
+
+#ifdef TCSUPPORT_WLAN_LED_BY_SW
+#define WLAN_DISCONNECT 0
+#define WLAN_CONNECT 1
+#define WLAN_BLINK 2
+#define WLAN_DEFAULT 3
+#endif
+// define led mode
+#define LED_MODE_NOT_USED			0
+#define LED_MODE_ONOFF				1
+#define LED_MODE_BLINK				2
+#define LED_MODE_NOACT				3
+#define LED_MODE_PULSE				4
+/*20090811pork modified: add for sys reset gpio*/
+#define LED_MODE_INPUT				5
+#define LED_MODE_BLINKING			6	/* working when gpio led on */
+#define LED_MODE_FLASH				7	/* working when gpio led on */
+#define LED_MODE_MASK				0xf
+#define LED_MODE_BICOLOR			0x10
+
+// define led blink speed
+#define LED_SPEED_FAST				0
+#define LED_SPEED_MED				1
+#define LED_SPEED_SLOW				2
+#define LED_SPEED_VERY_SLOW			3
+#ifdef TCSUPPORT_WLAN_LED_BY_SW
+#define LED_SPEED_FASTEST			4
+#endif
+
+/*Add by YuChuwei, For PV-W422T-1200ACG. To stop LED Blink*/
+#define LED_SPEED_STOP	(LED_SPEED_FAST + 10)
+#define LED_SPEED_BLINK_STOP (LED_SPEED_FAST + 5)
+
+// define software led no
+#define LED_BASE 					0
+
+#define LED_DSL_STATUS				(LED_BASE + 0)
+#define LED_DSL_ACT_STATUS			(LED_BASE + 1)
+#define LED_DSL_NOACT_STATUS		(LED_BASE + 2)
+#define LED_DSL_IDLE_STATUS			(LED_BASE + 3)
+#define LED_DSL_HANDSHAKE_STATUS	(LED_BASE + 4)
+#define LED_DSL_TRAINING_STATUS		(LED_BASE + 5)
+#define LED_DSL_SHOWTIME_STATUS		(LED_BASE + 6)
+
+#define LED_PPP_STATUS				(LED_BASE + 7)
+#define LED_PPP_ACT_STATUS			(LED_BASE + 8)
+#define LED_PPP_NOACT_STATUS		(LED_BASE + 9)
+
+#define LED_USB_STATUS				(LED_BASE + 10)
+#define LED_USB_ACT_STATUS			(LED_BASE + 11)
+#define LED_USB_NOACT_STATUS		(LED_BASE + 12)
+
+#define LED_WLAN_STATUS				(LED_BASE + 13)
+#define LED_WLAN_ACT_STATUS			(LED_BASE + 14)
+#define LED_WLAN_NOACT_STATUS		(LED_BASE + 15)
+
+#define LED_ETHER_STATUS			(LED_BASE + 16)
+#define LED_ETHER_ACT_STATUS		(LED_BASE + 17)
+#define LED_ETHER_NOACT_STATUS		(LED_BASE + 18)
+
+#define LED_FLASH_STATUS			(LED_BASE + 19)
+#define LED_SYS_BOOT_STATUS			(LED_BASE + 20)
+#define LED_SYS_STATUS				(LED_BASE + 21)
+#define LED_SYS_INIT_STATUS			(LED_BASE + 22)
+
+#define LED_ETHER_10M_STATUS		(LED_BASE + 23)
+#define LED_ETHER_10M_ACT_STATUS	(LED_BASE + 24)
+#define LED_ETHER_10M_NOACT_STATUS	(LED_BASE + 25)
+
+#define LED_ETHER_100M_STATUS		(LED_BASE + 26)
+#define LED_ETHER_100M_ACT_STATUS	(LED_BASE + 27)
+#define LED_ETHER_100M_NOACT_STATUS	(LED_BASE + 28)
+
+#define LED_SIM_CFG_STATUS	(LED_BASE + 29)
+/*add by xjt for PV-W42T-1200ACG,2016-06-30*/
+/*LED_SIM_CFG_STATUS is unused,now use it for vdsl showtime led onoff*/
+#define LED_VDSL_SHOWTIME_STATUS	LED_SIM_CFG_STATUS
+/*end add xjt*/
+#define LED_SIM_CFG_ACT_STATUS	(LED_BASE + 30)
+
+#define LED_LAN_RESET				(LED_BASE + 31)
+//add for TR068 compliance
+#define LED_INTERNET_STATUS		(LED_BASE + 33)
+#define LED_INTERNET_ACT_STATUS		(LED_BASE + 34)
+#define LED_INTERNET_NOACT_STATUS	(LED_BASE + 35)
+#define LED_INTERNET_STATUS_TP		(LED_BASE + 36)
+#define LED_INTERNET_TRYING_STATUS	(LED_BASE + 38)
+#define LED_TR68_PWR_BOOTING		(LED_BASE + 40)
+#define LED_TR68_PWR_BOOTED		(LED_BASE + 41)
+#define LED_PHY_TX_POWER_DISABLE		(LED_BASE + 42)
+#define LED_WLAN_WPS_STATUS		(LED_BASE + 43)
+#define LED_WLAN_WPS_ACT_STATUS	(LED_BASE + 44)
+#define LED_WLAN_WPS_NOACT_STATUS	(LED_BASE + 45)
+
+#define LED_VOIP_SLIC1_RESET (LED_BASE + 46)
+#define LED_VOIP_SLIC2_RESET (LED_BASE + 47)
+#define LED_DSL_ALARM (LED_BASE + 48)
+#define LED_VOIP_HOOK1_STATUS (LED_BASE + 49)
+#define LED_VOIP_HOOK2_STATUS (LED_BASE + 50)
+
+/*Modify by  YuChuwei.For PV-W422T-1200ACGv1*/
+#if 0
+#define LED_SIM_STATUS	(LED_BASE + 51)
+#define LED_SIM_ACT_STATUS	(LED_BASE + 52)
+#define LED_SIM_NOACT_STATUS	(LED_BASE + 53)
+#else
+#define LED_VOIP_USBVM1_STATUS (LED_BASE + 51)
+#define LED_VOIP_USBVM2_STATUS (LED_BASE + 52)
+#endif
+
+/* Modified by Zhao Mengqing, 2016-8-3, always define LED_USB2_STATUS & LED_USB2_ACT_STATUS */
+//#ifdef TCSUPPORT_USB_HOST_LED
+//#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7505)
+#define LED_USB2_STATUS				(LED_BASE + 54)
+#define LED_USB2_ACT_STATUS			(LED_BASE + 55)
+//#endif
+//#endif
+
+#define GPIO_SYS_RESET				(LED_BASE + 56)
+
+#define LED_WLAN_RADIO                 	(LED_BASE + 57) 
+#define GPIO_WLAN_WPS				(LED_BASE + 58)
+
+//add by brian for gpio additional request
+#define LED_PWR_FLASH				(LED_BASE + 59)
+
+
+#define LED_PWR_USB				(LED_BASE + 61)
+
+#define LED_LED_SWITCH                          (LED_BASE + 62)
+
+/*20090811 pork added: fit for linos LED setting*/
+#define LED_LAN1_RESET				(LED_BASE + 63)
+
+#ifdef TCSUPPORT_XPON_LED
+#define LED_XPON_STATUS				(LED_BASE + 64)
+#define LED_XPON_TRYING_STATUS		(LED_BASE + 65)
+
+#define LED_XPON_LOS_ON_STATUS		(LED_BASE + 66)
+#define LED_XPON_LOS_STATUS			(LED_BASE + 67)
+
+#define LED_ETHER_PORT1_STATUS			(LED_BASE + 68)
+#define LED_ETHER_PORT1_ACT_STATUS	(LED_BASE + 69)
+#define LED_ETHER_PORT2_STATUS			(LED_BASE + 70)
+#define LED_ETHER_PORT2_ACT_STATUS	(LED_BASE + 71)
+#define LED_ETHER_PORT3_STATUS			(LED_BASE + 72)
+#define LED_ETHER_PORT3_ACT_STATUS	(LED_BASE + 73)
+#define LED_ETHER_PORT4_STATUS			(LED_BASE + 74)
+#define LED_ETHER_PORT4_ACT_STATUS	(LED_BASE + 75)
+#endif
+
+#define LED_VOIP_REG_STATUS	(LED_BASE + 101)
+#define LED_PHY_VCC_DISABLE		(LED_BASE + 102)
+#define LED_WLAN_2_4G_STATUS		(LED_BASE + 103)
+#define LED_WLAN_5G_STATUS		(LED_BASE + 104)
+
+#define LED_ETH_LAN1		(LED_BASE + 105)
+#define LED_ETH_LAN2		(LED_BASE + 106)
+#define LED_ETH_LAN3		(LED_BASE + 107)
+#define LED_ETH_LAN4		(LED_BASE + 108)
+#define LED_ETH_WAN			(LED_BASE + 109)
+
+/* 49与51, 50与53应该是同样的用途?yuanshang,2012-06-21 */
+//#define LED_VOIP_FXS1_HOOK_STATUS (LED_BASE + 76)
+//#define LED_VOIP_FXS1_RING_STATUS (LED_BASE + 77)
+#define LED_VOIP_FXS2_HOOK_STATUS (LED_BASE + 78)
+#define LED_VOIP_FXS2_RING_STATUS (LED_BASE + 79)
+#define LED_VOIP_FXO_HOOK_STATUS  (LED_BASE + 80)
+#define LED_VOIP_FXO_RING_STATUS  (LED_BASE + 81)
+
+#define mtkled_read_reg_word(reg) 			regRead32(reg)
+#define mtkled_write_reg_word(reg, wdata) 	regWrite32(reg, wdata)
+/*__________________________________________________________________________
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%%      function declaration
+%%________________________________________________________________________*/
+
+void ledInit(void);
+void ledSysInitOn(void);
+void ledSysInitOff(void);
+void ledTurnOn(uint8 led_no);
+void ledTurnOff(uint8 led_no);
+uint8 ledGetMode(uint8 led_no);
+void ledSetMode(uint8 led_no, uint8 mode);
+void ledSetSpeed(uint8 led_no, uint8 speed);
+uint8 ledGetGpio(uint8 led_no);
+void led_oen(uint8 led_no);
+void led_ien(uint8 led_no);
+//#define ledTurnOn(led_no)
+//#define ledTurnOff(led_no)
+int exModeMDIOGpioConf(uint8 mdc_gpio_num,uint8  mdio_gpio_num);
+void exModeMDIOGpioQuery(uint8 * mdc_gpio_num,uint8 * mdio_gpio_num);
+uint32 exModeMDIORead(uint32 reg);
+void exModeMDIOWrite(uint32 reg, uint32 data);
+
+void ledMtnInit(void);
+
+int	ledTaskInit(void);
+void ledTask(void);
+
+#ifdef TCSUPPORT_XPON_HAL_API_EXT
+/* get the ctrl value of gpio num x */
+#define MTK_LED_GET_GPIO_CTRL(x) ((x>31)?(regRead32(CR_GPIO_CTRL1)&(1<<(x-32))):(regRead32(CR_GPIO_CTRL)&(1<<x)))
+/* get the data value of gpio num x */
+#define MTK_LED_GET_GPIO_DATA(x) ((x>31)?(regRead32(CR_GPIO_DATA1)&(1<<(x-32))):(regRead32(CR_GPIO_DATA)&(1<<x)))
+/* gpio num x to write value 1 */
+#define MTK_DO_LED_OFF(x) do {								\
+								if(x > 31){					\
+									regWrite32(CR_GPIO_DATA1,regRead32(CR_GPIO_DATA1)|(1<<(x-32)));	\
+								}else{						\
+									regWrite32(CR_GPIO_DATA,regRead32(CR_GPIO_DATA)|(1<<x));	\
+								}						\
+							} while (0)
+/* gpio num x to write value 0 */
+#define MTK_DO_LED_ON(x) do {								\
+								if(x > 31){ 				\
+									regWrite32(CR_GPIO_DATA1,regRead32(CR_GPIO_DATA1)& ~(1<<(x-32)));	\
+								}else{						\
+									regWrite32(CR_GPIO_DATA,regRead32(CR_GPIO_DATA)& ~(1<<x));	\
+								}						\
+							} while (0)
+/* gpio num x set to ouput enable */
+#define MTK_LED_OEN(x)		do { 	\
+							if(x > 31){ 						\
+								if(x > 47){ 					\
+									regWrite32(CR_GPIO_CTRL3,regRead32(CR_GPIO_CTRL3)|(1<<((x-48)*2))); \
+								}else{							\
+									regWrite32(CR_GPIO_CTRL2,regRead32(CR_GPIO_CTRL2)|(1<<((x-32)*2))); \
+								}								\
+								regWrite32(CR_GPIO_ODRAIN1,regRead32(CR_GPIO_ODRAIN1)|(1<<(x-32))); \
+							}else{								\
+								if(x > 15){ 					\
+									regWrite32(CR_GPIO_CTRL1,regRead32(CR_GPIO_CTRL1)|(1<<((x-16)*2))); \
+								}else{							\
+									regWrite32(CR_GPIO_CTRL,regRead32(CR_GPIO_CTRL)|(1<<(x*2)));	\
+								}								\
+								regWrite32(CR_GPIO_ODRAIN,regRead32(CR_GPIO_ODRAIN)|(1<<(x)));	\
+							}\
+						} while(0)
+/* gpio num x set to input enable */
+#define MTK_LED_IEN(x)		do { 	\
+							if(x > 31){ 						\
+								if(x > 47)						\
+									regWrite32(CR_GPIO_CTRL3,regRead32(CR_GPIO_CTRL3)&~(0x00000003 << ((x-48)* 2)));	\
+								else							\
+									regWrite32(CR_GPIO_CTRL2,regRead32(CR_GPIO_CTRL2)&~(0x00000003 << ((x-32)* 2)));	\
+								regWrite32(CR_GPIO_ODRAIN1,regRead32(CR_GPIO_ODRAIN1)&~(0x00000001 << (x-32))); \
+							}else{								\
+								if(x > 15)						\
+									regWrite32(CR_GPIO_CTRL1,regRead32(CR_GPIO_CTRL1)&~(0x00000003 << ((x-16)* 2)));	\
+								else							\
+									regWrite32(CR_GPIO_CTRL,regRead32(CR_GPIO_CTRL)&~(0x00000003 << (x* 2)));	\
+								regWrite32(CR_GPIO_ODRAIN,regRead32(CR_GPIO_ODRAIN)&~(0x00000001 << x));	\
+							}									\
+					} while(0)
+
+#endif
+#endif
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/tc3162/tc3162.h vr300-linux/arch/mips/include/asm/tc3162/tc3162.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/tc3162.h	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/tc3162/tc3162.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,1329 @@
+/*
+** $Id: tc3162.h,v 1.7 2011/01/07 06:05:58 pork Exp $
+*/
+/************************************************************************
+ *
+ *	Copyright (C) 2006 Trendchip Technologies, Corp.
+ *	All Rights Reserved.
+ *
+ * Trendchip Confidential; Need to Know only.
+ * Protected as an unpublished work.
+ *
+ * The computer program listings, specifications and documentation
+ * herein are the property of Trendchip Technologies, Co. and shall
+ * not be reproduced, copied, disclosed, or used in whole or in part
+ * for any reason without the prior express written permission of
+ * Trendchip Technologeis, Co.
+ *
+ *************************************************************************/
+/*
+** $Log: tc3162.h,v $
+** Revision 1.7  2011/01/07 06:05:58  pork
+** add the definition of INT!16,INT32,SINT15,SINT7
+**
+** Revision 1.6  2010/09/20 07:08:02  shnwind
+** decrease nf_conntrack buffer size
+**
+** Revision 1.5  2010/09/03 16:43:07  here
+** [Ehance] TC3182 GMAC Driver is support TC-Console & WAN2LAN function & update the tc3182 dmt version (3.12.8.83)
+**
+** Revision 1.4  2010/09/02 07:04:50  here
+** [Ehance] Support TC3162U/TC3182 Auto-Bench
+**
+** Revision 1.3  2010/08/30 07:53:02  lino
+** add power saving mode kernel module support
+**
+** Revision 1.2  2010/06/05 05:40:29  lino
+** add tc3182 asic board support
+**
+** Revision 1.1.1.1  2010/04/09 09:39:21  feiyan
+** New TC Linux Make Flow Trunk
+**
+** Revision 1.4  2010/01/14 10:56:42  shnwind
+** recommit
+**
+** Revision 1.3  2010/01/14 08:00:10  shnwind
+** add TC3182 support
+**
+** Revision 1.2  2010/01/10 15:27:26  here
+** [Ehancement]TC3162U MAC EEE is operated at 100M-FD, SAR interface is accroding the SAR_CLK to calculate atm rate.
+**
+** Revision 1.1.1.1  2009/12/17 01:42:47  josephxu
+** 20091217, from Hinchu ,with VoIP
+**
+** Revision 1.2  2006/07/06 07:24:57  lino
+** update copyright year
+**
+** Revision 1.1.1.1  2005/11/02 05:45:38  lino
+** no message
+**
+** Revision 1.5  2005/09/27 08:01:38  bread.hsu
+** adding IMEM support for Tc3162L2
+**
+** Revision 1.4  2005/09/14 11:06:20  bread.hsu
+** new definition for TC3162L2
+**
+** Revision 1.3  2005/06/17 16:26:16  jasonlin
+** Remove redundant code to gain extra 100K bytes free memory.
+** Add "CODE_REDUCTION" definition to switch
+**
+** Revision 1.2  2005/06/14 10:02:01  jasonlin
+** Merge TC3162L2 source code into new main trunk
+**
+** Revision 1.1.1.1  2005/03/30 14:04:22  jasonlin
+** Import Linos source code
+**
+** Revision 1.4  2004/11/15 03:43:17  lino
+** rename ATM SAR max packet length register
+**
+** Revision 1.3  2004/09/01 13:15:47  lino
+** fixed when pc shutdown, system will reboot
+**
+** Revision 1.2  2004/08/27 12:16:37  lino
+** change SYS_HCLK to 96Mhz
+**
+** Revision 1.1  2004/07/02 08:03:04  lino
+** tc3160 and tc3162 code merge
+**
+*/
+
+#ifndef _TC3162_H_
+#define _TC3162_H_
+
+#ifdef CONFIG_MIPS_TC3262 
+#include "./tc3182_int_source.h"
+#else
+#include "./int_source.h" /*shnwind add*/
+#endif
+
+
+#ifndef INT32
+#define INT32
+typedef signed long int int32;    		/* 32-bit signed integer        */
+#endif
+
+#ifndef SINT31
+#define SINT31
+typedef signed long int sint31;        	/* 32-bit signed integer        */
+#endif
+
+#ifndef UINT32
+#define UINT32
+typedef unsigned long int uint32; 		/* 32-bit unsigned integer      */
+#endif
+
+#ifndef SINT15
+#define SINT15
+typedef signed short sint15;            /* 16-bit signed integer        */
+#endif
+
+#ifndef INT16
+#define INT16
+typedef signed short int int16;         /* 16-bit signed integer        */
+#endif
+
+#ifndef UINT16
+#define UINT16
+typedef unsigned short uint16;          /* 16-bit unsigned integer      */
+#endif
+
+#ifndef SINT7
+#define SINT7
+typedef signed char sint7;              /* 8-bit signed integer         */
+#endif
+
+
+#ifndef UINT8
+#define UINT8
+typedef unsigned char uint8;            /* 8-bit unsigned integer       */
+#endif
+
+#ifndef VPint
+#define VPint			*(volatile unsigned long int *)
+#endif
+#ifndef VPshort
+#define VPshort			*(volatile unsigned short *)
+#endif
+#ifndef VPchar
+#define VPchar			*(volatile unsigned char *)
+#endif
+#ifdef TCSUPPORT_MT7510_E1
+static inline unsigned long int regRead32(uint32 reg)	\
+{       						\
+	uint32 tmp;					\
+	tmp = VPint((reg & 0xf) + 0xbfb003a0);   	\
+	__asm__ __volatile("sync");			\
+	tmp = VPint(reg);				\
+	__asm__ __volatile("sync");			\
+        return tmp;             	           	\
+}
+static inline void regWrite32(uint32 reg, uint32 vlaue) \
+{                                                       \
+        VPint(reg) = vlaue;                             \
+	__asm__ __volatile("sync");			\
+}
+
+#else
+static inline uint32 regRead32(uint32 reg)		\
+{						  	\
+	return VPint(reg);			  	\
+}		
+static inline void regWrite32(uint32 reg, uint32 vlaue)	\
+{                                                	\
+        VPint(reg) = vlaue;                      	\
+}
+#endif
+static inline unsigned long int regReadPhy32(uint32 reg)	\
+{       						\
+	uint32 tmp;					\
+	tmp = VPint(reg);	  	\
+	tmp = VPint(reg);				\
+        return tmp;             	           	\
+}
+
+#ifdef CONFIG_CPU_TC3162
+#define TC3162L2		1
+#endif
+
+#define isTC3162L2P2 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)!=0)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L3P3 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==7)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L4P4 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==8)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L5P5E2 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==0xa)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L5P5E3 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==0xb)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isTC3162L5P5 (isTC3162L5P5E2 || isTC3162L5P5E3)
+#define isTC3162U ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==0x10)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+#define isRT63260 ((((unsigned char)(regRead32(0xbfb0008c)>>12)&0xff)==0x20)&&(((regRead32(0xbfb00064)&0xffffffff))==0x00000000)?1:0)
+
+#define isTC3169 	(((regRead32(0xbfb00064)&0xffff0000))==0x00000000)
+#define isTC3182 	(((regRead32(0xbfb00064)&0xffff0000))==0x00010000)
+#define isRT65168 	(((regRead32(0xbfb00064)&0xffff0000))==0x00020000)
+#define isRT63165 	(((regRead32(0xbfb00064)&0xffff0000))==0x00030000)
+#define isRT63365 	(((regRead32(0xbfb00064)&0xffff0000))==0x00040000)
+#define isRT63368   (isRT63365 ? ((((regRead32(0xbfb0008c)>>8) & 0x3) == 0x3) ? 1 : 0): 0)
+#define isRT62806   (((gswPbusRead(0x7ffc))&0xffff0000)==0x28060000)
+
+#define isENP_MOD	(((regRead32(0xBFBF8214)&0x8)==0x8)?(((regRead32(0xBFBF8214)&0x20)==0x20)?1:0):(((regRead32(0xBFBF8214)&0x2)==0x2)?1:0))
+#define isENS_MOD	(((regRead32(0xBFBF8214)&0x8)==0x8)?((regRead32(0xBFBF8214)&0x40)==0x40):((regRead32(0xBFBF8214)&0x4)==0x4))
+#define isMT751020 	(((regRead32(0xbfb00064)&0xffff0000))==0x00050000)
+#define isMT7505 	(((regRead32(0xbfb00064)&0xffff0000))==0x00060000)
+#define isEN751221 	(((VPint(0xbfb00064)&0xffff0000))==0x00070000)
+#define isMT7510	(isMT751020 && ((regRead32(0xbfb000f8)&0x3)==0) && (isENP_MOD))
+#define isMT7511	(isMT751020 && ((regRead32(0xbfb000f8)&0x3)==0)&& (!isENP_MOD))
+#define isMT7520	(((regRead32(0xbfb000f8)&0x3)==0x2) && isMT751020 && (isENP_MOD) && (!isENS_MOD))
+#define isMT7520G	(((regRead32(0xbfb000f8)&0x3)==0x3) && isMT751020 && (isENP_MOD))
+#define isMT7525	(((regRead32(0xbfb000f8)&0x3)==0x2) && isMT751020 && (!isENP_MOD) && (!isENS_MOD))
+#define isMT7525G	(((regRead32(0xbfb000f8)&0x3)==0x3) && isMT751020 && (!isENP_MOD))
+#define isMT7520S       (((regRead32(0xbfb000f8)&0x3)==0x2) && isMT751020 && (isENS_MOD))
+#define isMT7520E2E3 ((regRead32(0xbfb00064) & 0xFF) <= 0x2 && (isMT7520 || isMT7520G || isMT7525 || isMT7525G || isMT7520S))
+#define isEPONFWID   (((regRead32(0xbfb00064) & 0xF) == 0x3) && ((regRead32(0xbfb5fffc) & 0xF) >= 0x1) && (isMT7520 || isMT7520G || isMT7525 || isMT7525G || isMT7520S))
+
+
+#define isEN751221FPGA      ((regRead32(CR_AHB_HWCONF)&(1<<29)) ? 0 : 1) //used for 7512/7521
+#define isGenernalFPGA          ((regRead32(CR_AHB_HWCONF)&(1<<31)) ? 1 : 0) //used for 63365/751020
+#define isFPGA              0 //(isEN751221 ? isEN751221FPGA : isGenernalFPGA )
+
+#define EFUSE_VERIFY_DATA0 (0xBFBF8214)
+#define EFUSE_PKG_MASK          (0x3F)
+#define EFUSE_REMARK_BIT        (1<<6)
+
+#define EFUSE_PKG_REMARK_SHITF 7
+
+#define EFUSE_EN7526F   (0x0)
+#define EFUSE_EN7521F   (0x10)
+#define EFUSE_EN7521S   (0x20)
+#define EFUSE_EN7512    (0x4)
+#define EFUSE_EN7526D   (0x1)
+#define EFUSE_EN7513    (0x5)
+#define EFUSE_EN7526G   (0x2)
+#define EFUSE_EN7521G   (0x12)
+#define EFUSE_EN7513G   (0x6)
+#define EFUSE_EN7586    (0xA)
+#define EFUSE_EN7586    (0xA)
+
+#define isEN7526F (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7526F): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7526F)))
+#define isEN7521F (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7521F): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7521F)))
+#define isEN7521S (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7521S): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7521S)))
+#define isEN7512 (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7512): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7512)))
+#define isEN7526D (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7526D): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7526D)))
+#define isEN7513 (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7513): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7513)))
+#define isEN7526G (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7526G): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7526G)))
+#define isEN7521G (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7521G): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7521G)))
+#define isEN7513G (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7513G): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7513G)))
+#define isEN7586 (isEN751221 && ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        (((regRead32(EFUSE_VERIFY_DATA0)>>EFUSE_PKG_REMARK_SHITF)& EFUSE_PKG_MASK)== EFUSE_EN7586): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)&EFUSE_PKG_MASK)==EFUSE_EN7586)))
+
+#define EFUSE_DDR3_BIT (1<<23)
+#define EFUSE_DDR3_REMARK_BIT (1<<24)
+#define EFUSE_IS_DDR3 ( (regRead32(EFUSE_VERIFY_DATA0)&EFUSE_REMARK_BIT)? \
+                        ((regRead32(EFUSE_VERIFY_DATA0)& EFUSE_DDR3_REMARK_BIT)): \
+                        ((regRead32(EFUSE_VERIFY_DATA0)& EFUSE_DDR3_BIT)))
+
+#define REG_SAVE_INFO 0xBFB00284
+#define SET_DRAM_SIZE(x) regWrite32(REG_SAVE_INFO ,((regRead32(REG_SAVE_INFO)&(~0xfff)) | (x&0xfff)))
+#define GET_DRAM_SIZE   (regRead32(REG_SAVE_INFO)&0xfff)
+#define SET_SYS_CLK(x)  regWrite32(REG_SAVE_INFO ,((regRead32(REG_SAVE_INFO)&~0xfff000) | ((x&0xfff)<<12)))
+#define GET_SYS_CLK     ((regRead32(REG_SAVE_INFO)&0xfff000)>>12)
+
+
+
+
+#ifdef TCSUPPORT_MT7510_E1
+#define READ_E1(x) do{if (VPint(x) == 0)printk("Error Reg %x\n",x);}while(0)
+#endif
+
+#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520)
+#define JUDGE_SWITCH_SCENARIO_BY_751020_SUBMODEL
+#ifdef JUDGE_SWITCH_SCENARIO_BY_751020_SUBMODEL
+#define MT751020_SUBMODEL_REG   (0xbfb000f8)
+
+#define ExistExtMT7530		(isMT7520G || isMT7525G)
+#define DefaultUseExtMT7530	(isMT7520G || isMT7525G)
+#define LanPortIntMT7530	(isMT7510 || isMT7511 || isMT7520 || isMT7525)
+#define LanPortExtMT7530	(isMT7520G || isMT7525G)
+#endif
+#endif
+
+#define isMT7530	(((regRead32(0xbfb58000+0x7ffc)&0xffff0000))==0x75300000)
+//#define isMT7530FPGA	(((gswPbusRead(0x7ffc))&0xffff0000)==0x75300000)
+#define isMT7530ext	(((gswPbusRead(0x7ffc))&0xffff0000)==0x75300000)
+
+#ifdef TC3162L2
+#define RT63260_SYS_HCLK ((12*(((regRead32(0xbfb000b0))&0x1ff)+1)/(((regRead32(0xbfb000b0)>>9)&0x1f)+1))/5)
+#define TC3162U_SYS_HCLK (3*(((regRead32(0xbfb000b0)>>16)&0x1ff)+1)/(((regRead32(0xbfb000b0)>>25)&0x1f)+1))
+#define SYS_HCLK        (isRT63260 ? RT63260_SYS_HCLK : (isTC3162U ? TC3162U_SYS_HCLK : 133))
+#endif
+
+#ifdef CONFIG_MIPS_TC3262
+/* RT63165 ASIC */
+/* FPGA is 25Mhz, ASIC LQFP128 is 166.67Mhz, others are 200Mhz */
+#define	RT63165_SYS_HCLK       	(regRead32(0xbfb0008c)&(1<<31) ? 25 : (regRead32(0xbfb0008c)&(1<<9) ? (200) : (16667/100)))
+/* RT63365 ASIC */
+/* FPGA is 25/32Mhz 
+ * ASIC RT6856/RT63368: DDR(0): 233.33, DDR(1): 175, SDR: 140
+ *      RT6855/RT63365: DDR(0): 166.67, DDR(1): 125, SDR: 140 */
+#define	RT63365_SYS_HCLK       	(regRead32(0xbfb0008c)&(1<<31) ? (25) : (regRead32(0xbfb0008c)&(1<<9) ? (regRead32(0xbfb0008c)&(1<<25) ? (regRead32(0xbfb0008c)&(1<<26) ? (175) : (23333/100)) : (140)) : (regRead32(0xbfb0008c)&(1<<25) ? (regRead32(0xbfb0008c)&(1<<26) ? (125) : (16667/100)) : (140))))
+#define MT751020_CPU_CLK		(((regRead32(0xbfb0008c) >> 0x9) & 0x3) == 0x0) ? (750) : (((regRead32(0xbfb0008c) >> 0x9) & 0x3) == 0x1) ? (650) : (((regRead32(0xbfb0008c) >> 0x9) & 0x3) == 0x2) ? (500) : (250)
+#define	MT751020_SYS_HCLK		((regRead32(0xbfb0008c)&(1<<31)) ? (32) : ((((MT751020_CPU_CLK)* 100) / ((regRead32(0xbfb000f8) >> 0x3) & 0x7)) / 100))
+#define	MT7505_SYS_HCLK		((regRead32(0xbfb0008c)&(1<<31)) ? (32) : (135))  //MT7505 CPU clock is 540
+#define EN7512_SYS_HCLK         ((isFPGA) ? (32) : (GET_SYS_CLK)) //ASIC Clock need Check
+
+#define	SYS_HCLK		(isEN751221?EN7512_SYS_HCLK:(isMT7505? MT7505_SYS_HCLK:(isMT751020  ? MT751020_SYS_HCLK : (isRT63365 ? RT63365_SYS_HCLK : (isRT63165 ? RT63165_SYS_HCLK : (isRT65168 ? (1024/10) : (isTC3182 ? (1024/10) : (3*((VPint(0xbfb00058)>>16)+1)/(((VPint(0xbfb00058)&0x1f)+1)<<1)))))))))
+#endif
+
+#define	SAR_CLK	(SYS_HCLK)/(4.0)		//more accurate if 4.0 not 4
+
+/* define CPU timer clock, FPGA is 50Mhz, ASIC is 250Mhz */
+#define	CPUTMR_CLK		(isFPGA ? (50*1000000) : (isEN751221 ? (200*1000000) : (isMT7505 ? (100*1000000) : (isMT751020 ? (800*1000000/3) :(250*1000000)))))
+
+#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520)
+#define DSPRAM_BASE		0x9dff8000
+#else
+#define DSPRAM_BASE		0x9c000000
+#endif
+
+#define ENABLE          1
+#define DISABLE         0
+
+#define WAN2LAN_CH_ID	(1<<31)
+
+#define tc_inb(offset) 			(*(volatile unsigned char *)(offset))
+#define tc_inw(offset) 			(*(volatile unsigned short *)(offset))
+#define tc_inl(offset) 			(*(volatile unsigned long *)(offset))
+
+#define tc_outb(offset,val)    	(*(volatile unsigned char *)(offset) = val)
+#define tc_outw(offset,val)    	(*(volatile unsigned short *)(offset) = val)
+#define tc_outl(offset,val)    	(*(volatile unsigned long *)(offset) = val)
+
+#if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+#define IS_SPIFLASH		((~(VPint(0xBFA10114))) & 0x2)
+#define IS_NANDFLASH		(VPint(0xBFA10114) & 0x2)
+#else
+#if defined(TCSUPPORT_CPU_MT7505)
+#define IS_SPIFLASH		1
+#define IS_NANDFLASH	0
+#else
+#define IS_SPIFLASH				((regRead32(CR_AHB_SSR) & (1<<20)) || !(regRead32(CR_AHB_HWCONF) & 0x1))
+#define IS_NANDFLASH			(regRead32(CR_AHB_HWCONF) & 0x1)
+#endif
+#endif
+#define NF_CONNTRACK_BUF_SIZE 4096
+/*****************************
+ * RBUS CORE Module Registers *
+ *****************************/
+#define ARB_CFG     		0xBFA00008
+#define ROUND_ROBIN_ENABLE  (1<<30)
+#define ROUND_ROBIN_DISBALE  ~(1<<30)
+
+
+
+/*****************************
+ * DMC Module Registers *
+ *****************************/
+
+#define CR_DMC_BASE     	0xBFB20000
+#define CR_DMC_SRT      	(0x00 | CR_DMC_BASE)
+#define CR_DMC_STC      	(0x01 | CR_DMC_BASE)
+#define CR_DMC_SAMT      	(0x02 | CR_DMC_BASE)
+#define CR_DMC_SCR      	(0x03 | CR_DMC_BASE)
+
+/* RT63165 specific */
+/* DDR self refresh control register */
+#define CR_DMC_DDR_SR    	(0x18 | CR_DMC_BASE)
+/* DDR self refresh target count */
+#define CR_DMC_DDR_SR_CNT  	(0x1c | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG0    	(0x40 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG1    	(0x44 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG2    	(0x48 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG3    	(0x4c | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG4    	(0x50 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG8    	(0x60 | CR_DMC_BASE)
+#define CR_DMC_DDR_CFG9    	(0x64 | CR_DMC_BASE)
+
+#define CR_DMC_CTL0      	(0x70 | CR_DMC_BASE)
+#define CR_DMC_CTL1      	(0x74 | CR_DMC_BASE)
+#define CR_DMC_CTL2      	(0x78 | CR_DMC_BASE)
+#define CR_DMC_CTL3     	(0x7c | CR_DMC_BASE)
+#define CR_DMC_CTL4     	(0x80 | CR_DMC_BASE)
+
+#define CR_DMC_DCSR     	(0xb0 | CR_DMC_BASE)
+
+#define CR_DMC_ISPCFGR     	(0xc0 | CR_DMC_BASE)
+#define CR_DMC_DSPCFGR     	(0xc4 | CR_DMC_BASE)
+
+/* MT7510 */
+#define CR_DRAMC_CONF1		(0x04 | CR_DMC_BASE)
+#define CR_DRAMC_PADCTL4    (0xe4 | CR_DMC_BASE)
+
+/*****************************
+ * GDMA Module Registers *
+ *****************************/
+
+#define CR_GDMA_BASE     	0xBFB30000
+#define CR_GDMA_DCSA      	(0x00 | CR_GDMA_BASE)
+#define CR_GDMA_DCDA      	(0x04 | CR_GDMA_BASE)
+#define CR_GDMA_DCBT      	(0x08 | CR_GDMA_BASE)
+#define CR_GDMA_DCBL      	(0x0a | CR_GDMA_BASE)
+#define CR_GDMA_DCC      	(0x0c | CR_GDMA_BASE)
+#define CR_GDMA_DCS      	(0x0e | CR_GDMA_BASE)
+#define CR_GDMA_DCKSUM     	(0x10 | CR_GDMA_BASE)
+
+/*****************************
+ * SPI Module Registers *
+ *****************************/
+
+#define CR_SPI_BASE     	0xBFBC0000
+#define CR_SPI_CTL      	(0x00 | CR_SPI_BASE)
+#define CR_SPI_OPCODE      	(0x04 | CR_SPI_BASE)
+#define CR_SPI_DATA      	(0x08 | CR_SPI_BASE)
+
+/*****************************
+ * Ethernet Module Registers *
+ *****************************/
+
+#define CR_MAC_BASE     	0xBFB50000
+#define CR_MAC_ISR      	(0x00 | CR_MAC_BASE)// --- Interrupt Status Register ---
+#define CR_MAC_IMR      	(0x04 | CR_MAC_BASE)// --- Interrupt Mask Register ---
+#define CR_MAC_MADR  	   	(0x08 | CR_MAC_BASE)// --- MAC Address Register [47:32] ---
+#define CR_MAC_LADR     	(0x0c | CR_MAC_BASE)// --- MAC Address Register [31:0] ---
+#define CR_MAC_EEE		(0x10 | CR_MAC_BASE)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+// None
+#else
+  #define CR_MAC_MAHT0         (0x10 | CR_MAC_BASE)// --- MAC Hash Table Address Register [31:0] ---
+  #define CR_MAC_MAHT1         (0x14 | CR_MAC_BASE)// --- MAC Hash Table Address Register [31:0] ---
+#endif
+#define CR_MAC_TXPD     	(0x18 | CR_MAC_BASE)// --- Transmit Poll Demand Register ---
+#define CR_MAC_RXPD     	(0x1c | CR_MAC_BASE)// --- Receive Poll Demand Register ---
+#define CR_MAC_TXR_BADR 	(0x20 | CR_MAC_BASE)// --- Transmit Ring Base Address Register ---
+#define CR_MAC_RXR_BADR 	(0x24 | CR_MAC_BASE)// --- Receive Ring Base Address Register ---
+#define CR_MAC_ITC      	(0x28 | CR_MAC_BASE)// --- Interrupt Timer Control Register ---
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+  #define CR_MAC_TXR_SIZE  	   (0x2c | CR_MAC_BASE)// --- Transmit Ring Size Register ---
+  #define CR_MAC_RXR_SIZE      (0x30 | CR_MAC_BASE)// --- Receive Ring Size Register ---
+  #define CR_MAC_RXR_SWIDX     (0x34 | CR_MAC_BASE)// --- Receive Ring Software Index Register ---
+#else
+#define CR_MAC_APTC     	(0x2c | CR_MAC_BASE)// --- Automatic Polling Timer Control Register ---
+#define CR_MAC_DBLAC    	(0x30 | CR_MAC_BASE)// --- DMA Burst Length and Arbitration Control Register ---
+#endif
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+  #define CR_MAC_TXDESP_SIZE   (0x38 | CR_MAC_BASE)// --- Transmit Descriptor Size Register ---
+  #define CR_MAC_RXDESP_SIZE   (0x3c | CR_MAC_BASE)// --- Receive Descriptor Size Register ---
+#else
+  #define CR_MAC_TXDESCP_ADR   (0x38 | CR_MAC_BASE)// --- Current Transmit Descriptor Address Register ---
+  #define CR_MAC_RXDESCP_ADR   (0x3c | CR_MAC_BASE)// --- Current Receive Descriptor Address Register ---
+#endif
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+  #define CR_MAC_PRIORITY_CFG  (0x50 | CR_MAC_BASE)// --- Priority Configuration Register ---
+  #define CR_MAC_VLAN_CFG      (0x54 | CR_MAC_BASE)// --- VLAN Configuration Register ---
+  #define CR_MAC_TOS0_CFG      (0x58 | CR_MAC_BASE)// --- TOS 0 Configuration Register ---
+  #define CR_MAC_TOS1_CFG      (0x5c | CR_MAC_BASE)// --- TOS 1 Configuration Register ---
+  #define CR_MAC_TOS2_CFG      (0x60 | CR_MAC_BASE)// --- TOS 2 Configuration Register ---
+  #define CR_MAC_TOS3_CFG      (0x64 | CR_MAC_BASE)// --- TOS 3 Configuration Register ---
+  #define CR_MAC_TCP_CFG       (0x68 | CR_MAC_BASE)// --- TCP Configuration Register ---
+  #define CR_MAC_SWTAG_CFG     (0x6c | CR_MAC_BASE)// --- Software Tagging Configuration Register ---
+  #define CR_MAC_PMBL_CYC_NUM  (0x70 | CR_MAC_BASE)// --- Preamble Cycle Number Register ---
+  #define CR_MAC_FCTL_CYC_NUM  (0x74 | CR_MAC_BASE)// --- Flow Control Cycle Number Register ---
+  #define CR_MAC_JAM_CYC_NUM   (0x78 | CR_MAC_BASE)// --- JAM Cycle Number Register ---
+  #define CR_MAC_DEFER_VAL     (0x7c | CR_MAC_BASE)// --- Defer Value Register ---
+  #define CR_MAC_RANDOM_POLY   (0x80 | CR_MAC_BASE)// --- Random Polynomial Register ---
+#else
+// None
+#endif
+#define CR_MAC_MACCR    	(0x88 | CR_MAC_BASE)// --- MAC Control Register ---
+#define CR_MAC_MACSR    	(0x8c | CR_MAC_BASE)// --- MAC Status Register ---
+#define CR_MAC_PHYCR    	(0x90 | CR_MAC_BASE)// --- PHY Control Register ---
+#define CR_MAC_PHYWDATA 	(0x94 | CR_MAC_BASE)// --- PHY Write Data Register ---
+#define CR_MAC_FCR      	(0x98 | CR_MAC_BASE)// --- Flow Control Register ---
+#define CR_MAC_BPR      	(0x9c | CR_MAC_BASE)// --- Back Pressure Register ---
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define CR_MAC_DESP_IDX        (0xc4 | CR_MAC_BASE)// --- Current Tx/Rx Descriptor Index ---
+#endif
+#define CR_MAC_WOLCR    	(0xa0 | CR_MAC_BASE)// --- Wake-On-LAN Control Register ---
+#define CR_MAC_WOLSR    	(0xa4 | CR_MAC_BASE)// --- Wake-On-LAN Status Register ---
+#define CR_MAC_WFCRC    	(0xa8 | CR_MAC_BASE)// --- Wake-up Frame CRC Register ---
+#define CR_MAC_WFBM1    	(0xb0 | CR_MAC_BASE)// --- Wake-up Frame Byte Mask 1st Double Word Register ---
+#define CR_MAC_WFBM2    	(0xb4 | CR_MAC_BASE)// --- Wake-up Frame Byte Mask 2nd Double Word Register ---
+#define CR_MAC_WFBM3    	(0xb8 | CR_MAC_BASE)// --- Wake-up Frame Byte Mask 3rd Double Word Register ---
+#define CR_MAC_WFBM4    	(0xbc | CR_MAC_BASE)// --- Wake-up Frame Byte Mask 4th Double Word Register ---
+#define CR_MAC_DMA_FSM  	(0xc8 | CR_MAC_BASE)// --- DMA State Machine
+#define CR_MAC_TM       	(0xcc | CR_MAC_BASE)// --- Test Mode Register ---
+#define CR_MAC_XMPG_CNT 	(0xdc | CR_MAC_BASE)// --- XM and PG Counter Register ---
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define CR_MAC_RUNT_TLCC_CNT   (0xe0 | CR_MAC_BASE)// --- Receive Runt and Transmit Late Collision Packet Counter Register ---
+#define CR_MAC_RCRC_RLONG_CNT  (0xe4 | CR_MAC_BASE)// --- Receive CRC Error and Long Packet Counter Register ---
+#define CR_MAC_RLOSS_RCOL_CNT  (0xe8 | CR_MAC_BASE)// --- Receive Packet Loss and Receive Collision Counter Register ---
+#else
+#define CR_MAC_RUNT_LCOL_CNT 	(0xe0 | CR_MAC_BASE)// --- Runt and Late Collision Packet Counter Register ---
+#define CR_MAC_CRC_LONG_CNT   	(0xe4 | CR_MAC_BASE)// --- CRC and Long Packet Counter Register ---
+#define CR_MAC_LOSS_COL_CNT   	(0xe8 | CR_MAC_BASE)// --- Receive Packet Loss and Receive Collision Counter Register ---
+#endif
+#define CR_MAC_BROADCAST_CNT  	(0xec | CR_MAC_BASE)// --- Receive Broadcast Counter Register ---
+#define CR_MAC_MULTICAST_CNT  	(0xf0 | CR_MAC_BASE)// --- Receive Multicast Counter Register ---
+#define CR_MAC_RX_CNT   	(0xf4 | CR_MAC_BASE)// --- Receive Good Packet Counter Register ---
+#define CR_MAC_TX_CNT   	(0xf8 | CR_MAC_BASE)// --- Transmit Good Packet Counter Register ---
+
+/*************************
+ * UART Module Registers *
+ *************************/
+#ifdef __BIG_ENDIAN
+#define CR_UART_OFFSET		(0x03)
+#else
+#define CR_UART_OFFSET		(0x0)
+#endif
+
+#define	CR_UART_BASE    	0xBFBF0000
+#define	CR_UART_RBR     	(0x00+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_THR     	(0x00+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_IER     	(0x04+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_IIR     	(0x08+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_FCR     	(0x08+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_LCR     	(0x0c+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_MCR     	(0x10+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_LSR     	(0x14+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_MSR     	(0x18+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_SCR     	(0x1c+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_BRDL    	(0x00+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_BRDH    	(0x04+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_WORDA		(0x20+CR_UART_BASE+0x00)
+#define	CR_UART_HWORDA		(0x28+CR_UART_BASE+0x00)
+#define	CR_UART_MISCC		(0x24+CR_UART_BASE+CR_UART_OFFSET)
+#define	CR_UART_XYD     	(0x2c+CR_UART_BASE)
+
+#define	UART_BRD_ACCESS		0x80
+#define	UART_XYD_Y          65000
+#define	UART_UCLK_115200    0
+#define	UART_UCLK_57600     1
+#define	UART_UCLK_38400     2
+#define	UART_UCLK_28800		3
+#define	UART_UCLK_19200		4
+#define	UART_UCLK_14400		5
+#define	UART_UCLK_9600		6
+#define	UART_UCLK_4800		7
+#define	UART_UCLK_2400		8
+#define	UART_UCLK_1200		9
+#define	UART_UCLK_600		10
+#define	UART_UCLK_300		11
+#define	UART_UCLK_110		12
+#define	UART_BRDL			0x03
+#define	UART_BRDH			0x00
+#define	UART_LCR			0x03
+#define	UART_FCR			0x0f
+#define	UART_WATERMARK		(0x0<<6)
+#define	UART_MCR			0x0
+#define	UART_MISCC			0x0
+//#define UART_IER			0x07
+//#define	UART_IER			0x05
+#define	UART_IER			0x01
+
+#define	IER_RECEIVED_DATA_INTERRUPT_ENABLE	0x01
+#define	IER_THRE_INTERRUPT_ENABLE			0x02
+#define	IER_LINE_STATUS_INTERRUPT_ENABLE	0x04
+
+#define	IIR_INDICATOR						VPchar(CR_UART_IIR)
+#define	IIR_RECEIVED_LINE_STATUS			0x06
+#define	IIR_RECEIVED_DATA_AVAILABLE			0x04
+#define IIR_RECEIVER_IDLE_TRIGGER			0x0C
+#define	IIR_TRANSMITTED_REGISTER_EMPTY		0x02
+#define	LSR_INDICATOR						VPchar(CR_UART_LSR)
+#define	LSR_RECEIVED_DATA_READY				0x01
+#define	LSR_OVERRUN							0x02
+#define	LSR_PARITY_ERROR					0x04
+#define	LSR_FRAME_ERROR						0x08
+#define	LSR_BREAK							0x10
+#define	LSR_THRE							0x20
+#define	LSR_THE								0x40
+#define	LSR_RFIFO_FLAG						0x80
+
+#define uartTxIntOn()		VPchar(CR_UART_IER) |= IER_THRE_INTERRUPT_ENABLE
+#define uartTxIntOff()		VPchar(CR_UART_IER) &= ~IER_THRE_INTERRUPT_ENABLE
+#define uartRxIntOn()		VPchar(CR_UART_IER) |= IER_RECEIVED_DATA_INTERRUPT_ENABLE
+#define	uartRxIntOff()		VPchar(CR_UART_IER) &= ~IER_RECEIVED_DATA_INTERRUPT_ENABLE
+
+/*************************
+ * UART2 Module Registers *
+ *************************/
+#ifdef TCSUPPORT_UART2
+#define	CR_UART2_BASE    	0xBFBF0300
+#define	CR_UART2_RBR     	(0x00+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_THR     	(0x00+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_IER     	(0x04+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_IIR     	(0x08+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_FCR     	(0x08+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_LCR     	(0x0c+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_MCR     	(0x10+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_LSR     	(0x14+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_MSR     	(0x18+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_SCR     	(0x1c+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_BRDL    	(0x00+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_BRDH    	(0x04+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_WORDA		(0x20+CR_UART2_BASE+0x00)
+#define	CR_UART2_HWORDA	    (0x28+CR_UART2_BASE+0x00)
+#define	CR_UART2_MISCC		(0x24+CR_UART2_BASE+CR_UART_OFFSET)
+#define	CR_UART2_XYD     	(0x2c+CR_UART2_BASE)
+
+#define	IIR_INDICATOR2		VPchar(CR_UART2_IIR)
+#define	LSR_INDICATOR2		VPchar(CR_UART2_LSR)
+#endif
+
+/*************************
+ * HSUART Module Registers *
+ *************************/
+#define	CR_HSUART_BASE    	0xBFBF0300
+#define	CR_HSUART_RBR     	(0x00+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_THR     	(0x00+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_IER     	(0x04+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_IIR     	(0x08+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_FCR     	(0x08+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_LCR     	(0x0c+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_MCR     	(0x10+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_LSR     	(0x14+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_MSR     	(0x18+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_SCR     	(0x1c+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_BRDL    	(0x00+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_BRDH    	(0x04+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_WORDA		(0x20+CR_HSUART_BASE+0x00)
+#define	CR_HSUART_HWORDA	(0x28+CR_HSUART_BASE+0x00)
+#define	CR_HSUART_MISCC		(0x24+CR_HSUART_BASE+CR_UART_OFFSET)
+#define	CR_HSUART_XYD     	(0x2c+CR_HSUART_BASE)
+
+/**********************************
+ * Interrupt Controller Registers *
+ **********************************/
+#define CR_INTC_BASE    0xBFB40000
+			// --- Interrupt Type Register ---
+#define CR_INTC_ITR     (CR_INTC_BASE+0x0000)
+			// --- Interrupt Mask Register ---
+#define CR_INTC_IMR     (CR_INTC_BASE+0x0004)
+			// --- Interrupt Pending Register ---
+#define CR_INTC_IPR     (CR_INTC_BASE+0x0008)
+			// --- Interrupt Set Register ---
+#define CR_INTC_ISR    	(CR_INTC_BASE+0x000c)
+			// --- Interrupt Priority Register 0 ---
+#define CR_INTC_IPR0    (CR_INTC_BASE+0x0010)
+			// --- Interrupt Priority Register 1 ---
+#define CR_INTC_IPR1    (CR_INTC_BASE+0x0014)
+			// --- Interrupt Priority Register 2 ---
+#define CR_INTC_IPR2    (CR_INTC_BASE+0x0018)
+			// --- Interrupt Priority Register 3 ---
+#define CR_INTC_IPR3    (CR_INTC_BASE+0x001c)
+			// --- Interrupt Priority Register 4 ---
+#define CR_INTC_IPR4    (CR_INTC_BASE+0x0020)
+			// --- Interrupt Priority Register 5 ---
+#define CR_INTC_IPR5    (CR_INTC_BASE+0x0024)
+			// --- Interrupt Priority Register 6 ---
+#define CR_INTC_IPR6    (CR_INTC_BASE+0x0028)
+			// --- Interrupt Priority Register 7 ---
+#define CR_INTC_IPR7    (CR_INTC_BASE+0x002c)
+			// --- Interrupt Vector egister ---
+#ifdef CONFIG_MIPS_TC3262
+			// --- Interrupt VPE and SRS Register 0 ---
+#define CR_INTC_IVSR0   (CR_INTC_BASE+0x0030)
+			// --- Interrupt VPE and SRS Register 1 ---
+#define CR_INTC_IVSR1   (CR_INTC_BASE+0x0034)
+			// --- Interrupt VPE and SRS Register 2 ---
+#define CR_INTC_IVSR2   (CR_INTC_BASE+0x0038)
+			// --- Interrupt VPE and SRS Register 3 ---
+#define CR_INTC_IVSR3   (CR_INTC_BASE+0x003c)
+			// --- Interrupt VPE and SRS Register 4 ---
+#define CR_INTC_IVSR4   (CR_INTC_BASE+0x0040)
+			// --- Interrupt VPE and SRS Register 5 ---
+#define CR_INTC_IVSR5   (CR_INTC_BASE+0x0044)
+			// --- Interrupt VPE and SRS Register 6 ---
+#define CR_INTC_IVSR6   (CR_INTC_BASE+0x0048)
+			// --- Interrupt VPE and SRS Register 7 ---
+#define CR_INTC_IVSR7   (CR_INTC_BASE+0x004c)
+			// --- Interrupt Vector egister ---
+#define CR_INTC_IVR     (CR_INTC_BASE+0x0050)
+
+/* RT63165 */
+			// --- Interrupt Mask Register ---
+#define CR_INTC_IMR_1   (CR_INTC_BASE+0x0050)
+			// --- Interrupt Pending Register ---
+#define CR_INTC_IPR_1   (CR_INTC_BASE+0x0054)
+			// --- Interrupt Priority Register 8 ---
+#define CR_INTC_IPSR8	(CR_INTC_BASE+0x0058)
+			// --- Interrupt Priority Register 9 ---
+#define CR_INTC_IPSR9	(CR_INTC_BASE+0x005c)
+			// --- Interrupt VPE and SRS Register 8 ---
+#define CR_INTC_IVSR8   (CR_INTC_BASE+0x0060)
+			// --- Interrupt VPE and SRS Register 9 ---
+#define CR_INTC_IVSR9   (CR_INTC_BASE+0x0064)
+
+/*MT7510*/
+#define CR_INTC_NMI0IMR0   (CR_INTC_BASE+0x0080)
+#define CR_INTC_NMI1IMR0   (CR_INTC_BASE+0x0088)
+
+
+
+
+#else
+			// --- Interrupt Vector egister ---
+#define CR_INTC_IVR     (CR_INTC_BASE+0x0030)
+#endif
+
+#if 0
+/*move this to the int_source.h because the definition of unsigned long int...etc has been defined in type.h.
+  The ralink driver uses type.h and needs this interrupt_source structure so move this interrupt_source structure
+	to int_source.h. shnwind */
+enum
+interrupt_source
+	{
+#ifdef CONFIG_MIPS_TC3262
+		DUMMY_INT,
+#endif
+		UART_INT,		//0 	IPL10
+		RTC_ALARM_INT,	//1 	IPL29
+#ifdef CONFIG_MIPS_TC3262
+		SI_SWINT1_INT0,	//2
+		SI_SWINT1_INT1,	//3
+#else
+		RTC_TICK_INT,	//2 	IPL31
+		RESERVED0,		//3 	IPL30
+#endif
+		TIMER0_INT, 	//4 	IPL1
+		TIMER1_INT, 	//5 	IPL5
+		TIMER2_INT, 	//6 	IPL6
+#ifdef CONFIG_MIPS_TC3262
+		SI_SWINT_INT0, 	//7
+		SI_SWINT_INT1, 	//8
+#else
+		TIMER3_INT, 	//7 	IPL7
+		TIMER4_INT, 	//8 	IPL8
+#endif
+		TIMER5_INT, 	//9 	IPL9
+		GPIO_INT,		//10	IPL11
+#ifdef CONFIG_MIPS_TC3262
+		RESERVED1,		//11	IPL20
+		SI_PC1_INT, 	//12
+		SI_PC_INT, 		//13
+#else
+		PCIE_A_INT,		//11	IPL20
+		PCIE_SERR_INT,	//12	IPL21
+		RESERVED3,		//13	IPL22
+#endif
+		APB_DMA0_INT,	//14	IPL12
+		APB_DMA1_INT,	//15	IPL13
+#ifdef CONFIG_MIPS_TC3262
+		HSUART_INT,		//16	IPL23
+#else
+		RESERVED4,		//16	IPL23
+#endif
+		RESERVED5,		//17	IPL24
+		DYINGGASP_INT,	//18	IPL25
+		DMT_INT,		//19	IPL26
+		ARBITER_ERR_INT,//20	IPL0
+		MAC_INT,		//21	IPL3
+		SAR_INT,		//22	IPL2
+		USB_INT,		//23	IPL14
+		PCI_A_INT,		//24
+		PCI_B_INT,		//25
+//		  RESERVED8,	  //24	  IPL27
+//		  RESERVED9,	  //25	  IPL28
+		XSLV0_INT,		//26	IPL15
+		XSLV1_INT,		//27	IPL16
+		XSLV2_INT,		//28	IPL17
+#ifdef CONFIG_MIPS_TC3262
+		SI_TIMER1_INT,	//29
+		SI_TIMER_INT,	//30
+#else
+		XAPB0_INT,		//29	IPL18
+		XAPB1_INT,		//30	IPL19
+#endif
+		SWR_INT 		//31	IPL4
+	};
+#endif
+
+enum
+interrupt_priority
+{
+		IPL0,	IPL1,	IPL2,	IPL3,	IPL4,
+		IPL5,	IPL6,	IPL7,	IPL8,	IPL9,
+		IPL10,	IPL11,	IPL12,	IPL13,	IPL14,
+		IPL15,	IPL16,	IPL17,	IPL18,	IPL19,
+		IPL20,	IPL21,	IPL22,	IPL23,	IPL24,
+		IPL25,	IPL26,	IPL27,	IPL28,	IPL29,
+		IPL30,	IPL31
+};
+
+/**************************
+ * Timer Module Registers *
+ **************************/
+#define CR_TIMER_BASE  		0xBFBF0100
+#define CR_TIMER_CTL    	(CR_TIMER_BASE + 0x00)
+#define CR_TIMER0_LDV   	(CR_TIMER_BASE + 0x04)
+#define CR_TIMER0_VLR    	(CR_TIMER_BASE + 0x08)
+#define CR_TIMER1_LDV       (CR_TIMER_BASE + 0x0C)
+#define CR_TIMER1_VLR       (CR_TIMER_BASE + 0x10)
+#define CR_TIMER2_LDV       (CR_TIMER_BASE + 0x14)
+#define CR_TIMER2_VLR       (CR_TIMER_BASE + 0x18)
+#define CR_TIMER3_LDV       (CR_TIMER_BASE + 0x1C)
+#define CR_TIMER3_VLR       (CR_TIMER_BASE + 0x20)
+#define CR_TIMER4_LDV       (CR_TIMER_BASE + 0x24)
+#define CR_TIMER4_VLR       (CR_TIMER_BASE + 0x28)
+#define CR_TIMER5_LDV       (CR_TIMER_BASE + 0x2C)
+#define CR_TIMER5_VLR       (CR_TIMER_BASE + 0x30)
+/* new watchdog design */
+#define CR_WDOG_THSLD       (CR_TIMER_BASE + 0x34)
+#define CR_WDOG_RLD         (CR_TIMER_BASE + 0x38)
+
+#define TIMER_ENABLE         1
+#define TIMER_DISABLE        0
+#define TIMER_TOGGLEMODE     1
+#define TIMER_INTERVALMODE   0
+#define TIMER_TICKENABLE     1
+#define TIMER_TICKDISABLE    0
+#define TIMER_WDENABLE       1
+#define TIMER_WDDISABLE      0
+#define TIMER_HALTENABLE     1
+#define TIMER_HALTDISABLE    0
+
+#define TIMERTICKS_1MS       1
+#define TIMERTICKS_10MS      10  // set timer ticks as 10 ms
+#define TIMERTICKS_100MS     100
+#define TIMERTICKS_1S        1000
+#define TIMERTICKS_10S       10000
+
+#define timerCtlSet(timer_no, timer_enable, timer_mode,timer_halt)	timer_Configure(timer_no, timer_enable, timer_mode, timer_halt)
+#define timerWdSet(tick_enable, watchdog_enable) timer_WatchDogConfigure(tick_enable,watchdog_enable)
+#define timerLdvSet(timer_no,val) *(volatile uint32 *)(CR_TIMER0_LDV+timer_no*0x08) = (val)
+#define timerVlrGet(timer_no,val) (val)=*(volatile uint32 *)(CR_TIMER0_VLR+timer_no*0x08)
+
+/**************************
+ * Timer Module Registers *
+ **************************/
+#define CR_CPUTMR_BASE 		0xBFBF0400
+#define CR_CPUTMR_CTL    	(CR_CPUTMR_BASE + 0x00)
+#define CR_CPUTMR_CMR0    	(CR_CPUTMR_BASE + 0x04)
+#define CR_CPUTMR_CNT0    	(CR_CPUTMR_BASE + 0x08)
+#define CR_CPUTMR_CMR1    	(CR_CPUTMR_BASE + 0x0c)
+#define CR_CPUTMR_CNT1    	(CR_CPUTMR_BASE + 0x10)
+
+/*************************
+ * GPIO Module Registers *
+ *************************/
+#define CR_GPIO_BASE       	0xBFBF0200
+#define CR_GPIO_CTRL	    (CR_GPIO_BASE + 0x00)
+#define CR_GPIO_DATA	    (CR_GPIO_BASE + 0x04)
+#define CR_GPIO_INTS      	(CR_GPIO_BASE + 0x08)
+#define CR_GPIO_EDET	    (CR_GPIO_BASE + 0x0C)
+#define CR_GPIO_LDET       	(CR_GPIO_BASE + 0x10)
+#define CR_GPIO_ODRAIN      (CR_GPIO_BASE + 0x14)
+#define CR_GPIO_CTRL1	    (CR_GPIO_BASE + 0x20)
+#ifdef TCSUPPORT_GPIO_ECM
+#define CR_SGPIO_DATA        (CR_GPIO_BASE + 0x24)
+#define CR_SGPIO_CDIV        (CR_GPIO_BASE + 0x28)
+#define CR_SGPIO_CDLY        (CR_GPIO_BASE + 0x2C)
+#define CR_SGPIO_MODE	    (CR_GPIO_BASE + 0x30)
+#define CR_GPIO_FLAMOD	    (CR_GPIO_BASE + 0x34)
+#define CR_GPIO_IMME	    (CR_GPIO_BASE + 0x38)
+#define CR_GPIO_FLAP0	    (CR_GPIO_BASE + 0x3C)
+#define CR_GPIO_FLAP1	    (CR_GPIO_BASE + 0x40)
+#define CR_GPIO_FLAP2 	    (CR_GPIO_BASE + 0x44)
+#define CR_GPIO_FLAP3	    (CR_GPIO_BASE + 0x48)
+#define CR_GPIO_FMAP0	    (CR_GPIO_BASE + 0x4C)
+#define CR_GPIO_FMAP1 	    (CR_GPIO_BASE + 0x50)
+#define CR_SGPIO_FMAP0	    (CR_GPIO_BASE + 0x54)
+#define CR_SGPIO_FMAP1	    (CR_GPIO_BASE + 0x58)
+#define CR_SGPIO_FMAP2	    (CR_GPIO_BASE + 0x5C)
+#define CR_GPIO_TYPE	    0xBFB000B0
+#endif
+/* MT7510 */
+#define CR_GPIO_CTRL2	    (CR_GPIO_BASE + 0x60)
+#define CR_GPIO_CTRL3	    (CR_GPIO_BASE + 0x64)
+#define CR_GPIO_FLAMOD_EXT	(CR_GPIO_BASE + 0x68)
+#define CR_GPIO_DATA1		(CR_GPIO_BASE + 0x70)
+#define CR_GPIO_ODRAIN1     (CR_GPIO_BASE + 0x78)
+
+#define GPIO_IN				0x0
+#define GPIO_OUT			0x1
+#define GPIO_ALT_IN			0x2
+#define GPIO_ALT_OUT		0x3
+
+#define GPIO_E_DIS			0x0
+#define GPIO_E_RISE			0x1
+#define GPIO_E_FALL			0x2
+#define GPIO_E_BOTH			0x3
+
+#define GPIO_L_DIS			0x0
+#define GPIO_L_HIGH			0x1
+#define GPIO_L_LOW			0x2
+#define GPIO_L_BOTH			0x3
+
+/*****************************
+ * Arbiter/Decoder Registers *
+ *****************************/
+#define CR_AHB_BASE       	0xBFB00000
+#define CR_AHB_AACS	    	(CR_AHB_BASE + 0x00)
+#define CR_AHB_ABEM      	(CR_AHB_BASE + 0x08)
+#define CR_AHB_ABEA		    (CR_AHB_BASE + 0x0C)
+#define CR_AHB_DMB0       	(CR_AHB_BASE + 0x10)
+#define CR_AHB_DMB1       	(CR_AHB_BASE + 0x14)
+#define CR_AHB_DMB2       	(CR_AHB_BASE + 0x18)
+#define CR_AHB_DMB3       	(CR_AHB_BASE + 0x1C)
+#define CR_AHB_SMB0       	(CR_AHB_BASE + 0x20)
+#define CR_AHB_SMB1       	(CR_AHB_BASE + 0x24)
+#define CR_AHB_SMB2       	(CR_AHB_BASE + 0x28)
+#define CR_AHB_SMB3       	(CR_AHB_BASE + 0x2C)
+#define CR_AHB_SMB4       	(CR_AHB_BASE + 0x30)
+#define CR_AHB_SMB5       	(CR_AHB_BASE + 0x34)
+
+/* RT63165 */
+#define CR_ERR_ADDR    		(CR_AHB_BASE + 0x3c)
+#define CR_PRATIR      		(CR_AHB_BASE + 0x58)
+#define CR_MON_TMR     		(CR_AHB_BASE + 0x60)
+
+/*MT7510*/
+#define CR_AHB_NMI_CONF		(CR_AHB_BASE + 0x50)
+
+#define CR_AHB_PMCR       	(CR_AHB_BASE + 0x80)
+#define CR_AHB_DMTCR       	(CR_AHB_BASE + 0x84)
+#define CR_AHB_PCIC	       	(CR_AHB_BASE + 0x88)
+#define CR_AHB_HWCONF       (CR_AHB_BASE + 0x8C)
+#define CR_AHB_SSR       	(CR_AHB_BASE + 0x90)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define CR_IMEM       	(CR_AHB_BASE + 0x9C)
+#define CR_DMEM       	(CR_AHB_BASE + 0xA0)
+#endif
+/* RT63365 */
+#define CR_CRCC_REG		(CR_AHB_BASE + 0xA0)
+#define CR_AHB_UHCR		(CR_AHB_BASE + 0xA8)
+#define CR_AHB_ABMR       	(CR_AHB_BASE + 0xB8)
+#define CR_CKGEN_CONF		(CR_AHB_BASE + 0xC0)
+#define CR_PSMCR       		(CR_AHB_BASE + 0xCC)
+#define CR_PSMDR       		(CR_AHB_BASE + 0xD0)
+#define CR_PSMMR       		(CR_AHB_BASE + 0xD0)
+
+/* RT63165 */
+#define CR_SRAM       		(CR_AHB_BASE + 0xF4)
+#define CR_AHB_HWCONF2      (CR_AHB_BASE + 0xF8)
+
+/* RT63365 */
+#define CR_AHB_CLK			(CR_AHB_BASE + 0x1c0)
+#define CR_CLK_CFG     		(CR_AHB_BASE + 0x82c)
+#define CR_RSTCTRL2    		(CR_AHB_BASE + 0x834)
+#define CR_GPIO_SHR			(CR_AHB_BASE + 0x860)			
+
+#define CR_BUSTIMEOUT_SWITCH     (CR_AHB_BASE + 0x92c)
+/*************************************************
+ * SRAM/FLASH/ROM Controller Operation Registers *
+ *************************************************/
+#define CR_SMC_BASE       	0xBFB10000
+#define CR_SMC_BCR0	    	(CR_SMC_BASE + 0x00)
+#define CR_SMC_BCR1	    	(CR_SMC_BASE + 0x04)
+#define CR_SMC_BCR2	    	(CR_SMC_BASE + 0x08)
+#define CR_SMC_BCR3	    	(CR_SMC_BASE + 0x0C)
+#define CR_SMC_BCR4	    	(CR_SMC_BASE + 0x10)
+#define CR_SMC_BCR5	    	(CR_SMC_BASE + 0x14)
+
+/************************************************
+ * System Control Uint                          *
+ ************************************************/
+ /* MT7510 */
+#define CR_SCU_BASE				0xbfb00000
+#define CR_DRAMC_HW_SREF_CONF	(0x44 | CR_SCU_BASE)
+#define CR_DRAMC_CONF			(0x74 | CR_SCU_BASE)
+
+/*****************************
+ * Clock Generator Registers *
+ *****************************/
+
+/****************************
+ * USB Module Registers *
+ ****************************/
+
+#define CR_USB_BASE     0xBFB70000
+
+        // --- System Control Register ---
+#define CR_USB_SYS_CTRL_REG           (0x00 | CR_USB_BASE)
+
+        // --- Device Control Register ---
+#define CR_USB_DEV_CTRL_REG           (0x04 | CR_USB_BASE)
+
+        // --- Interrupt Status Register ---
+#define CR_USB_INTR_STATUS_REG        (0x08 | CR_USB_BASE)
+
+        // --- Interrupt Mask Register ---
+#define CR_USB_INTR_MASK_REG          (0x0c | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode Control Register ---
+#define CR_USB_CTRL_ENDP_IO_CTRL_REG  (0x10 | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode OUT Transfer Data Register #00 ---
+#define CR_USB_CTRL_ENDP_IO_OUT_REG0  (0x18 | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode OUT Transfer Data Register #01 ---
+#define CR_USB_CTRL_ENDP_IO_OUT_REG1  (0x1c | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode IN Transfer Data Register #00 ---
+#define CR_USB_CTRL_ENDP_IO_IN_REG0   (0x20 | CR_USB_BASE)
+
+        // --- Control Endpoint I/O Mode IN Transfer Data Register #01 ---
+#define CR_USB_CTRL_ENDP_IO_IN_REG1   (0x24 | CR_USB_BASE)
+
+        // --- Interrupt IN Endpoint Control Register ---
+#define CR_USB_INTR_IN_ENDP_CTRL_REG  (0x30 | CR_USB_BASE)
+
+        // --- Interrupt IN Endpoint IN Transfer Data Register #00 ---
+#define CR_USB_INTR_IN_ENDP_IN_REG0   (0x38 | CR_USB_BASE)
+
+        // --- Interrupt IN Endpoint IN Transfer Data Register #01 ---
+#define CR_USB_INTR_IN_ENDP_IN_REG1   (0x3c | CR_USB_BASE)
+
+        // --- Bulk/ISO OUT Descriptor Pointer Register ---
+#define CR_USB_BULKISO_OUT_DESCP_BASE_REG   (0x40 | CR_USB_BASE)
+
+        // --- Bulk/ISO IN Descriptor Pointer Register ---
+#define CR_USB_BULKISO_IN_DESCP_BASE_REG    (0x44 | CR_USB_BASE)
+
+        // --- Bulk/ISO IN/OUT Endpoint Number Register ---
+#define CR_USB_BULKISO_INOUT_ENDP_NUM_REG   (0x48 | CR_USB_BASE)
+
+        // --- Bulk/ISO Endpoint DMA Control Register ---
+#define CR_USB_BULKISO_ENDP_DMA_CTRL_REG    (0x4c | CR_USB_BASE)
+
+        // --- Bulk/ISO Endpoint DMA Configuration Register ---
+#define CR_USB_BULKISO_ENDP_DMA_CONF_REG    (0x50 | CR_USB_BASE)
+
+        // --- ISO Endpoint Transfer Delimiter Register #00 ---
+#define CR_USB_ISO_ENDP_DELIMITER_REG0      (0x58 | CR_USB_BASE)
+
+        // --- ISO Endpoint Transfer Delimiter Register #01 ---
+#define CR_USB_ISO_ENDP_DELIMITER_REG1      (0x5c | CR_USB_BASE)
+
+        // --- Vendor ID Register ---
+#define CR_USB_VENDOR_ID_REG                (0x68 | CR_USB_BASE)
+
+        // --- Product ID Register ---
+#define CR_USB_PRODUCT_ID_REG               (0x6c | CR_USB_BASE)
+
+/*************************
+ * HOST BRIDGE Registers *
+ * ***********************/
+#define HOST_BRIDGE_BASE 	0xBFB80000
+#define CR_CFG_ADDR_REG 	(HOST_BRIDGE_BASE+0x0020)
+#define CR_CFG_DATA_REG 	(HOST_BRIDGE_BASE+0x0024)
+/****************************
+ * ATM SAR Module Registers *
+ ****************************/
+#define TSCONTROL_BASE			0xBFB00000
+#define TSARM_REGISTER_BASE		(TSCONTROL_BASE + 0x00060000)
+
+/* ----- General configuration registers  ----- */
+
+/* ----- Reset And Identify register  ----- */
+#define TSARM_RAI				VPint(TSARM_REGISTER_BASE + 0x0000)
+/* ----- General Configuration register  ----- */
+#define TSARM_GFR				VPint(TSARM_REGISTER_BASE + 0x0004)
+/* ----- Traffic Scheduler Timer Base Counter register  ----- */
+#define TSARM_TSTBR				VPint(TSARM_REGISTER_BASE + 0x0008)
+/* ----- Receive Maximum Packet Length register  ----- */
+#define TSARM_RMPLR				VPint(TSARM_REGISTER_BASE + 0x000c)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+//Transmit Priority 0/1 Data Buffer Control and Status Register
+#define TSARM_TXDBCSR_P01		VPint(TSARM_REGISTER_BASE + 0x0010)
+#else
+/* ----- TX Data Buffer Control and Status register  ----- */
+#define TSARM_TXDBCSR			VPint(TSARM_REGISTER_BASE + 0x0010)
+#endif
+/* ----- TX OAM Buffer Control and Status register  ----- */
+#define TSARM_TXMBCSR			VPint(TSARM_REGISTER_BASE + 0x0014)
+/* ----- RX Data Buffer Control and Status register  ----- */
+#define TSARM_RXDBCSR			VPint(TSARM_REGISTER_BASE + 0x0018)
+/* ----- RX OAM Buffer Control and Status register  ----- */
+#define TSARM_RXMBCSR			VPint(TSARM_REGISTER_BASE + 0x001c)
+/* ----- Last IRQ Status register  ----- */
+#define TSARM_LIRQ				VPint(TSARM_REGISTER_BASE + 0x0020)
+/* ----- IRQ Queue Base Address register  ----- */
+#define TSARM_IRQBA				VPint(TSARM_REGISTER_BASE + 0x0024)
+/* ----- IRQ Queue Entry Length register  ----- */
+#define TSARM_IRQLEN			VPint(TSARM_REGISTER_BASE + 0x0028)
+/* ----- IRQ Head Indication register  ----- */
+#define TSARM_IRQH				VPint(TSARM_REGISTER_BASE + 0x002c)
+/* ----- Clear IRQ Entry register  ----- */
+#define TSARM_IRQC				VPint(TSARM_REGISTER_BASE + 0x0030)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+//Traffic Scheduler Line Rate Counter Register
+#define TSARM_TXSLRC			VPint(TSARM_REGISTER_BASE + 0x0034)
+//Transmit Priority 2/3 Data Buffer Control and Status Register
+#define TSARM_TXDBCSR_P23		VPint(TSARM_REGISTER_BASE + 0x0038)
+#endif
+
+/* ----- VC IRQ Mask register  ----- */
+#define TSARM_IRQM_BASE			(TSARM_REGISTER_BASE + 0x0040)
+#define TSARM_IRQM(vc)			VPint(TSARM_IRQM_BASE + (vc * 4))
+#define TSARM_IRQMCC			VPint(TSARM_IRQM_BASE + 0x0040)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_IRQ_QUE_THRE		VPint(TSARM_REGISTER_BASE + 0x0084)		//IRQ Queue Threshold Register
+#define TSARM_IRQ_TIMEOUT_CTRL 	VPint(TSARM_REGISTER_BASE + 0x0088)		//IRQ Timeout Control Register
+#endif
+
+/* ----- VC Configuration register  ----- */
+#define TSARM_VCCR_BASE			(TSARM_REGISTER_BASE + 0x0100)
+#define TSARM_VCCR(vc)			VPint(TSARM_VCCR_BASE + (vc * 4))
+#define TSARM_CCCR				VPint(TSARM_VCCR_BASE + 0x0040)
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+/* ----- DMA WRR Configuration Register (DMA_WRR_WEIT) (for TC3162L4) ----- */
+#define TSARM_DMAWRRCR			VPint(TSARM_REGISTER_BASE + 0x0150)
+#endif
+/* ----- Transmit Buffer Descriptor register  ----- */
+#define TSARM_TXDCBDA_BASE		(TSARM_REGISTER_BASE + 0x0200)
+#define TSARM_TXDCBDA(vc)		VPint(TSARM_TXDCBDA_BASE + (vc * 4))
+#define TSARM_TXMCBDA_BASE		(TSARM_REGISTER_BASE + 0x0240)
+#define TSARM_TXMCBDA(vc)		VPint(TSARM_TXMCBDA_BASE + (vc * 4))
+
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_CC_TX_BD_BASE				VPint(TSARM_REGISTER_BASE + 0x0228)		//Control Channel Transmit BD Base Address 0x228
+#define TSARM_CC_TX_BD_MNG_BASE			VPint(TSARM_REGISTER_BASE + 0x0268)		//Control Channel Transmit BD Management Base
+#define TSARM_VC_TX_BD_PRIORITY01_BASE		(TSARM_REGISTER_BASE + 0x0280)
+#define TSARM_VC_TX_BD_PRIORITY01(vc)		VPint(TSARM_VC_TX_BD_PRIORITY01_BASE + vc * 4)		//VC0 Transmit BD Data Priority 0/1 Base 280
+#define TSARM_VC_TX_BD_PRIORITY23_BASE		(TSARM_REGISTER_BASE + 0x02c0)
+#define TSARM_VC_TX_BD_PRIORITY23(vc)		VPint(TSARM_VC_TX_BD_PRIORITY23_BASE + vc * 4)		//VC0 Transmit BD Data Priority 0/1 Base 280
+#else
+#define TSARM_TXCCBDA			VPint(TSARM_REGISTER_BASE + 0x0280)
+#endif
+
+/* ----- Receive Buffer Descriptor register  ----- */
+#define TSARM_RXDCBDA_BASE		(TSARM_REGISTER_BASE + 0x0300)
+#define TSARM_RXDCBDA(vc)		VPint(TSARM_RXDCBDA_BASE + (vc * 4))
+#define TSARM_RXMCBDA_BASE		(TSARM_REGISTER_BASE + 0x0340)
+#define TSARM_RXMCBDA(vc)		VPint(TSARM_RXMCBDA_BASE + (vc * 4))
+
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_CC_RX_BD_BASE			VPint(TSARM_REGISTER_BASE + 0x328)		//Control Channel Receive BD Base Address	0x328
+#define TSARM_CC_RX_BD_MNG_BASE		VPint(TSARM_REGISTER_BASE + 0x368)		//Control Channel Receive BD Management Base	0x368
+#define TSARM_VC_RX_DATA_BASE				(TSARM_REGISTER_BASE + 0x380)
+#define TSARM_VC_RX_DATA(vc)			VPint(TSARM_VC_RX_DATA_BASE + vc * 4)	//VC0 Receive BD Data Base	0x380
+#else
+#define TSARM_RXCCBDA			VPint(TSARM_REGISTER_BASE + 0x0380)
+#endif
+
+/* ----- Traffic Scheduler register  ----- */
+#define TSARM_PCR_BASE			(TSARM_REGISTER_BASE + 0x0400)
+#define TSARM_PCR(vc)			VPint(TSARM_PCR_BASE + (vc * 4))
+#define TSARM_SCR_BASE			(TSARM_REGISTER_BASE + 0x0440)
+#define TSARM_SCR(vc)			VPint(TSARM_SCR_BASE + (vc * 4))
+#define TSARM_MBSTP_BASE		(TSARM_REGISTER_BASE + 0x0480)
+#define TSARM_MBSTP(vc)			VPint(TSARM_MBSTP_BASE + (vc * 4))
+
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_MAX_FRAME_SIZE_BASE	(TSARM_REGISTER_BASE + 0x04c0)
+#define TSARM_MAX_FRAME_SIZE(vc)		VPint(TSARM_MAX_FRAME_SIZE_BASE + (vc * 4))
+/* define for TC3162L4 */
+#define TSARM_TRAFFIC_SHAPER_WEIGHT_BASE (TSARM_REGISTER_BASE + 0x0500)
+#define TSARM_TRAFFIC_SHAPER_WEIGHT(vc)     VPint(TSARM_TRAFFIC_SHAPER_WEIGHT_BASE + (vc * 4))
+#else
+/* ----- Receive Timeout register  ----- */
+#define TSARM_RTOCNT_BASE		(TSARM_REGISTER_BASE + 0x0500)
+#define TSARM_RTOCNT(vc)		VPint(TSARM_RTOCNT_BASE + (vc * 4))
+#endif
+
+/* ----- TX Statistic Counter register  ----- */
+#define TSARM_TDCNT_BASE		(TSARM_REGISTER_BASE + 0x0600)
+#define TSARM_TDCNT(vc)			VPint(TSARM_TDCNT_BASE + (vc * 4))
+#define TSARM_TDCNTCC			VPint(TSARM_TDCNT_BASE + 0x0040)
+
+/* ----- RX Statistic Counter register  ----- */
+#define TSARM_RDCNT_BASE		(TSARM_REGISTER_BASE + 0x0700)
+#define TSARM_RDCNT(vc)			VPint(TSARM_RDCNT_BASE + (vc * 4))
+#define TSARM_RDCNTCC			VPint(TSARM_RDCNT_BASE + 0x0040)
+#define TSARM_MISCNT			VPint(TSARM_RDCNT_BASE + 0x0044)
+
+#if defined(TC3162L2) || defined(CONFIG_MIPS_TC3262)
+#define TSARM_MPOA_GCR				VPint(TSARM_REGISTER_BASE + 0x0800)			//MPOA global control register
+#define TSARM_VC_MPOA_CTRL_BASE			(TSARM_REGISTER_BASE + 0x0810)			//VC0 ~9  MPOA Control register
+#define TSARM_VC_MPOA_CTRL(vc)			VPint(TSARM_VC_MPOA_CTRL_BASE + vc * 4)
+#define TSARM_MPOA_HFIV11				VPint(TSARM_REGISTER_BASE + 0x0850)			//MPOA header Field1 Insertion Value1
+#define TSARM_MPOA_HFIV12				VPint(TSARM_REGISTER_BASE + 0x0854)			//MPOA header Field1 Insertion Value2
+#define TSARM_MPOA_HFIV13				VPint(TSARM_REGISTER_BASE + 0x0858)			//MPOA header Field2 Insertion Value1
+#define TSARM_MPOA_HFIV21				VPint(TSARM_REGISTER_BASE + 0x0860)			//MPOA header Field2 Insertion Value2
+#define TSARM_MPOA_HFIV22				VPint(TSARM_REGISTER_BASE + 0x0864)			//MPOA header Field2 Insertion Value2
+#define TSARM_MPOA_HFIV23				VPint(TSARM_REGISTER_BASE + 0x0868)			//MPOA header Field2 Insertion Value2
+#define TSARM_MPOA_HFIV31				VPint(TSARM_REGISTER_BASE + 0x0870)			//MPOA header Field3 Insertion Value1
+#define TSARM_MPOA_HFIV32				VPint(TSARM_REGISTER_BASE + 0x0874)			//MPOA header Field3 Insertion Value2
+#define TSARM_MPOA_HFIV33				VPint(TSARM_REGISTER_BASE + 0x0878)			//MPOA header Field3 Insertion Value3
+#define TSARM_MPOA_HFIV41				VPint(TSARM_REGISTER_BASE + 0x0880)			//MPOA header Field4 Insertion Value1
+#define TSARM_MPOA_HFIV42				VPint(TSARM_REGISTER_BASE + 0x0884)			//MPOA header Field4 Insertion Value2
+#define TSARM_MPOA_HFIV43				VPint(TSARM_REGISTER_BASE + 0x0888)			//MPOA header Field4 Insertion Value2
+#endif
+
+/**************************
+ * USB Module Registers *
+ **************************/
+
+#define LA_DEBUG_TRIGGER(addr,val) VPint(0xbfc00000+addr) = val
+/**************************
+* USB 2.0 device Register *
+**************************/
+#define CR_USB20_BASE     0xBFB70000
+
+// --- System Control Register ---
+#define CR_USB20_SYS_CTRL_REG			(0x00 | CR_USB20_BASE)
+
+// --- Device Control Register ---
+#define CR_USB20_DEV_CTRL_REG			(0x04 | CR_USB20_BASE)
+
+// --- Interrupt Status Register ---
+#define CR_USB20_INTR_STATUS_REG		(0x0c | CR_USB20_BASE)
+
+// --- Interrupt ENABLE Register ---
+#define CR_USB20_INTR_ENABLE_REG          	(0x10 | CR_USB20_BASE)
+
+// --- Interrupt Timing Control Register ---
+#define CR_USB20_INTR_TIMING_CONTROL_REG	(0x14 | CR_USB20_BASE)
+
+// --- SETUP Receive Data Buffer Register ---
+#define CR_USB20_SETUP_BASE_REG          	(0x20 | CR_USB20_BASE)
+
+// --- Control OUT Receive Data Buffer Pointer Register ---
+#define CR_USB20_CONTROL_OUT_BASE_REG		(0x24 | CR_USB20_BASE)
+
+// --- Control IN Receive Data Buffer Pointer Register ---
+#define CR_USB20_CONTROL_IN_BASE_REG		(0x28 | CR_USB20_BASE)
+
+// --- Control IN Receive Data Buffer Pointer Register ---
+#define CR_USB20_CONTROL_CONF_REG		(0x2c | CR_USB20_BASE)
+
+// --- CONTROL Endpoint DMA Transfer Control Register ---
+#define CR_USB20R_CONTROL_EP_DMA_CTRL_REG	(0x30 | CR_USB20_BASE)
+
+// --- CONTROL Endpoint DMA Transfer Status Register ---
+#define CR_USB20_CONTROL_EP_DMA_STATUS_REG	(0x34 | CR_USB20_BASE)
+
+// --- INTERRUPT IN Transmit Data Buffer Pointer  Register ---
+#define CR_USB20_INTERRUPT_IN_BASE_REG		(0x38 | CR_USB20_BASE)
+
+// --- INTERRUPT IN Configuration   Register ---
+#define CR_USB20_INTERRUPT_IN_CONF_REG		(0x3c | CR_USB20_BASE)
+
+// --- INTERRUPT IN Endpoint DMA Transfer Control Register ---
+#define CR_USB20_INTERRUPT_IN_DMA_CTRL_REG	(0x40 | CR_USB20_BASE)
+
+// --- INTERRUPT IN Endpoint DMA Transfer Status Register ---
+#define CR_USB20_INTERRUPT_IN_EP_DMA_STATUS_REG	(0x44 | CR_USB20_BASE)
+
+// --- Bulk/Ctrl/Intr IN/OUT Underrun/Overrun Error Counter  Register ---
+#define CR_USB20_STATUS_COUNT_REG		(0x48 | CR_USB20_BASE)
+
+// --- BULK OUT Endpoint Transfer DMA Polling Demand Control Register ---
+#define CR_USB20_BULK_OUT_DMA_POLLING_REG	(0x60 | CR_USB20_BASE)
+
+// --- BULK IN Endpoint Transfer DMA Polling Demand Control Register ---
+#define CR_USB20_BULK_IN_DMA_POLLING_REG	(0x64 | CR_USB20_BASE)
+
+// --- Bulk OUT Endpoint Transfer Dscriptor Base Address Register ---
+#define CR_USB20_BULK_OUT_DESC_BASE_REG		(0x68 | CR_USB20_BASE)
+
+// --- Bulk IN Endpoint Transfer Dscriptor Base Address Register ---
+#define CR_USB20_BULK_IN_DESC_BASE_REG		(0x6c | CR_USB20_BASE)
+
+// --- Bulk OUT/IN Endpoint Transfer Dscriptor Rinf Size/Offset Register ---
+#define CR_USB20_BULK_DESC_SIZE_OFFSET_REG	(0x70 | CR_USB20_BASE)
+
+// --- Bulk OUT/IN Endpoint Configuration Register ---
+#define CR_USB20_BULK_EP_CONF_REG		(0x74 | CR_USB20_BASE)
+
+// --- Bulk OUT/IN Endpoint DMA Transfer Control Register ---
+#define CR_USB20_BULK_EP_DMA_CTRL_REG          	(0x78 | CR_USB20_BASE)
+
+// --- Bulk OUT/IN Endpoint DMA Transfer Status Register ---
+#define CR_USB20_BULK_EP_DMA_STATUS_REG         (0x7c | CR_USB20_BASE)
+
+// --- UDC Setup Command Address Register ---
+#define CR_USB20_UDC_SETUP_COMMAND_ADDR_REG	(0x80 | CR_USB20_BASE)
+
+// --- UDC Control Endpoint Information Register ---
+#define CR_USB20_UDC_CTRL_EP_INFO_REG          	(0x84 | CR_USB20_BASE)
+
+// --- UDC BULK IN Endpoint Information Register ---
+#define CR_USB20_UDC_BULK_IN_EP_INFO_REG    	(0x88 | CR_USB20_BASE)
+
+// --- UUDC BULK OUT Endpoint Information Register ---
+#define CR_USB20_UDC_BULK_OUT_EP_INFO_REG	(0x8c | CR_USB20_BASE)
+
+// --- UDC INTERRUPT IN Endpoint Information Register ---
+#define CR_USB20_UDC_INTERRUPT_IN_EP_INFO_REG	(0x90 | CR_USB20_BASE)
+
+#if 0
+#define TCSUPPORT_CPU_MT7510_FAKE
+
+#ifdef TCSUPPORT_CPU_MT7510
+#undef DEFAULT_USE_EXT_SWIC
+#endif
+#ifdef TCSUPPORT_CPU_MT7520
+#define DEFAULT_USE_EXT_SWIC
+#endif
+#if defined(TCSUPPORT_CPU_RT65168) || defined(TCSUPPORT_CPU_TC3182)	// for early MT7530 FPGA verification only
+#define DEFAULT_USE_EXT_SWIC
+#endif
+
+#if defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7520E) || defined(TCSUPPORT_CPU_MT751x20G25G) || defined(TCSUPPORT_CPU_MT7511G) || defined(TCSUPPORT_CPU_MT752025)
+//#define EXT_SWITCH_PHY_CONNECT_INT_MDIO
+
+#ifdef EXT_SWITCH_PHY_CONNECT_INT_MDIO
+#define EXT_SWITCH_PHY_ADDR_OFFSET	(0)
+#define INT_SWITCH_PHY_ADDR_OFFSET	(8)
+
+#endif	//EXT_SWITCH_PHY_CONNECT_INT_MDIO
+
+#endif
+#endif
+#endif /* _TC3162_H_ */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/tc3162/tc3182_int_source.h vr300-linux/arch/mips/include/asm/tc3162/tc3182_int_source.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/tc3182_int_source.h	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/tc3162/tc3182_int_source.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,67 @@
+/************************************************************************
+ *
+ *	Copyright (C) 2006 Trendchip Technologies, Corp.
+ *	All Rights Reserved.
+ *
+ * Trendchip Confidential; Need to Know only.
+ * Protected as an unpublished work.
+ *
+ * The computer program listings, specifications and documentation
+ * herein are the property of Trendchip Technologies, Co. and shall
+ * not be reproduced, copied, disclosed, or used in whole or in part
+ * for any reason without the prior express written permission of
+ * Trendchip Technologeis, Co.
+ *
+ *************************************************************************/
+
+#ifndef _INT_SOURCE_H_
+#define _INT_SOURCE_H_
+
+enum
+interrupt_source
+	{
+		DUMMY_INT,
+		UART_INT,		//0 	IPL10
+		PTM_B0_INT,		//1
+		SI_SWINT1_INT0,	//2
+		SI_SWINT1_INT1,	//3
+		TIMER0_INT, 	//4 	IPL1
+		TIMER1_INT, 	//5 	IPL5
+		TIMER2_INT, 	//6 	IPL6
+		SI_SWINT_INT0, 	//7
+		SI_SWINT_INT1, 	//8
+		TIMER5_INT, 	//9 	IPL9
+		GPIO_INT,		//10	IPL11
+		RESERVED1,		//11	IPL20
+		SI_PC1_INT, 	//12
+		SI_PC_INT, 		//13
+		APB_DMA0_INT,	//14	IPL12
+		MAC1_INT,		//15	IPL13
+		HSUART_INT,		//16	IPL23
+#if !defined(CONFIG_MIPS_RT63365)
+		RESERVED2,		//17
+#else
+		IRQ_RT3XXX_USB,	//17	IPL24
+#endif
+		DYINGGASP_INT,	//18	IPL25
+		DMT_INT,		//19	IPL26
+		USB20_INT,		//20
+		MAC_INT,		//21	IPL3
+		SAR_INT,		//22	IPL2
+		USB11_INT,
+		PCIE_A_INT,		//24
+		PCIE_SERR_INT,		//25
+		PTM_B1_INT,		//26	IPL15
+		XSLV1_INT,		//27	IPL16
+		USB_INT,		//28	IPL17
+		SI_TIMER1_INT,	//29
+		SI_TIMER_INT,	//30
+		SWR_INT, 		//31	IPL4
+		BUS_TOUT_INT, 	//32
+		RESERVE_A_INT, 	//33
+		RESERVE_B_INT, 	//34
+		RESERVE_C_INT, 	//35
+		AUTO_MANUAL_INT 	//36
+	};
+
+#endif /* _INT_SOURCE_H_ */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/tc3162/TCIfSetQuery_os.h vr300-linux/arch/mips/include/asm/tc3162/TCIfSetQuery_os.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/TCIfSetQuery_os.h	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/tc3162/TCIfSetQuery_os.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,294 @@
+//******************************************************************************
+//
+// Copyright (C) 2003 TrendChip Technologies Corp.
+//
+// Module name
+// -----------
+// TCIfSetQuery.h
+//
+// Abstract
+// --------
+// This file contains the set and query id definition with ZyNOS
+//              
+// Modification History
+// --------------------
+// Date   : 2003/5/27 Jason
+// Rev.   : 001
+// Modify : 
+//
+//*****************************************************************************
+// $Id: TCIfSetQuery_os.h,v 1.1.1.1 2010/04/09 09:39:21 feiyan Exp $
+// $Log: TCIfSetQuery_os.h,v $
+// Revision 1.1.1.1  2010/04/09 09:39:21  feiyan
+// New TC Linux Make Flow Trunk
+//
+// Revision 1.2  2010/02/03 10:14:31  yuren_nj
+// [Enhancement]#4788 Add tr69 parameters.
+//
+// Revision 1.1.1.1  2009/12/17 01:42:47  josephxu
+// 20091217, from Hinchu ,with VoIP
+//
+// Revision 1.1.1.1  2007/04/12 09:42:03  ian
+// TCLinuxTurnkey2007
+//
+// Revision 1.2  2006/07/06 04:12:45  lino
+// add kernel module support
+//
+// Revision 1.1.1.1  2005/11/02 05:45:38  lino
+// no message
+//
+// Revision 1.2  2005/08/19 14:36:59  jasonlin
+// Merge Huawei's code into new main trunk
+//
+// Revision 1.1.1.1  2005/03/30 14:04:23  jasonlin
+// Import Linos source code
+//
+// Revision 1.8  2005/03/02 06:57:12  jasonlin
+// add extra query function ID for CHINA_NM
+//
+// Revision 1.7  2004/11/10 06:42:04  jasonlin
+// Add CI command "wan adsl opencmf adsl2|adsl2plus"
+//
+// Revision 1.5  2004/11/10 05:40:52  wheellenni
+// wheellenni_931110
+// compatible for the previous firmware
+//
+// Revision 1.4  2004/11/09 08:51:15  wheellenni
+// 931109_wheellenni
+// Add adsl2/adsl2plus to CI command "wan adsl opencmd xxxx"
+// "adsl2" only support G.992.3	and "adsl2plus" support G.992.5
+//
+// Revision 1.3  2004/10/04 12:46:58  bright
+// bright_931004
+//
+// Revision 1.2  2004/09/14 08:50:21  bright
+// bright_930914
+//
+// Revision 1.1.1.1  2004/08/17 07:06:46  jeffrey
+// Import framework code from V3.0.0.
+//
+// Revision 1.1.1.1  2003/08/22 06:19:18  jasonlin
+// no message
+//
+//*****************************************************************************
+
+#ifndef _TCIFSETQUERY_H
+#define _TCIFSETQUERY_H
+
+// ADSL Query ID list   Jason_920527
+#define ADSL_QUERY_MODESET          0x0000              
+#define ADSL_QUERY_MODE             0x0001
+#define ADSL_QUERY_STATUS           0x0002
+#define ADSL_QUERY_SW_VER           0x0003
+#define ADSL_QUERY_VENDOR_ID        0x0004
+#define ADSL_QUERY_NEAR_OP_DATA     0x0005
+#define ADSL_QUERY_FAR_OP_DATA      0x0006
+#define ADSL_QUERY_CH_OP_DATA       0x0007
+#define ADSL_QUERY_DEFECT_CNT       0x0008
+#define ADSL_QUERY_DEFECT           0x0009
+#define ADSL_QUERY_NEAR_ITUID       0x000a
+#define ADSL_QUERY_FAR_ITUID        0x000b
+#define ADSL_QUERY_WATCHDOG         0x000c
+#define ADSL_QUERY_AUTOLINK         0x000d
+#define ADSL_QUERY_CELL_CNT         0x000e
+#define ADSL_QUERY_TX_GAIN          0x000f
+#define ADSL_QUERY_TX_FILTER_TYPE   0x0010
+#define ADSL_QUERY_TX_MEDLEY_TONE   0x0011
+#define ADSL_QUERY_SNR_OFFSET       0x0012
+#define ADSL_QUERY_MIN_SNR_M        0x0013
+#define ADSL_QUERY_FW_VER           0x0014
+#define ADSL_QUERY_FW_REV           0x0015
+#define ADSL_QUERY_TDM_FDM_VER      0x0016
+#define ADSL_QUERY_RTS_LOG_SIZE_STR 0x0017
+#define ADSL_QUERY_RTS_ADDR_STR     0x0018
+#define ADSL_QUERY_RTS_LOG_SIZE     0x0019
+#define ADSL_QUERY_HW_VER           0x001a
+#define ADSL_QUERY_DGASP_CNTR		0x001b
+#define ADSL_QUERY_SHOW_DIAG		0x001c
+//#define ADSL_QUERY_CUSTOMER 		0x001d //bright_930914_1
+#define ADSL_QUERY_BUILD_VERSION	0x001d //bright_930914_1
+#define ADSL_QUERY_ANNEX            0x001e	//julia_070424
+#define ADSL_QUERY_TR69_WLAN_DSL_INTERFACE_Config  0x001f	//jf_070522
+#define ADSL_QUERY_PMS_PARAM        0x0020	//cheng_070727
+#define ADSL_QUERY_TR69_WLAN_DSL_DIAGNOSTIC  0x0021	//dyma_071017
+#define ADSL_QUERY_SHOW_STATE_PARAM        0x0022	//jmxu_071219
+#define ADSL_QUERY_LINERATE      0x0023   //haotang_080416
+#define ADSL_QUERY_TR098_WAN_DSL_INTERFACE_CONFIG 0x0024    //rmzha_080527
+#define ADSL_QUERY_PM_STATE 0x0025  //Roger_090206
+#define ADSL_QUERY_BITSWAP_ONOFF 0x0026//Roger_090206
+
+#define ADSL_QUERY_LAST_DROP_REASON 0x002a    //whliu_090924
+
+#ifdef DADI				//Julia_051117
+#define ADSL_QUERY_ATTAIN_RATE      0x0027	//Julia_051117
+#endif
+#define ADSL_QUERY_CELL_CNT1         0x002b      //zzma_091020
+#define ADSL_QUERY_RX_BEAR_TPSTC_TYPE         0x002c
+
+#if defined(TCSUPPORT_CWMP_VDSL)
+#define VDSL_QUERY_TR098_DSL_INTERFACE_CONFIG 0x2001
+#endif
+
+#define ADSL_QUERY_AFE_DMT_LPBK		0x0033
+#define ADSL_QUERY_AFE_R_W			0x0034//Roger120402
+
+#define TPSTC_DISABLE      			0x00
+#define TPSTC_ATM_TC       			0x01
+#define TPSTC_PTM_TC_64_65B       	0x02
+#define TPSTC_PTM_TC_HDLC       	0x03
+
+#define ADSL_QUERY_SRA_ONOFF 0x0028 //Roger_090206
+#define ADSL_QUERY_PM_ONOFF 0x0029 //Roger_090206
+
+#define ADSL_SET_MODE_A43           0x1000
+#define ADSL_SET_MODE_LITE          0x1001
+#define ADSL_SET_MODE_MULTIMODE     0x1002
+#define ADSL_SET_MODE_ANSI          0x1003
+#define ADSL_SET_MODE_ADSL2         0x1004   // wheellenni_931110
+#define ADSL_SET_MODE_ADSL2PLUS     0x1005   // wheellenni_931110
+#define ADSL_SET_MODE_AUTO_SENSE_GDMT_FIRST   0x1006	//yyfeng_050719
+#define ADSL_SET_MODE_AUTO_SENSE_T1413_FIRST   0x1007	//yyfeng_050719
+#define ADSL_SET_MODE_GDMT_OR_LITE     0x1008	//yyfeng_050719
+#define ADSL_SET_MODE_AUTO_SENSE_T1413_OFF     0x1009	//yyfeng_070210
+#define ADSL_SET_MODE_AUTO_SENSE_ADSL2_OFF     0x100a	//yyfeng_070210
+#define ADSL_SET_MODE_ADSL1_MULTI     0x100b	//yyfeng_070210
+#define ADSL_SET_MODE_ADSL2_MULTI     0x100c	//yyfeng_070210
+#define ADSL_SET_MODE_ADSL2PLUS_T1413 0x100d	// Ryan_961128
+#define ADSL_SET_MODE_VDSL2         0x100e
+#if defined(TCSUPPORT_CWMP_VDSL)
+#define ADSL_SET_MODE_ADSL2PLUS_MULTI	0x100f
+#else
+#endif
+#define ADSL_SET_R_VENDOR_ID        0x1010
+#define ADSL_SET_TX_GAIN            0x1011
+#define ADSL_SET_TX_FILTER_TYPE     0x1012
+#define ADSL_SET_TX_MEDLEY_TONE     0x1013
+#define ADSL_SET_SNR_OFFSET         0x1014
+#define ADSL_SET_MIN_SNR_M          0x1015
+#define ADSL_SET_RTS_LOG_STOP       0x0016
+#define ADSL_SET_RTS_LOG_RESUME     0x0017
+#define ADSL_SET_RTS_LOG_FREE       0x0018
+#define ADSL_SET_R_SOFT_RESET       0x0019
+#define ADSL_SET_DMT_CLOSE          0x001a
+#define ADSL_SET_INT_MASK0          0x001b
+#define ADSL_SET_DGASP_CNTR_ZERO	0x001c		// Gilb_920901_1
+#define ADSL_SET_CONSOLE_DATA		0x001d		// Jason_930315
+#define ADSL_SET_TRELLIS                               0x1100	//yyfeng_050719
+#define ADSL_SET_BITSWAP                              0x1101	//yyfeng_050719
+#define ADSL_SET_PRINT                              0x1102	//jmxu_071219
+#define ADSL_SET_SRA           0X1103  //Roger_090206
+#define ADSL_SET_PM            0X1104 //Roger_090206
+#define ADSL_SET_LDM          0X1105  //Roger_090206
+#define ADSL_SET_DMT_DYING_GASP             0x3000
+/*//yyfeng_060510_1
+#define ADSL_SET_ANNEX_M                                  0x1102          //yyfeng_060424
+#define ADSL_SET_ANNEX                                       0x1103          //yyfeng_060425
+*/
+
+#if defined(TCSUPPORT_CPU_MT7510) && defined(TCSUPPORT_BONDING)
+#define VDSL2_QUERY_BONDING_BACP_SUPPORT    0x2003
+#define TCIF_SET_BONDING_BACP_SUPPORT		0x3001
+#define BONDING_OFF_BACP_OFF    0x0
+#define BONDING_ON_BACP_OFF     0x1
+#define BONDING_OFF_BACP_ON     0x2
+#define BONDING_ON_BACP_ON      0x3
+#endif
+
+
+//julia_070424
+#define         ME_CMD_ADSL_ANNEXA                    0x21
+#define         ME_CMD_ADSL_ANNEXB                    0x22
+#define         ME_CMD_ADSL_ANNEXI                    0x23
+#define         ME_CMD_ADSL_ANNEXJ                    0x24
+#define         ME_CMD_ADSL_ANNEXM                    0x25
+#define         ME_CMD_ADSL_ANNEXL  				  0x26
+//julia_070424
+
+#define ADSL_MODEM_STATE_DOWN       0x00
+#define ADSL_MODEM_STATE_WAIT_INIT  0x08
+#define ADSL_MODEM_STATE_INIT       0x10
+#define ADSL_MODEM_STATE_UP         0x20
+
+#define         ME_CMD_ADSL_SELFTEST1               0x01
+#define         ME_CMD_ADSL_SELFTEST2               0x02
+#define         ME_CMD_ADSL_OPEN                    0x03
+#define         ME_CMD_ADSL_CLOSE                   0x04
+/*
+#define         ME_CMD_ADSL_ANSI                    0x05
+#define         ME_CMD_ADSL_OPEN_GDMT  				0x06
+#define 		ME_CMD_ADSL_OPEN_GLITE 				0x07
+#define 		ME_CMD_ADSL_OPEN_MULTIMODE			0x08
+//xzwang 041103
+#define          ME_CMD_ADSL_OPEN_GDMT_GLITE              0x0B
+*/
+//Jason_930706
+#define    		ME_CMD_ADSL2						0x09
+#define    		ME_CMD_ADSL2PLUS					0x0A
+#define    		ME_CMD_VDSL2						0x0B
+//Sam 20140305
+#define    		ME_CMD_GVECTOR						0x0C
+#define    		ME_CMD_GVECTOR_GINP					0x0D
+#define    		ME_CMD_VDSL2_GINP					0x0E
+#define    		ME_CMD_ADSL2_GINP					0x0F
+#define    		ME_CMD_ADSL2PLUS_GINP					0x10
+
+// add by chenyingbo 2018-05-14 
+#define			ME_CMD_GVECTOR_GINP_US_ONLY			0x11
+#define			ME_CMD_GVECTOR_GINP_DS_ONLY			0x12
+#define			ME_CMD_VDSL2_GINP_US_ONLY			0x13
+#define			ME_CMD_VDSL2_GINP_DS_ONLY			0x14
+
+//xzwang
+#define         ME_CMD_ADSL_ANSI                    0x05
+#define         ME_CMD_ADSL_OPEN_GDMT  				0x06
+#define 		ME_CMD_ADSL_OPEN_GLITE 				0x07
+#define 		ME_CMD_ADSL_OPEN_MULTIMODE		       0x08
+#define         ME_CMD_ADSL_GDMT_OR_LITE                     0x91 //yyfeng_041015_14
+#define         ME_CMD_ADSL_AUTO_GDMT_FIRST              0x92
+#define         ME_CMD_ADSL_AUTO_T1413_FIRST             0x93
+
+void TCIfQuery( unsigned short query_id, void *result1, void *result2 );
+void TCIfSet( unsigned short set_id, void *value1, void *value2 );
+
+typedef struct {
+	void (*query)(unsigned short query_id, void *result1, void *result2);
+	void (*set)(unsigned short set_id, void *value1, void *value2);
+
+	void (*rts_rcv)(struct sk_buff *skb);
+
+	int	(*rts_cmd)(int argc,char *argv[],void *p);
+	int	(*dmt_cmd)(int argc,char *argv[],void *p);
+	int	(*dmt2_cmd)(int argc,char *argv[],void *p);
+	int	(*hw_cmd)(int argc,char *argv[],void *p);
+	int	(*sw_cmd)(int argc,char *argv[],void *p);
+	int	(*ghs_cmd)(int argc,char *argv[],void *p);
+	int	(*tcif_cmd)(int argc,char *argv[],void *p);
+} adsldev_ops;
+
+extern adsldev_ops *adsl_dev_ops;
+void adsl_dev_ops_register(adsldev_ops *ops);
+void adsl_dev_ops_deregister(void);
+#if defined(TCSUPPORT_BONDING)
+extern adsldev_ops *adsl_dev_ops_slave;
+void adsl_dev_ops_register_slave(adsldev_ops *ops);
+void adsl_dev_ops_deregister_slave(void);
+#endif
+
+#if defined(CONFIG_RALINK_VDSL)
+typedef struct {
+	int	(*vdsl2_cmd)(int argc,char *argv[],void *p);
+} vdsldev_ops;
+
+extern vdsldev_ops *vdsl_dev_ops;
+void vdsl_dev_ops_register(vdsldev_ops *ops);
+void vdsl_dev_ops_deregister(void);
+
+#if defined(TCSUPPORT_BONDING)
+extern vdsldev_ops *vdsl_dev_ops_slave;
+void vdsl_dev_ops_register_slave(vdsldev_ops *ops);
+void vdsl_dev_ops_deregister_slave(void);
+#endif
+
+#endif
+
+#endif
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/tc3162/voip_hook.h vr300-linux/arch/mips/include/asm/tc3162/voip_hook.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/voip_hook.h	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/tc3162/voip_hook.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,5 @@
+#ifndef __VOIP_HOOK_H
+#define __VOIP_HOOK_H
+
+extern unsigned int* (*recv_rtp_src_port_get_hook)(void);
+#endif
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/tc3162/war.h vr300-linux/arch/mips/include/asm/tc3162/war.h
--- linux-2.6.36/arch/mips/include/asm/tc3162/war.h	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/tc3162/war.h	2019-03-07 03:40:16.000000000 +0200
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_RALINK_WAR_H
+#define __ASM_MIPS_MACH_RALINK_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	1
+#define MIPS_CACHE_SYNC_WAR		1
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	1
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_RALINK_WAR_H */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/include/asm/thread_info.h vr300-linux/arch/mips/include/asm/thread_info.h
--- linux-2.6.36/arch/mips/include/asm/thread_info.h	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/include/asm/thread_info.h	2019-03-07 03:40:17.000000000 +0200
@@ -62,8 +62,12 @@
 
 /* thread information allocation */
 #if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_32BIT)
+#if defined(CONFIG_CPU_TC3162) || defined(CONFIG_MIPS_TC3262)
+#define THREAD_SIZE_ORDER (2)
+#else
 #define THREAD_SIZE_ORDER (1)
 #endif
+#endif
 #if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_64BIT)
 #define THREAD_SIZE_ORDER (2)
 #endif
@@ -88,8 +92,12 @@
 #ifdef CONFIG_DEBUG_STACK_USAGE
 #define alloc_thread_info(tsk) kzalloc(THREAD_SIZE, GFP_KERNEL)
 #else
+#if defined(CONFIG_CPU_TC3162) || defined(CONFIG_MIPS_TC3262)
+#define alloc_thread_info(tsk) kzalloc(THREAD_SIZE, GFP_KERNEL)
+#else
 #define alloc_thread_info(tsk) kmalloc(THREAD_SIZE, GFP_KERNEL)
 #endif
+#endif
 
 #define free_thread_info(info) kfree(info)
 
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/Kbuild vr300-linux/arch/mips/Kbuild
--- linux-2.6.36/arch/mips/Kbuild	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/Kbuild	2019-03-07 03:40:18.000000000 +0200
@@ -1,7 +1,7 @@
 # Fail on warnings - also for files referenced in subdirs
 # -Werror can be disabled for specific files using:
 # CFLAGS_<file.o> := -Wno-error
-subdir-ccflags-y := -Werror
+#subdir-ccflags-y := -Werror
 
 # platform specific definitions
 include arch/mips/Kbuild.platforms
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/Kbuild.platforms vr300-linux/arch/mips/Kbuild.platforms
--- linux-2.6.36/arch/mips/Kbuild.platforms	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/Kbuild.platforms	2019-03-07 03:40:18.000000000 +0200
@@ -18,6 +18,7 @@
 platforms += pnx833x
 platforms += pnx8550
 platforms += powertv
+platforms += ralink
 platforms += rb532
 platforms += sgi-ip22
 platforms += sgi-ip27
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/Kconfig vr300-linux/arch/mips/Kconfig
--- linux-2.6.36/arch/mips/Kconfig	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/Kconfig	2019-03-07 03:40:18.000000000 +0200
@@ -252,6 +252,65 @@
 	  This enables support for the MIPS Technologies Malta evaluation
 	  board.
 
+config MIPS_TC3262
+	bool "TrendChip's TC3262 Board"
+	select CPU_MIPSR2_IRQ_VI
+	select CPU_MIPSR2_IRQ_EI
+	select NO_EXCEPT_FILL
+	select BOOT_RAW
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select HW_HAS_PCI
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_CPU_MIPS64_R1
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_MULTITHREADING
+	select TC3162_ADSL
+	select TC3162_IMEM
+	select TC3162_DMEM
+	help
+	  This enables support for TrendChip's TC3262 based board.  
+	  board.
+
+config MIPS_TC3182
+	bool "TrendChip's TC3182 Board"
+	depends on MIPS_TC3262
+	help
+	  This enables support for TrendChip's TC3182 based board.  
+	  board.
+
+config MIPS_RT63165
+	bool "Ralink's RT63165 Board"
+	depends on MIPS_TC3262
+	help
+	  This enables support for Ralink's RT63165 based board.  
+
+config MIPS_RT65168
+	bool "Ralink's RT65168 Board"
+	depends on MIPS_TC3262
+	select RALINK_VDSL
+	help
+	  This enables support for Ralink's RT65168 based board.  
+
+config MIPS_RT63365
+	bool "Ralink's RT63365 Board"
+	depends on MIPS_TC3262
+	help
+	  This enables support for Ralink's RT63365 based board.  
+config MIPS_MT7510
+	bool "MediaTek's MT7510 Board"
+	depends on MIPS_TC3262
+	select RALINK_VDSL
+	help
+	  This enables support for MediaTek's MT7510 based board.  
+	  
 config MIPS_SIM
 	bool 'MIPS simulator (MIPSsim)'
 	select CEVT_R4K
@@ -1053,6 +1112,32 @@
 config BOOT_ELF32
 	bool
 
+config MIPS_PATENTFREE
+	bool
+	depends on SYS_HAS_CPU_TC3162
+
+config TC3162_ADSL
+	bool 
+	depends on SYS_HAS_CPU_TC3162
+
+config RALINK_VDSL
+	bool 
+	depends on SYS_HAS_CPU_TC3162
+
+config TC3162_IMEM
+	bool 
+	depends on SYS_HAS_CPU_TC3162
+
+config TC3162_DMEM
+	bool 
+	depends on SYS_HAS_CPU_TC3162
+
+config IMEM_SIZE
+	int
+	default "32768" if MIPS_TC3162U || MIPS_TC3182 || MIPS_TC3262
+	default "16384" if MIPS_TC3162
+	depends on TC3162_IMEM
+
 config MIPS_L1_CACHE_SHIFT
 	int
 	default "4" if MACH_DECSTATION || MIKROTIK_RB532 || PMC_MSP4200_EVAL
@@ -2303,3 +2388,5 @@
 source "crypto/Kconfig"
 
 source "lib/Kconfig"
+
+source "pwModel/Kconfig"
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/kernel/asm-offsets.s vr300-linux/arch/mips/kernel/asm-offsets.s
--- linux-2.6.36/arch/mips/kernel/asm-offsets.s	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/kernel/asm-offsets.s	2019-03-07 05:06:20.000000000 +0200
@@ -0,0 +1,1134 @@
+	.file	1 "asm-offsets.c"
+	.section .mdebug.abi32
+	.previous
+	.gnu_attribute 4, 3
+
+ # -G value = 0, Arch = mips32r2, ISA = 33
+ # GNU C (Buildroot 2012.05) version 4.3.6 (mips-unknown-linux-uclibc)
+ #	compiled by GNU C version 3.4.6, GMP version 5.0.4, MPFR version 3.1.0-p6.
+ # GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
+ # options passed:  -nostdinc
+ # -I/home/swd/Dev/VR300/linux_mtk_VR300v1/mtk/linux-2.6.36/arch/mips/include
+ # -Iinclude
+ # -I/home/swd/Dev/VR300/linux_mtk_VR300v1/mtk/linux-2.6.36/arch/mips/include/asm/tc3162/
+ # -I/home/swd/Dev/VR300/linux_mtk_VR300v1/mtk/linux-2.6.36/arch/mips/include/asm/mach-generic
+ # -I/home/swd/Dev/VR300/linux_mtk_VR300v1/build/../mtk/global_inc
+ # -I/home/swd/Dev/VR300/linux_mtk_VR300v1/build/../mtk/modules/private/ra_hwnat_7510
+ # -D__KERNEL__ -DVMLINUX_LOAD_ADDRESS=0xffffffff80002000 -DDATAOFFSET=0
+ # -DTCSUPPORT_NEWTOOLCHAIN -DTCSUPPORT_DRIVER_API -DTC3262
+ # -DTCSUPPORT_CPU_RT63365 -DTCSUPPORT_CPU_MT7510 -DTCSUPPORT_CPU_EN7512
+ # -DTCSUPPORT_MT7510_FE -DTCSUPPORT_ADDR_MAPPING -DTCSUPPORT_HWNAT_LED
+ # -DTCSUPPORT_MULTIWAN -DTCSUPPORT_MT7530_SWITCH_API
+ # -DTCSUPPORT_2_6_36_KERNEL -DTCSUPPORT_MT7530_SWITCH_API
+ # -DTCSUPPORT_WAN_ATM -DTCSUPPORT_WAN_PTM -DTCSUPPORT_QDMA_BUFMGR
+ # -DTCSUPPORT_SLM_EN -DTCSUPPORT_BB_NAND -DTCSUPPORT_DDR_CALI
+ # -DSTART_ADDR=0x80002000 -DTCSUPPORT_FREE_BOOTBASE -DTR068_LED
+ # -DTCSUPPORT_I2C -DTCSUPPORT_WLAN -DWSC_AP_SUPPORT -DLED_WPSSPEC_COMPLY
+ # -DIGMP_SNOOP_SUPPORT -DTCSUPPORT_WLAN_GPIO -DMT7592 -DBBUTOWBU
+ # -DTCSUPPORT_WLAN_MT7592 -DMT7612E -DBBUTOWBU -DTCSUPPORT_DUAL_WLAN
+ # -DTCSUPPORT_WLAN_AC -DMTK_CRYPTO_DRIVER -DTCSUPPORT_IPSEC_PASSTHROUGH
+ # -DTCSUPPORT_VPN -DCMD_API -DTCSUPPORT_RA_HWNAT -DTCSUPPORT_IPV6 -DIPV6
+ # -DTCSUPPORT_IPV6_ENHANCEMENT -DTCSUPPORT_DSLITE -DTCSUPPORT_6RD
+ # -DTCSUPPORT_OPT212 -DTCSUPPORT_IPV6_ADVANCE -DTCSUPPORT_IPV6_FIREWALL
+ # -DCONFIG_SYN_COOKIES -DTCSUPPORT_IPV6_FIREWALL_RFC2827
+ # -DTCSUPPORT_IPV6_TELNET -DTCSUPPORT_IPV6_TFTP -DTCSUPPORT_IPV6_FTP
+ # -DTCSUPPORT_IPV6_INETD -DTCSUPPORT_CWMP -DCWMP -DCWMP_MULTI_CA
+ # -DMULTI_CA -DTR111 -DTR143 -DTCSUPPORT_DOWNSTREAM_QOS -DTCSUPPORT_QOS
+ # -DCONFIG_QOS -DTCSUPPORT_IGMP_QOS -DTCSUPPORT_PORTBIND
+ # -DTCSUPPORT_VLAN_TAG -DTCSUPPORT_SNMP -DTCSUPPORT_SNMP_TRUSTIP
+ # -DTCSUPPORT_SNMP_ATMADSL -DTCSUPPORT_SNMP_FULL -DTCSUPPORT_START_TRAP
+ # -DTCSUPPORT_SNMP_V3 -DTCSUPPORT_IPV6_SNMP -DALIAS_IP -DSTATIC_DHCP
+ # -DDHCP_PROFILE -DTCSUPPORT_MLD_SNOOPING -DTCSUPPORT_MLD_PROXY
+ # -DTCSUPPORT_IGMP_SNOOPING -DTCSUPPORT_IGMPSNOOPING_ENHANCE
+ # -DTCSUPPORT_MULTICAST_SPEED -DTCSUPPORT_IGMP_PROXY_V3 -DTCSUPPORT_SMUX
+ # -DTCSUPPORT_LEDKEY -DTCSUPPORT_IGMP_SNOOPING_V3
+ # -DTCSUPPORT_MTD_PARTITIONS_CMDLINE
+ # -DTCSUPPORT_PARTITIONS_CMDLINE_STR="-[tclinux]"
+ # -DTCSUPPORT_MTD_ENCHANCEMENT -DTCSUPPORT_RESERVEAREA_BLOCK=4
+ # -DTCSUPPORT_BACKUPROMFILE -DTCSUPPORT_PRODUCTIONLINE -DTCSUPPORT_DMS
+ # -DTCSUPPORT_DMS_FULL_FORMAT -DTCSUPPORT_WEB_SAVE -DTCSUPPORT_MODEL_CHECK
+ # -DTCSUPPORT_FILTER_DSCP -DTCSUPPORT_DHCP_PORT_FLT -DTCSUPPORT_PPP_AUTHEN
+ # -DTCSUPPORT_UPNP_CERT -DTCSUPPORT_TR069_OPT43 -DTCSUPPORT_SYSLOG_ENHANCE
+ # -DTCSUPPORT_WLAN_8021X -DTCSUPPORT_WLAN_RATELIMIT
+ # -DTCSUPPORT_WEBSERVER_SSL -DTCSUPPORT_SSH -DTCSUPPORT_FW_UPGRADE_16M
+ # -DTCSUPPORT_REMOTE_SYSLOG -DTCSUPPORT_GENERAL_MULTILANGUAGE
+ # -DRA_PARENTALCONTROL -DTCSUPPORT_PARENTAL_URLBLOCK -DRA_ETHERMEDIATYPE
+ # -DTCSUPPORT_SYSLOG -DTCSUPPORT_SAMBA -DTCSUPPORT_RA_GUI
+ # -DTCSUPPORT_MEMORY_CONTROL -DTCSUPPORT_TFTP_UPGRADE_PROTECT
+ # -DTCSUPPORT_MODEL_NAME_CUSKIT -DTCSUPPORT_VPN_SWITCH_GUI
+ # -DTCSUPPORT_LAYER3FORWARD_ENHANCEMENT -DTCSUPPORT_WPA_SUPPLICANT
+ # -DTCSUPPORT_SUPPORT_FLASH -DTCSUPPORT_TEST_LED_ALL
+ # -DTCSUPPORT_WLAN_MAXSTANUM_GUI -DTCSUPPORT_MULTISERVICE_ON_WAN
+ # -DTCSUPPORT_CWMP_VDSL -DTCSUPPORT_AGEOUT_MAC -DTCSUPPORT_OOM_RB_NEXT
+ # -DTCSUPPORT_MT7530_SWITCH_API -DTCSUPPORT_NEW_SPIFLASH
+ # -DTCSUPPORT_DOT11N_SPEC_COMPLY -DTCSUPPORT_HTBW_40M
+ # -DTCSUPPORT_WPA2_PRE_AUTH -DCONFIG_TP_WPS_SHARED_LED
+ # -DINCLUDE_CPU_BIG_ENDIAN -DINCLUDE_MTK_ACCELERATE -DINCLUDE_MTD_TYPE4
+ # -DINCLUDE_FLASH_8M -DINCLUDE_CLI_FULL_FEATURE -DINCLUDE_CHGINIT_PWD
+ # -DINCLUDE_AUTH_PASSWORD -DINCLUDE_EWAN_VLAN -DINCLUDE_DUAL_CONFIG
+ # -DINCLUDE_OPENSSL_1_0_2x -DINCLUDE_ETH_RA -DINCLUDE_LAN_WLAN
+ # -DINCLUDE_WLAN_RA -DINCLUDE_LAN_WLAN_MSSID -DWLAN_VAP_NUM=1
+ # -DINCLUDE_LAN_WLAN_GUESTNETWORK -DINCLUDE_LAN_WLAN_WDS
+ # -DINCLUDE_LAN_WLAN_802_1X -DINCLUDE_LAN_WLAN_DUALBAND
+ # -DINCLUDE_LAN_WLAN_AC -DINCLUDE_LAN_WLAN_SCHEDULE
+ # -DINCLUDE_WIFI_5G_CHIP_MT7612E -DINCLUDE_DNS_PROXY -DINCLUDE_BRIDGING
+ # -DINCLUDE_ADSLWAN -DINCLUDE_VDSLWAN -DINCLUDE_ADSL_RA
+ # -DINCLUDE_ETHERNET_WAN -DINCLUDE_IGMP -DINCLUDE_IPTV -DINCLUDE_IPTV_V2
+ # -DINCLUDE_EWAN_IPTV -DINCLUDE_RU_IPTV -DINCLUDE_RIP -DINCLUDE_SNMP
+ # -DINCLUDE_SSL -DINCLUDE_CWMP -DINCLUDE_CWMP_SSL -DINCLUDE_NEW_WEB_UI_V2
+ # -DINCLUDE_DDNS -DINCLUDE_DYNDNS -DINCLUDE_NOIPDNS
+ # -DINCLUDE_DDNS_USERDEFINE -DINCLUDE_ALG -DINCLUDE_ALG_H323
+ # -DINCLUDE_ALG_SIP -DINCLUDE_ALG_RTSP -DINCLUDE_TC -DINCLUDE_HTTP_SSL
+ # -DINCLUDE_NEW_WEB_UI -DINCLUDE_MIC -DINCLUDE_IPV6 -DINCLUDE_DISABLE_LAN6
+ # -DINCLUDE_IPV6_SLAAC -DINCLUDE_IPV6_HTTP -DINCLUDE_IPV6_FORWARDING_RULE
+ # -DINCLUDE_IPSEC -DINCLUDE_WAN_MODE -DINCLUDE_PPP_HOST_UNIQ -DINCLUDE_ACL
+ # -DINCLUDE_PORTABLE_APP -DINCLUDE_CLOUD -DINCLUDE_CLOUD_V2
+ # -DINCLUDE_WAN_BLOCK -DINCLUDE_WAN_BLOCK_FW_UP_INFO
+ # -DINCLUDE_HOSTNAME_EDITABLE -DINCLUDE_REBOOT_SCHEDULE -DINCLUDE_VPN
+ # -DINCLUDE_MER -DINCLUDE_FACTORY_DEFAULT -DINCLUDE_DHCP_OPT_121
+ # -DINCLUDE_VR300V1_20 -DUSE_FILE_TO_PASS_PPP_ARG -DWEB_INCLUDE_MOBILE_UI
+ # -DINCLUDE_MULTI_LANGUAGE -DINCLUDE_WEB_REGION -DMTD_PART_TYPE=4
+ # -DCONFIG_TP_IMAGE -DINCLUDE_CPU_BIG_ENDIAN -DINCLUDE_MTK_ACCELERATE
+ # -DINCLUDE_MTD_TYPE4 -DINCLUDE_FLASH_8M -DINCLUDE_CLI_FULL_FEATURE
+ # -DINCLUDE_CHGINIT_PWD -DINCLUDE_AUTH_PASSWORD -DINCLUDE_EWAN_VLAN
+ # -DINCLUDE_DUAL_CONFIG -DINCLUDE_OPENSSL_1_0_2x -DINCLUDE_ETH_RA
+ # -DINCLUDE_LAN_WLAN -DINCLUDE_WLAN_RA -DINCLUDE_LAN_WLAN_MSSID
+ # -DWLAN_VAP_NUM=1 -DINCLUDE_LAN_WLAN_GUESTNETWORK -DINCLUDE_LAN_WLAN_WDS
+ # -DINCLUDE_LAN_WLAN_802_1X -DINCLUDE_LAN_WLAN_DUALBAND
+ # -DINCLUDE_LAN_WLAN_AC -DINCLUDE_LAN_WLAN_SCHEDULE
+ # -DINCLUDE_WIFI_5G_CHIP_MT7612E -DINCLUDE_DNS_PROXY -DINCLUDE_BRIDGING
+ # -DINCLUDE_ADSLWAN -DINCLUDE_VDSLWAN -DINCLUDE_ADSL_RA
+ # -DINCLUDE_ETHERNET_WAN -DINCLUDE_IGMP -DINCLUDE_IPTV -DINCLUDE_IPTV_V2
+ # -DINCLUDE_EWAN_IPTV -DINCLUDE_RU_IPTV -DINCLUDE_RIP -DINCLUDE_SNMP
+ # -DINCLUDE_SSL -DINCLUDE_CWMP -DINCLUDE_CWMP_SSL -DINCLUDE_NEW_WEB_UI_V2
+ # -DINCLUDE_DDNS -DINCLUDE_DYNDNS -DINCLUDE_NOIPDNS
+ # -DINCLUDE_DDNS_USERDEFINE -DINCLUDE_ALG -DINCLUDE_ALG_H323
+ # -DINCLUDE_ALG_SIP -DINCLUDE_ALG_RTSP -DINCLUDE_TC -DINCLUDE_HTTP_SSL
+ # -DINCLUDE_NEW_WEB_UI -DINCLUDE_MIC -DINCLUDE_IPV6 -DINCLUDE_DISABLE_LAN6
+ # -DINCLUDE_IPV6_SLAAC -DINCLUDE_IPV6_HTTP -DINCLUDE_IPV6_FORWARDING_RULE
+ # -DINCLUDE_IPSEC -DINCLUDE_WAN_MODE -DINCLUDE_PPP_HOST_UNIQ -DINCLUDE_ACL
+ # -DINCLUDE_PORTABLE_APP -DINCLUDE_CLOUD -DINCLUDE_CLOUD_V2
+ # -DINCLUDE_WAN_BLOCK -DINCLUDE_WAN_BLOCK_FW_UP_INFO
+ # -DINCLUDE_HOSTNAME_EDITABLE -DINCLUDE_REBOOT_SCHEDULE -DINCLUDE_VPN
+ # -DINCLUDE_MER -DINCLUDE_FACTORY_DEFAULT -DINCLUDE_DHCP_OPT_121
+ # -DINCLUDE_VR300V1_20 -DUSE_FILE_TO_PASS_PPP_ARG -DWEB_INCLUDE_MOBILE_UI
+ # -DINCLUDE_MULTI_LANGUAGE -DINCLUDE_WEB_REGION -DKBUILD_STR(s)=#s
+ # -DKBUILD_BASENAME=KBUILD_STR(asm_offsets)
+ # -DKBUILD_MODNAME=KBUILD_STR(asm_offsets) -isystem
+ # /opt/trendchip/mips-linux-uclibc-4.3.6-v2/usr/lib/gcc/mips-unknown-linux-uclibc/4.3.6/include
+ # -include include/generated/autoconf.h -MD
+ # arch/mips/kernel/.asm-offsets.s.d arch/mips/kernel/asm-offsets.c -G 0
+ # -mno-check-zero-division -mabi=32 -mno-abicalls -msoft-float
+ # -march=mips32r2 -mtune=mips32r2 -mllsc -mno-shared -auxbase-strip
+ # arch/mips/kernel/asm-offsets.s -O2 -Wall -Wundef -Wstrict-prototypes
+ # -Wno-trigraphs -Wdeclaration-after-statement -Wno-pointer-sign
+ # -fno-strict-aliasing -fno-common -ffunction-sections -fno-pic
+ # -ffreestanding -fno-stack-protector -fomit-frame-pointer
+ # -fno-strict-overflow -fverbose-asm
+ # options enabled:  -falign-loops -fargument-alias -fauto-inc-dec
+ # -fbranch-count-reg -fcaller-saves -fcprop-registers -fcrossjumping
+ # -fcse-follow-jumps -fdefer-pop -fdelete-null-pointer-checks
+ # -fearly-inlining -feliminate-unused-debug-types
+ # -fexpensive-optimizations -fforward-propagate -ffunction-cse
+ # -ffunction-sections -fgcse -fgcse-lm -fguess-branch-probability -fident
+ # -fif-conversion -fif-conversion2 -finline-functions-called-once
+ # -finline-small-functions -fipa-pure-const -fipa-reference -fivopts
+ # -fkeep-static-consts -fleading-underscore -fmath-errno -fmerge-constants
+ # -fmerge-debug-strings -fmove-loop-invariants -fomit-frame-pointer
+ # -foptimize-register-move -foptimize-sibling-calls -fpcc-struct-return
+ # -fpeephole -fpeephole2 -fregmove -freorder-blocks -freorder-functions
+ # -frerun-cse-after-loop -fsched-interblock -fsched-spec
+ # -fsched-stalled-insns-dep -fschedule-insns -fschedule-insns2
+ # -fsigned-zeros -fsplit-ivs-in-unroller -fsplit-wide-types -fthread-jumps
+ # -ftoplevel-reorder -ftrapping-math -ftree-ccp -ftree-ch -ftree-copy-prop
+ # -ftree-copyrename -ftree-cselim -ftree-dce -ftree-dominator-opts
+ # -ftree-dse -ftree-fre -ftree-loop-im -ftree-loop-ivcanon
+ # -ftree-loop-optimize -ftree-parallelize-loops= -ftree-pre -ftree-reassoc
+ # -ftree-salias -ftree-scev-cprop -ftree-sink -ftree-sra -ftree-store-ccp
+ # -ftree-ter -ftree-vect-loop-version -ftree-vrp -funit-at-a-time
+ # -fverbose-asm -fzero-initialized-in-bss -mdivide-traps -mdouble-float
+ # -meb -mexplicit-relocs -mextern-sdata -mfp-exceptions -mfp32
+ # -mfused-madd -mgp32 -mgpopt -mllsc -mlocal-sdata -mlong32 -mno-mips16
+ # -mno-mips3d -msoft-float -msplit-addresses -muclibc
+
+ # Compiler executable checksum: 5473d803ee373647040f460bca6ba7b9
+
+#APP
+	.macro _ssnop; sll $0, $0, 1; .endm
+	.macro _ehb; sll $0, $0, 3; .endm
+	.macro mtc0_tlbw_hazard; _ehb; .endm
+	.macro tlbw_use_hazard; _ehb; .endm
+	.macro tlb_probe_hazard; _ehb; .endm
+	.macro irq_enable_hazard; _ehb; .endm
+	.macro irq_disable_hazard; _ehb; .endm
+	.macro back_to_back_c0_hazard; _ehb; .endm
+	.macro enable_fpu_hazard; _ehb; .endm
+	.macro disable_fpu_hazard; _ehb; .endm
+		.macro	raw_local_irq_enable				
+	.set	push						
+	.set	reorder						
+	.set	noat						
+	mfc0	$1, $2, 1	# SMTC - clear TCStatus.IXMT	
+	ori	$1, 0x400					
+	xori	$1, 0x400					
+	mtc0	$1, $2, 1					
+	irq_enable_hazard					
+	.set	pop						
+	.endm
+		.macro	raw_local_irq_disable
+	.set	push						
+	.set	noat						
+	mfc0	$1, $2, 1					
+	ori	$1, 0x400					
+	.set	noreorder					
+	mtc0	$1, $2, 1					
+	irq_disable_hazard					
+	.set	pop						
+	.endm							
+
+		.macro	raw_local_save_flags flags			
+	.set	push						
+	.set	reorder						
+	mfc0	\flags, $2, 1					
+	.set	pop						
+	.endm							
+
+		.macro	raw_local_irq_save result			
+	.set	push						
+	.set	reorder						
+	.set	noat						
+	mfc0	\result, $2, 1					
+	ori	$1, \result, 0x400				
+	.set	noreorder					
+	mtc0	$1, $2, 1					
+	andi	\result, \result, 0x400			
+	irq_disable_hazard					
+	.set	pop						
+	.endm							
+
+		.macro	raw_local_irq_restore flags			
+	.set	push						
+	.set	noreorder					
+	.set	noat						
+mfc0	$1, $2, 1						
+andi	\flags, 0x400						
+ori	$1, 0x400						
+xori	$1, 0x400						
+or	\flags, $1						
+mtc0	\flags, $2, 1						
+	irq_disable_hazard					
+	.set	pop						
+	.endm							
+
+#NO_APP
+	.section	.text.output_ptreg_defines,"ax",@progbits
+	.align	2
+	.globl	output_ptreg_defines
+	.ent	output_ptreg_defines
+	.type	output_ptreg_defines, @function
+output_ptreg_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 23 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#MIPS pt_regs offsets.
+ # 0 "" 2
+ # 24 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R0 24 offsetof(struct pt_regs, regs[0])	 #
+ # 0 "" 2
+ # 25 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R1 28 offsetof(struct pt_regs, regs[1])	 #
+ # 0 "" 2
+ # 26 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R2 32 offsetof(struct pt_regs, regs[2])	 #
+ # 0 "" 2
+ # 27 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R3 36 offsetof(struct pt_regs, regs[3])	 #
+ # 0 "" 2
+ # 28 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R4 40 offsetof(struct pt_regs, regs[4])	 #
+ # 0 "" 2
+ # 29 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R5 44 offsetof(struct pt_regs, regs[5])	 #
+ # 0 "" 2
+ # 30 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R6 48 offsetof(struct pt_regs, regs[6])	 #
+ # 0 "" 2
+ # 31 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R7 52 offsetof(struct pt_regs, regs[7])	 #
+ # 0 "" 2
+ # 32 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R8 56 offsetof(struct pt_regs, regs[8])	 #
+ # 0 "" 2
+ # 33 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R9 60 offsetof(struct pt_regs, regs[9])	 #
+ # 0 "" 2
+ # 34 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R10 64 offsetof(struct pt_regs, regs[10])	 #
+ # 0 "" 2
+ # 35 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R11 68 offsetof(struct pt_regs, regs[11])	 #
+ # 0 "" 2
+ # 36 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R12 72 offsetof(struct pt_regs, regs[12])	 #
+ # 0 "" 2
+ # 37 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R13 76 offsetof(struct pt_regs, regs[13])	 #
+ # 0 "" 2
+ # 38 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R14 80 offsetof(struct pt_regs, regs[14])	 #
+ # 0 "" 2
+ # 39 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R15 84 offsetof(struct pt_regs, regs[15])	 #
+ # 0 "" 2
+ # 40 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R16 88 offsetof(struct pt_regs, regs[16])	 #
+ # 0 "" 2
+ # 41 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R17 92 offsetof(struct pt_regs, regs[17])	 #
+ # 0 "" 2
+ # 42 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R18 96 offsetof(struct pt_regs, regs[18])	 #
+ # 0 "" 2
+ # 43 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R19 100 offsetof(struct pt_regs, regs[19])	 #
+ # 0 "" 2
+ # 44 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R20 104 offsetof(struct pt_regs, regs[20])	 #
+ # 0 "" 2
+ # 45 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R21 108 offsetof(struct pt_regs, regs[21])	 #
+ # 0 "" 2
+ # 46 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R22 112 offsetof(struct pt_regs, regs[22])	 #
+ # 0 "" 2
+ # 47 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R23 116 offsetof(struct pt_regs, regs[23])	 #
+ # 0 "" 2
+ # 48 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R24 120 offsetof(struct pt_regs, regs[24])	 #
+ # 0 "" 2
+ # 49 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R25 124 offsetof(struct pt_regs, regs[25])	 #
+ # 0 "" 2
+ # 50 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R26 128 offsetof(struct pt_regs, regs[26])	 #
+ # 0 "" 2
+ # 51 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R27 132 offsetof(struct pt_regs, regs[27])	 #
+ # 0 "" 2
+ # 52 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R28 136 offsetof(struct pt_regs, regs[28])	 #
+ # 0 "" 2
+ # 53 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R29 140 offsetof(struct pt_regs, regs[29])	 #
+ # 0 "" 2
+ # 54 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R30 144 offsetof(struct pt_regs, regs[30])	 #
+ # 0 "" 2
+ # 55 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_R31 148 offsetof(struct pt_regs, regs[31])	 #
+ # 0 "" 2
+ # 56 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_LO 160 offsetof(struct pt_regs, lo)	 #
+ # 0 "" 2
+ # 57 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_HI 156 offsetof(struct pt_regs, hi)	 #
+ # 0 "" 2
+ # 61 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_EPC 172 offsetof(struct pt_regs, cp0_epc)	 #
+ # 0 "" 2
+ # 62 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_BVADDR 164 offsetof(struct pt_regs, cp0_badvaddr)	 #
+ # 0 "" 2
+ # 63 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_STATUS 152 offsetof(struct pt_regs, cp0_status)	 #
+ # 0 "" 2
+ # 64 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_CAUSE 168 offsetof(struct pt_regs, cp0_cause)	 #
+ # 0 "" 2
+ # 66 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_TCSTATUS 176 offsetof(struct pt_regs, cp0_tcstatus)	 #
+ # 0 "" 2
+ # 72 "arch/mips/kernel/asm-offsets.c" 1
+	
+->PT_SIZE 184 sizeof(struct pt_regs)	 #
+ # 0 "" 2
+ # 73 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_ptreg_defines
+	.section	.text.output_task_defines,"ax",@progbits
+	.align	2
+	.globl	output_task_defines
+	.ent	output_task_defines
+	.type	output_task_defines, @function
+output_task_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 78 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#MIPS task_struct offsets.
+ # 0 "" 2
+ # 79 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TASK_STATE 0 offsetof(struct task_struct, state)	 #
+ # 0 "" 2
+ # 80 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TASK_THREAD_INFO 4 offsetof(struct task_struct, stack)	 #
+ # 0 "" 2
+ # 81 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TASK_FLAGS 12 offsetof(struct task_struct, flags)	 #
+ # 0 "" 2
+ # 82 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TASK_MM 184 offsetof(struct task_struct, mm)	 #
+ # 0 "" 2
+ # 83 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TASK_PID 232 offsetof(struct task_struct, pid)	 #
+ # 0 "" 2
+ # 84 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TASK_STRUCT_SIZE 1152 sizeof(struct task_struct)	 #
+ # 0 "" 2
+ # 85 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_task_defines
+	.section	.text.output_thread_info_defines,"ax",@progbits
+	.align	2
+	.globl	output_thread_info_defines
+	.ent	output_thread_info_defines
+	.type	output_thread_info_defines, @function
+output_thread_info_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 90 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#MIPS thread_info offsets.
+ # 0 "" 2
+ # 91 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_TASK 0 offsetof(struct thread_info, task)	 #
+ # 0 "" 2
+ # 92 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_EXEC_DOMAIN 4 offsetof(struct thread_info, exec_domain)	 #
+ # 0 "" 2
+ # 93 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_FLAGS 8 offsetof(struct thread_info, flags)	 #
+ # 0 "" 2
+ # 94 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_TP_VALUE 12 offsetof(struct thread_info, tp_value)	 #
+ # 0 "" 2
+ # 95 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_CPU 16 offsetof(struct thread_info, cpu)	 #
+ # 0 "" 2
+ # 96 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_PRE_COUNT 20 offsetof(struct thread_info, preempt_count)	 #
+ # 0 "" 2
+ # 97 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_ADDR_LIMIT 24 offsetof(struct thread_info, addr_limit)	 #
+ # 0 "" 2
+ # 98 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_RESTART_BLOCK 32 offsetof(struct thread_info, restart_block)	 #
+ # 0 "" 2
+ # 99 "arch/mips/kernel/asm-offsets.c" 1
+	
+->TI_REGS 72 offsetof(struct thread_info, regs)	 #
+ # 0 "" 2
+ # 100 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_THREAD_SIZE 16384 THREAD_SIZE	 #
+ # 0 "" 2
+ # 101 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_THREAD_MASK 16383 THREAD_MASK	 #
+ # 0 "" 2
+ # 102 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_thread_info_defines
+	.section	.text.output_thread_defines,"ax",@progbits
+	.align	2
+	.globl	output_thread_defines
+	.ent	output_thread_defines
+	.type	output_thread_defines, @function
+output_thread_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 107 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#MIPS specific thread_struct offsets.
+ # 0 "" 2
+ # 108 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG16 504 offsetof(struct task_struct, thread.reg16)	 #
+ # 0 "" 2
+ # 109 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG17 508 offsetof(struct task_struct, thread.reg17)	 #
+ # 0 "" 2
+ # 110 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG18 512 offsetof(struct task_struct, thread.reg18)	 #
+ # 0 "" 2
+ # 111 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG19 516 offsetof(struct task_struct, thread.reg19)	 #
+ # 0 "" 2
+ # 112 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG20 520 offsetof(struct task_struct, thread.reg20)	 #
+ # 0 "" 2
+ # 113 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG21 524 offsetof(struct task_struct, thread.reg21)	 #
+ # 0 "" 2
+ # 114 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG22 528 offsetof(struct task_struct, thread.reg22)	 #
+ # 0 "" 2
+ # 115 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG23 532 offsetof(struct task_struct, thread.reg23)	 #
+ # 0 "" 2
+ # 116 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG29 536 offsetof(struct task_struct, thread.reg29)	 #
+ # 0 "" 2
+ # 117 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG30 540 offsetof(struct task_struct, thread.reg30)	 #
+ # 0 "" 2
+ # 118 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_REG31 544 offsetof(struct task_struct, thread.reg31)	 #
+ # 0 "" 2
+ # 119 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_STATUS 548 offsetof(struct task_struct, thread.cp0_status)	 #
+ # 0 "" 2
+ # 121 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPU 552 offsetof(struct task_struct, thread.fpu)	 #
+ # 0 "" 2
+ # 123 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_BVADDR 876 offsetof(struct task_struct, thread.cp0_badvaddr)	 #
+ # 0 "" 2
+ # 125 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_BUADDR 880 offsetof(struct task_struct, thread.cp0_baduaddr)	 #
+ # 0 "" 2
+ # 127 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_ECODE 884 offsetof(struct task_struct, thread.error_code)	 #
+ # 0 "" 2
+ # 129 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_TRAMP 888 offsetof(struct task_struct, thread.irix_trampoline)	 #
+ # 0 "" 2
+ # 131 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_OLDCTX 892 offsetof(struct task_struct, thread.irix_oldctx)	 #
+ # 0 "" 2
+ # 133 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_thread_defines
+	.section	.text.output_thread_fpu_defines,"ax",@progbits
+	.align	2
+	.globl	output_thread_fpu_defines
+	.ent	output_thread_fpu_defines
+	.type	output_thread_fpu_defines, @function
+output_thread_fpu_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 138 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR0 552 offsetof(struct task_struct, thread.fpu.fpr[0])	 #
+ # 0 "" 2
+ # 139 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR1 560 offsetof(struct task_struct, thread.fpu.fpr[1])	 #
+ # 0 "" 2
+ # 140 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR2 568 offsetof(struct task_struct, thread.fpu.fpr[2])	 #
+ # 0 "" 2
+ # 141 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR3 576 offsetof(struct task_struct, thread.fpu.fpr[3])	 #
+ # 0 "" 2
+ # 142 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR4 584 offsetof(struct task_struct, thread.fpu.fpr[4])	 #
+ # 0 "" 2
+ # 143 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR5 592 offsetof(struct task_struct, thread.fpu.fpr[5])	 #
+ # 0 "" 2
+ # 144 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR6 600 offsetof(struct task_struct, thread.fpu.fpr[6])	 #
+ # 0 "" 2
+ # 145 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR7 608 offsetof(struct task_struct, thread.fpu.fpr[7])	 #
+ # 0 "" 2
+ # 146 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR8 616 offsetof(struct task_struct, thread.fpu.fpr[8])	 #
+ # 0 "" 2
+ # 147 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR9 624 offsetof(struct task_struct, thread.fpu.fpr[9])	 #
+ # 0 "" 2
+ # 148 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR10 632 offsetof(struct task_struct, thread.fpu.fpr[10])	 #
+ # 0 "" 2
+ # 149 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR11 640 offsetof(struct task_struct, thread.fpu.fpr[11])	 #
+ # 0 "" 2
+ # 150 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR12 648 offsetof(struct task_struct, thread.fpu.fpr[12])	 #
+ # 0 "" 2
+ # 151 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR13 656 offsetof(struct task_struct, thread.fpu.fpr[13])	 #
+ # 0 "" 2
+ # 152 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR14 664 offsetof(struct task_struct, thread.fpu.fpr[14])	 #
+ # 0 "" 2
+ # 153 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR15 672 offsetof(struct task_struct, thread.fpu.fpr[15])	 #
+ # 0 "" 2
+ # 154 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR16 680 offsetof(struct task_struct, thread.fpu.fpr[16])	 #
+ # 0 "" 2
+ # 155 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR17 688 offsetof(struct task_struct, thread.fpu.fpr[17])	 #
+ # 0 "" 2
+ # 156 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR18 696 offsetof(struct task_struct, thread.fpu.fpr[18])	 #
+ # 0 "" 2
+ # 157 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR19 704 offsetof(struct task_struct, thread.fpu.fpr[19])	 #
+ # 0 "" 2
+ # 158 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR20 712 offsetof(struct task_struct, thread.fpu.fpr[20])	 #
+ # 0 "" 2
+ # 159 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR21 720 offsetof(struct task_struct, thread.fpu.fpr[21])	 #
+ # 0 "" 2
+ # 160 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR22 728 offsetof(struct task_struct, thread.fpu.fpr[22])	 #
+ # 0 "" 2
+ # 161 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR23 736 offsetof(struct task_struct, thread.fpu.fpr[23])	 #
+ # 0 "" 2
+ # 162 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR24 744 offsetof(struct task_struct, thread.fpu.fpr[24])	 #
+ # 0 "" 2
+ # 163 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR25 752 offsetof(struct task_struct, thread.fpu.fpr[25])	 #
+ # 0 "" 2
+ # 164 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR26 760 offsetof(struct task_struct, thread.fpu.fpr[26])	 #
+ # 0 "" 2
+ # 165 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR27 768 offsetof(struct task_struct, thread.fpu.fpr[27])	 #
+ # 0 "" 2
+ # 166 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR28 776 offsetof(struct task_struct, thread.fpu.fpr[28])	 #
+ # 0 "" 2
+ # 167 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR29 784 offsetof(struct task_struct, thread.fpu.fpr[29])	 #
+ # 0 "" 2
+ # 168 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR30 792 offsetof(struct task_struct, thread.fpu.fpr[30])	 #
+ # 0 "" 2
+ # 169 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FPR31 800 offsetof(struct task_struct, thread.fpu.fpr[31])	 #
+ # 0 "" 2
+ # 171 "arch/mips/kernel/asm-offsets.c" 1
+	
+->THREAD_FCR31 808 offsetof(struct task_struct, thread.fpu.fcr31)	 #
+ # 0 "" 2
+ # 172 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_thread_fpu_defines
+	.section	.text.output_mm_defines,"ax",@progbits
+	.align	2
+	.globl	output_mm_defines
+	.ent	output_mm_defines
+	.type	output_mm_defines, @function
+output_mm_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 177 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#Size of struct page
+ # 0 "" 2
+ # 178 "arch/mips/kernel/asm-offsets.c" 1
+	
+->STRUCT_PAGE_SIZE 32 sizeof(struct page)	 #
+ # 0 "" 2
+ # 179 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+ # 180 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#Linux mm_struct offsets.
+ # 0 "" 2
+ # 181 "arch/mips/kernel/asm-offsets.c" 1
+	
+->MM_USERS 40 offsetof(struct mm_struct, mm_users)	 #
+ # 0 "" 2
+ # 182 "arch/mips/kernel/asm-offsets.c" 1
+	
+->MM_PGD 36 offsetof(struct mm_struct, pgd)	 #
+ # 0 "" 2
+ # 183 "arch/mips/kernel/asm-offsets.c" 1
+	
+->MM_CONTEXT 344 offsetof(struct mm_struct, context)	 #
+ # 0 "" 2
+ # 184 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+ # 185 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PGD_T_SIZE 4 sizeof(pgd_t)	 #
+ # 0 "" 2
+ # 186 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PMD_T_SIZE 4 sizeof(pmd_t)	 #
+ # 0 "" 2
+ # 187 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PTE_T_SIZE 4 sizeof(pte_t)	 #
+ # 0 "" 2
+ # 188 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+ # 189 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PGD_T_LOG2 2 PGD_T_LOG2	 #
+ # 0 "" 2
+ # 193 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PTE_T_LOG2 2 PTE_T_LOG2	 #
+ # 0 "" 2
+ # 194 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+ # 195 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PGD_ORDER 0 PGD_ORDER	 #
+ # 0 "" 2
+ # 199 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PTE_ORDER 0 PTE_ORDER	 #
+ # 0 "" 2
+ # 200 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+ # 201 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PMD_SHIFT 22 PMD_SHIFT	 #
+ # 0 "" 2
+ # 202 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PGDIR_SHIFT 22 PGDIR_SHIFT	 #
+ # 0 "" 2
+ # 203 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+ # 204 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PTRS_PER_PGD 1024 PTRS_PER_PGD	 #
+ # 0 "" 2
+ # 205 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PTRS_PER_PMD 1 PTRS_PER_PMD	 #
+ # 0 "" 2
+ # 206 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_PTRS_PER_PTE 1024 PTRS_PER_PTE	 #
+ # 0 "" 2
+ # 207 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_mm_defines
+	.section	.text.output_sc_defines,"ax",@progbits
+	.align	2
+	.globl	output_sc_defines
+	.ent	output_sc_defines
+	.type	output_sc_defines, @function
+output_sc_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 213 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#Linux sigcontext offsets.
+ # 0 "" 2
+ # 214 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_REGS 16 offsetof(struct sigcontext, sc_regs)	 #
+ # 0 "" 2
+ # 215 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_FPREGS 272 offsetof(struct sigcontext, sc_fpregs)	 #
+ # 0 "" 2
+ # 216 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_ACX 528 offsetof(struct sigcontext, sc_acx)	 #
+ # 0 "" 2
+ # 217 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_MDHI 552 offsetof(struct sigcontext, sc_mdhi)	 #
+ # 0 "" 2
+ # 218 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_MDLO 560 offsetof(struct sigcontext, sc_mdlo)	 #
+ # 0 "" 2
+ # 219 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_PC 8 offsetof(struct sigcontext, sc_pc)	 #
+ # 0 "" 2
+ # 220 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_FPC_CSR 532 offsetof(struct sigcontext, sc_fpc_csr)	 #
+ # 0 "" 2
+ # 221 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_FPC_EIR 536 offsetof(struct sigcontext, sc_fpc_eir)	 #
+ # 0 "" 2
+ # 222 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_HI1 568 offsetof(struct sigcontext, sc_hi1)	 #
+ # 0 "" 2
+ # 223 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_LO1 572 offsetof(struct sigcontext, sc_lo1)	 #
+ # 0 "" 2
+ # 224 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_HI2 576 offsetof(struct sigcontext, sc_hi2)	 #
+ # 0 "" 2
+ # 225 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_LO2 580 offsetof(struct sigcontext, sc_lo2)	 #
+ # 0 "" 2
+ # 226 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_HI3 584 offsetof(struct sigcontext, sc_hi3)	 #
+ # 0 "" 2
+ # 227 "arch/mips/kernel/asm-offsets.c" 1
+	
+->SC_LO3 588 offsetof(struct sigcontext, sc_lo3)	 #
+ # 0 "" 2
+ # 228 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_sc_defines
+	.section	.text.output_signal_defined,"ax",@progbits
+	.align	2
+	.globl	output_signal_defined
+	.ent	output_signal_defined
+	.type	output_signal_defined, @function
+output_signal_defined:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 259 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#Linux signal numbers.
+ # 0 "" 2
+ # 260 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGHUP 1 SIGHUP	 #
+ # 0 "" 2
+ # 261 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGINT 2 SIGINT	 #
+ # 0 "" 2
+ # 262 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGQUIT 3 SIGQUIT	 #
+ # 0 "" 2
+ # 263 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGILL 4 SIGILL	 #
+ # 0 "" 2
+ # 264 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGTRAP 5 SIGTRAP	 #
+ # 0 "" 2
+ # 265 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGIOT 6 SIGIOT	 #
+ # 0 "" 2
+ # 266 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGABRT 6 SIGABRT	 #
+ # 0 "" 2
+ # 267 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGEMT 7 SIGEMT	 #
+ # 0 "" 2
+ # 268 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGFPE 8 SIGFPE	 #
+ # 0 "" 2
+ # 269 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGKILL 9 SIGKILL	 #
+ # 0 "" 2
+ # 270 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGBUS 10 SIGBUS	 #
+ # 0 "" 2
+ # 271 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGSEGV 11 SIGSEGV	 #
+ # 0 "" 2
+ # 272 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGSYS 12 SIGSYS	 #
+ # 0 "" 2
+ # 273 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGPIPE 13 SIGPIPE	 #
+ # 0 "" 2
+ # 274 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGALRM 14 SIGALRM	 #
+ # 0 "" 2
+ # 275 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGTERM 15 SIGTERM	 #
+ # 0 "" 2
+ # 276 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGUSR1 16 SIGUSR1	 #
+ # 0 "" 2
+ # 277 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGUSR2 17 SIGUSR2	 #
+ # 0 "" 2
+ # 278 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGCHLD 18 SIGCHLD	 #
+ # 0 "" 2
+ # 279 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGPWR 19 SIGPWR	 #
+ # 0 "" 2
+ # 280 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGWINCH 20 SIGWINCH	 #
+ # 0 "" 2
+ # 281 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGURG 21 SIGURG	 #
+ # 0 "" 2
+ # 282 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGIO 22 SIGIO	 #
+ # 0 "" 2
+ # 283 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGSTOP 23 SIGSTOP	 #
+ # 0 "" 2
+ # 284 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGTSTP 24 SIGTSTP	 #
+ # 0 "" 2
+ # 285 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGCONT 25 SIGCONT	 #
+ # 0 "" 2
+ # 286 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGTTIN 26 SIGTTIN	 #
+ # 0 "" 2
+ # 287 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGTTOU 27 SIGTTOU	 #
+ # 0 "" 2
+ # 288 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGVTALRM 28 SIGVTALRM	 #
+ # 0 "" 2
+ # 289 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGPROF 29 SIGPROF	 #
+ # 0 "" 2
+ # 290 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGXCPU 30 SIGXCPU	 #
+ # 0 "" 2
+ # 291 "arch/mips/kernel/asm-offsets.c" 1
+	
+->_SIGXFSZ 31 SIGXFSZ	 #
+ # 0 "" 2
+ # 292 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_signal_defined
+	.section	.text.output_irq_cpustat_t_defines,"ax",@progbits
+	.align	2
+	.globl	output_irq_cpustat_t_defines
+	.ent	output_irq_cpustat_t_defines
+	.type	output_irq_cpustat_t_defines, @function
+output_irq_cpustat_t_defines:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+#APP
+ # 297 "arch/mips/kernel/asm-offsets.c" 1
+	
+->#Linux irq_cpustat_t offsets.
+ # 0 "" 2
+ # 298 "arch/mips/kernel/asm-offsets.c" 1
+	
+->IC_SOFTIRQ_PENDING 0 offsetof(irq_cpustat_t, __softirq_pending)	 #
+ # 0 "" 2
+ # 300 "arch/mips/kernel/asm-offsets.c" 1
+	
+->IC_IRQ_CPUSTAT_T 32 sizeof(irq_cpustat_t)	 #
+ # 0 "" 2
+ # 301 "arch/mips/kernel/asm-offsets.c" 1
+	
+->
+ # 0 "" 2
+#NO_APP
+	j	$31
+	.end	output_irq_cpustat_t_defines
+	.ident	"GCC: (Buildroot 2012.05) 4.3.6"
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/kernel/cpu-probe.c vr300-linux/arch/mips/kernel/cpu-probe.c
--- linux-2.6.36/arch/mips/kernel/cpu-probe.c	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/kernel/cpu-probe.c	2021-12-06 09:21:25.378872572 +0200
@@ -356,6 +356,13 @@
 			c->options |= MIPS_CPU_FPU;
 		c->tlbsize = 64;
 		break;
+	case PRID_IMP_TC3162:
+		c->cputype = CPU_R3000;
+		c->isa_level = MIPS_CPU_ISA_I;
+		c->options = MIPS_CPU_TLB | MIPS_CPU_3K_CACHE |
+		             MIPS_CPU_NOFPUEX;
+		c->tlbsize = 32;
+		break;
 	case PRID_IMP_R4000:
 		if (read_c0_config() & CONF_SC) {
 			if ((c->processor_id & 0xff) >= PRID_REV_R4400) {
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/kernel/csrc-r4k.c vr300-linux/arch/mips/kernel/csrc-r4k.c
--- linux-2.6.36/arch/mips/kernel/csrc-r4k.c	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/kernel/csrc-r4k.c	2019-03-07 03:40:15.000000000 +0200
@@ -15,7 +15,8 @@
 	return read_c0_count();
 }
 
-static struct clocksource clocksource_mips = {
+//static 
+struct clocksource clocksource_mips = {
 	.name		= "MIPS",
 	.read		= c0_hpt_read,
 	.mask		= CLOCKSOURCE_MASK(32),
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/kernel/entry.S vr300-linux/arch/mips/kernel/entry.S
--- linux-2.6.36/arch/mips/kernel/entry.S	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/kernel/entry.S	2019-03-07 03:40:15.000000000 +0200
@@ -123,7 +123,7 @@
 	SAVE_AT
 	SAVE_TEMP
 	LONG_L	v0, PT_STATUS(sp)
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 	and	v0, ST0_IEP
 #else
 	and	v0, ST0_IE
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/kernel/genex.S vr300-linux/arch/mips/kernel/genex.S
--- linux-2.6.36/arch/mips/kernel/genex.S	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/kernel/genex.S	2021-12-06 12:04:59.842775420 +0200
@@ -178,7 +178,7 @@
 	.set	push
 	.set	noat
 	mfc0	k0, CP0_STATUS
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 	and	k0, ST0_IEP
 	bnez	k0, 1f
 
@@ -512,7 +512,7 @@
 	get_saved_sp	/* k1 := current_thread_info */
 	.set	noreorder
 	MFC0	k0, CP0_EPC
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX) || defined(CONFIG_CPU_TC3162)
 	ori	k1, _THREAD_MASK
 	xori	k1, _THREAD_MASK
 	LONG_L	v1, TI_TP_VALUE(k1)
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/kernel/Makefile vr300-linux/arch/mips/kernel/Makefile
--- linux-2.6.36/arch/mips/kernel/Makefile	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/kernel/Makefile	2019-03-07 03:40:15.000000000 +0200
@@ -36,6 +36,7 @@
 obj-$(CONFIG_CPU_MIPS32)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_MIPS64)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R3000)		+= r2300_fpu.o r2300_switch.o
+obj-$(CONFIG_CPU_TC3162)	+= r2300_fpu.o r2300_switch.o
 obj-$(CONFIG_CPU_R4300)		+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R4X00)		+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R5000)		+= r4k_fpu.o r4k_switch.o
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/kernel/mips-mt.c vr300-linux/arch/mips/kernel/mips-mt.c
--- linux-2.6.36/arch/mips/kernel/mips-mt.c	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/kernel/mips-mt.c	2019-03-07 03:40:15.000000000 +0200
@@ -31,7 +31,7 @@
 
 __setup("maxvpes=", maxvpes);
 
-int tclimit;
+int tclimit = 4;
 
 static int __init maxtcs(char *str)
 {
@@ -125,12 +125,108 @@
 	local_irq_restore(flags);
 }
 
+/*
+ * Dump new MIPS MT state for the core. Does not leave TCs halted.
+ * Takes an argument which taken to be a pre-call MVPControl value.
+ */
+
+void mips_mt_regdump_nmi(unsigned long mvpctl)
+{
+	unsigned long flags;
+	unsigned long vpflags;
+	unsigned long mvpconf0;
+	int nvpe;
+	int ntc;
+	int i;
+	int tc;
+	unsigned long haltval;
+	unsigned long tcstatval;
+#ifdef CONFIG_MIPS_MT_SMTC
+	void smtc_soft_dump(void);
+#endif /* CONFIG_MIPT_MT_SMTC */
+
+	local_irq_save(flags);
+	vpflags = dvpe();
+	printk("=== MIPS MT State Dump ===\n");
+	printk("-- Global State --\n");
+	printk("   MVPControl Passed: %08lx\n", mvpctl);
+	printk("   MVPControl Read: %08lx\n", vpflags);
+	printk("   MVPConf0 : %08lx\n", (mvpconf0 = read_c0_mvpconf0()));
+	nvpe = ((mvpconf0 & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT) + 1;
+	ntc = ((mvpconf0 & MVPCONF0_PTC) >> MVPCONF0_PTC_SHIFT) + 1;
+	printk("-- per-VPE State --\n");
+	for (i = 0; i < nvpe; i++) {
+		for (tc = 0; tc < ntc; tc++) {
+			settc(tc);
+			if ((read_tc_c0_tcbind() & TCBIND_CURVPE) == i) {
+				printk("  VPE %d\n", i);
+				printk("   VPEControl : %08lx\n",
+				       read_vpe_c0_vpecontrol());
+				printk("   VPEConf0 : %08lx\n",
+				       read_vpe_c0_vpeconf0());
+				printk("   VPE%d.Status : %08lx\n",
+				       i, read_vpe_c0_status());
+				//printk("   VPE%d.EPC : %08lx %pS\n",
+				//       i, read_vpe_c0_epc(),
+				//       (void *) read_vpe_c0_epc());
+				printk("   VPE%d.EPC : %08lx\n",
+				       i, read_vpe_c0_epc());
+				printk("   VPE%d.Cause : %08lx\n",
+				       i, read_vpe_c0_cause());
+				printk("   VPE%d.Config7 : %08lx\n",
+				       i, read_vpe_c0_config7());
+				break; /* Next VPE */
+			}
+		}
+	}
+	printk("-- per-TC State --\n");
+	for (tc = 0; tc < ntc; tc++) {
+		settc(tc);
+		if (read_tc_c0_tcbind() == read_c0_tcbind()) {
+			/* Are we dumping ourself?  */
+			haltval = 0; /* Then we're not halted, and mustn't be */
+			tcstatval = flags; /* And pre-dump TCStatus is flags */
+			printk("  TC %d (current TC with VPE EPC above)\n", tc);
+		} else {
+			haltval = read_tc_c0_tchalt();
+			write_tc_c0_tchalt(1);
+			tcstatval = read_tc_c0_tcstatus();
+			printk("  TC %d\n", tc);
+		}
+		printk("   TCStatus : %08lx\n", tcstatval);
+		printk("   TCBind : %08lx\n", read_tc_c0_tcbind());
+		//printk("   TCRestart : %08lx %pS\n",
+		//       read_tc_c0_tcrestart(), (void *) read_tc_c0_tcrestart());
+		printk("   TCRestart : %08lx\n",
+		       read_tc_c0_tcrestart());
+		printk("   TCHalt : %08lx\n", haltval);
+		printk("   TCContext : %08lx\n", read_tc_c0_tccontext());
+		if (!haltval)
+			write_tc_c0_tchalt(0);
+	}
+#ifdef CONFIG_MIPS_MT_SMTC
+	smtc_soft_dump();
+#endif /* CONFIG_MIPT_MT_SMTC */
+	printk("===========================\n");
+	evpe(vpflags);
+	local_irq_restore(flags);
+}
+
+
+static int mt_opt_es;
 static int mt_opt_norps;
 static int mt_opt_rpsctl = -1;
 static int mt_opt_nblsu = -1;
 static int mt_opt_forceconfig7;
 static int mt_opt_config7 = -1;
 
+static int __init es_set(char *str)
+{
+	get_option(&str, &mt_opt_es);
+	return 1;
+}
+__setup("es=", es_set);
+
 static int __init rps_disable(char *s)
 {
 	mt_opt_norps = 1;
@@ -209,6 +305,13 @@
 	unsigned int oconfig7 = read_c0_config7();
 	unsigned int nconfig7 = oconfig7;
 
+	if (mt_opt_es >= 0) {
+		printk("34K sync es set to %d.\n", mt_opt_es);
+		if (mt_opt_es)
+			nconfig7 |= (1 << 8);
+		else
+			nconfig7 &= ~(1 << 8);
+	}
 	if (mt_opt_norps) {
 		printk("\"norps\" option deprectated: use \"rpsctl=\"\n");
 	}
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/kernel/mips-mt-fpaff.c vr300-linux/arch/mips/kernel/mips-mt-fpaff.c
--- linux-2.6.36/arch/mips/kernel/mips-mt-fpaff.c	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/kernel/mips-mt-fpaff.c	2019-03-07 03:40:15.000000000 +0200
@@ -73,6 +73,28 @@
 	if (copy_from_user(&new_mask, user_mask_ptr, sizeof(new_mask)))
 		return -EFAULT;
 
+
+#ifdef CONFIG_MIPS_MT_SMP
+#ifndef CONFIG_MIPS_MT_SMTC
+	printk("\r\n\r\n%s new_mask origin value is %08x\r\n\r\n", __FUNCTION__, *new_mask);
+	if(*(unsigned long *)new_mask == 0x8)
+	{
+		*(unsigned long *)new_mask = 0x2;
+	}
+	else if(*(unsigned long *)new_mask == 0xf)
+	{
+		*(unsigned long *)new_mask = 0x3;
+	}
+	else
+	{
+		*(unsigned long *)new_mask = 0x1;
+	}
+	
+	printk("\r\n\r\n%s new_mask changed value is %08x\r\n\r\n", __FUNCTION__, *new_mask);
+#endif
+#endif
+
+
 	get_online_cpus();
 	rcu_read_lock();
 
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/kernel/smp-mt.c vr300-linux/arch/mips/kernel/smp-mt.c
--- linux-2.6.36/arch/mips/kernel/smp-mt.c	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/kernel/smp-mt.c	2019-03-07 03:40:15.000000000 +0200
@@ -151,6 +151,10 @@
 
 static void __cpuinit vsmp_init_secondary(void)
 {
+#ifdef CONFIG_MIPS_TC3262
+	write_c0_status((read_c0_status() & ~ST0_IM ) |
+	                (STATUSF_IP0 | STATUSF_IP1)); 
+#else
 	extern int gic_present;
 
 	/* This is Malta specific: IPI,performance and timer inetrrupts */
@@ -160,6 +164,7 @@
 	else
 		change_c0_status(ST0_IM, STATUSF_IP0 | STATUSF_IP1 |
 					 STATUSF_IP6 | STATUSF_IP7);
+#endif
 }
 
 static void __cpuinit vsmp_smp_finish(void)
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/kernel/spram.c vr300-linux/arch/mips/kernel/spram.c
--- linux-2.6.36/arch/mips/kernel/spram.c	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/kernel/spram.c	2019-03-07 03:40:15.000000000 +0200
@@ -12,12 +12,84 @@
 #include <linux/kernel.h>
 #include <linux/ptrace.h>
 #include <linux/stddef.h>
+#include <linux/module.h>
 
+#include <asm/cpu.h>
 #include <asm/fpu.h>
 #include <asm/mipsregs.h>
 #include <asm/system.h>
 #include <asm/r4kcache.h>
 #include <asm/hazards.h>
+#ifdef CONFIG_MIPS_TC3262
+#include <asm/tc3162/tc3162.h>
+
+extern int __imem, __dmem;
+#endif
+static char *sram_allocp = NULL;
+static int sram_size = 0;
+static int sram_free = 0;
+
+static char *dspram_p = NULL;
+static int dspram_used_size = 0;
+static int dspram_max_size = 0x1000;	//4K
+int is_sram_addr(void *p)
+{
+	if ((CKSEG1ADDR(p) & 0xffffc000) == (CKSEG1ADDR(DSPRAM_BASE) & 0xffffc000))
+		return 1;
+	else 
+		return 0;
+}
+EXPORT_SYMBOL(is_sram_addr);
+
+void *alloc_sram(int n)
+{
+	if (sram_allocp == NULL)
+		return NULL;
+
+	if (sram_free >= n) {
+		sram_free -= n;
+		sram_allocp += n;
+		printk("alloc_sram p=%p free=%04x\n", sram_allocp, sram_free);
+		return sram_allocp - n;
+	} else 
+		return NULL;
+}
+EXPORT_SYMBOL(alloc_sram);
+
+void free_sram(void *p, int n)
+{
+	if (sram_allocp == (p+n)) {
+		sram_free += n;
+		sram_allocp -= n;
+	}
+	printk("free_sram p=%p free=%04x\n", sram_allocp, sram_free);
+}
+EXPORT_SYMBOL(free_sram);
+
+void write_to_dspram(long  data)
+{
+	if(dspram_p == NULL || dspram_max_size == 0)
+		return;
+
+	
+	*(long *)dspram_p = data;
+	dspram_p += sizeof(long);
+
+	dspram_used_size += sizeof(long);
+
+	if(dspram_used_size >= dspram_max_size){
+		dspram_p = (char *)(DSPRAM_BASE);
+		dspram_used_size = 0;
+	}
+}
+
+unsigned int dspram_base_addr()
+{
+	return DSPRAM_BASE;
+}
+
+
+#define MIPS34K_Index_Store_Data_I	0x0c
 
 /*
  * These definitions are correct for the 24K/34K/74K SPRAM sample
@@ -38,7 +110,7 @@
 /*
  * Different semantics to the set_c0_* function built by __BUILD_SET_C0
  */
-static __cpuinit unsigned int bis_c0_errctl(unsigned int set)
+static unsigned int bis_c0_errctl(unsigned int set)
 {
 	unsigned int res;
 	res = read_c0_errctl();
@@ -46,7 +118,36 @@
 	return res;
 }
 
-static __cpuinit void ispram_store_tag(unsigned int offset, unsigned int data)
+static void ispram_store_data(unsigned int offset, unsigned int datalo, unsigned int datahi)
+{
+	unsigned int errctl;
+
+	/* enable SPRAM tag access */
+	errctl = bis_c0_errctl(ERRCTL_SPRAM);
+	ehb();
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+	write_c0_idatalo(datahi);
+	ehb();
+
+	write_c0_idatahi(datalo);
+	ehb();
+#else
+	write_c0_idatalo(datalo);
+	ehb();
+
+	write_c0_idatahi(datahi);
+	ehb();
+#endif
+
+	cache_op(MIPS34K_Index_Store_Data_I, CKSEG0|offset);
+	ehb();
+
+	write_c0_errctl(errctl);
+	ehb();
+}
+
+static void ispram_store_tag(unsigned int offset, unsigned int data)
 {
 	unsigned int errctl;
 
@@ -65,7 +166,7 @@
 }
 
 
-static __cpuinit unsigned int ispram_load_tag(unsigned int offset)
+static unsigned int ispram_load_tag(unsigned int offset)
 {
 	unsigned int data;
 	unsigned int errctl;
@@ -116,7 +217,7 @@
 	return data;
 }
 
-static __cpuinit void probe_spram(char *type,
+static void probe_spram(char *type,
 	    unsigned int base,
 	    unsigned int (*read)(unsigned int),
 	    void (*write)(unsigned int, unsigned int))
@@ -176,6 +277,7 @@
 		if (strcmp(type, "DSPRAM") == 0) {
 			unsigned int *vp = (unsigned int *)(CKSEG1 | pa);
 			unsigned int v;
+			if(!isMT751020 && !isMT7505 && !isEN751221){
 #define TDAT	0x5a5aa5a5
 			vp[0] = TDAT;
 			vp[1] = ~TDAT;
@@ -190,6 +292,18 @@
 			if (v != ~TDAT)
 				printk(KERN_ERR "vp=%p wrote=%08x got=%08x\n",
 				       vp+1, ~TDAT, v);
+			}
+#ifdef CONFIG_MIPS_TC3262
+			if (enabled) {
+				if(isMT751020 || isMT7505 || isEN751221){
+					dspram_max_size = size;
+				}
+				else{
+				sram_allocp = (char *) vp;
+				sram_size = sram_free = size;
+				}
+			}
+#endif
 		}
 
 		pr_info("%s%d: PA=%08x,Size=%08x%s\n",
@@ -197,6 +311,36 @@
 		offset += 2 * SPRAM_TAG_STRIDE;
 	}
 }
+
+void ispram_fill(void)
+{
+	unsigned int pa, size, tag0, tag1;
+	unsigned int offset;
+	unsigned int datalo, datahi;
+
+	tag0 = ispram_load_tag(0);
+	tag1 = ispram_load_tag(0+SPRAM_TAG_STRIDE);
+
+	pa = tag0 & SPRAM_TAG0_PA_MASK;
+	size = tag1 & SPRAM_TAG1_SIZE_MASK;
+
+	if (size == 0)
+		return;
+
+	for (offset = 0; offset < size; offset += 8) {
+		datalo = *(unsigned int *) (PHYS_TO_K0(pa + offset));
+		datahi = *(unsigned int *) (PHYS_TO_K0(pa + offset + 4));
+		ispram_store_data(offset, datalo, datahi);
+	}
+}
+
+void ispram_refill(void)
+{
+	//probe_spram("ISPRAM", CPHYSADDR(&__imem),
+	//		&ispram_load_tag, &ispram_store_tag);
+	ispram_fill();
+}
+
 void __cpuinit spram_config(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
@@ -209,6 +353,41 @@
 	case CPU_1004K:
 		config0 = read_c0_config();
 		/* FIXME: addresses are Malta specific */
+#ifdef CONFIG_MIPS_TC3262
+#ifdef CONFIG_TC3162_IMEM
+		if (config0 & (1<<24)) {
+			probe_spram("ISPRAM", CPHYSADDR(&__imem),
+				    &ispram_load_tag, &ispram_store_tag);
+			ispram_fill();
+			if (!isRT63165 && !isRT63365 && !isMT751020 && !isMT7505 && !isEN751221)
+				VPint(CR_DMC_ISPCFGR) = (CPHYSADDR(&__imem) & 0xfffff000) | (1<<8) | (0x7);
+		}
+#endif
+#ifdef CONFIG_TC3162_DMEM
+		if (isRT63165 || isRT63365) {
+			VPint(CR_SRAM) = (CPHYSADDR(DSPRAM_BASE) & 0xffffc000) | (1<<0);
+			printk("Enable SRAM=%08lx\n", VPint(CR_SRAM));
+
+			sram_allocp = (char *) CKSEG1ADDR(DSPRAM_BASE);
+			sram_size = sram_free = 0x8000;
+		} else {
+			if (!isTC3182 && !isRT65168) {
+				if (config0 & (1<<23)) {
+					if(isMT751020){
+						probe_spram("DSPRAM", CPHYSADDR(DSPRAM_BASE),
+							&dspram_load_tag, &dspram_store_tag);
+						dspram_p = (char *)(DSPRAM_BASE);
+					}
+					else{
+						probe_spram("DSPRAM", CPHYSADDR(DSPRAM_BASE),
+							&dspram_load_tag, &dspram_store_tag);
+						VPint(CR_DMC_DSPCFGR) = (CPHYSADDR(DSPRAM_BASE) & 0xfffff000) | (1<<8) | (0x7);
+					}
+				}
+			}
+		}
+#endif
+#else
 		if (config0 & (1<<24)) {
 			probe_spram("ISPRAM", 0x1c000000,
 				    &ispram_load_tag, &ispram_store_tag);
@@ -216,5 +395,6 @@
 		if (config0 & (1<<23))
 			probe_spram("DSPRAM", 0x1c100000,
 				    &dspram_load_tag, &dspram_store_tag);
+#endif
 	}
 }
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/kernel/vmlinux.lds.S vr300-linux/arch/mips/kernel/vmlinux.lds.S
--- linux-2.6.36/arch/mips/kernel/vmlinux.lds.S	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/kernel/vmlinux.lds.S	2019-03-07 03:40:15.000000000 +0200
@@ -4,6 +4,10 @@
 
 #undef mips
 #define mips mips
+#if defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+#undef CONFIG_IMEM_SIZE
+#define CONFIG_IMEM_SIZE 65536
+#endif
 OUTPUT_ARCH(mips)
 ENTRY(kernel_entry)
 PHDRS {
@@ -51,7 +55,21 @@
 		*(.fixup)
 		*(.gnu.warning)
 	} :text = 0
+
+#ifdef CONFIG_TC3162_IMEM
+#ifdef CONFIG_CPU_TC3162
+  	. = ALIGN(16384);
+#else
+  	. = ALIGN(32768);
+#endif
+  	__imem = . ;
+  	.imem_text : { *(.imem_text) }
+  	_imem_end = .;
+  	_etext = (__imem + CONFIG_IMEM_SIZE) > . ? (__imem + CONFIG_IMEM_SIZE) : .;
+  	. = _etext;
+#else
 	_etext = .;	/* End of text section */
+#endif  
 
 	EXCEPTION_TABLE(16)
 
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/kernel/vpe.c vr300-linux/arch/mips/kernel/vpe.c
--- linux-2.6.36/arch/mips/kernel/vpe.c	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/kernel/vpe.c	2019-03-07 03:40:15.000000000 +0200
@@ -148,9 +148,9 @@
 	spinlock_t tc_list_lock;
 	struct list_head tc_list;	/* Thread contexts */
 } vpecontrol = {
-	.vpe_list_lock	= SPIN_LOCK_UNLOCKED,
+	.vpe_list_lock	= __SPIN_LOCK_UNLOCKED(vpecontrol.vpe_list_lock),
 	.vpe_list	= LIST_HEAD_INIT(vpecontrol.vpe_list),
-	.tc_list_lock	= SPIN_LOCK_UNLOCKED,
+	.tc_list_lock	= __SPIN_LOCK_UNLOCKED(vpecontrol.tc_list_lock),
 	.tc_list	= LIST_HEAD_INIT(vpecontrol.tc_list)
 };
 
@@ -192,7 +192,7 @@
 	}
 	spin_unlock(&vpecontrol.tc_list_lock);
 
-	return NULL;
+	return res;//modify by xfu seams like a bug
 }
 
 /* allocate a vpe and associate it with this minor (or index) */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/mm/cache.c vr300-linux/arch/mips/mm/cache.c
--- linux-2.6.36/arch/mips/mm/cache.c	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/mm/cache.c	2019-03-07 03:40:15.000000000 +0200
@@ -51,6 +51,7 @@
 void (*_dma_cache_wback)(unsigned long start, unsigned long size);
 void (*_dma_cache_inv)(unsigned long start, unsigned long size);
 
+EXPORT_SYMBOL(_dma_cache_inv);
 EXPORT_SYMBOL(_dma_cache_wback_inv);
 
 #endif /* CONFIG_DMA_NONCOHERENT */
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/mm/c-r4k.c vr300-linux/arch/mips/mm/c-r4k.c
--- linux-2.6.36/arch/mips/mm/c-r4k.c	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/mm/c-r4k.c	2019-03-07 03:40:15.000000000 +0200
@@ -595,7 +595,7 @@
 
 #ifdef CONFIG_DMA_NONCOHERENT
 
-static void r4k_dma_cache_wback_inv(unsigned long addr, unsigned long size)
+__IMEM static void r4k_dma_cache_wback_inv(unsigned long addr, unsigned long size)
 {
 	/* Catch bad driver code */
 	BUG_ON(size == 0);
@@ -623,7 +623,7 @@
 	bc_wback_inv(addr, size);
 }
 
-static void r4k_dma_cache_inv(unsigned long addr, unsigned long size)
+__IMEM static void r4k_dma_cache_inv(unsigned long addr, unsigned long size)
 {
 	/* Catch bad driver code */
 	BUG_ON(size == 0);
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/mm/c-tc3162.c vr300-linux/arch/mips/mm/c-tc3162.c
--- linux-2.6.36/arch/mips/mm/c-tc3162.c	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/mm/c-tc3162.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,318 @@
+/*
+ * Cache operations for the TC3162
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <asm/mipsregs.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+#include <asm/mmu_context.h>
+#include <asm/isadep.h>
+#include <asm/io.h>
+#include <asm/wbflush.h>
+#include <asm/cpu.h>
+#include <asm/asm.h>
+#include <asm/cacheops.h>
+
+#include <asm/r4kcache.h>
+
+/**
+ * The icace and dcache size variables are currently set to hard values,
+ * as there is no way to size the Lexra caches through software.
+ */
+unsigned long icache_size, dcache_size;
+__DMEM unsigned long icache_lsize, dcache_lsize;
+
+extern int r3k_have_wired_reg;	/* in r3k-tlb.c */
+
+static inline void tc3162_blast_dcache_page(unsigned long addr)
+{
+	blast_dcache16_page(addr);
+}
+
+static inline void tc3162_blast_icache(void)
+{
+	unsigned int controlReg;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	controlReg = read_c0_cctl();
+
+	write_c0_cctl(controlReg & ~CCTL_IINVAL);
+	write_c0_cctl(controlReg | CCTL_IINVAL);
+
+	/* delay to allow cache to be flushed */
+	__asm__ __volatile__(".set\tnoreorder\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t" "nop\n\t" ".set\treorder\n\t");
+
+	write_c0_cctl(controlReg);
+	local_irq_restore(flags);
+}
+
+static void tc3162_blast_dcache(void)
+{
+	unsigned int controlReg;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	controlReg = read_c0_cctl();
+
+	write_c0_cctl(controlReg & ~CCTL_DWBINVAL);
+	write_c0_cctl(controlReg | CCTL_DWBINVAL);
+
+	/* delay to allow cache to be flushed */
+	__asm__ __volatile__(".set\tnoreorder\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t"
+			     "nop\n\t" "nop\n\t" ".set\treorder\n\t");
+
+	write_c0_cctl(controlReg);
+	local_irq_restore(flags);
+}
+
+static void tc3162_flush_icache_all(void)
+{
+	tc3162_blast_icache();
+}
+
+static inline void tc3162_blast_icache_page(unsigned long addr)
+{
+	tc3162_blast_icache();
+}
+
+static inline void tc3162_flush_cache_all(void)
+{
+	if (!cpu_has_dc_aliases)
+		return;
+
+	tc3162_blast_dcache();
+}
+
+static inline void tc3162___flush_cache_all(void)
+{
+	tc3162_blast_dcache();
+	tc3162_blast_icache();
+}
+
+static void tc3162_flush_cache_mm(struct mm_struct *mm)
+{
+	if (!cpu_has_dc_aliases)
+		return;
+
+	if (cpu_context(smp_processor_id(), mm) != 0)
+		tc3162_blast_dcache();
+}
+
+static void tc3162_flush_cache_range(struct vm_area_struct *vma,
+	unsigned long start, unsigned long end)
+{
+	if (!cpu_has_dc_aliases)
+		return;
+	if (!(cpu_context(smp_processor_id(), vma->vm_mm)))
+		return;
+
+	tc3162_blast_dcache();
+}
+
+static void tc3162_flush_cache_page(struct vm_area_struct *vma, unsigned long page, unsigned long pfn)
+{
+	int exec = vma->vm_flags & VM_EXEC;
+	struct mm_struct *mm = vma->vm_mm;
+	pgd_t *pgdp;
+	pud_t *pudp;
+	pmd_t *pmdp;
+	pte_t *ptep;
+
+	/*
+	 * If ownes no valid ASID yet, cannot possibly have gotten
+	 * this page into the cache.
+	 */
+	if (cpu_context(smp_processor_id(), mm) == 0)
+		return;
+
+	page &= PAGE_MASK;
+	pgdp = pgd_offset(mm, page);
+	pudp = pud_offset(pgdp, page);
+	pmdp = pmd_offset(pudp, page);
+	ptep = pte_offset(pmdp, page);
+
+	/*
+	 * If the page isn't marked valid, the page cannot possibly be
+	 * in the cache.
+	 */
+	if (!(pte_val(*ptep) & _PAGE_PRESENT))
+		return;
+
+	/*
+	 * Doing flushes for another ASID than the current one is
+	 * too difficult since stupid R4k caches do a TLB translation
+	 * for every cache flush operation.  So we do indexed flushes
+	 * in that case, which doesn't overly flush the cache too much.
+	 */
+	if ((mm == current->active_mm) && (pte_val(*ptep) & _PAGE_VALID)) {
+		if (cpu_has_dc_aliases || exec)
+			tc3162_blast_dcache_page(page);
+		if (exec)
+			tc3162_blast_icache_page(page);
+
+		return;
+	}
+}
+
+static void local_tc3162_flush_data_cache_page(void * addr)
+{
+	tc3162_blast_dcache_page((unsigned long)addr);
+}
+
+static void tc3162_flush_data_cache_page(unsigned long addr)
+{
+	tc3162_blast_dcache_page(addr);
+}
+
+static void tc3162_flush_icache_range(unsigned long start, unsigned long end)
+{
+	protected_blast_dcache_range(start, end);
+	tc3162_blast_icache();
+}
+
+static void tc3162_flush_cache_sigtramp(unsigned long addr)
+{
+	protected_writeback_dcache_line(addr & ~(dcache_lsize - 1)); 
+	tc3162_blast_icache();
+}
+
+static void tc3162_dma_cache_wback_inv(unsigned long addr, unsigned long size)
+{
+#if 1
+	blast_dcache_range(addr, addr + size);
+#else
+	unsigned long end;
+
+	if (((size | addr) & (PAGE_SIZE - 1)) == 0) {
+		end = addr + size;
+		do {
+			tc3162_blast_dcache_page(addr);
+			addr += PAGE_SIZE;
+		} while(addr != end);
+	} else if (size > dcache_size) {
+		tc3162_blast_dcache();
+	} else {
+		blast_dcache_range(addr, addr + size);
+	}
+#endif
+}
+
+static void tc3162_dma_cache_inv(unsigned long addr, unsigned long size)
+{
+#if 1
+	blast_inv_dcache_range(addr, addr + size);
+#else
+	unsigned long end;
+
+	if (((size | addr) & (PAGE_SIZE - 1)) == 0) {
+		end = addr + size;
+		do {
+			tc3162_blast_dcache_page(addr);
+			addr += PAGE_SIZE;
+		} while(addr != end);
+	} else if (size > dcache_size) {
+		tc3162_blast_dcache();
+	} else {
+		blast_inv_dcache_range(addr, addr + size);
+	}
+#endif
+}
+
+static void __init tc3162_probe_cache(void)
+{
+	dcache_size = 1024*8;
+	if (dcache_size)
+		dcache_lsize = 16;
+	icache_size = 1024*32;
+	if (icache_size)
+		icache_lsize = 16;
+
+	current_cpu_data.icache.ways = 2;
+	current_cpu_data.icache.linesz = 16;
+	current_cpu_data.dcache.ways = 2;
+	current_cpu_data.dcache.linesz = 16;
+}
+
+void __init r3k_cache_init(void)
+{
+	extern void build_clear_page(void);
+	extern void build_copy_page(void);
+
+	/*
+	 * These variables are unused on this architecture.
+	 */
+	tc3162_probe_cache();
+	
+	r3k_have_wired_reg = 1;
+
+	flush_cache_all = tc3162_flush_cache_all;
+	__flush_cache_all = tc3162___flush_cache_all; 
+	flush_cache_mm = tc3162_flush_cache_mm;
+	flush_cache_range = tc3162_flush_cache_range;
+	flush_cache_page = tc3162_flush_cache_page;
+	flush_icache_range = tc3162_flush_icache_range;
+
+	flush_cache_sigtramp = tc3162_flush_cache_sigtramp;
+	flush_icache_all = tc3162_flush_icache_all;
+	local_flush_data_cache_page = local_tc3162_flush_data_cache_page;
+	flush_data_cache_page = tc3162_flush_data_cache_page;
+
+	_dma_cache_wback_inv = tc3162_dma_cache_wback_inv;
+	_dma_cache_wback = tc3162_dma_cache_wback_inv;
+	_dma_cache_inv = tc3162_dma_cache_inv;
+
+	/*
+	shm_align_mask = max_t(unsigned long,
+			(dcache_size / current_cpu_data.dcache.ways) - 1,
+		   		PAGE_SIZE - 1);
+	*/
+
+	current_cpu_data.icache.waysize = icache_size / current_cpu_data.icache.ways;
+	current_cpu_data.dcache.waysize = dcache_size / current_cpu_data.dcache.ways;
+
+	current_cpu_data.icache.sets =
+		current_cpu_data.icache.waysize / current_cpu_data.icache.linesz;
+	current_cpu_data.dcache.sets =
+		current_cpu_data.dcache.waysize / current_cpu_data.dcache.linesz;
+
+	/* TC3162 is Physically-indexed, physically-tagged cache policy, don't have dcache alias
+	   problem */
+	/*
+	if (current_cpu_data.dcache.waysize > PAGE_SIZE)
+		current_cpu_data.dcache.flags |= MIPS_CACHE_ALIASES;
+	*/
+
+	current_cpu_data.icache.waybit = 0;
+	current_cpu_data.dcache.waybit = 0;
+
+	printk("Primary instruction cache %ldkB, linesize %ld bytes.\n",
+		icache_size >> 10, icache_lsize);
+	printk("Primary data cache %ldkB, linesize %ld bytes.\n",
+		dcache_size >> 10, dcache_lsize);
+
+	build_clear_page();
+	build_copy_page();
+	tc3162_blast_icache();
+}
+
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/mm/Makefile vr300-linux/arch/mips/mm/Makefile
--- linux-2.6.36/arch/mips/mm/Makefile	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/mm/Makefile	2019-03-07 03:40:15.000000000 +0200
@@ -16,6 +16,7 @@
 obj-$(CONFIG_CPU_NEVADA)	+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R10000)	+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R3000)		+= c-r3k.o tlb-r3k.o
+obj-$(CONFIG_CPU_TC3162)	+= c-tc3162.o tlb-r3k.o pg-r4k.o
 obj-$(CONFIG_CPU_R4300)		+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R4X00)		+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R5000)		+= c-r4k.o cex-gen.o tlb-r4k.o
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/pci/fixup-tc3162.c vr300-linux/arch/mips/pci/fixup-tc3162.c
--- linux-2.6.36/arch/mips/pci/fixup-tc3162.c	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/pci/fixup-tc3162.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,64 @@
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <asm/tc3162/tc3162.h>
+
+static char irq_tab_tc3162[] __initdata = {
+#ifndef CONFIG_MIPS_TC3262
+    [1] = PCI_A_INT,
+    [2] = PCI_B_INT,
+#endif
+};
+
+int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+#ifndef PCIE_PCI_COEXIT
+	if (slot <= 0)
+		return -1;
+#else
+
+	if (isEN751221){
+		if (slot == 0)
+			return USB11_INT;
+		else if(slot == 1)
+			return PCIE_A_INT;
+	}
+
+	if (slot == 0){
+		return PCIE_A_INT;
+	}
+#ifdef CONFIG_MIPS_TC3262	
+	else if((isRT63365 || isMT751020 || isMT7505) && (slot == 1)){
+		return USB11_INT; //rt63365 use original usb 11 INT number
+	}
+#endif	
+#endif
+    return irq_tab_tc3162[slot];
+}
+
+static void tc3162_pci_fixup(struct pci_dev *dev)
+{
+	/* setup COMMAND register */
+	pci_write_config_word(dev, PCI_COMMAND,
+		(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER));
+
+	/* setup CACHE_LINE_SIZE register */
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 0x8);
+
+	/* setup LATENCY_TIMER register */
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x20);
+
+	/* setup BARS */
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0);
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_1, 0x1FBA0000);
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_2, 0x1FBB0000);
+}
+
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_TRENDCHIP, PCI_DEVICE_ID_TC3162,
+          tc3162_pci_fixup);
+
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/pci/fixup-tc3162u.c vr300-linux/arch/mips/pci/fixup-tc3162u.c
--- linux-2.6.36/arch/mips/pci/fixup-tc3162u.c	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/pci/fixup-tc3162u.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,412 @@
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <asm/tc3162/tc3162.h>
+#include <linux/delay.h>
+#if defined(TCSUPPORT_CPU_MT7505) || defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+#define isRC0_LINKUP		((regRead32(0xbfb80050) & 0x2) ? 1 : 0)  
+#define isRC1_LINKUP		((regRead32(0xbfb80050) & 0x4) ? 1 : 0)
+#else 
+#define isRC0_LINKUP		((regRead32(0xbfb82050) & 0x1) ? 1 : 0)
+#define isRC1_LINKUP		((regRead32(0xbfb83050) & 0x1) ? 1 : 0)
+#endif
+
+
+unsigned long int pcie_read_config_word(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum);
+int pcie_write_config_word(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum, unsigned long int value);
+
+extern int mt7512_pcie_is_slave();
+extern int dual_band_support;
+
+#ifndef PCIE_PCI_COEXIT
+/* 
+static char irq_tab_tc3162_pcie[] __initdata = {
+    //[1] = PCI_A_INT,
+    //[2] = PCI_B_INT,
+    [0] = PCIE_A_INT,//krammer
+};
+*/
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	//if (slot <= 0)
+#if 0
+	if (slot < 0)
+		return -1;
+#endif
+    	//return irq_tab_tc3162[slot];
+	return PCIE_A_INT;
+}
+#endif
+
+
+static void tc3162_pcie_fixup(struct pci_dev *dev)
+{
+	/* setup COMMAND register */
+	pci_write_config_word(dev, PCI_COMMAND,
+		(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER));
+
+	/* setup CACHE_LINE_SIZE register */
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 0x8);
+
+	/* setup LATENCY_TIMER register */
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x20);
+
+	/* setup BARS */
+//	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0);
+//	pci_write_config_dword(dev, PCI_BASE_ADDRESS_1, 0x1FBA0000);
+//	pci_write_config_dword(dev, PCI_BASE_ADDRESS_2, 0x1FBB0000);
+}
+static void tc3162_pcie_fixup_ra63165(struct pci_dev *dev)
+{
+	uint32 tmp;
+#if defined(TCSUPPORT_BONDING)
+	int i;
+#endif
+
+	/* setup COMMAND register */
+	pci_write_config_word(dev, PCI_COMMAND,
+		(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER));
+
+#if defined(TCSUPPORT_BONDING)
+	//Enable slave RC ECRC count . //bus1, dev1
+	regWrite32(0xbfb80020, 0x1080118);
+	tmp = regRead32(0xbfb80024);
+	regWrite32(0xbfb80024, (tmp | (1<<8)));
+
+	//config PCIe RC/EP VC mapping
+	//set bus0, dev0, fun0, reg154 (setup VC0)
+	regWrite32(0xbfb80020, 0x154);
+	regWrite32(0xbfb80024, 0X80000001);
+	//set bus0, dev0, fun0, reg160 (setup VC1)
+	regWrite32(0xbfb80020, 0x160);
+	regWrite32(0xbfb80024, 0X81000002);
+	//set bus1, dev0, fun0, reg154 (setup VC0)
+	regWrite32(0xbfb80020, 0x1000154);
+	regWrite32(0xbfb80024, 0X80000001);
+	//set bus1, dev0, fun0, reg160 (setup VC1)
+	regWrite32(0xbfb80020, 0x1000160);
+	regWrite32(0xbfb80024, 0X81000002);
+
+	//config slave chip EP MSI
+	regWrite32(0xbfb80020, 0x1000050);
+	tmp = regRead32(0xbfb80024);
+	regWrite32(0xbfb80020, 0x1000050);
+	regWrite32(0xbfb80024, (tmp | 0x510000));
+	regWrite32(0xbfb80020, 0x1000054);
+	regWrite32(0xbfb80024, 0x20af1000);
+	regWrite32(0xbfb80020, 0x100005c);
+	regWrite32(0xbfb80024, 0x0);
+
+	//setup RC0 MSI address reg
+	regWrite32(0xbfb82090, 0x20af1000);
+
+	//setup RC0 Pbus/Rbus VC mapping
+	regWrite32(0xbfb82094, 0x1);
+	regWrite32(0xbfb83094, 0x0);
+
+	//wait RC0 VC1 set up OK
+	for(i=0 ; i<1000 ; i++){
+		mdelay(1);
+		regWrite32(0xbfb80020, 0x164);
+		if((regRead32(0xbfb80024) & (1<<17)) == 0){
+			break;
+		}
+	}
+#endif
+
+	//pci-e interrupt enable_dma
+	if(isRT63365 || isMT751020 || isMT7505){
+#if defined(TCSUPPORT_BONDING)
+		if((regRead32(0xbfb82050) & 0x1) != 0){
+			/* slave dmt */
+			tmp = regRead32(0xbfb8000c);
+			regWrite32(0xbfb8000c, (tmp | (1<<23)));
+			/* slave gdma */
+			tmp = regRead32(0xbfb8000c);
+			regWrite32(0xbfb8000c, (tmp | (1<<25)));
+
+			if(regRead32(0xbfb80050) == 1){
+				/* wifi 0 (slave)*/
+				tmp = regRead32(0xbfb8000c);
+				regWrite32(0xbfb8000c, (tmp | (1<<22)));
+			}
+		}
+#else
+		if((regRead32(0xbfb82050) & 0x1) != 0){
+			tmp = regRead32(0xbfb8000c);
+			regWrite32(0xbfb8000c, (tmp | (1<<20)));
+		}
+#endif
+		//second band
+		if(dual_band_support){
+			if((regRead32(0xbfb83050) & 0x1) != 0){
+				if(isMT751020 || isMT7505){
+					tmp = regRead32(0xbfb8000c);
+					regWrite32(0xbfb8000c, (tmp | (1<<26)));
+				}else{
+					tmp = regRead32(0xbfb8000c);
+					regWrite32(0xbfb8000c, (tmp | (1<<21)));
+				}
+			}
+		}
+	}else{
+		tmp = regRead32(0xbfb8100c);
+		regWrite32(0xbfb8100c, (tmp | (1<<20)));
+	}
+
+	if(isMT751020 || isMT7505){
+		pcie_timeout_disable();
+		aer_config(1);
+	}
+}
+
+#ifndef PCIE_PCI_COEXIT
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+#endif
+
+
+int mt7512_pcie_get_pos(char bus,char dev)
+{
+	unsigned int val,pos;
+
+	val = pcie_read_config_word(0,bus,dev,0x34);
+	pos = val&0xff;
+	while(pos && pos != 0xff)
+	{
+		val = pcie_read_config_word(0,bus,dev,pos);
+		if ( (val&0xff) == 0x10)
+			return pos;
+		pos = (val >> 0x08) & 0xff;
+	}
+	return 0;
+}
+
+int  mt7512_pcie_rc1_retrain(void)
+{
+	unsigned int pos = 0, ppos = 0,bus;
+	unsigned int  linkcap, plinkcap,plinksta;
+
+	ppos = mt7512_pcie_get_pos(0,1);
+	if (mt7512_pcie_is_slave()==1)
+		bus = 1;
+	else
+		bus =  2;
+	
+	pos = mt7512_pcie_get_pos(bus,0);
+	
+	if (pos <0x40 || ppos < 0x40)
+		return 0;
+	
+	plinkcap =  pcie_read_config_word(0,0,1,ppos+0x0c);
+	linkcap = pcie_read_config_word(0,bus,0,pos+0x0c);
+	
+	printk("\n mt7512_pcie_rc1_retrain: %x = %08x %x = %08x",pos,linkcap,ppos,plinkcap);
+	
+	if ((linkcap&0x0f)== 1 || (plinkcap&0x0f)==1)
+		return 0;
+	
+	plinksta = pcie_read_config_word(0,0,1,ppos+0x10);
+	if( ((plinksta>>16)&0x0f) ==  (plinkcap&0x0f))
+		return 0;
+
+	plinksta =  pcie_read_config_word(0,0,1,ppos+0x10);
+	plinksta |= 0x20;
+	pcie_write_config_word(0,0,1,ppos+0x10,plinksta);
+	
+	mdelay(1000); 
+	
+	plinksta =  pcie_read_config_word(0,0,1,ppos+0x10);
+	
+	printk("\nRC1 Link Traing Result: %08x",plinksta);
+	
+	return 1;
+}
+/* Add by Zhao Mengqing, 2016-3-20, copy from mt7512_pcie_rc1_retrain() and modified devnum */
+#ifdef CONFIG_PW_MODEL_PVW42T1200ACGV1
+int  mt7512_pcie_rc0_retrain(void)
+{
+	unsigned int pos = 0, ppos = 0,bus;
+	unsigned int  linkcap, plinkcap,plinksta;
+
+	ppos = mt7512_pcie_get_pos(0,0);//dev 1 -> 0
+	if (mt7512_pcie_is_slave()==1)
+		bus = 1;
+	else
+		bus =  2;
+	
+	pos = mt7512_pcie_get_pos(bus,0);
+	
+	if (pos <0x40 || ppos < 0x40)
+		return 0;
+	
+	plinkcap =  pcie_read_config_word(0,0,0,ppos+0x0c);//devnum 1 -> 0
+	linkcap = pcie_read_config_word(0,bus,0,pos+0x0c);
+	
+	printk("\n mt7512_pcie_rc0_retrain: %x = %08x %x = %08x",pos,linkcap,ppos,plinkcap);
+	
+	if ((linkcap&0x0f)== 1 || (plinkcap&0x0f)==1)
+		return 0;
+	
+	plinksta = pcie_read_config_word(0,0,0,ppos+0x10);//devnum 1 -> 0
+	if( ((plinksta>>16)&0x0f) ==  (plinkcap&0x0f))
+		return 0;
+
+	plinksta =  pcie_read_config_word(0,0,0,ppos+0x10);//devnum 1 -> 0
+	plinksta |= 0x20;
+	pcie_write_config_word(0,0,1,ppos+0x10,plinksta);
+	
+	mdelay(1000); 
+	
+	plinksta =  pcie_read_config_word(0,0,0,ppos+0x10);//devnum 1 -> 0
+	
+	printk("\nRC0 Link Traing Result: %08x",plinksta);
+	
+	return 1;
+}
+#endif
+/* End add */
+
+void mt7512_pcie_fixup(void)
+{
+	unsigned int val = 0,tmp = 0 ,i = 0;
+	
+	if (isRC0_LINKUP)
+	{
+	
+		val =  pcie_read_config_word(0,0,0,0x20);
+		tmp = ((val&0xffff)<<16);
+		val = (val&0xffff0000) + 0x100000;
+		val = val - tmp;
+		i = 0;
+		while(i < 32)
+		{
+			if((1<<i) >= val)
+				break;
+			i++;
+		}
+		regWrite32(0xbfb81438,tmp | i);   //config RC0 to EP Addr window
+		mdelay(1);
+		regWrite32(0xbfb81448,0x80);     //enable EP to RC0 access
+		printk("\n mt7512_pcie_fixup: 0x1438 = %x ",tmp | i);
+	}
+	
+	if (isRC1_LINKUP)
+	{
+	
+		val =  pcie_read_config_word(0,0,1,0x20);
+		tmp = ((val&0xffff)<<16);
+		val = (val&0xffff0000) + 0x100000;
+		val = val - tmp;
+		i = 0;
+		while(i < 32)
+		{
+			if((1<<i) >= val)
+				break;
+			i++;
+		}
+		regWrite32(0xbfb83438,tmp | i);   //config RC1 to EP Addr window
+		mdelay(1);
+		regWrite32(0xbfb83448,0x80);     //enable EP to RC1 access
+		printk("\n mt7512_pcie_fixup: 0x3438 = %x ",tmp | i);
+		
+		mt7512_pcie_rc1_retrain();
+		
+	}
+
+	return ;
+}
+
+EXPORT_SYMBOL(mt7512_pcie_fixup);
+
+
+
+void mt7512_pcie_fixup_rc0(struct pci_dev *dev)
+{
+
+	unsigned int val = 0,tmp = 0 ,i = 0;
+
+	if (isRC0_LINKUP)
+	{
+		val =  pcie_read_config_word(0,0,0,0x20);
+		tmp = ((val&0xffff)<<16);
+		val = (val&0xffff0000) + 0x100000;
+		val = val - tmp;
+		i = 0;
+		
+		while(i < 32)
+		{
+			if((1<<i) >= val)
+				break;
+			i++;
+		}
+		
+		/* config RC1 to EP Addr window */	
+		regWrite32(0xbfb81438,tmp | i);  
+		mdelay(1);
+
+	 	/* enable EP to RC1 access */	
+		regWrite32(0xbfb81448,0x80);	
+		printk("\n mt7512_pcie_fixup: 0x1438 = %x ",tmp | i);
+
+//Add by Zhao Mengqing, 2016-5-31 */
+#ifdef CONFIG_PW_MODEL_PVW42T1200ACGV1
+		mt7512_pcie_rc0_retrain();
+#endif
+/* End add */
+	}
+	return;
+}
+
+
+void mt7512_pcie_fixup_rc1(struct pci_dev *dev)
+{
+
+	unsigned int val = 0,tmp = 0 ,i = 0;
+
+
+	if (isRC1_LINKUP)
+	{
+		val =  pcie_read_config_word(0,0,1,0x20);
+		tmp = ((val&0xffff)<<16);
+		val = (val&0xffff0000) + 0x100000;
+		val = val - tmp;
+		i = 0;
+		while(i < 32)
+		{
+			if((1<<i) >= val)
+				break;
+			i++;
+		}
+		
+		/* config RC1 to EP Addr window */
+		regWrite32(0xbfb83438,tmp | i);   
+		mdelay(1);
+
+	 	/* enable EP to RC1 access */
+		regWrite32(0xbfb83448,0x80);	
+		printk("\n mt7512_pcie_fixup: 0x3438 = %x ",tmp | i);
+
+/* Modified by Zhao Mengqing, 2016-5-31 */
+#ifndef CONFIG_PW_MODEL_PVW42T1200ACGV1
+		mt7512_pcie_rc1_retrain();
+#endif
+	}
+	return;
+	
+}
+
+
+
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SIS, PCI_DEVICE_ID_SIS,
+          tc3162_pcie_fixup);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_RT, PCI_DEVICE_ID_RT,
+          tc3162_pcie_fixup_ra63165);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_MTK, PCI_DEVICE_ID_MTK,
+		tc3162_pcie_fixup_ra63165);
+
+DECLARE_PCI_FIXUP_FINAL(0x14c3,0x0810,mt7512_pcie_fixup_rc0);
+DECLARE_PCI_FIXUP_FINAL(0x14c3,0x0811,mt7512_pcie_fixup_rc1);
+
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/pci/Makefile vr300-linux/arch/mips/pci/Makefile
--- linux-2.6.36/arch/mips/pci/Makefile	2010-10-20 23:30:22.000000000 +0300
+++ vr300-linux/arch/mips/pci/Makefile	2019-03-07 03:40:15.000000000 +0200
@@ -19,6 +19,18 @@
 obj-$(CONFIG_BCM63XX)		+= pci-bcm63xx.o fixup-bcm63xx.o \
 					ops-bcm63xx.o
 
+obj-$(CONFIG_MIPS_TC3162)	+= ops-tc3162.o pci-tc3162.o fixup-tc3162.o
+ifdef CONFIG_MIPS_TC3262 
+EXTRA_CFLAGS += -DPCIE_PCI_COEXIT
+endif
+obj-$(CONFIG_MIPS_TC3262)	+= ops-tc3162u.o pci-tc3162u.o fixup-tc3162u.o pcie-phy.o
+obj-$(CONFIG_MIPS_TC3262)       += ops-tc3162.o pci-tc3162.o fixup-tc3162.o pci-7512api.o
+ifdef CONFIG_MIPS_TC3162U
+EXTRA_CFLAGS += -DPCIE_PCI_COEXIT
+endif
+obj-$(CONFIG_MIPS_TC3162U)	+= ops-tc3162u.o pci-tc3162u.o fixup-tc3162u.o pcie-phy.o
+obj-$(CONFIG_MIPS_TC3162U)	+= ops-tc3162.o pci-tc3162.o fixup-tc3162.o
+
 #
 # These are still pretty much in the old state, watch, go blind.
 #
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/pci/ops-tc3162.c vr300-linux/arch/mips/pci/ops-tc3162.c
--- linux-2.6.36/arch/mips/pci/ops-tc3162.c	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/pci/ops-tc3162.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,136 @@
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/addrspace.h>
+#include <asm/tc3162/tc3162.h>
+
+#define PCI_CONFIG_ADDR		0x1fb80cf8
+#define PCI_CONFIG_DATA		0x1fb80cfc
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(f, a...)	printk(f, ## a )
+#else
+#define DBG(f, a...)	do {} while (0)
+#endif
+
+#define PCI_ENABLE 0x80000000
+
+static spinlock_t pci_lock = SPIN_LOCK_UNLOCKED;
+
+/* -------------------------------------------------------------------------*/
+
+static inline void write_cfgaddr(u32 addr)
+{
+	__raw_writel((addr | PCI_ENABLE),
+		(void __iomem *)(KSEG1ADDR(PCI_CONFIG_ADDR)));
+}
+
+static inline void write_cfgdata(u32 data)
+{
+	__raw_writel(data, (void __iomem *)KSEG1ADDR(PCI_CONFIG_DATA));
+}
+
+static inline u32 read_cfgdata(void)
+{
+	return __raw_readl((void __iomem *)KSEG1ADDR(PCI_CONFIG_DATA));
+}
+
+static inline u32 mkaddr(struct pci_bus *bus, unsigned int devfn, int where)
+{
+#ifndef PCIE_PCI_COEXIT
+	return (((bus->number & 0xFF) << 16) | ((devfn & 0xFF) << 8) | \
+		(where & 0xFC));
+#else
+	return (((bus->number & 0) << 16) | ((devfn & 0xFF) << 8) | \
+		(where & 0xFC));
+#endif
+}
+
+/* -------------------------------------------------------------------------*/
+
+static int tc3162_pcibios_read(struct pci_bus *bus, unsigned int devfn, int where,
+		int size, u32 *val)
+{
+	unsigned long flags;
+	u32 data;
+
+	spin_lock_irqsave(&pci_lock, flags);
+
+	write_cfgaddr(mkaddr(bus,devfn,where));
+	data = read_cfgdata();
+
+	DBG("PCI: cfg_read  %02u.%02u.%01u/%02X:%01d, cfg:0x%08X",
+		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, size, data);
+
+	switch (size) {
+	case 1:
+		if (where & 1)
+			data >>= 8;
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFF;
+		break;
+	case 2:
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFFFF;
+		break;
+	}
+
+	*val = data;
+	DBG(", 0x%08X returned\n", data);
+
+	spin_unlock_irqrestore(&pci_lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int tc3162_pcibios_write(struct pci_bus *bus, unsigned int devfn, int where,
+		int size, u32 val)
+{
+	unsigned long flags;
+	u32 data;
+	int s;
+
+	spin_lock_irqsave(&pci_lock, flags);
+
+	write_cfgaddr(mkaddr(bus,devfn,where));
+	data = read_cfgdata();
+
+	DBG("PCI: cfg_write %02u.%02u.%01u/%02X:%01d, cfg:0x%08X",
+		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, size, data);
+
+	switch (size) {
+	case 1:
+		s = ((where & 3) << 3);
+		data &= ~(0xFF << s);
+		data |= ((val & 0xFF) << s);
+		break;
+	case 2:
+		s = ((where & 2) << 4);
+		data &= ~(0xFFFF << s);
+		data |= ((val & 0xFFFF) << s);
+		break;
+	case 4:
+		data = val;
+		break;
+	}
+
+	write_cfgdata(data);
+	DBG(", 0x%08X written\n", data);
+
+	spin_unlock_irqrestore(&pci_lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops tc3162_pci_ops = {
+    .read   = tc3162_pcibios_read,
+    .write  = tc3162_pcibios_write
+};
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/pci/ops-tc3162u.c vr300-linux/arch/mips/pci/ops-tc3162u.c
--- linux-2.6.36/arch/mips/pci/ops-tc3162u.c	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/pci/ops-tc3162u.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,230 @@
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/addrspace.h>
+#include <asm/tc3162/tc3162.h>
+
+uint32 pcie_config_addr = 0x1fb81cf8;
+uint32 pcie_config_data = 0x1fb81cfc;
+
+#undef DEBUG
+
+//#define DEBUG
+#ifdef DEBUG
+#define DBG(f, a...)	printk(f, ## a )
+#else
+#define DBG(f, a...)	do {} while (0)
+#endif
+
+#define PCIE_ENABLE 0x80000000
+
+spinlock_t pcie_lock = SPIN_LOCK_UNLOCKED;
+
+/* -------------------------------------------------------------------------*/
+
+static inline void write_cfgaddr(u32 addr)
+{
+	__raw_writel(addr,
+			(void __iomem *)(KSEG1ADDR(pcie_config_addr)));
+//	__raw_writel((addr | PCI_ENABLE),
+//		(void __iomem *)(KSEG1ADDR(PCI_CONFIG_ADDR)));
+}
+
+static inline void write_cfgdata(u32 data)
+{
+	__raw_writel(data, (void __iomem *)KSEG1ADDR(pcie_config_data));
+}
+
+static inline u32 read_cfgdata(void)
+{
+	u32 tmp;
+
+	if(isRT63365)
+		 tmp = __raw_readl((void __iomem *)KSEG1ADDR(pcie_config_data));
+
+	return __raw_readl((void __iomem *)KSEG1ADDR(pcie_config_data));
+}
+
+static inline u32 mkaddr(struct pci_bus *bus, unsigned int devfn, int where)
+{
+	u32 type;
+
+	if(isRT63165 || isRT63365 || isMT751020 || isMT7505 || isEN751221){
+		return	(((bus->number & 0xFF) << 24) | ((devfn & 0xFF) << 16) |\
+				(where & 0xFFC));
+	}else{
+		type=(bus->number & 0xFF)?PCIE_ENABLE:0;
+
+		return (type | ((bus->number & 0xFF) << 20) | ((devfn & 0xFF) << 12) | \
+			(where & 0xFFC));
+	}
+}
+
+/* -------------------------------------------------------------------------*/
+extern unsigned long int pcie_read_config_word_extend(unsigned char bus,unsigned char dev,unsigned char func,unsigned int reg);
+extern int pcie_write_config_word_extend(unsigned char bus, unsigned char dev,unsigned char func, unsigned int reg, unsigned long int value);
+
+static int mt7512_pciebios_read(struct pci_bus *bus, unsigned int devfn, int where,int size, u32 *val)
+{
+	unsigned long flags;
+	u32 data,addr;
+	
+/*	spin_lock_irqsave(&pcie_lock, flags);*/
+
+	addr = mkaddr(bus,devfn,where);
+	data = pcie_read_config_word_extend((addr>>24)&0xff,(addr>>19)&0x1f,(addr>>16)&0x7,addr&0xffc);
+	
+/*	printk("\n pcie_read: bus = %d, dev = %d func = %d, reg = %x, val = %x",(addr>>24)&0xff,(addr>>19)&0x1f,(addr>>16)&0x7,addr&0xffc,data); */
+
+	switch (size) {
+	case 1:
+		if (where & 1)
+			data >>= 8;
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFF;
+		break;
+	case 2:
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFFFF;
+		break;
+	}
+	*val = data;
+/*	spin_unlock_irqrestore(&pcie_lock, flags);*/
+	
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+static int mt7512_pciebios_write(struct pci_bus *bus, unsigned int devfn, int where,int size, u32 val)
+{
+	unsigned long flags;
+	u32 data,addr;
+	int s;
+
+
+	addr= mkaddr(bus,devfn,where);
+	data = pcie_read_config_word_extend((addr>>24)&0xff,(addr>>19)&0x1f,(addr>>16)&0x7,addr&0xffc);
+
+	switch (size) {
+	case 1:
+		s = ((where & 3) << 3);
+		data &= ~(0xFF << s);
+		data |= ((val & 0xFF) << s);
+		break;
+	case 2:
+		s = ((where & 2) << 3);
+		data &= ~(0xFFFF << s);
+		data |= ((val & 0xFFFF) << s);
+		break;
+	case 4:
+		data = val;
+		break;
+	}
+/*	printk("\n pcie_write: bus = %d, dev = %d func = %d, reg = %x, val = %x",(addr>>24)&0xff,(addr>>19)&0x1f,(addr>>16)&0x7,addr&0xffc,data);*/
+	
+	pcie_write_config_word_extend((addr>>24)&0xff,(addr>>19)&0x1f,(addr>>16)&0x7,addr&0xffc,data);
+	return PCIBIOS_SUCCESSFUL;
+
+
+}
+
+static int tc3162_pciebios_read(struct pci_bus *bus, unsigned int devfn, int where,
+		int size, u32 *val)
+{
+	unsigned long flags;
+	u32 data;
+
+	spin_lock_irqsave(&pcie_lock, flags);
+
+	if(isRT63165){
+		if((devfn & 0xFF) != 0){
+			*val = 0xffffffff;
+			spin_unlock_irqrestore(&pcie_lock, flags);
+			return PCIBIOS_SUCCESSFUL;
+		}
+	}
+
+	write_cfgaddr(mkaddr(bus,devfn,where));
+	data = read_cfgdata();
+
+	DBG("PCIE: cfg_read  %02u.%02u.%01u/%02X:%01d, cfg:0x%08X",
+		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, size, data);
+
+	switch (size) {
+	case 1:
+		if (where & 1)
+			data >>= 8;
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFF;
+		break;
+	case 2:
+		if (where & 2)
+			data >>= 16;
+		data &= 0xFFFF;
+		break;
+	}
+
+	*val = data;
+	DBG(", 0x%08X returned\n", data);
+
+	spin_unlock_irqrestore(&pcie_lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int tc3162_pciebios_write(struct pci_bus *bus, unsigned int devfn, int where,
+		int size, u32 val)
+{
+	unsigned long flags;
+	u32 data;
+	int s;
+
+	spin_lock_irqsave(&pcie_lock, flags);
+
+	write_cfgaddr(mkaddr(bus,devfn,where));
+	data = read_cfgdata();
+
+	DBG("PCIE: cfg_write %02u.%02u.%01u/%02X:%01d,%08x, cfg:0x%08X",
+		bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn),
+		where, size, val, data);
+
+	switch (size) {
+	case 1:
+		s = ((where & 3) << 3);
+		data &= ~(0xFF << s);
+		data |= ((val & 0xFF) << s);
+		break;
+	case 2:
+		//s = ((where & 2) << 4);
+		s = ((where & 2) << 3);//krammer try
+		data &= ~(0xFFFF << s);
+		data |= ((val & 0xFFFF) << s);
+		break;
+	case 4:
+		data = val;
+		break;
+	}
+
+	write_cfgdata(data);
+	DBG(", 0x%08X written\n", data);
+
+	spin_unlock_irqrestore(&pcie_lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops mt7512_pcie_ops = {
+    .read   = mt7512_pciebios_read,
+    .write  = mt7512_pciebios_write
+};
+
+struct pci_ops tc3162_pcie_ops = {
+    .read   = tc3162_pciebios_read,
+    .write  = tc3162_pciebios_write
+};
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/pci/pcie-phy.c vr300-linux/arch/mips/pci/pcie-phy.c
--- linux-2.6.36/arch/mips/pci/pcie-phy.c	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/pci/pcie-phy.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,426 @@
+#include <asm/tc3162/tc3162.h>
+#include <linux/delay.h>
+
+//#define PCIE_PHY_DEBUG 1
+
+#define ENABLE 1
+#define DISABLE 0
+
+#if defined(TCSUPPORT_BONDING)
+extern unsigned long slaveVirBaseAddr;
+#endif
+
+
+#if 0 //for FPGA auto scan timing
+#define PCIe_AUTO_SCAN_TIMING 1
+#define PCIE_7510_FPGA_TIMING_PHY_P0 12
+#define PCIE_7510_FPGA_TIMING_PHY_P1 13
+#define PHY_PORT0 0
+#define PHY_PORT1 1
+
+static int  pcie_reset_link(check_addr)
+{
+	int i;
+	uint32 tmp;
+	//PCI-E reset
+	/* enabled PCIe port 1 */
+	VPint(0xbfb00088) |= (1<<22);
+	mdelay(1);
+	/*first reset to default*/
+	VPint(0xbfb00834) &= ~((1<<26) | (1<<27) | (1<<29));
+	mdelay(1);
+	VPint(0xbfb00834) |= ((1<<26) | (1<<27) | (1<<29));
+	mdelay(1);
+	VPint(0xbfb00834) &= ~((1<<26) | (1<<27) | (1<<29));
+	mdelay(1);
+
+	//relese pcie device reset
+	VPint(0xbfb80000) &= ~((1<<1) | (1<<2));
+	mdelay(1);
+
+	//start to check pcie if link up
+	//wait device link up
+	for(i=1 ; i<601 ; i++){
+		mdelay(1);
+		if((VPint(check_addr) & 0x1) != 0){
+			break;
+		}   
+		if((i%100)==0){//reset device PCIe MAC if not link up every 100ms biker_20120816
+			//pcie reset again
+			VPint(0xbfb80000) |= ((1<<1) | (1<<2));
+			mdelay(1);
+
+			VPint(0xbfb80000) &= ~((1<<1) | (1<<2));
+			mdelay(1);
+		}
+	}
+	if(i == 601)
+		return -1;
+	else
+		return 0;
+
+}
+#endif
+
+void pcie_phy_force_mode_en(char enable, char rc_num){
+
+	if(isFPGA)
+		return;
+
+	//printk("pcie_phy_force_mode_en %x %x \n",enable,rc_num);
+	if(enable == ENABLE) //means disable
+	{
+		switch (rc_num){
+			case 0:
+				regWrite32(0xbfaf202c, 0x1010);
+				regWrite32(0xbfaf202c, 0x1090);
+				regWrite32(0xbfaf202c, 0x1010);
+				break;
+			case 1:
+				regWrite32(0xbfaf212c, 0x1010);
+				regWrite32(0xbfaf212c, 0x1090);
+				regWrite32(0xbfaf212c, 0x1010);
+				break;
+#if defined(TCSUPPORT_BONDING)
+
+			case 2: //external chip use for bonding
+				if(slaveVirBaseAddr != 0){
+					regWrite32(slaveVirBaseAddr + 0xaf202c, 0x1010); 
+					regWrite32(slaveVirBaseAddr + 0xaf202c, 0x1090);
+					regWrite32(slaveVirBaseAddr + 0xaf202c, 0x1010);
+					
+					regWrite32(slaveVirBaseAddr + 0xaf212c, 0x1010); 
+					regWrite32(slaveVirBaseAddr + 0xaf212c, 0x1090);
+					regWrite32(slaveVirBaseAddr + 0xaf212c, 0x1010);
+				}	
+				break;
+#endif
+			default:
+				printk("RC number %d Error !! \n",rc_num);
+				break;
+		}
+		
+	}
+	else
+	{
+		switch (rc_num){
+			case 0:
+				regWrite32(0xbfaf202c, 0x0);
+				regWrite32(0xbfaf202c, 0x80);
+				regWrite32(0xbfaf202c, 0x0);
+				break;
+			case 1:
+				regWrite32(0xbfaf212c, 0x0);
+				regWrite32(0xbfaf212c, 0x80);
+				regWrite32(0xbfaf212c, 0x0);
+				break;
+#if defined(TCSUPPORT_BONDING)
+
+			case 2: //external
+				if(slaveVirBaseAddr != 0){
+					regWrite32(slaveVirBaseAddr + 0xaf202c, 0x0); 
+					regWrite32(slaveVirBaseAddr + 0xaf202c, 0x80);
+					regWrite32(slaveVirBaseAddr + 0xaf202c, 0x0);
+					
+					regWrite32(slaveVirBaseAddr + 0xaf212c, 0x0); 
+					regWrite32(slaveVirBaseAddr + 0xaf212c, 0x80);
+					regWrite32(slaveVirBaseAddr + 0xaf212c, 0x0);
+				}
+				break;
+#endif
+			default:
+				printk("RC number %d Error !! \n",rc_num);
+				break;
+		}
+	}
+}
+ void init_60901(void)
+{
+	uint32 tmp;
+	#ifdef PCIE_PHY_DEBUG
+	printk("biker1_pcie_phy_init debug message: master init \n");
+	printk("debug: read address 0xbfaf24a0 (380389); value is: %lx\n",VPint(0xbfaf24a0));
+	printk("debug: read address 0xbfaf24a8 (E80E8); value is: %lx\n",VPint(0xbfaf24a8));
+	#endif
+	//init Master
+	//init 20MHz or 25MHz
+	tmp = (regRead32(0xbfb0008c)&(0x3 <<22))>>22;
+	if (tmp == 0x1 ) 
+	{
+		//xtal is 20MHz 
+		#ifdef PCIE_PHY_DEBUG
+		printk("xtal is 20MHz \n");
+		#endif
+
+		//I2C      70    0xA8[11:00]   0x74      RW      RG_PE1_H_LCDDS_SSC_DELTA        //Improve SSC deviation	
+		//tmp = regRead32(0xbfaf24a8);
+		regWrite32(0xbfaf24a8, 0x740074);
+		//VPint(0xbfaf24a8) = (VPint(0xbfaf24a8) & (~0xfff )) | (0x74);
+		mdelay(1);	
+		//I2C      70    0xA8[23:16]   0x74      RW      RG_PE1_H_LCDDS_SSC_DELTA1       //Improve SSC deviation	
+		//VPint(0xbfaf24a8) =  (VPint(0xbfaf24a8) & (~(0xfff <<16))) | (0x74<<16);
+		//I2C      70    0xA0[19:19]   0x00      RW      RG_PE1_H_LCDDS_SSC_EN           //Disable SSC	
+		tmp = regRead32(0xbfaf24a0);
+		regWrite32(0xbfaf24a0, tmp & (~(0x1 <<19)) );
+		//VPint(0xbfaf24a0) =  VPint(0xbfaf24a0) & (~(0x1 <<19)) ;
+		mdelay(1);	
+		//I2C      70    0xA0[19:19]   0x01      RW      RG_PE1_H_LCDDS_SSC_EN           //Enable SSC	
+		tmp = regRead32(0xbfaf24a0);
+		regWrite32(0xbfaf24a0, tmp | (0x1<<19) );
+		//VPint(0xbfaf24a0) =  VPint(0xbfaf24a0)  | (0x1<<19);
+		mdelay(1);
+	}else if(tmp == 0x0 )
+	{   
+		//xtal is 25MHz 
+		#ifdef PCIE_PHY_DEBUG
+		printk("xtal is 25MHz \n");
+		#endif
+//	I2C      70    0xFC[31:24]   0x00      RW                                      //Change bank address to 0x00
+//	I2C      70    0x00[04:04]   0x01      RW      rg_pe1_frc_phy_en               //Force Port 0 disable control
+		regWrite32(0xbfaf2000,  (regRead32(0xbfaf2000) &(~(0x1 <<4)) ) | (0x1<<4) );
+		mdelay(1);
+//	I2C      70    0xFC[31:24]   0x01      RW                                      //Change bank address to 0x01
+//	I2C      70    0x00[04:04]   0x01      RW      rg_pe1_frc_phy_en               //Force Port 1 disable control
+		regWrite32(0xbfaf2100,  (regRead32(0xbfaf2100) &(~(0x1 <<4)) ) | (0x1<<4) );
+		mdelay(1);
+
+//	I2C      70    0xFC[31:24]   0x00      RW                                      //Change bank address to 0x00
+//	I2C      70    0x00[05:05]   0x00      RW      rg_pe1_phy_en                   //Port 0 disable
+		regWrite32(0xbfaf2000,  (regRead32(0xbfaf2000) &(~(0x1 <<5)) )  );
+		mdelay(1);
+
+//	I2C      70    0xFC[31:24]   0x01      RW                                      //Change bank address to 0x01
+//	I2C      70    0x00[05:05]   0x00      RW      rg_pe1_phy_en                   //Port 1 disable
+		regWrite32(0xbfaf2100,  (regRead32(0xbfaf2100) &(~(0x1 <<5)) ) );
+		mdelay(1);
+
+//	I2C      70    0xFC[31:24]   0x04      RW                                      //Change bank address to 0x04
+//	I2C      70    0x00[08:08]   0x01      RW      rg_pe1_frc_h_xtal_type          //
+		regWrite32(0xbfaf2400,  (regRead32(0xbfaf2400) &(~(0x1 <<8)) ) | (0x1<<8) );
+		mdelay(1);
+
+//	I2C      70    0x00[10:09]   0x00      RW      rg_pe1_h_xtal_type              //
+		regWrite32(0xbfaf2400,  (regRead32(0xbfaf2400) &(~(0x3 <<9)) )  );
+		mdelay(1);
+
+//	I2C      70    0x90[15:12]   0x0A      RW      RG_PE1_H_PLL_IR                 //
+		regWrite32(0xbfaf2490,  (regRead32(0xbfaf2490) &(~(0xf <<12)) ) | (0xA<<12) );
+		mdelay(1);
+
+//	I2C      70    0xAC[18:16]   0x01      RW      RG_PE1_H_PLL_BR                 //
+		regWrite32(0xbfaf24AC,  (regRead32(0xbfaf24AC) &(~(0x7 <<16)) ) | (0x1<<16) );
+		mdelay(1);
+		
+//	I2C      70    0x9C[30:16]   0x1900    RW      RG_PE1_H_LCDDS_PCW_NCPO         //
+		regWrite32(0xbfaf249C,  (regRead32(0xbfaf249C) &(~(0x7fff <<16)) ) | (0x1900<<16) );
+		mdelay(1);
+		
+//	I2C      70    0x9C[31:31]   0x00      RW      RG_PE1_H_LCDDS_PCW_NCPO_CHG     //
+		regWrite32(0xbfaf249C,  (regRead32(0xbfaf249C) &(~(0x1 <<31)) ) );
+		mdelay(1);
+
+//	I2C      70    0x9C[31:31]   0x01      RW      RG_PE1_H_LCDDS_PCW_NCPO_CHG     //
+		regWrite32(0xbfaf249C,  regRead32(0xbfaf249C)  | (0x1<<31) );
+		mdelay(1);
+
+//	I2C      70    0xA4[15:00]   0x018D    RW      RG_PE1_H_LCDDS_SSC_PRD          //
+		regWrite32(0xbfaf24A4,  (regRead32(0xbfaf24A4) &(~(0xffff )) ) | (0x18D) );
+		mdelay(1);
+
+//	I2C      70    0xA8[11:00]   0x004A    RW      RG_PE1_H_LCDDS_SSC_DELTA        //
+		regWrite32(0xbfaf24A8,  (regRead32(0xbfaf24A8) &(~(0xfff )) ) | (0x4A) );
+		mdelay(1);
+
+//	I2C      70    0xA8[27:16]   0x004A    RW      RG_PE1_H_LCDDS_SSC_DELTA1       //
+		regWrite32(0xbfaf24A8,  (regRead32(0xbfaf24A8) &(~(0xfff <<16)) ) | (0x4A<<16) );
+		mdelay(1);
+
+//	I2C      70    0x00[12:12]   0x01      RW      rg_pe1_mstck_25m                //value of mstck_25m when force mode enable
+		regWrite32(0xbfaf2400,  (regRead32(0xbfaf2400)  ) | (0x1<<12) );
+		mdelay(1);
+
+//	I2C      70    0x00[11:11]   0x01      RW      rg_pe1_frc_mstck_25m            //force mode enable of mstck_25m
+		regWrite32(0xbfaf2400,  (regRead32(0xbfaf2400)  ) | (0x1<<11) );
+		mdelay(1);
+
+//	I2C      70    0xFC[31:24]   0x00      RW                                      //Change bank address to 0x00
+//	I2C      70    0x00[05:05]   0x01      RW      rg_pe1_phy_en                   //Port 0 enable
+		regWrite32(0xbfaf2000,  (regRead32(0xbfaf2000) |(0x1 <<5) )  );
+		mdelay(1);
+//	I2C      70    0xFC[31:24]   0x01      RW                                      //Change bank address to 0x01
+//	I2C      70    0x00[05:05]   0x01      RW      rg_pe1_phy_en                   //Port 1 enable
+		regWrite32(0xbfaf2100,  (regRead32(0xbfaf2100) |(0x1 <<5) ));
+		mdelay(1);
+
+//	I2C      70    0xFC[31:24]   0x00      RW                                      //Change bank address to 0x00
+//	I2C      70    0x00[04:04]   0x00      RW      rg_pe1_frc_phy_en               //Force Port 0 disable control
+		//regWrite32(0xbfaf2000,  (regRead32(0xbfaf2000) &(~(0x1 <<4)) ));
+		//mdelay(1);
+
+//	I2C      70    0xFC[31:24]   0x01      RW                                      //Change bank address to 0x01
+//	I2C      70    0x00[04:04]   0x00      RW      rg_pe1_frc_phy_en               //Force Port 1 disable control
+		//regWrite32(0xbfaf2100,  (regRead32(0xbfaf2100) &(~(0x1 <<4)) ));
+		//mdelay(1);
+
+//	I2C      70    0xFC[31:24]   0x00      RW                                      //Change bank address to 0x00
+
+	}
+	#ifdef PCIE_PHY_DEBUG
+	printk("pcie_phy_init debug message:\n");
+	printk("debug: read address 0xbfaf24a0 (380389); value is: %lx\n",VPint(0xbfaf24a0));
+	printk("debug: read address 0xbfaf24a8 (740074); value is: %lx\n",VPint(0xbfaf24a8));
+	#endif
+	
+	//init Slave
+	
+}
+
+#if 0 //for FPGA auto scan timing
+uint8 pcie_60901_auto_scan(uint8 PHY_PORT, uint8 win_range, uint8 win_loop, uint32 check_addr)
+{
+	uint8 win_init = 0;
+	uint8 win_start = 0;	
+	uint8 win_len = 0; 	
+	uint8 max_win_start = 0;	
+	uint8 max_win_len = 0; 	
+	uint8 i = 0;
+	uint8 timing = 0;
+
+	printk(">>>>>Start to scan PCIe timing setting<<<<<\n");
+		for (i=win_init; i<win_range; i++){
+			if (PHY_PORT == PHY_PORT0)
+				init_60901((uint32) (i%win_loop),0);
+			else
+				init_60901(0,(uint32) (i%win_loop));
+			//printk("timing setting: %2d ",i);
+			if (pcie_reset_link(check_addr) == 0){
+				win_len++;				
+				if(win_len > max_win_len){					
+					max_win_len = win_len;					
+					max_win_start = win_start;				
+				}				
+				printk("Link up! \n");		
+			}else{				
+			win_len = 0;				
+			win_start = i + 1;				
+			printk("Not link \n");			
+			}		
+		}		
+		timing = (uint8) ((max_win_start%win_loop) + ((max_win_len%win_loop)>>1));
+		printk("The pcie timing window start at : %d \n",max_win_start);		
+		printk("Window length is : %d \n",max_win_len);		
+		printk("The chosen PCIe: %d \n ",timing);
+		return timing;
+}
+#endif
+
+ void init_7505(void)
+{
+	//For WCN ch14 de-sence issue, default Disable SSC, bit 28 => 1
+	printk("Disable PCIe SSC\n");
+	regWrite32(0xbfaf2414,  (regRead32(0xbfaf2414) |(0x1 <<28) ));
+	
+	//change MSTSET from 1 to 5;
+	mdelay(1);
+	regWrite32(0xbfaf2498,  ((regRead32(0xbfaf2498) &(~0xff) )|(0x5) ));
+
+	//decrease PLL BW to improve jitter; by biker_20140721; add 25MHz_20140815
+	mdelay(1);
+	regWrite32(0xbfaf2400,  ((regRead32(0xbfaf2400) &(~(0x1<<8)) )|(0x1<<8) ));
+	mdelay(1);
+	regWrite32(0xbfaf2400,  ((regRead32(0xbfaf2400) &(~(0x3<<9)) )|(0x0<<9) ));
+	mdelay(1);
+	regWrite32(0xbfaf2000,  ((regRead32(0xbfaf2000) &(~(0x1<<4)) )|(0x1<<4) ));
+	mdelay(1);
+	regWrite32(0xbfaf2000,  ((regRead32(0xbfaf2000) &(~(0x1<<5)) )|(0x0<<5) ));
+	mdelay(1);
+	regWrite32(0xbfaf24ac,  ((regRead32(0xbfaf24ac) &(~(0x7<<16)) )|(0x3<<16) ));
+	mdelay(1);
+	regWrite32(0xbfaf24bc,  ((regRead32(0xbfaf24bc) &(~(0xff<<24)) )|(0x64<<24) ));
+	mdelay(1);
+	regWrite32(0xbfaf2490,  ((regRead32(0xbfaf2490) &(~(0xf<<12)) )|(0xa<<12) ));
+	mdelay(1);
+	regWrite32(0xbfaf2490,  ((regRead32(0xbfaf2490) &(~(0x3<<6)) )|(0x0<<6) ));
+	mdelay(1);
+	regWrite32(0xbfaf24c0,  ((regRead32(0xbfaf24c0) &(~(0xffffffff<<0)) )|(0x19000000<<0) ));
+	mdelay(1);
+	regWrite32(0xbfaf24a4,  ((regRead32(0xbfaf24a4) &(~(0xffff<<0)) )|(0x18d<<0) ));
+	mdelay(1);
+	regWrite32(0xbfaf24a8,  ((regRead32(0xbfaf24a8) &(~(0xfff<<0)) )|(0x4a<<0) ));
+	mdelay(1);
+	regWrite32(0xbfaf24a8,  ((regRead32(0xbfaf24a8) &(~(0xfff<<16)) )|(0x4a<<16) ));
+	mdelay(1);
+	regWrite32(0xbfaf2000,  ((regRead32(0xbfaf2000) &(~(0x1<<5)) )|(0x1<<5) ));
+	mdelay(1);
+	regWrite32(0xbfaf2000,  ((regRead32(0xbfaf2000) &(~(0x1<<4)) )|(0x0<<4) ));
+	mdelay(1);
+
+
+	/*MT7505 input crystall is 40Mhz*/
+	//Fix frequence setting bug when hardware trap is 40MHz XTAL ; 
+#if 0	//Already done in bootloader
+	if(VPint(CR_AHB_HWCONF)&(1<<1)){
+	VPint(0xbfaf2400) = (VPint(0xbfaf2400) | 0x100); /*force mode enable xtal type*/
+	}
+#endif
+		
+}
+void init_7512(void)
+{
+/* By Zhao Mengqing, 2016-7-4, 单频机型则关闭RC1接口，仅使用RC0接口，以降低功耗和温度 */
+#if defined(CONFIG_PW_MODEL_PVW41T300NV2) || defined(CONFIG_PW_MODEL_W9960V1) || defined(CONFIG_PW_MODEL_W9960V1_20)
+	printk("PCIe driver version:751221.2.2016.0429\n");
+	
+	//LCDDS_CLK_PH_INV
+	regWrite32(0xbfaf24a0, ((regRead32(0xbfaf24a0) & (~(0x1<<5))) | (0x1<<5) ));
+	mdelay(1);
+	
+	if (isEN751221)
+	{
+		//7512 is QFP IC, use gen1 prot only, disable gen2 port for COC test
+		regWrite32(0xbfac030c, (regRead32(0xbfac030c) | (0x1 << 31))); //PHY IP_SW_RESET
+		mdelay(1);
+	}
+#else
+	regWrite32(0xbfaf24a0, 0x3813e9);
+	mdelay(1);
+#endif
+}
+
+int pciePhyInit(void){
+
+#if 0	//for FPGA auto scan timing	
+#ifdef PCIe_AUTO_SCAN_TIMING
+		timing_p0 = pcie_60901_auto_scan(PHY_PORT0,36,18,0xbfb83050);
+		timing_p1 = pcie_60901_auto_scan(PHY_PORT1,36,18,0xbfb82050);
+#endif
+#endif
+
+	if(isEN751221) {
+		
+		if (!isFPGA) {
+			init_7512();
+		}
+	}
+
+	if(isMT7505) {
+		
+		if (!isFPGA) {
+			init_7505();
+		}
+	}
+	
+	if(isMT751020){
+#if 0	//for FPGA auto scan timing	
+#ifdef PCIe_AUTO_SCAN_TIMING
+		timing_p0 = pcie_60901_auto_scan(PHY_PORT0,36,18,0xbfb83050);
+		timing_p1 = pcie_60901_auto_scan(PHY_PORT1,36,18,0xbfb82050);
+#endif
+#endif
+		init_60901();
+
+	}
+	
+	return 0;
+}
+
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/pci/pci-tc3162.c vr300-linux/arch/mips/pci/pci-tc3162.c
--- linux-2.6.36/arch/mips/pci/pci-tc3162.c	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/pci/pci-tc3162.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,118 @@
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/tc3162/tc3162.h>
+
+
+#ifdef CONFIG_MIPS_TC3262
+#define PCI_COMMAND_WINDOW 0xBFB80CF8
+#endif
+static struct resource tc3162_pci_io_resource = {
+	.name   = "pci IO space",
+	.start  = 0x1FB90000,
+	.end    = 0x1FB9FFFF,
+	.flags  = IORESOURCE_IO
+};
+
+static struct resource tc3162_pci_mem_resource = {
+	.name   = "pci memory space",
+	.start  = 0x1FBA0000,
+	.end    = 0x1FBCFFFF,
+	.flags  = IORESOURCE_MEM
+};
+
+extern struct pci_ops tc3162_pci_ops;
+
+struct pci_controller tc3162_controller = {
+	.pci_ops   		= &tc3162_pci_ops,
+	.io_resource	= &tc3162_pci_io_resource,
+	.mem_resource	= &tc3162_pci_mem_resource,
+};
+
+static __init int tc3162_pci_init(void)
+{
+	int pci_bios;
+	unsigned long tmp;
+
+	if(isRT63365 || isMT751020 || isMT7505 || isEN751221)
+		return -1;
+
+#ifndef CONFIG_MIPS_TC3262
+	pci_bios = regRead32(CR_AHB_HWCONF) & (1<<8);
+
+	printk(KERN_INFO "tc3162: system has %sPCI BIOS\n",
+		pci_bios ? "" : "no ");
+	if (pci_bios == 0)
+		return -1;
+#endif
+	tmp = regRead32(CR_AHB_PCIC);
+	regWrite32(CR_AHB_PCIC, (tmp & ~(1<<31)));
+	mdelay(100);
+	tmp = regRead32(CR_AHB_PCIC);
+	regWrite32(CR_AHB_PCIC, (tmp | (1<<31)));
+	mdelay(300);
+
+	/* PCI memory byte swap enable */
+	/*
+	tmp = regRead32(CR_AHB_PCIC);
+	regWrite32(CR_AHB_PCIC, (tmp | ((1<<24) | (1<<25))) );
+	*/
+
+#ifdef CONFIG_MIPS_TC3262
+
+	/*read pci enable bit from PCI bridge command window to check pci support.
+           shnwind*/
+	regWrite32(PCI_COMMAND_WINDOW, (1<<31));
+	pci_bios = regRead32(PCI_COMMAND_WINDOW);
+	 
+	printk(KERN_INFO "system has %sPCI BIOS\n",pci_bios ? "" : "no ");
+	if (pci_bios == 0){
+		return -1;
+	}
+#endif	
+	/* Set I/O resource limits.  */
+	ioport_resource.end = 0x1fffffff;
+	iomem_resource.end = 0xffffffff;
+
+if(isRT63165)
+{
+/* rt63165's PCI bridge has additional config registers 
+ * which can be direct-accessed, such as the first 3 
+ * registers shown below
+ */
+	//Disable PCI IO SWAP.
+	
+	tmp = regRead32(0xbfb000ec);
+	tmp &= ~(1<<9);
+	regWrite32(0xbfb000ec, tmp);
+
+    /* configure USB Host Control Register to 
+     do byte swaping in HW --Trey */
+	regWrite32(0xbfb000a8, 0x00000060);
+    mdelay(10);
+    /* set space of PCI base address
+    up to 256M  --Trey*/
+    regWrite32(0xbfb80010, 0x0fff0001);
+    /* configure PCIArbitor Control Register to
+    set priority scheme --Trey*/
+    regWrite32(0xbfb80080, 0x00000079);
+
+    //set base address of PCI
+    regWrite32(0xbfb80cf8, 0x80000410);
+    regWrite32(0xbfb80cfc, 0x00000000);
+    
+    //enable PCI's master, memory functions 
+    regWrite32(0xbfb80cf8, 0x80000404);
+    regWrite32(0xbfb80cfc, 0xa4800016);
+    
+    //set PCI's latency-timer, cache-line-size
+    regWrite32(0xbfb80cf8, 0x8000040c);
+    regWrite32(0xbfb80cfc, 0x00002008);
+}
+	register_pci_controller(&tc3162_controller);
+	return 0;
+}
+
+arch_initcall(tc3162_pci_init);
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '^\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*.ko' -x '*.[chS]~' -x cevt-smtc.c -x smtc.c -x '*ecnt*' -x pci-7512api.c -x softfloat -x '*usb*' -x '*ralink*' -x .gitignore -urN linux-2.6.36/arch/mips/pci/pci-tc3162u.c vr300-linux/arch/mips/pci/pci-tc3162u.c
--- linux-2.6.36/arch/mips/pci/pci-tc3162u.c	1970-01-01 03:00:00.000000000 +0300
+++ vr300-linux/arch/mips/pci/pci-tc3162u.c	2019-03-07 03:40:15.000000000 +0200
@@ -0,0 +1,3261 @@
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h> 
+#include <asm/tc3162/tc3162.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+
+//#define PCIE_DEBUG	1
+//#define ESD_DEBUG 1
+//#define PRE_CONFIG_DEBUG 1
+#ifdef TCSUPPORT_WLAN_MT7592_PCIE
+#define MCU_CFG_BASE		0x2000
+#define MCU_PCIE_REMAP_1	(MCU_CFG_BASE + 0x500)
+#define REMAP_1_OFFSET_MASK (0x3ffff)
+#define GET_REMAP_1_OFFSET(p) (((p) & REMAP_1_OFFSET_MASK))
+#define REMAP_1_BASE_MASK	(0x3fff << 18)
+#define GET_REMAP_1_BASE(p) (((p) & REMAP_1_BASE_MASK) >> 18)
+#define MCU_PCIE_REMAP_2	(MCU_CFG_BASE + 0x504)
+#define REMAP_2_OFFSET_MASK (0x7ffff)
+#define GET_REMAP_2_OFFSET(p) (((p) & REMAP_2_OFFSET_MASK))
+#define REMAP_2_BASE_MASK (0x1fff << 19)
+#define GET_REMAP_2_BASE(p) (((p) & REMAP_2_BASE_MASK) >> 19)
+#endif
+
+#define PCIE_CONFIG_ADDR		0xbfb81cf8
+#define PCIE_CONFIG_DATA		0xbfb81cfc
+#define AHB_BUS_TIMEOUT_ERR		(1<<25)
+#define AHB_BUS_ADDR_ERR		(1<<24)
+
+#define NIC3090_PCIe_DEVICE_ID  0x3090		// 1T/1R miniCard
+#define NIC3091_PCIe_DEVICE_ID  0x3091		// 1T/2R miniCard
+#define NIC3092_PCIe_DEVICE_ID  0x3092		// 2T/2R miniCard
+#define NIC3390_PCIe_DEVICE_ID  0x3390		// 1T/1R miniCard
+#define NIC5390_PCIe_DEVICE_ID	0x5390
+#define NIC539F_PCIe_DEVICE_ID  0x539F
+#define NIC5392_PCIe_DEVICE_ID  0x5392
+#define NIC5592_PCIe_DEVICE_ID  0x5592
+#define NIC3593_PCIe_DEVICE_ID  0x3593
+#define PCIE60901_DEVICE_ID 	0x7510
+#define NIC7603_PCIe_DEVICE_ID	0x7603
+
+#define NIC_PCI_VENDOR_ID	0x1814
+#define MTK_PCI_VENDOR_ID 	0x14c3
+
+#define PCI_DEVICE_MEM1		0xbf700000
+#define PCIE_TYPE_RC		0x0
+#define PCIE_TYPE_DEV		0x1
+
+#define PCIE_BUS_0			0x0
+#define PCIE_BUS_1			0x1
+#define PCIE_BUS_2			0x2
+#define PCIE_BUS_3			0x3
+#define PCIE_DEV_0			0x0
+#define PCIE_DEV_1			0x1
+#define PCIE_BUS_RC			0x0
+#define PCIE_BUS_DEV		0x1
+#define PCIE_DEVNUM_0		0x0
+#define PCIE_DEVNUM_1		0x1
+#define PCIE_RESET_CON_BUSTIMEOUT 0
+#define PCIE_RESET_CON_PCIEERROR 1
+#define PCIE_SAVE_BUS_NUM	4
+#define PCIE_SAVE_DEVICE_NUM	2
+#define ENABLE 1
+#define DISABLE 0
+
+#define PHYSADDR(a)	((unsigned int)(a)&0x1fffffff)
+
+#if defined(TCSUPPORT_CPU_MT7505) || defined(TCSUPPORT_CPU_EN7512) || defined(TCSUPPORT_CPU_EN7521)
+#define isRC0_LINKUP		((regRead32(0xbfb80050) & 0x2) ? 1 : 0)  
+#define isRC1_LINKUP		((regRead32(0xbfb80050) & 0x4) ? 1 : 0)
+#else 
+#define isRC0_LINKUP		((regRead32(0xbfb82050) & 0x1) ? 1 : 0)
+#define isRC1_LINKUP		((regRead32(0xbfb83050) & 0x1) ? 1 : 0)
+
+#define isSLAVERC_LINKUP	((regRead32(0xbfb80050) & 0x1) ? 1 : 0)
+
+#endif
+
+struct pci_config_s{	
+	int reg;	
+	unsigned long int value;
+};
+
+#ifdef TCSUPPORT_WLAN_MT7592_PCIE
+struct pci_linkpath_s{	
+	int rcbusnum;
+	int rcdevnum;
+	int epbusnum;
+	int epdevnum;
+};
+
+struct pci_probeinfo_s{	
+	char rcindex;
+	char flag;
+	struct pci_linkpath_s num[2];
+};
+
+struct pci_access_s{	
+	int busnum;
+	int devnum;
+	int reg;	
+	unsigned long int value;
+};
+#endif
+#if defined(TCSUPPORT_BONDING)
+#define MAX_REG_CONFIG  3
+struct reg_config_s{	
+	unsigned int reg;	
+	unsigned int value;
+};
+#endif
+
+/**************************Gloabol Value***************************/
+
+#if defined(TCSUPPORT_BONDING)
+unsigned long slaveVirBaseAddr = 0;
+struct reg_config_s reg_config_temp[MAX_REG_CONFIG];
+#endif
+extern uint32 pcie_config_addr;
+extern uint32 pcie_config_data;
+
+static int ahb_status=0;
+static int pcie_soft_patch=1;
+static int wifiDeviceId = 0;
+int dual_band_support = 0;
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+static char pcie_reset_condiction = PCIE_RESET_CON_PCIEERROR;/*change default value*/
+#else
+static char pcie_reset_condiction = PCIE_RESET_CON_BUSTIMEOUT;
+#endif
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+static int pcie_error_detect_count = 1;/*when pcie error count is beyond pcie_error_detect_count, do pcie reset*/
+#endif
+static int pcie_reset_count = 0;
+static char rc0_is_exist=0, rc1_is_exist=0;
+static DEFINE_SPINLOCK(pcie_esd_lock);
+struct pci_config_s *pcie_config_temp[PCIE_SAVE_BUS_NUM][PCIE_SAVE_DEVICE_NUM];//save 4 bus and 2 dev for each bus
+
+#ifdef TCSUPPORT_WLAN_MT7592_PCIE
+#define MAX_PRE_CONFIG_NUM 20
+
+enum
+{
+	MODE0RCBASEADDR = 0,
+	MODE1RCBASEADDR = 2,
+	MODE2RCBASEADDR = 4,
+};
+
+struct pci_config_s pcie_config_table_WiFi_RC0_Special[] =
+{
+	//single wifi
+	//wifi mode :(dual band)
+	//linebond mode:(only master wifi)
+	{0x18,0x00010100},
+	{-1,0},
+	//linebond mode:(only slave wifi,dualband)
+	{0x18,0x00020100},
+	{0x18,0x00020201},
+	{-1,0}
+};
+
+struct pci_config_s pcie_config_table_WiFi_RC1_Special[] =
+{
+	//single wifi
+	{0x18,0x00010100},
+	{-1,0},
+	//wifi mode :(dual band)
+	//linebond mode:(only master wifi)
+	{0x18,0x00020200},
+	{-1,0},
+	//linebond mode:(dualband)
+	{0x18,0x00020100},
+	{0x18,0x00030300},
+	{-1,0}
+};
+
+#ifdef TCSUPPORT_BONDING
+struct pci_config_s pcie_config_table_EP[] =
+{
+	{0x04,0x00100006},{0x10,0x21000000},
+	{-1,0}
+};
+
+struct pci_config_s pcie_config_table_WiFi_RC_General[] =
+{
+	//first RC1 and then RC0
+	{0x04,0x00100007},{0x20,0x21002100},
+	{-1,0},
+	{0x04,0x00100007},{0x20,0x21702000},
+	{-1,0}
+};
+struct pci_config_s pcie_config_table_WiFi_RC_Slave_General[] =
+{
+	//first RC1 and then RC0
+	{0x04,0x00100007},{0x20,0x21702100},
+	{-1,0},
+	{0x04,0x00100007},{0x20,0x21702000},
+	{-1,0}
+};
+
+struct pci_config_s pcie_config_table_WiFi_RC_Master_General[] =
+{
+	//first RC1 and then RC0
+	{0x04,0x00100007},{0x20,0x21002100},
+	{-1,0},
+	{0x04,0x00100007},{0x20,0x20002000},
+	{-1,0}
+};
+
+struct pci_config_s pcie_config_table_EP_DMT[] =
+{
+	{0x04,0x00100007},{0x10,0x20000000},
+	{-1,0}
+};
+
+#else
+struct pci_config_s pcie_config_table_EP[] =
+{
+	{0x04,0x00100006},{0x10,0x20000000},
+	{-1,0}
+};
+
+struct pci_config_s pcie_config_table_WiFi_RC_General[] =
+{
+	{0x04,0x00100007},{0x20,0x20002000},
+	{-1,0}
+};
+
+#endif
+
+struct pci_access_s pcie_config_table_temp[MAX_PRE_CONFIG_NUM];
+
+#endif
+
+/**************************function definition***************************/
+static void aer_status_dump(void);
+extern int pciePhyInit(void);
+extern void pcie_phy_force_mode_en(char enable, char rc_num);
+void aer_config(int aerEnable);
+void pcieResetRC0(void);
+void pcieResetRC1(void);
+int pcie_timeout_disable(void);
+static void aer_status_clear(void);
+unsigned long int pcie_read_config_word(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum);
+int pcie_write_config_word(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum, unsigned long int value);
+int pcie_write_config_byte(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum, unsigned char value);
+int pcie_reset_handler(char rc_num);
+struct pci_config_s *save_pcie_config(char bus, char dev);
+void restore_pcie_config(char bus, char dev, struct pci_config_s* restore_p);
+
+
+
+static struct resource tc3162_pcie_io_resource = {
+	.name   = "pcie IO space",
+#ifdef CONFIG_MIPS_TC3162U
+	.start  = 0x1FBD0000,
+	.end    = 0x1FBEFFFF,
+#endif
+#ifdef CONFIG_MIPS_TC3262
+	.start  = 0x1F600000,
+	.end    = 0x1F61FFFF,
+#endif
+	.flags  = IORESOURCE_IO
+};
+
+static struct resource tc3162_pcie_mem_resource = {
+	.name   = "pcie memory space",
+	.start  = 0x1F700000,
+	.end    = 0x1F8FFFFF,
+	.flags  = IORESOURCE_MEM
+};
+
+extern struct pci_ops tc3162_pcie_ops;
+
+struct pci_controller tc3162_pcie_controller = {
+	.pci_ops   		= &tc3162_pcie_ops,
+	.io_resource	= &tc3162_pcie_io_resource,
+	.mem_resource	= &tc3162_pcie_mem_resource,
+};
+
+extern struct pci_ops mt7512_pcie_ops;
+struct pci_controller mt7512_pcie_controller = {
+	.pci_ops   		= &mt7512_pcie_ops,
+	.io_resource	= &tc3162_pcie_io_resource,
+	.mem_resource	= &tc3162_pcie_mem_resource,
+};
+
+#ifdef TCSUPPORT_WLAN_MT7592_PCIE
+unsigned long wifi_csr_addr = 0;
+#ifdef TCSUPPORT_BONDING
+unsigned long mappingaddr = 0;
+#endif
+#define RTMP_IO_READ32(_A, _R, _pV)	\
+{		\
+	(*_pV = readl((void *)((_A) + (_R))));			\
+}
+
+#define RTMP_IO_WRITE32(_A, _R, _V)		\
+{		\
+	writel((_V), (void *)((_A) + (_R)));\
+}
+
+void GlobalCRWrite(unsigned char* baseAddr, unsigned long Offset, unsigned long Value)
+{
+	unsigned long RemapBase, RemapOffset;
+	unsigned long RestoreValue;
+
+	RTMP_IO_READ32(baseAddr, MCU_PCIE_REMAP_1, &RestoreValue);
+	RemapBase = GET_REMAP_1_BASE(Offset) << 18;
+	RemapOffset = GET_REMAP_1_OFFSET(Offset);
+	RTMP_IO_WRITE32(baseAddr, MCU_PCIE_REMAP_1, RemapBase);
+	RTMP_IO_WRITE32(baseAddr, 0x40000 + RemapOffset, Value);
+
+	RTMP_IO_WRITE32(baseAddr, MCU_PCIE_REMAP_1, RestoreValue);
+}
+
+void GlobalCRRead(unsigned char* baseAddr, unsigned long Offset, unsigned long *Value)
+{
+	unsigned long RemapBase, RemapOffset;
+	unsigned long RestoreValue;
+
+	RTMP_IO_READ32(baseAddr, MCU_PCIE_REMAP_1, &RestoreValue);
+	RemapBase = GET_REMAP_1_BASE(Offset) << 18;
+	RemapOffset = GET_REMAP_1_OFFSET(Offset);
+	RTMP_IO_WRITE32(baseAddr, MCU_PCIE_REMAP_1, RemapBase);
+	RTMP_IO_READ32(baseAddr, 0x40000 + RemapOffset, Value);
+
+	RTMP_IO_WRITE32(baseAddr, MCU_PCIE_REMAP_1, RestoreValue);
+}
+
+void RecoverInitialValue()
+{
+	struct pci_access_s * config_p = &pcie_config_table_temp[0];
+	int i = 0;
+#ifdef PRE_CONFIG_DEBUG	
+	printk("\r\n====RecoverInitValue====\r\n");
+#endif
+	while((i < MAX_PRE_CONFIG_NUM) && ((*(config_p + (i))).reg != 0)){
+#ifdef PRE_CONFIG_DEBUG				
+		printk("[write]pre config bus %x dev %x reg %x value %lx \n", (*(config_p + i)).busnum,(*(config_p + i)).devnum,(*(config_p + i)).reg, (*(config_p + i)).value);
+#endif	
+		pcie_write_config_word(PCIE_TYPE_DEV,  (*(config_p + i)).busnum, (*(config_p + i)).devnum, (*(config_p + i)).reg, (*(config_p + i)).value);
+		memset((config_p + (i)),0,sizeof(struct pci_access_s ));
+		i++;
+	}
+}
+
+/*we config RC first and then read EP info,if wifichip==0x7603 then config EP*/
+int RegConfigFunc(struct pci_probeinfo_s* pre_info, struct pci_config_s* pre_config_RC_S)
+{
+	int i = 0,j = 0,k = 0,m = 0;
+	int wifiDevice;
+	int rcnum = pre_info->rcindex;
+	int rcbusindex = pre_info->num[0].rcbusnum;
+	int rcdevindex = pre_info->num[0].rcdevnum;
+	int epbusindex = pre_info->num[0].epbusnum;
+	int epdevindex = pre_info->num[0].epdevnum;
+	struct pci_config_s* pre_config_RC_G = &pcie_config_table_WiFi_RC_General[0];
+	struct pci_config_s* pre_config_EP = &pcie_config_table_EP[0];
+	#ifdef TCSUPPORT_BONDING
+	struct pci_config_s* pre_config_EP_DMT;
+	#endif
+	/*step1: config RC special register to led data pass RC to EP*/
+	while((*(pre_config_RC_S + (i))).reg != -1){		
+		if(i >= MAX_PRE_CONFIG_NUM)
+		{
+			#ifdef PRE_CONFIG_DEBUG
+			printk("\r\n pcie_config_table_temp is not enough");
+			#endif
+			RecoverInitialValue();
+			i = 0;
+		}
+		pcie_config_table_temp[i].busnum = rcbusindex;
+		pcie_config_table_temp[i].devnum = rcdevindex;
+		pcie_config_table_temp[i].reg = (*(pre_config_RC_S + i)).reg;
+		pcie_config_table_temp[i].value =  pcie_read_config_word(PCIE_TYPE_DEV, rcbusindex,rcdevindex, (*(pre_config_RC_S + i)).reg);
+
+		pcie_write_config_word(PCIE_TYPE_DEV,  rcbusindex, rcdevindex, (*(pre_config_RC_S + i)).reg, (*(pre_config_RC_S + i)).value);
+#ifdef PRE_CONFIG_DEBUG				
+		printk("[Config RC]pre config bus %x dev %x reg %x value %lx \n", rcbusindex,rcdevindex,(*(pre_config_RC_S + i)).reg, (*(pre_config_RC_S + i)).value);
+#endif		
+		i++;
+#ifdef TCSUPPORT_BONDING
+		if(--rcnum > 0)
+		{
+			rcbusindex = pre_info->num[i].rcbusnum;
+			rcdevindex = pre_info->num[i].rcdevnum;
+		}
+#endif
+	}	
+
+	/*step2: read EP CHIP info,if not 7603,just return*/
+	wifiDevice = pcie_read_config_word(PCIE_TYPE_DEV,  epbusindex,epdevindex, 0) >> 16;
+#ifdef PRE_CONFIG_DEBUG		
+	printk("[read device id]wifi config bus %x dev %x value %lx \n",epbusindex,epdevindex, pcie_read_config_word(PCIE_TYPE_DEV, epbusindex, epdevindex, 0));
+#endif
+	if(0x7603 != wifiDevice)
+	{
+		RecoverInitialValue();
+		#ifdef PRE_CONFIG_DEBUG	
+		printk("\r\n not 7592 wifi,so just return");
+		#endif
+		return -1;
+	}
+
+	/*step3: config RC general register*/
+	#ifdef TCSUPPORT_BONDING
+	if(1 ==  pre_info->flag)
+		pre_config_RC_G = &pcie_config_table_WiFi_RC_Slave_General[0];
+	else if(2 ==  pre_info->flag)
+		pre_config_RC_G = &pcie_config_table_WiFi_RC_Master_General[0];
+	#endif
+	
+	m = pre_info->rcindex;
+	while(--m >= 0)
+	{
+		while((*(pre_config_RC_G + (k))).reg != -1){		
+		if(i >= MAX_PRE_CONFIG_NUM)
+		{
+			#ifdef PRE_CONFIG_DEBUG
+			printk("\r\n pcie_config_table_temp is not enough");
+			#endif
+			RecoverInitialValue();
+			i = 0;
+		}
+			pcie_config_table_temp[i].busnum = rcbusindex;
+			pcie_config_table_temp[i].devnum = rcdevindex;
+			pcie_config_table_temp[i].reg = (*(pre_config_RC_G + k)).reg;
+			pcie_config_table_temp[i].value =  pcie_read_config_word(PCIE_TYPE_DEV, rcbusindex,rcdevindex, (*(pre_config_RC_G + k)).reg);
+	
+			pcie_write_config_word(PCIE_TYPE_DEV,  rcbusindex, rcdevindex, (*(pre_config_RC_G + k)).reg, (*(pre_config_RC_G + k)).value);
+#ifdef PRE_CONFIG_DEBUG				
+			printk("[Config RC]pre config bus %x dev %x reg %x value %lx \n", rcbusindex,rcdevindex,(*(pre_config_RC_G + k)).reg, (*(pre_config_RC_G + k)).value);
+#endif		
+			k++;
+			i++;
+		}
+		#ifdef TCSUPPORT_BONDING
+		if(m > 0)
+		{
+			k++;
+			rcbusindex = pre_info->num[m-1].rcbusnum;
+			rcdevindex = pre_info->num[m-1].rcdevnum;
+		}
+		#endif
+	};
+	
+#ifdef TCSUPPORT_BONDING
+	if(1 ==  pre_info->flag)
+	{
+		pre_config_EP_DMT = &pcie_config_table_EP_DMT[0];
+		m = 0;
+	/*step4: config EP dmt general register,only for linebond dual band and 7592 in slave ep*/
+		while((*(pre_config_EP_DMT + (m))).reg != -1){		
+				if(i >= MAX_PRE_CONFIG_NUM)
+				{
+					#ifdef PRE_CONFIG_DEBUG
+					printk("\r\n pcie_config_table_temp is not enough");
+					#endif
+					RecoverInitialValue();
+					i = 0;
+				}
+				pcie_config_table_temp[i].busnum = 1;
+				pcie_config_table_temp[i].devnum = 0;
+				pcie_config_table_temp[i].reg = (*(pre_config_EP_DMT + m)).reg;
+				pcie_config_table_temp[i].value =  pcie_read_config_word(PCIE_TYPE_DEV, 1, 0, (*(pre_config_EP_DMT + m)).reg);
+		
+				pcie_write_config_word(PCIE_TYPE_DEV,  1, 0, (*(pre_config_EP_DMT + m)).reg, (*(pre_config_EP_DMT + m)).value);
+#ifdef PRE_CONFIG_DEBUG				
+				printk("[Config EP]pre config bus %x dev %x reg %x value %lx \n", 1,0,(*(pre_config_EP_DMT + m)).reg, (*(pre_config_EP_DMT + m)).value);
+#endif		
+				i++;
+				m++;	
+		}
+		mappingaddr = 0x20000000;
+	}
+	else
+	{
+		mappingaddr = 0x21000000;
+	}
+#endif
+
+	/*step5: config EP general register*/
+	while((*(pre_config_EP + (j))).reg != -1){		
+			if(i >= MAX_PRE_CONFIG_NUM)
+			{
+			#ifdef PRE_CONFIG_DEBUG
+			printk("\r\n pcie_config_table_temp is not enough");
+			#endif
+				RecoverInitialValue();
+				i = 0;
+			}
+				
+			pcie_config_table_temp[i].busnum = epbusindex;
+			pcie_config_table_temp[i].devnum = epdevindex;
+			pcie_config_table_temp[i].reg = (*(pre_config_EP + j)).reg;
+			pcie_config_table_temp[i].value =  pcie_read_config_word(PCIE_TYPE_DEV, epbusindex, epdevindex, (*(pre_config_EP + j)).reg);
+	
+			pcie_write_config_word(PCIE_TYPE_DEV,  epbusindex, epdevindex, (*(pre_config_EP + j)).reg, (*(pre_config_EP + j)).value);
+#ifdef PRE_CONFIG_DEBUG				
+			printk("[Config EP]pre config bus %x dev %x reg %x value %lx \n", epbusindex,epdevindex,(*(pre_config_EP + j)).reg, (*(pre_config_EP + j)).value);
+#endif		
+			i++;
+			j++;	
+		}
+
+	
+#ifdef PRE_CONFIG_DEBUG 
+	printk("\r\nsave total index is %d",i);
+#endif
+
+	return 0;
+}
+
+int pciePreConfigReg()
+{
+	int preconfigflag = -1;
+	int preconfigtemp = -1;
+	int rctempflag = 0;
+	struct pci_probeinfo_s preinfo;
+	struct pci_config_s* pre_config_RC_S;
+	/*
+		preconfigflag
+		0:single wifi(include dual band with only one wifi)
+		1:wifi mode((dual band) and (lineband mode with only master wifi))
+		2:linebond mode(only slave wifi)
+		3:linebond mode(dual band)
+	*/
+	memset(&preinfo,0,sizeof(struct pci_probeinfo_s));
+	if(isMT751020 || isRT63368 || isEN751221)
+	{	
+		if(dual_band_support)
+		{
+			#ifdef TCSUPPORT_BONDING
+			rctempflag = (isRC0_LINKUP)|(isRC1_LINKUP<<1)|(isSLAVERC_LINKUP<<2);
+			#else
+			rctempflag = (isRC0_LINKUP)|(isRC1_LINKUP<<1);
+			#endif
+			switch (rctempflag)
+			{
+			#ifdef TCSUPPORT_BONDING
+				case 3:
+					//master wifi
+					preconfigflag = 1;
+					break;
+				case 5:
+					//slave wifi
+					preconfigflag = 2;
+					break;
+				case 7:
+					//dual band
+					preconfigflag = 3;
+					break;
+			#else
+				case 1:
+				case 2:	
+					//one wifi
+					preconfigflag = 0;
+					break;
+				case 3:
+					//dual band
+					preconfigflag = 1;
+					break;
+
+			#endif
+				default:
+					break;
+			}			
+		}
+		else
+		{
+			if(isRC0_LINKUP)
+				preconfigflag = 0;
+		}
+	}
+	else if(isMT7505 || isRT63365)
+	{
+		if(isRC0_LINKUP)
+			preconfigflag = 0;
+	}
+
+	
+#ifdef PRE_CONFIG_DEBUG	
+	printk("preconfigflag =%d\n",preconfigflag);
+#endif
+	preinfo.rcindex = 1;
+	switch (preconfigflag)
+	{
+		case 0:
+			preinfo.num[0].rcbusnum = PCIE_BUS_0;
+			preinfo.num[0].rcdevnum = PCIE_DEV_0;
+			preinfo.num[0].epbusnum = PCIE_BUS_1;
+			preinfo.num[0].epdevnum = PCIE_DEV_0;
+			pre_config_RC_S = &pcie_config_table_WiFi_RC0_Special[MODE0RCBASEADDR];
+			preconfigtemp =  RegConfigFunc(&preinfo,pre_config_RC_S);
+			break;
+		case 1:
+			#ifndef TCSUPPORT_BONDING
+			preinfo.num[0].rcbusnum = PCIE_BUS_0;
+			preinfo.num[0].rcdevnum = PCIE_DEV_0;
+			preinfo.num[0].epbusnum = PCIE_BUS_1;
+			preinfo.num[0].epdevnum = PCIE_DEV_0;
+			pre_config_RC_S = &pcie_config_table_WiFi_RC0_Special[MODE0RCBASEADDR];
+			preconfigtemp =  RegConfigFunc(&preinfo,pre_config_RC_S);
+			if(!preconfigtemp)
+				return;
+			#endif
+			preinfo.num[0].rcbusnum = PCIE_BUS_0;
+			preinfo.num[0].rcdevnum = PCIE_DEV_1;
+			preinfo.num[0].epbusnum = PCIE_BUS_2;
+			preinfo.num[0].epdevnum = PCIE_DEV_0;
+			pre_config_RC_S = &pcie_config_table_WiFi_RC1_Special[MODE1RCBASEADDR];
+			preconfigtemp =  RegConfigFunc(&preinfo,pre_config_RC_S);
+			break;
+		#ifdef TCSUPPORT_BONDING	
+		case 2:
+			preinfo.rcindex = 2;
+			preinfo.flag = 1;
+			preinfo.num[0].rcbusnum = PCIE_BUS_0;
+			preinfo.num[0].rcdevnum = PCIE_DEV_0;
+			preinfo.num[1].rcbusnum = PCIE_BUS_1;
+			preinfo.num[1].rcdevnum = PCIE_DEV_1;
+			preinfo.num[0].epbusnum = PCIE_BUS_2;
+			preinfo.num[0].epdevnum = PCIE_DEV_0;
+			pre_config_RC_S = &pcie_config_table_WiFi_RC0_Special[MODE1RCBASEADDR];
+			preconfigtemp =  RegConfigFunc(&preinfo,pre_config_RC_S);
+			break;
+		case 3:
+			preinfo.flag = 1;
+			preinfo.rcindex = 2;
+			preinfo.num[0].rcbusnum = PCIE_BUS_0;
+			preinfo.num[0].rcdevnum = PCIE_DEV_0;
+			preinfo.num[1].rcbusnum = PCIE_BUS_1;
+			preinfo.num[1].rcdevnum = PCIE_DEV_1;
+			preinfo.num[0].epbusnum = PCIE_BUS_2;
+			preinfo.num[0].epdevnum = PCIE_DEV_0;
+			pre_config_RC_S = &pcie_config_table_WiFi_RC0_Special[MODE1RCBASEADDR];
+			preconfigtemp =  RegConfigFunc(&preinfo,pre_config_RC_S);
+			if(!preconfigtemp)
+				return;
+
+			preinfo.flag = 2;
+			preinfo.num[0].rcbusnum = PCIE_BUS_0;
+			preinfo.num[0].rcdevnum = PCIE_DEV_0;
+			preinfo.num[1].rcbusnum = PCIE_BUS_0;
+			preinfo.num[1].rcdevnum = PCIE_DEV_1;
+			preinfo.num[0].epbusnum = PCIE_BUS_3;
+			preinfo.num[0].epdevnum = PCIE_DEV_0;
+			pre_config_RC_S = &pcie_config_table_WiFi_RC1_Special[MODE2RCBASEADDR];
+			preconfigtemp =  RegConfigFunc(&preinfo,pre_config_RC_S);
+			break;
+		#endif
+		default:
+		#ifdef PRE_CONFIG_DEBUG	
+			printk("\r\nflag not support:%d",preconfigflag);
+		#endif
+			preconfigtemp = -2;
+			break;
+	}
+
+#ifdef PRE_CONFIG_DEBUG	
+		printk("\r\nreturn preconfigflag =%d\n",preconfigflag);
+#endif
+
+	return preconfigtemp;
+}
+
+void SetLDO()
+{
+	
+	unsigned int Value1 = 0;
+	unsigned int Value2 = 0;
+	int cnt = 10;
+	unsigned char *baseAddr = (unsigned char *)wifi_csr_addr;
+	
+	while(cnt--){
+		GlobalCRWrite(baseAddr, 0x50012498, 0x5);
+		GlobalCRRead(baseAddr, 0x50012498, &Value1);
+		if(Value1 == 0x5) //Setting success
+			break;		
+	}
+
+	if(Value1 != 0x5){
+		printk("Wifi CR 0x%x value setting fail(Value=0x%x)\n", 0x50012498, Value1);
+	}
+
+	while(cnt--){
+		GlobalCRWrite(baseAddr, 0x50012040, 0x80);
+		GlobalCRRead(baseAddr, 0x50012040, &Value2);
+		if(Value2 == 0x80) //Setting success
+			break;		
+	}
+
+	if(Value2 != 0x80){
+		printk("Wifi CR 0x%x value setting fail(Value=0x%x)\n", 0x50012040, Value2);
+	}
+
+	printk("CR 0x%x value is 0x%x\n", 0x50012498, Value1);
+	printk("CR 0x%x value is 0x%x\n", 0x50012040, Value2);		
+}
+
+void preConfigLDO()
+{	
+	int i,preconfigflag;
+	for(i = 0;i < MAX_PRE_CONFIG_NUM; i++)
+	{	
+		memset(&pcie_config_table_temp[i],0,sizeof(struct pci_access_s ));
+	}
+	preconfigflag = pciePreConfigReg();
+	if(!preconfigflag)
+	{
+#ifdef TCSUPPORT_BONDING
+		wifi_csr_addr = (unsigned long)ioremap(mappingaddr,0x100000);
+#else
+		wifi_csr_addr = (unsigned long)ioremap(0x20000000,0x100000);
+#endif
+		SetLDO();
+		RecoverInitialValue();
+		iounmap((char *)wifi_csr_addr);
+	}
+}
+#endif
+
+struct pci_config_s *save_pcie_config(char bus, char dev){	
+	int reco_reg[] = {0x4, 0xc, 0x10, 0x18, 0x1c, 0x20, 0x24, 0x30, 0x3c, 0x50, 0x54, 0x5c, 0x154, 0x160, -1};
+	int i, num_reg;	
+	struct pci_config_s * ret_p;
+#ifdef ESD_DEBUG	
+	printk("save pcie config bus %d dev %d\n",bus,dev);
+#endif	
+	i = 0;	
+	num_reg = 0;
+
+	if(pcie_read_config_word(PCIE_TYPE_RC, bus, dev, 0) == 0xffffffff)//means no device 
+		return NULL;
+	
+	while(reco_reg[num_reg++] != -1){}; // caclute total reg_num	
+	ret_p = (struct pci_config_s *)kzalloc(sizeof(struct pci_config_s) * num_reg ,GFP_KERNEL);	
+	if(ret_p == NULL)			
+		return NULL;	
+	for(i=0; i<num_reg; i++){		
+		(*(ret_p + i)).reg = reco_reg[i];		
+		if(reco_reg[i] != -1){				
+			(*(ret_p + i)).value= pcie_read_config_word(PCIE_TYPE_RC, bus, dev, reco_reg[i]);
+#ifdef ESD_DEBUG						
+			printk("reg %x value %lx\n",(*(ret_p + i)).reg,(*(ret_p + i)).value);
+#endif		
+		}		
+	}			
+	return ret_p;	
+}
+void restore_pcie_config(char bus, char dev, struct pci_config_s* restore_p){	
+	int i;
+#ifdef ESD_DEBUG	
+	printk("restore pcie config bus %d dev %d\n", bus, dev);
+#endif	
+	if(restore_p == NULL){		
+		printk("Recover BUS %d DEV %d Faill !!\n",bus,dev);		
+		return;	
+	}		
+	i = 0;	
+	while((*(restore_p + (i))).reg != -1){		
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, (*(restore_p + i)).reg, (*(restore_p + i)).value);
+#ifdef ESD_DEBUG				
+		printk("restore reg %x value %lx \n", (*(restore_p + i)).reg, (*(restore_p + i)).value);
+#endif		
+		i++;	
+	}	
+
+}
+void pcie_int_enable(char enable, char rc_num){
+	unsigned long int tmp;
+	
+	if(enable == ENABLE){
+		if(rc_num == 0){//Enable Interrupt
+		#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+			if(isMT751020 || isMT7505 || isRT63368){
+		#else
+			if(isMT751020 || isMT7505 || isEN751221){
+		#endif
+				tmp = regRead32(0xbfb8000c);
+#if defined(TCSUPPORT_BONDING)
+				/* slave dmt, error interrupt, slave gdma */
+				tmp |= ((1<<23) | (1<<24) | (1<<25));
+#else
+				tmp |= (1<<20);
+#endif
+				regWrite32(0xbfb8000c, tmp);
+			}	
+		}else{//only need rc0 or 1
+			if(isMT751020 || isEN751221){
+				tmp = regRead32(0xbfb8000c);
+				tmp |= (1<<26);
+				regWrite32(0xbfb8000c, tmp);
+			}	
+			#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+			else if(isRT63368){
+				tmp = regRead32(0xbfb8000c);
+				tmp |= (1<<21);
+				regWrite32(0xbfb8000c, tmp);
+			}
+			#endif
+		}
+	}else{//Disable Interrupt
+		if(rc_num == 0){
+		#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+			if(isMT751020 || isMT7505 || isRT63368){
+		#else
+			if(isMT751020 || isMT7505 || isEN751221){
+		#endif
+				tmp = regRead32(0xbfb8000c);
+#if defined(TCSUPPORT_BONDING)
+				/* slave dmt, error interrupt, slave gdma */
+				tmp &= ~((1<<23) | (1<<24) | (1<<25));
+#else
+				tmp &= ~(1<<20);
+#endif
+				regWrite32(0xbfb8000c, tmp);
+			}
+		}else{
+			if(isMT751020 || isEN751221){
+				tmp = regRead32(0xbfb8000c);
+				tmp &= ~(1<<26);
+				regWrite32(0xbfb8000c, tmp);
+			}
+			#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+			else if(isRT63368){
+				tmp = regRead32(0xbfb8000c);
+				tmp &= ~(1<<21);
+				regWrite32(0xbfb8000c, tmp);
+			}
+			#endif
+		}	
+	}
+}
+
+int pcie_reset_handler(char rc_num){
+		int wifi_dev_bus_id = 1;
+    #if defined(TCSUPPORT_BONDING)
+        int i;
+    #endif
+	
+		if((rc_num == 0) || (rc_num == 2)){		
+			pcie_reset_count ++;
+			aer_config(0);
+			pcieResetRC0();
+			if(isRC0_LINKUP){
+				restore_pcie_config(PCIE_BUS_0, PCIE_DEV_0, pcie_config_temp[PCIE_BUS_0][PCIE_DEV_0]);
+				restore_pcie_config(PCIE_BUS_1, PCIE_DEV_0, pcie_config_temp[PCIE_BUS_1][PCIE_DEV_0]);
+                                
+#ifdef TCSUPPORT_BONDING
+#ifdef TCSUPPORT_CPU_EN7512
+
+                                   printk(" pcie_reset_handler function is not implement in chip 7512.");
+#else
+				if(isSLAVERC_LINKUP){
+					wifi_dev_bus_id++;
+					restore_pcie_config(PCIE_BUS_1, PCIE_DEV_1, pcie_config_temp[PCIE_BUS_1][PCIE_DEV_1]);//slave RC
+					restore_pcie_config(wifi_dev_bus_id, PCIE_DEV_0, pcie_config_temp[wifi_dev_bus_id][PCIE_DEV_0]);//slave WIFI
+				}else{
+					wifi_dev_bus_id = -1; //no wifi
+				}
+				
+                for (i = 0; i < MAX_REG_CONFIG; i++)
+                    regWrite32(reg_config_temp[i].reg, reg_config_temp[i].value);
+#endif /*TCSUPPORT_CPU_EN7512*/
+#endif/*TCSUPPORT_BONDING*/
+				if(wifi_dev_bus_id != -1){
+					wifiDeviceId = pcie_read_config_word(PCIE_TYPE_DEV, wifi_dev_bus_id, PCIE_DEV_0, 0) >> 16;
+#ifdef ESD_DEBUG					
+					printk("wifi DeviceID %x\n",wifiDeviceId);
+#endif
+				}	
+				pcie_int_enable(ENABLE, 0);
+				pcie_timeout_disable();
+				aer_status_clear();
+				aer_config(1);
+			}else{
+				printk("RC0 Dead\n");
+				return -1;
+			}	
+
+			#if defined(TCSUPPORT_CPU_RT63368) ||defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7510)|| defined(TCSUPPORT_CPU_MT7505)
+			#if 0/*def TCSUPPORT_WLAN_MT7592_PCIE*/
+			if(0x7603 == wifiDeviceId)
+				preConfigLDO();
+			#endif
+			#endif
+
+		}else if(rc_num == 1){		
+			pcie_reset_count ++;
+			aer_config(0);
+			pcieResetRC1();
+			if(isRC1_LINKUP){
+				restore_pcie_config(PCIE_BUS_0, PCIE_DEV_1, pcie_config_temp[PCIE_BUS_0][PCIE_DEV_1]);
+				if(isRC0_LINKUP){
+					wifi_dev_bus_id++;
+                                        
+#ifdef TCSUPPORT_BONDING
+#ifdef TCSUPPORT_CPU_EN7512
+                                /*pcie_reset_handler function is not implement in chip 7512.*/
+#else
+					if(isSLAVERC_LINKUP){
+						wifi_dev_bus_id++;
+						restore_pcie_config(wifi_dev_bus_id, PCIE_DEV_0, pcie_config_temp[wifi_dev_bus_id][PCIE_DEV_0]);
+					}else
+#endif   /*TCSUPPORT_CPU_EN7512*/
+#endif	/*TCSUPPORT_BONDING*/				
+					{
+						restore_pcie_config(wifi_dev_bus_id, PCIE_DEV_0, pcie_config_temp[wifi_dev_bus_id][PCIE_DEV_0]);
+					}
+				}else{
+					restore_pcie_config(wifi_dev_bus_id, PCIE_DEV_0, pcie_config_temp[wifi_dev_bus_id][PCIE_DEV_0]);
+				}
+				if(wifi_dev_bus_id != -1){
+					wifiDeviceId = pcie_read_config_word(PCIE_TYPE_DEV, wifi_dev_bus_id, PCIE_DEV_0, 0) >> 16;
+#ifdef ESD_DEBUG					
+					printk("wifi DeviceID %x\n",wifiDeviceId);
+#endif
+				}
+				pcie_int_enable(ENABLE, 1);
+				pcie_timeout_disable();
+				aer_status_clear();
+				aer_config(1);
+			}else{
+				printk("RC1 Dead\n");
+				
+				return -1;
+			}	
+			#if defined(TCSUPPORT_CPU_RT63368) ||defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7510)|| defined(TCSUPPORT_CPU_MT7505)
+			#if 0/*def TCSUPPORT_WLAN_MT7592_PCIE*/
+			if(0x7603 == wifiDeviceId)
+				preConfigLDO();
+			#endif
+			#endif
+			
+		}else{
+			printk("RC ID %d Fail\n",rc_num);
+			return -1;
+		}
+
+
+		return 0;
+}	
+
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+/*______________________________________________________________________________
+**function name:pcie_reset_handler_o
+**
+**description:
+*    63368 reset handler
+**parameters:
+*    none
+**global:
+*    none
+**return:
+*    0:success
+*    -1:fail
+**call:
+*    start_cc()
+**revision:
+*     Brian.shi
+**____________________________________________________________________________*/
+int pcie_reset_handler_o()
+{
+	int wifi_dev_bus_id = 1;
+	int ret = 0;
+	prom_printf("\r\n======pcie_reset_handler_o=======");	
+	pcieReset();
+	if(isRC0_LINKUP){
+		restore_pcie_config(PCIE_BUS_0, PCIE_DEV_0, pcie_config_temp[PCIE_BUS_0][PCIE_DEV_0]);
+		restore_pcie_config(PCIE_BUS_1, PCIE_DEV_0, pcie_config_temp[PCIE_BUS_1][PCIE_DEV_0]);
+		if(wifi_dev_bus_id != -1){
+			wifiDeviceId = pcie_read_config_word(PCIE_TYPE_DEV, wifi_dev_bus_id, PCIE_DEV_0, 0) >> 16;
+#ifdef ESD_DEBUG					
+			prom_printf("wifi DeviceID %x\n",wifiDeviceId);
+#endif
+		}	
+		pcie_int_enable(ENABLE, 0);
+		pcie_timeout_disable();
+	}else{
+		printk("RC0 Dead\n");
+		ret += 1;
+	}	
+
+	if(isRC1_LINKUP){
+		if(isRC0_LINKUP)
+		{
+			wifi_dev_bus_id++;
+			restore_pcie_config(PCIE_BUS_0, PCIE_DEV_1, pcie_config_temp[PCIE_BUS_0][PCIE_DEV_1]);
+			
+		}else
+		{
+			restore_pcie_config(PCIE_BUS_0, PCIE_DEV_0, pcie_config_temp[PCIE_BUS_0][PCIE_DEV_0]);
+		}
+		restore_pcie_config(wifi_dev_bus_id, PCIE_DEV_0, pcie_config_temp[wifi_dev_bus_id][PCIE_DEV_0]);
+		
+		if(wifi_dev_bus_id != -1){
+			wifiDeviceId = pcie_read_config_word(PCIE_TYPE_DEV, wifi_dev_bus_id, PCIE_DEV_0, 0) >> 16;
+#ifdef ESD_DEBUG					
+			prom_printf("wifi 5g DeviceID %x\n",wifiDeviceId);
+#endif
+		}
+		pcie_int_enable(ENABLE, 1);
+		pcie_timeout_disable();
+	}else{
+		printk("RC1 Dead\n");
+		ret += 1;
+	}	
+
+	if(ret > 1)
+		return -1;
+	
+	return 0;
+}
+#endif
+
+void pcie_check(char force){
+	uint32 val, addr;
+	unsigned long flags;
+	char need_reset = 0;
+
+	if(pcie_soft_patch == 0){
+		return;
+	}
+
+	spin_lock_irqsave(&pcie_esd_lock, flags);	
+	if(pcie_reset_condiction == PCIE_RESET_CON_BUSTIMEOUT){
+		//Read Config 0 for RC0/RC1 to generate Bustime out
+		if(force == 0){
+			if(rc0_is_exist){
+				val = regRead32(0xbfb82034);
+			}	
+			if(rc1_is_exist){
+				val = regRead32(0xbfb83034);	
+			}
+			if(regRead32(CR_PRATIR)){
+				//bus timeout happened
+				addr = regRead32(CR_ERR_ADDR);
+				if(((addr >= 0x1fb80000) && (addr <= 0x1fb83fff)) 
+					|| ((addr >= 0x20000000) && (addr <= 0x2fffffff)) )
+				{
+					#if defined(TCSUPPORT_CPU_MT7505)
+					if(isMT7505 || isEN751221){
+						regWrite32(CR_PRATIR, 1);
+					}
+					else
+					#endif
+					{
+					regWrite32(CR_PRATIR, 0);
+					}
+					printk("check bustimeout and reset %lx\n",addr);
+					need_reset = 1;
+				}
+			}	
+		}else{
+			addr = regRead32(CR_ERR_ADDR);
+			if(((addr >= 0x1fb80000) && (addr <= 0x1fb83fff)) 
+				|| ((addr >= 0x20000000) && (addr <= 0x2fffffff)) )
+			{
+				#if defined(TCSUPPORT_CPU_MT7505)
+				if(isMT7505 || isEN751221){
+					regWrite32(CR_PRATIR, 1);
+				}
+				else
+				#endif
+				{
+				regWrite32(CR_PRATIR, 0);
+				}
+				printk("bustimeout int and reset %lx\n",addr);
+				need_reset = 1;
+			}
+		}	
+
+		if(need_reset){	
+			if(rc0_is_exist){
+				if(pcie_reset_handler(0) == 0){
+					ahb_status = 1;
+				}
+			}	
+			if(rc1_is_exist){
+				if(pcie_reset_handler(1) == 0){
+					ahb_status = 1;
+				}
+			}	
+		}
+	}else if(pcie_reset_condiction == PCIE_RESET_CON_PCIEERROR){
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER	
+		/*use pcie_reset_handler_o() do reset(63368 reset rc0 & rc1 using one register one bit)*/
+		if(pcie_reset_handler_o() == 0){
+			ahb_status = 1;
+		}
+#else
+		val = regRead32(0xbfb80060);
+		if((val & (1<<1)) != 0){
+			regWrite32(0xbfb82070, 1); //clear interrupt status
+			regWrite32(0xbfb82070, 0); //set interrupt status
+		
+			if(pcie_reset_handler(0) == 0){
+				ahb_status = 1;
+			}
+		}
+		if((val & (1<<2)) != 0){
+			regWrite32(0xbfb83070, 1); //clear interrupt status
+			regWrite32(0xbfb83070, 0); //set interrupt status
+
+			if(pcie_reset_handler(1) == 0){
+				ahb_status = 1;
+			}
+			
+		}
+#if defined(TCSUPPORT_BONDING)	
+		if((val & (1<<0)) != 0){
+			if(slaveVirBaseAddr == 0){
+				spin_unlock_irqrestore(&pcie_esd_lock, flags);
+				printk("No slaveVirBaseAddr\n");
+				return;
+			}	
+			regWrite32(slaveVirBaseAddr + 0xb83070, 1); //clear interrupt status
+			regWrite32(slaveVirBaseAddr + 0xb83070, 0); //set interrupt status
+		
+			if(pcie_reset_handler(2) == 0){
+				ahb_status = 1;
+			}
+		}
+#endif
+#endif
+	}
+	spin_unlock_irqrestore(&pcie_esd_lock, flags);
+	return;
+}
+
+void setahbstat(int val){
+		ahb_status = val;
+}
+EXPORT_SYMBOL(setahbstat);
+
+void pcieReset(void){	
+	int i;
+	unsigned long tmp;
+	
+	if(isRT63165){
+		return;		
+	}
+	if(isRT63365){
+		//disable interrupt
+		if(dual_band_support){
+			tmp = regRead32(0xbfb8000c);
+			regWrite32(0xbfb8000c, (tmp & (~((1<<20) | (1<<21)) )));
+		}else{
+			tmp = regRead32(0xbfb8000c);
+			regWrite32(0xbfb8000c, (tmp & ~(1<<20)));
+		}	
+		mdelay(5);
+		//PCI-E reset
+		if (isFPGA) {		
+			//FPGA mode
+			tmp = regRead32(0xbfb00834);
+			regWrite32(0xbfb00834, (tmp & ~(1<<26)));
+			mdelay(1);
+			tmp = regRead32(0xbfb00834);
+			regWrite32(0xbfb00834, (tmp | (1<<26)));
+			mdelay(1);
+		}else{	
+			//rt63368 enable pci-e port1 and port1 do not have power will cause hang. shnwind.
+			if(dual_band_support){
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp &  (~((1<<26) | (1<<27) | (1<<29)))));
+				mdelay(1);
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp | ((1<<26) | (1<<27) | (1<<29))));
+				#ifdef MT7592
+				mdelay(100);
+				#else
+				mdelay(1);
+				#endif
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp &  (~((1<<26) | (1<<27) | (1<<29)))));
+				mdelay(1);
+			}else{
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<29)))));
+				mdelay(1);
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp | ((1<<26) | (1<<29))));
+				#ifdef MT7592
+				mdelay(100);
+				#else
+				mdelay(1);
+				#endif
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<29)))));
+				mdelay(1);
+			}	
+		}		
+
+		tmp = regRead32(0xbfb80000);
+		regWrite32(0xbfb80000, (tmp | (1<<1)));
+		mdelay(1);
+		tmp = regRead32(0xbfb80000);
+		regWrite32(0xbfb80000, (tmp & ~(1<<1)));
+		mdelay(1);
+		//wait device link up
+		for(i=0 ; i<1000 ; i++){
+			mdelay(1);
+			if(dual_band_support){
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+				/*need to dualband all up*/
+				if(isRC0_LINKUP && isRC1_LINKUP){
+#else
+				if(isRC0_LINKUP || isRC1_LINKUP){
+#endif
+					break;
+				}	
+			}else{
+				if(isRC0_LINKUP){
+					break;
+				}
+			}	
+		}
+		if(i == 1000){
+			printk("PCI-E RC can not link up\n");
+			return ;
+		}
+		if(dual_band_support){		
+			if(isRC0_LINKUP){
+				//config PCI-E RC
+				regWrite32(0xbfb82010, 0xffff0001); //disable support BAR0
+
+				//change class PCI-PCI Bridge
+				regWrite32(0xbfb82034, 0x06040001);
+			}else{
+				//disable port 0
+				tmp = regRead32(0xbfb00088);
+				regWrite32(0xbfb00088, (tmp & ~(1<<23)));
+				mdelay(1);
+			}
+
+			if(isRC1_LINKUP){
+				//config PCI-E RC
+				regWrite32(0xbfb83010, 0xffff0001); //disable support BAR0
+
+				//change class PCI-PCI Bridge
+				regWrite32(0xbfb83034, 0x06040001);
+			}else{
+				//disable port 1
+				tmp = regRead32(0xbfb00088);
+				regWrite32(0xbfb00088, (tmp & ~(1<<22)));
+				mdelay(1);
+			}
+		}else{
+			//config PCI-E RC
+			regWrite32(0xbfb82010, 0xffff0001); //disable support BAR0
+
+			//change class PCI-PCI Bridge
+			regWrite32(0xbfb82034, 0x06040001);
+		}	
+		
+		//Enable CRC count .
+		regWrite32(KSEG1ADDR(pcie_config_addr), 0x118);
+		tmp = regRead32(KSEG1ADDR(pcie_config_data));
+		regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+
+	}else{
+		tmp = regRead32(CR_AHB_PCIC);
+		regWrite32(CR_AHB_PCIC, (tmp & ~(1<<29)));
+		mdelay(5);
+		tmp = regRead32(CR_AHB_PCIC);
+		regWrite32(CR_AHB_PCIC, (tmp & ~(1<<30)));
+		mdelay(5);
+		tmp = regRead32(CR_AHB_PCIC);
+		regWrite32(CR_AHB_PCIC, (tmp | (1<<29)));
+		mdelay(5);
+		tmp = regRead32(CR_AHB_PCIC);
+		regWrite32(CR_AHB_PCIC, (tmp | (1<<30)));
+		mdelay(5);
+		/*force link up, workaround the pcie hardware problems.*/
+		if(isTC3162U){
+			regWrite32(KSEG1ADDR(pcie_config_addr), 0x40);
+			regWrite32(KSEG1ADDR(pcie_config_data), 0x20);
+		}
+	}
+}
+
+EXPORT_SYMBOL(pcieReset);
+
+
+void pcieResetRC0(void){
+	unsigned long tmp;
+
+	if(!isMT751020 && !isMT7505 && !isEN751221){
+		return;
+	}
+
+	pcie_int_enable(DISABLE, 0);
+	mdelay(5);
+
+	//PCI-E reset
+	tmp = regRead32(0xbfb00834);
+	regWrite32(0xbfb00834, (tmp & (~(1<<26))));
+	mdelay(1);
+	regWrite32(0xbfb00834, (tmp | (1<<26)));
+#ifdef MT7592
+			mdelay(100);
+#else
+			mdelay(1);
+#endif
+	regWrite32(0xbfb00834, (tmp & (~(1<<26))));
+	mdelay(1);
+
+#if defined(TCSUPPORT_BONDING)
+	//printk("reset slave chip \n");
+	tmp = regRead32(0xbfbf0214);
+	regWrite32(0xbfbf0214, (tmp | (1<<6)));
+	tmp = regRead32(0xbfbf0234);
+	regWrite32(0xbfbf0234, (tmp & ~(1<<6)));
+	tmp = regRead32(0xbfbf021c);
+	regWrite32(0xbfbf021c, (tmp & (~((1<<12) | (1<<13)))));
+	tmp = regRead32(0xbfbf0200);
+	regWrite32(0xbfbf0200, (tmp & ~(1<<13)));
+	tmp = regRead32(0xbfbf0200);
+	regWrite32(0xbfbf0200, (tmp | (1<<12)));
+	if (isFPGA) {
+		//printk("isFPGA \n");
+		tmp = regRead32(0xbfbf0204);
+		regWrite32(0xbfbf0204, (tmp | (1<<6)));
+		mdelay(1);
+		tmp = regRead32(0xbfbf0204);
+		regWrite32(0xbfbf0204, (tmp & ~(1<<6)));
+	}else{
+		tmp = regRead32(0xbfbf0204);
+		regWrite32(0xbfbf0204, (tmp & ~(1<<6)));
+		mdelay(1);
+		tmp = regRead32(0xbfbf0204);
+		regWrite32(0xbfbf0204, (tmp | (1<<6)));
+	}
+	tmp = regRead32(0xbfbf0214);
+	regWrite32(0xbfbf0214, (tmp & ~(1<<6)));
+
+	//disable VC1
+	regWrite32(0xbfb80020, 0x160);
+	regWrite32(0xbfb80024, 0x0);
+#endif
+        if(isMT7505 || isEN751221)
+        {
+                tmp = regRead32(0xbfb00088);
+                regWrite32(0xbfb00088, (tmp | ((1<<29) | (1<<26))));
+        }	
+        else
+        {
+	        tmp = regRead32(0xbfb80000);
+	        regWrite32(0xbfb80000, (tmp & (~((1<<1) | (1<<2)))));
+        }
+	//wait device link up
+	mdelay(250);
+	//printk("#isRC0_LINKUP=%x \n", isRC0_LINKUP);
+#if defined(TCSUPPORT_BONDING)
+	//printk("isSLAVERC_LINKUP=%x \n", isSLAVERC_LINKUP);
+#endif
+
+	if(isRC0_LINKUP){
+		//config PCI-E RC
+		regWrite32(0xbfb82010, 0xffff0001); //disable support BAR0
+
+		//change class PCI-PCI Bridge
+		regWrite32(0xbfb82034, 0x06040001);
+
+		//Enable CRC count .
+		regWrite32(KSEG1ADDR(pcie_config_addr), 0x118);
+		tmp = regRead32(KSEG1ADDR(pcie_config_data));
+		regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+		pcie_phy_force_mode_en(ENABLE, 0);
+	}else{
+		//disable port 0
+		tmp = regRead32(0xbfb00088);
+		regWrite32(0xbfb00088, (tmp & ~(1<<23)));
+		mdelay(1);
+	}
+
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+	if(isSLAVERC_LINKUP){
+		pcie_phy_force_mode_en(ENABLE, 2);
+	}
+	else{
+		//disable slave RC
+		tmp = regRead32(0xbfb00088);
+		regWrite32(0xbfb00088, (tmp & ~(1<<24)));
+		mdelay(1);
+	}
+#endif
+
+
+	return;
+}
+EXPORT_SYMBOL(pcieResetRC0);
+
+void pcieResetRC1(void){
+	unsigned long tmp;
+
+	if(!isMT751020){
+		return;
+	}
+
+	pcie_int_enable(DISABLE, 1);
+	mdelay(5);
+
+	//PCI-E reset
+	tmp = regRead32(0xbfb00834);
+	regWrite32(0xbfb00834, (tmp & ~(1<<27)));
+	mdelay(1);
+	regWrite32(0xbfb00834, (tmp | (1<<27)));
+#ifdef MT7592
+			mdelay(100);
+#else
+			mdelay(1);
+#endif
+	regWrite32(0xbfb00834, (tmp & ~(1<<27)));
+	mdelay(1);
+
+	tmp = regRead32(0xbfb80000);
+	regWrite32(0xbfb80000, (tmp & (~((1<<1) | (1<<2)))));
+	//wait device link up
+	mdelay(250);
+	//printk("isRC1_LINKUP=%d \n", isRC1_LINKUP);;
+	if(isRC1_LINKUP){
+		//config PCI-E RC
+		regWrite32(0xbfb83010, 0xffff0001); //disable support BAR0
+
+		//change class PCI-PCI Bridge
+		regWrite32(0xbfb83034, 0x06040001);
+
+		//Enable RC1 ECRC count . //bus0, dev1
+		regWrite32(KSEG1ADDR(pcie_config_addr), 0x80118);
+		tmp = regRead32(KSEG1ADDR(pcie_config_data));
+		regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+		pcie_phy_force_mode_en(ENABLE, 1);
+	}else{
+		//disable port 1
+		tmp = regRead32(0xbfb00088);
+		regWrite32(0xbfb00088, (tmp & ~(1<<22)));
+		mdelay(1);
+	}
+
+	return;
+}
+
+
+extern spinlock_t pcie_lock;
+
+int mt7512_pcie_is_slave()
+{
+	if (isFPGA)
+		return (regRead32(0xbfb0008c) & (1 << 30)) == (1 << 30)?1:0;
+
+	return (regRead32(0xbfb0008c) & (1 << 5)) == 0?1:0;
+}
+
+static int get_rc_port(unsigned char bus,unsigned char dev)
+{
+	int rc = 2;
+
+	if (mt7512_pcie_is_slave())
+	{
+		if ((bus == 0) && (dev < 2))
+			rc = dev ;
+		 else if ((bus == 1) && (dev == 0) && isRC1_LINKUP)
+			rc = 1 ;
+	}
+	else
+	{
+                	if ((bus == 0) && (dev < 2))
+                  {
+                		rc = dev;
+                	}
+                  else if ((bus == 1) && (dev == 0) && isRC0_LINKUP)
+                  {           
+                	         rc = 0;
+                	}
+                  else if ((bus == 2) && (dev == 0) && isRC1_LINKUP)
+                  {
+                		rc = 1;
+                	}
+	}
+	return rc;
+}
+
+int pcie_write_config_word_extend(unsigned char bus, unsigned char dev,unsigned char func, unsigned int reg, unsigned long int value)
+{
+	unsigned int val,rc,offset = 0;
+	unsigned long flags;
+
+	rc = get_rc_port(bus,dev);
+
+	if (rc == 0){
+		offset = 0x1000;
+	}else if(rc == 1){
+		offset = 0x3000;
+	}else{
+		printk("pcie_write err: rc = %d",rc);
+		return 0;
+	}	
+
+	spin_lock_irqsave(&pcie_lock, flags);
+
+	/*mt=2|type=4|length=1 */
+	val = (2 << 29) | (4 << 24) | 1;  
+
+	 /* write TLP Header offset 0-3 */
+	regWrite32(0xbfb80460+offset, val);   
+
+	/*write requester ID */
+	val = (rc<<19) | 0x070f;						
+
+	/*write TLP Header offset 4-7 */
+	regWrite32(0xbfb80464+offset, val);    
+	
+	val = (bus << 24) | (dev << 19) |(func << 16) | reg;
+
+	 /*write TLP Header offset 8-11 */
+	regWrite32(0xbfb80468+offset, val);  
+
+	/*write TLP data */
+	regWrite32(0xbfb80470+offset, value);    
+
+	/*start TLP Requuest */
+	regWrite32(0xbfb80488+offset, 1);   
+
+	mdelay(1);
+
+	val = 0;
+
+	/*polling TLP Request status */
+	while((val++)<10)             
+	{
+	 	/*TLP Request finished or timeout */
+		if ((regRead32(0xbfb80488+offset)&0x1)==0) 
+			break;
+		mdelay(1);
+	}
+	
+	spin_unlock_irqrestore(&pcie_lock, flags);
+
+	if (val==10)
+		printk("\nPCIE Write Err: bus = %d, dev = %d Reg = %d",bus,dev,reg);
+
+ 	return 0;
+
+}
+EXPORT_SYMBOL(pcie_write_config_word_extend);
+
+
+unsigned int pcie_read_config_word_extend(unsigned char bus,unsigned char dev,unsigned char func ,unsigned int reg)
+{
+	unsigned long flags;
+	unsigned int val,rc, offset = 0;
+	if (mt7512_pcie_is_slave()){
+		if ((bus == 0) && (dev == 0) && (reg == 0))
+			return 0xffffffff;
+	}
+	
+	rc = get_rc_port(bus,dev);
+
+	
+	if (rc == 0){
+		offset = 0x1000;
+	}else if(rc == 1){
+		offset = 0x3000;
+	}else{
+		return 0xffffffff;
+	}
+	spin_lock_irqsave(&pcie_lock, flags);
+
+	/* iniitialize the data reg */
+	regWrite32(0xbfb8048c+offset, 0xffffffff);	
+
+	/*fmt=2|type=4|length=1 */
+	val = (4 << 24) | 1;  
+
+	/*write TLP Header offset 0-3 */
+	regWrite32(0xbfb80460+offset, val);
+	
+	/*write requester ID */
+	val = (rc << 19) | 0x070f;					
+
+	/*write TLP Header offset 4-7*/
+	regWrite32(0xbfb80464+offset, val);	
+
+	val = (bus << 24) | (dev << 19) | (func << 16) | reg;
+
+	/*write TLP Header offset 8-11*/
+	regWrite32(0xbfb80468+offset, val);	
+
+	/*start TLP Requuest*/
+	regWrite32(0xbfb80488+offset, 1);	
+
+	mdelay(1);
+
+	val = 0;
+
+	/*polling TLP Request status */
+	while((val++)<10)           
+	{
+		/*TLP Request finished or timeout*/
+		if ((regRead32(0xbfb80488+offset)&0x1)==0)  
+			break;
+		mdelay(1);
+	}
+
+	if (val==10)
+	{
+		printk("\n pcie_read_timeout: bus = %d, dev = %d, func = %d,reg = %d val = %x",bus,dev,func,reg,0xffffffff);
+		return 0xffffffff;
+	}
+
+	/*return the data from data reg*/
+	val = regRead32(0xbfb8048c+offset);      
+	
+	spin_unlock_irqrestore(&pcie_lock, flags);
+	
+	return val;
+}
+
+EXPORT_SYMBOL(pcie_read_config_word_extend);
+
+
+void mt7512_pcie_reset(void)
+{
+	unsigned int tmp;
+
+	/* enabled PCIe port 1 */
+	tmp = regRead32(0xbfb00088);
+	regWrite32(0xbfb00088, (tmp | (1<<22)));
+	mdelay(1);
+	
+	/*first reset to default*/
+         if(mt7512_pcie_is_slave() == 0)
+         {
+                	tmp = regRead32(0xbfb00834);
+                	regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<27) | (1<<29)))));
+                	mdelay(1);
+                	tmp = regRead32(0xbfb00834);
+                	regWrite32(0xbfb00834, (tmp | ((1<<26) | (1<<27) | (1<<29))));
+                	mdelay(100);
+                	tmp = regRead32(0xbfb00834);
+                	regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<27) | (1<<29)))));
+                	mdelay(1);
+         }
+         else
+         {
+                  
+                  tmp = regRead32(0xbfb00834);
+                	regWrite32(0xbfb00834, (tmp & (~((1<<27) ))));
+                	mdelay(1);
+                	tmp = regRead32(0xbfb00834);
+                	regWrite32(0xbfb00834, (tmp | ((1<<27) )));
+                	mdelay(100);
+                	tmp = regRead32(0xbfb00834);
+                	regWrite32(0xbfb00834, (tmp & (~((1<<27) ))));
+                	mdelay(1);
+                  
+         }
+         /*release device*/
+         tmp = regRead32(0xbfb00088);
+         regWrite32(0xbfb00088, (tmp & (~((1<<29) | (1<<26)))));
+         mdelay(1);
+         tmp = regRead32(0xbfb00088);
+         regWrite32(0xbfb00088, (tmp | ((1<<29) | (1<<26))));
+         /*
+	if(mt7512_pcie_is_slave() == 0)
+         {
+                	tmp = regRead32(0xbfb00088);
+                	regWrite32(0xbfb00088, (tmp & (~((1<<29) | (1<<26)))));
+                	mdelay(1);
+                	tmp = regRead32(0xbfb00088);
+                	regWrite32(0xbfb00088, (tmp | ((1<<29) | (1<<26))));
+         }
+         else
+         {
+
+                tmp = regRead32(0xbfb00088);
+                regWrite32(0xbfb00088, (tmp & (~((1<<29)))));
+                mdelay(1);
+                tmp = regRead32(0xbfb00088);
+                regWrite32(0xbfb00088, (tmp | ((1<<29))));
+                
+         }
+	*/
+	/*wait link up*/
+	mdelay(250);
+
+
+	if (mt7512_pcie_is_slave() == 0)
+	{
+	        /*change RC0 class to pci-pci class*/
+		regWrite32(0xbfb81104, 0x06040001);
+		mdelay(1);	
+
+		/*set pcie host mode*/
+		regWrite32(0xbfb81000, 0x804201);
+		mdelay(1);	
+	}	
+	/*change RC1 class to pci-pci class */
+	regWrite32(0xbfb83104, 0x06040001);
+	mdelay(1);	
+
+	/*set pcie host mode*/
+	regWrite32(0xbfb83000, 0x804201);
+	mdelay(1);
+	
+	return ;
+}
+
+EXPORT_SYMBOL(mt7512_pcie_reset);
+
+
+void mt7512_pcie_set_mac(void)
+{
+	unsigned int tmp;
+
+	if(isRC0_LINKUP && (mt7512_pcie_is_slave() == 0) ){
+			
+		/*disable MSI interrupt*/
+		tmp = regRead32(0xbfb8111c);
+		regWrite32(0xbfb8111c, tmp & (~(1<<5)));
+		mdelay(1);
+					
+		/*Enable Interrupt*/
+		tmp = regRead32(0xbfb81420);
+		regWrite32(0xbfb81420, tmp & (~(1<<16)));
+		mdelay(1);
+
+		/* Enable PCIE Error Interrupt */
+		tmp = regRead32(0xbfb80040);
+		regWrite32(0xbfb80040, tmp | 0x03);
+		mdelay(1);
+
+	}
+	
+	if(isRC1_LINKUP){		
+		/*disable MSI interrupt*/
+		tmp = regRead32(0xbfb8311c);
+		regWrite32(0xbfb8311c, tmp & (~(1<<5)));
+		mdelay(1);
+					
+		/*Enable Interrupt*/
+		tmp = regRead32(0xbfb83420);
+		regWrite32(0xbfb83420, tmp & (~(1<<16)));
+		mdelay(1);
+
+		/*Enable PCIE Error Interrupt */
+		tmp = regRead32(0xbfb80040);
+		regWrite32(0xbfb80040, tmp | 0x0c);
+		mdelay(1);
+
+	}
+	
+	return;
+}
+EXPORT_SYMBOL(mt7512_pcie_set_mac);
+
+int pcie_write_config_word(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum, unsigned long int value)
+{
+	if (isEN751221)
+		return pcie_write_config_word_extend(bus,devnum,0,regnum,value);
+
+	if(isRT63165 || isRT63365 || isMT751020 || isMT7505){
+		regWrite32(KSEG1ADDR(pcie_config_addr), (bus<<24 |devnum<<19|regnum));
+	}else{
+		regWrite32(KSEG1ADDR(pcie_config_addr), (type<<31|bus<<20 |devnum<<15|regnum));
+	}	
+	regWrite32(KSEG1ADDR(pcie_config_data), value);
+
+	return 0;
+}
+int pcie_write_config_byte(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum, unsigned char value)
+{
+	if(isRT63165 || isRT63365 || isMT751020 || isMT7505){
+		regWrite32(KSEG1ADDR(pcie_config_addr), (bus<<24 |devnum<<19|regnum));
+	}else{
+		regWrite32(KSEG1ADDR(pcie_config_addr), (type<<31|bus<<20 |devnum<<15|regnum));
+	}	
+	regWrite32(KSEG1ADDR(pcie_config_data), value);
+
+	return 0;
+}
+unsigned long int pcie_read_config_word(unsigned char type, unsigned char bus, unsigned char devnum, unsigned int regnum)
+{
+
+	if (isEN751221)
+			return pcie_read_config_word_extend(bus,devnum,0,regnum);
+
+	if(isRT63165 || isRT63365 || isMT751020 || isMT7505){
+		regWrite32(KSEG1ADDR(pcie_config_addr), (bus<<24 |devnum<<19|regnum));
+	}else{	
+		regWrite32(KSEG1ADDR(pcie_config_addr), (type<<31|bus<<20|devnum<<15|regnum));
+	}
+	return regRead32(KSEG1ADDR(pcie_config_data));
+}
+#if (defined(TCSUPPORT_POWERSAVE_ENABLE) && (defined(TCSUPPORT_CPU_MT7510) || defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7505)))
+EXPORT_SYMBOL(pcie_write_config_word);
+EXPORT_SYMBOL(pcie_read_config_word);
+#endif
+int pcieRegInitConfig(void)
+{
+	unsigned int reg1_val, reg2_val;
+	unsigned int reg_val = 0;
+	int i = 0;
+	int slot;
+	int pci_device_exist = 0;
+	unsigned long tmp;
+
+	if(isRT63165){
+		return 0;		
+	}
+
+	/* PCIe init module */
+	/* reset PCIe module */
+	/*
+	 * From: TC/Li Fengbo 
+	 * To: 'krammer' ; 'Marshall Yen \
+	 * Cc: 'Liu, Shuenn-Ren' ; 'Graham Fan\
+	 * Sent: Friday, May 22, 2009 2:49 PM
+	 * Subject: new pof for software reboot
+	 *
+	 * Dear both,
+	 * I have generated a new pof for software reboot, the pof file name is 
+	 * software_reboot_20090522.pof
+	 * It has been transported to Hsingchu, please help to check it
+	 * Software Reset User Guide:
+	 * After power on, there are two steps to active PCIe System
+	 * 1 Wait for minimum 50us, Write 隆搂1隆篓 to bit 29 of Register bfb0_0088, then
+	 * 2 Wait for minimum 3.5us, write 隆搂1隆篓 to bit 30 of Register bfb0_0088
+	 * 
+	 * Before do software reboot, 
+	 * 1 Write 隆搂0隆篓 to bit 29 and bit 30 of Register bfb0_0088
+	 * Then reset for PCIE system is completed, you can reboot system
+	 * Don隆娄t forget to release PCIe reset
+	 * 2 Wait for minimum 50us , Write 隆搂1隆篓 to bit 29 of bfb0_0088, then
+	 * 3 Wait for minimum 3.5us, write 隆搂1隆篓 to bit 30 of bfb0_0088
+	 *
+	 * Best regards
+	 * Fengbo Li
+	 *
+	 */
+	/* pcie fixup start */
+	/* setup COMMAND register */
+	pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x04, 0x00100007);
+
+	/* setup CACHE_LINE_SIZE register */
+	if(isRT63365){
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x0c, 0x00010000);
+	}else{	
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x0c/*PCI_CACHE_LINE_SIZE*/, 0x00000008);//duoduo_20090701
+	}	
+	/* setup LATENCY_TIMER register */
+	/* pcie fixup end */
+	/*setup secondary bus number*/
+	/*setup subordinate bus number*/
+	pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x18, 0x00010100);
+	/*setup I/O Base register*/
+	if(isRT63365){
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x30, 0x0);
+	}else{	
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x30, 0x0000FFFF);
+	}
+	pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x1C, 0x000000F0);
+	/*setup memory base register*/
+	if(isRT63365){
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x20, 0x20002000);
+	}else{	
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x20, 0x1F701F70);
+	}	
+	/*setup prefetchable memory base register */
+	pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x24, 0x0000FFF0);
+	/*setup I/O Base upper 16 bits register*/
+	/*setup interrupt line register*/
+	/*setup bridge control*/
+	if(isRT63365){
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x3C, 0x00040119);
+	}else{	
+		pcie_write_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x3C, 0x0004010B);
+	}	
+
+	/* pci register 0x10 config needed or not? Linos for L2H will configure it */
+	if(isRT63365){
+		for(i = 0; i < 10; i++){
+			reg1_val = pcie_read_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x0);
+			mdelay(1);
+			//reg2_val = pcie_read_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_1, 0x0);
+			//mdelay(1);
+		}	
+		reg2_val = 0xffffffff;
+		//Enable Interrupt
+		if(isRC0_LINKUP){
+			tmp = regRead32(0xbfb8000c);
+			regWrite32(0xbfb8000c, (tmp | (1<<20)));
+		}	
+		//second band
+		if(dual_band_support){
+			if(isRC1_LINKUP){
+				tmp = regRead32(0xbfb8000c);
+				regWrite32(0xbfb8000c, (tmp | (1<<21)));
+			}	
+		}	
+	}else{	
+		do
+		{
+			mdelay(30);
+			reg_val = pcie_read_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0xe0);
+			i++;
+		}
+		while((reg_val & 0x03f00000) != 0x00100000 && i <= 10);//check the if the dev has been link up
+		for(i = 0; i < 10; i++){
+			reg1_val = pcie_read_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x0);
+			mdelay(1);
+			reg2_val = pcie_read_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_1, 0x0);
+			mdelay(1);
+		}
+	}
+	if( (reg1_val != 0xffffffff) &&
+			( (reg1_val == ((NIC3090_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID)) //duoduo_20090702
+			  || (reg1_val == ((NIC3091_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC3092_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID)) 
+			  || (reg1_val == ((NIC3390_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC5390_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))//xyyou_20101111
+			  || (reg1_val == ((NIC539F_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC7603_PCIe_DEVICE_ID <<16) |MTK_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC5392_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))) ){//xyyou wait to do
+		pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x04, 0x00100006);
+		if(isRT63365)
+			pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x10, 0x20000000);
+		else	
+			pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x10, PHYSADDR(PCI_DEVICE_MEM1)); 
+		pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x14, 0); 
+		pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x18, 0); 
+		pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x1C, 0); 
+		pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x20, 0); 
+		pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x24, 0); 
+		pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x30, 0); 
+		if(isRT63365)
+			pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x3C, 0x00000119);
+		else	
+			pcie_write_config_word(PCIE_TYPE_DEV, PCIE_BUS_DEV, PCIE_DEVNUM_0, 0x3C, 0x0000010B); 
+
+		slot = PCIE_DEVNUM_0;		
+		pci_device_exist++;
+	}
+	else if( (reg2_val != 0xffffffff) &&
+			( (reg2_val == ((NIC3090_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID)) 
+			  || (reg2_val == ((NIC3091_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg2_val == ((NIC3092_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC3390_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC5390_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC539F_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC7603_PCIe_DEVICE_ID <<16) |MTK_PCI_VENDOR_ID))
+			  || (reg1_val == ((NIC5392_PCIe_DEVICE_ID <<16) |NIC_PCI_VENDOR_ID))) ){
+		slot=PCIE_DEVNUM_1;
+		pci_device_exist++;
+	}
+	else{
+		printk("no_pci_found error case\n");
+		return -1;
+	}
+	return slot;
+}
+EXPORT_SYMBOL(pcieRegInitConfig);
+
+
+
+void pcie_init(void)
+{
+	int i, j;
+#if defined(TCSUPPORT_BONDING)
+    unsigned int regs[] = {0xbfb8200c, 0xbfb82090, 0xbfb82094};
+#endif
+	
+	/*63368 use new recover mechanism ,so need to save pcie info*/
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+	if(isRT63365 && !isRT63368){
+#else
+	if(isRT63365){
+#endif
+		return;
+	}
+
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+	if(isMT751020 || isMT7505 || isRT63368){
+#else
+	if(isMT751020 || isMT7505 || isEN751221){
+#endif
+		//Save all configuration
+		for(i=0; i<PCIE_SAVE_BUS_NUM;i++){
+			for(j=0;j<PCIE_SAVE_DEVICE_NUM;j++){
+				if(pcie_config_temp[i][j] == NULL){
+					pcie_config_temp[i][j] = save_pcie_config(i, j);
+				}	
+			}
+		}
+    #if defined(TCSUPPORT_BONDING)
+        for (i = 0; i < MAX_REG_CONFIG; i++)
+        {
+            reg_config_temp[i].reg = regs[i];
+            reg_config_temp[i].value = regRead32(regs[i]);
+        }
+    #endif
+		pcie_soft_patch = ENABLE;
+	}else{
+		pcieReset();
+		pcieRegInitConfig();
+	}	
+}
+EXPORT_SYMBOL(pcie_init);
+
+int pcie_timeout_disable(void)
+{
+	unsigned int val = 0x10;
+	unsigned int reg = 0x98;
+	unsigned int dev = 0x0;
+	unsigned int bus;
+
+	bus = 0x1;
+	if(isRC0_LINKUP){
+		//disable RC0's device timeout
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, reg, val);
+	}
+
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+	if(isSLAVERC_LINKUP){
+		bus += 1;
+
+		//disable slave RC's device timeout
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, reg, val);
+	}
+#endif
+
+	if(isRC1_LINKUP){
+		bus += 1;
+
+		//disable RC1's device timeout
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, reg, val);
+	}
+	
+	return 0;
+}
+
+#if defined(TCSUPPORT_BONDING)
+void pcie_virBaseAddr_set(unsigned long addr)
+{
+	slaveVirBaseAddr = addr;
+}
+EXPORT_SYMBOL(pcie_virBaseAddr_set);
+#endif
+
+
+void aer_config(int aerEnable)
+{
+	unsigned int advRcErrReg = 0x12c, advRcErrVal = 0x7, disAdvRcErr = 0x0;
+	unsigned int briCtrlReg = 0x3c, briCtrlVal = 0x60119, disBriCtrl = 0x40119;
+	unsigned int devCtrlReg = 0x78, devCtrlVal = 0x201f, disDevCtrl = 0x2010;
+	unsigned int dev = 0x0;
+	unsigned int bus = 0x0;
+
+
+	if(aerEnable){ // Enable AER
+		// configure RC
+		bus = 0x0;
+		dev = 0x0;
+		if(isRC0_LINKUP){
+			//Enable RC0 interrupt
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, advRcErrReg, advRcErrVal);
+			regWrite32(KSEG1ADDR(pcie_config_data), advRcErrVal);
+			//Enable RC0 error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, briCtrlReg, briCtrlVal);
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, devCtrlVal);
+		}
+		if(isRC1_LINKUP){
+			dev += 1;
+
+			//Enable RC1 interrupt
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, advRcErrReg, advRcErrVal);
+
+			//Enable RC1 error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, briCtrlReg, briCtrlVal);
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, devCtrlVal);
+		}
+
+		// configure device
+		dev = 0x0;
+		if(isRC0_LINKUP){
+			bus += 1;
+
+			//Enable EP0 error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, devCtrlVal);
+		}
+
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+		// configure slave RC & device
+		if(isSLAVERC_LINKUP){
+			dev += 1;
+
+			//Enable slave RC interrupt
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, advRcErrReg, advRcErrVal);
+
+			//Enable slave RC error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, briCtrlReg, briCtrlVal);
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, devCtrlVal);
+
+			dev = 0x0;
+			bus += 1;
+			//Enable slave wifi error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, devCtrlVal);
+		}
+#endif
+
+		// configure device
+		dev = 0x0;
+		if(isRC1_LINKUP){
+			bus += 1;
+
+			//Enable EP1 error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, devCtrlVal);
+		}
+
+	}else{ // Disable AER
+		// configure RC
+		bus = 0x0;
+		dev = 0x0;
+		if(isRC0_LINKUP){
+			//Disable RC0 interrupt
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, advRcErrReg, disAdvRcErr);
+
+			//Disable RC0 error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, briCtrlReg, disBriCtrl);
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, disDevCtrl);
+
+		}
+		if(isRC1_LINKUP){
+			dev = 0x1;
+
+			//Disable RC1 interrupt
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, advRcErrReg, disAdvRcErr);
+			
+			//Disable RC1 error report
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, briCtrlReg, disBriCtrl);
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, disDevCtrl);
+
+		}
+
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+		if(isSLAVERC_LINKUP){
+			bus += 1;
+			dev = 0x1;
+
+			//Disable slave RC interrupt
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, advRcErrReg, disAdvRcErr);
+
+			//Disable slave RC interrupt
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, briCtrlReg, disBriCtrl);
+			pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, devCtrlReg, disDevCtrl);
+
+		}
+#endif
+	}
+}
+
+static void aer_status_dump(void)
+{
+	unsigned int rootErrReg = 0x130;
+	unsigned int errSrcIdReg = 0x134;
+	unsigned int unCorErrReg = 0x104;
+	unsigned int corErrReg = 0x110;
+	unsigned int dev = 0x0;
+	unsigned int bus = 0x0;
+
+
+	if(isRC0_LINKUP){
+		printk("### RC0 ###\n");
+		//check root error status
+		printk("root error status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg));
+		//check error source ID
+		printk("error source ID=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, errSrcIdReg));
+		//check uncorrectable error status
+		printk("UN-correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg));
+		//check correctable error status
+		printk("Correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg));
+		//check error counter
+		printk("RC0 LCRC counter: 0x%x         RC0 ECRC counter: 0x%x\n",(unsigned int)regRead32(0xbfb82060),(unsigned int)regRead32(0xbfb82064));
+		printk("EP correctable counter: 0x%x   EP non-fatal counter: 0x%x \n\n",(unsigned int)regRead32(0xbfb82068),(unsigned int)regRead32(0xbfb8206c));
+	}
+
+	if(isRC1_LINKUP){
+		bus = 0x0;
+		dev = 0x1;
+
+		printk("### RC1 ###\n");
+		//check root error status
+		printk("root error status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg));
+		//check error source ID
+		printk("error source ID=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, errSrcIdReg));
+		//check uncorrectable error status
+		printk("UN-correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg));
+		//check correctable error status
+		printk("Correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg));
+		//check error counter
+		printk("RC1 LCRC counter: 0x%x         RC1 ECRC counter: 0x%x\n",(unsigned int)regRead32(0xbfb83060),(unsigned int)regRead32(0xbfb83064));
+		printk("EP correctable counter: 0x%x   EP non-fatal counter: 0x%x \n\n",(unsigned int)regRead32(0xbfb83068),(unsigned int)regRead32(0xbfb8306c));
+	}
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+
+	if(isSLAVERC_LINKUP){
+		bus = 0x0;
+		if(isRC0_LINKUP){
+			bus += 1;
+		}
+		dev = 0x1;
+
+		printk("### slave RC ###\n");
+		//check root error status
+		printk("root error status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg));
+		//check error source ID
+		printk("error source ID=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, errSrcIdReg));
+		//check uncorrectable error status
+		printk("UN-correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg));
+		//check correctable error status
+		printk("Correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg));
+		//check error counter
+		if(slaveVirBaseAddr != 0){
+			printk("slaveRC LCRC counter: 0x%x         slaveRC ECRC counter: 0x%x\n",(unsigned int)regRead32(slaveVirBaseAddr + 0xb83060),(unsigned int)regRead32(slaveVirBaseAddr + 0xb83064));
+			printk("EP correctable counter: 0x%x   EP non-fatal counter: 0x%x \n\n",(unsigned int)regRead32(slaveVirBaseAddr + 0xb83068),(unsigned int)regRead32(slaveVirBaseAddr + 0xb8306c));
+		}
+	}
+#endif
+}
+
+static void aer_status_clear(void)
+{
+	unsigned int unCorErrReg = 0x104;
+	unsigned int corErrReg = 0x110;
+	unsigned int rootErrReg = 0x130;
+	unsigned int dev = 0x0;
+	unsigned int bus = 0x0;
+	unsigned long int errStatus;
+
+	if(isRC0_LINKUP){
+		//printk("RC0\n");
+		//clear UN-correctable error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg, errStatus);
+		//printk("Clear UN-orrectable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg));
+		//clear correctable error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg, errStatus);
+		//printk("Clear Correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg));
+		//clear root error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg, errStatus);
+		//printk("Clear root error status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg));
+	}
+
+	if(isRC1_LINKUP){
+		bus = 0x0;
+		dev = 0x1;
+
+		//printk("RC1\n");
+		//clear UN-correctable error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg, errStatus);
+		//printk("Clear UN-orrectable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg));
+		//clear correctable error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg, errStatus);
+		//printk("Clear Correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg));
+		//clear root error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg, errStatus);
+		//printk("Clear root error status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg));
+	}
+
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+	if(isSLAVERC_LINKUP){
+		bus = 0x0;
+		if(isRC0_LINKUP){
+			bus += 1;
+		}
+		dev = 0x1;
+
+		//printk("slave RC\n");
+		//clear UN-correctable error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg, errStatus);
+		//printk("Clear UN-orrectable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, unCorErrReg));
+		//clear correctable error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg, errStatus);
+		//printk("Clear Correctable status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, corErrReg));
+		//clear root error status
+		errStatus = pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg);
+		pcie_write_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg, errStatus);
+		//printk("Clear root error status=0x%lx\n", pcie_read_config_word(PCIE_TYPE_DEV, bus, dev, rootErrReg));
+	}
+#endif
+}
+
+
+void
+ahbErrChk(void){
+	register uint32 status=0;
+	unsigned long flags;
+
+	if(pcie_soft_patch == 0){
+		return;
+	}
+	
+	if(isRT63365 ||  isMT7505 || isEN751221)
+		return;
+	
+	
+	if(isMT751020 || isMT7505){
+		pcie_check(0);
+	}else
+	{
+		status=regRead32(CR_AHB_AACS);
+		if((status & AHB_BUS_TIMEOUT_ERR)||(status & AHB_BUS_ADDR_ERR)){	
+			printk("CR_AHB_AACS:0x%08lx\n", status);
+			printk("CR_AHB_ABEM:0x%08lx\n", regRead32(CR_AHB_ABEM));
+			printk("CR_AHB_ABEA:0x%08lx\n", regRead32(CR_AHB_ABEA));
+			local_irq_save(flags);
+			ahb_status=1;
+			pcieReset();
+			pcieRegInitConfig();
+			local_irq_restore(flags);
+		}
+	}
+	
+
+}
+EXPORT_SYMBOL(ahbErrChk);
+
+#ifdef CONFIG_MIPS_TC3162U
+static irqreturn_t ahbErrIsr(int irq, void *dev){
+	ahbErrChk();	
+	return IRQ_HANDLED;
+}
+#endif
+
+void chkAhbErr(int force){
+	uint32 val=0;
+	unsigned long flags;
+	uint32 lcrc, ecrc;
+
+	if(pcie_soft_patch == 0){
+		return;
+	}
+
+	if(isTC3162U){
+		local_irq_save(flags);
+		/*check the pcie bus crc error counter*/
+		val= pcie_read_config_word(PCIE_TYPE_RC, PCIE_BUS_RC, PCIE_DEVNUM_0, 0x54);
+		if((val!=0x0) || (force==0x1) ){
+			/*Reset pcie and refill pcie-registers*/
+			pcieReset();
+			pcieRegInitConfig();
+			ahb_status = 1;
+		}
+		local_irq_restore(flags);
+	}
+
+	else if(isRT63365){
+		local_irq_save(flags);
+		/*check the pcie bus crc error counter*/
+		lcrc = regRead32(0xbfb82060);
+		ecrc = regRead32(0xbfb82064);
+		if((lcrc != 0xdeadbeaf) || (ecrc != 0xdeadbeaf)){
+			if((lcrc != 0x0) || (ecrc != 0x0) || (force == 0x1)){
+				#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+				/*add a new mechanism*/
+				if((lcrc+ecrc) >= pcie_error_detect_count)
+				{
+                      	                printk("PCI-E L-crc %lx E-crc %lx!!\n", lcrc, ecrc);
+					pcie_reset_condiction = PCIE_RESET_CON_PCIEERROR;
+					ahb_status = 1;
+				}
+				#else
+				printk("RC0 PCI-E L-crc %lx E-crc %lx!!\n", lcrc, ecrc);
+				/*Reset pcie and refill pcie-registers*/
+				pcieReset();
+				pcieRegInitConfig();
+				ahb_status = 1;
+				#endif
+				
+			}
+		}
+		local_irq_restore(flags);
+	}
+	
+
+}
+EXPORT_SYMBOL(chkAhbErr);
+
+static int ahb_status_read_proc(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "%d %d %d", pcie_soft_patch, ahb_status, wifiDeviceId);
+	len -= off;
+	*start = page + off;
+
+	if (len > count)
+		len = count;
+	else
+		*eof = 1;
+
+	if (len < 0)
+		len = 0;
+	
+	chkAhbErr(0);
+	return len;
+}
+
+static int ahb_status_write_proc(struct file *file, const char *buffer,
+	unsigned long count, void *data)
+{
+	char val_string[8];
+	int val=0;
+	unsigned long flags;
+
+	if (count > sizeof(val_string) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+	if(sscanf(val_string,"%d %d", &pcie_soft_patch, &val)!=2){
+		printk("usage: <onoff> <type>\n");
+		return count;
+	}
+	if(val==0x2){
+		/*Reset pcie and refill pcie-registers*/
+		local_irq_save(flags);
+		#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+		/*63368 use new mechanism*/
+		if(isMT751020 || isMT7505 || isRT63368){
+		#else
+		if(isMT751020 || isMT7505 || isEN751221){
+		#endif
+			pcie_check(0);
+		}else{	
+			pcieReset();
+			pcieRegInitConfig();
+		}
+		local_irq_restore(flags);
+	}
+	if (val == 0) /*Disable wifi interface down to up*/{
+		ahb_status = 0;
+		wifiDeviceId = 0;
+	}else{
+		ahb_status = 1;
+	}
+	return count;
+}
+
+
+
+static int pcie_rcnum_read_proc(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+	
+	
+	return 0;
+}
+
+static int pcie_rcnum_write_proc(struct file *file, const char *buffer,
+	unsigned long count, void *data)
+{
+	char val_string[8];
+	int reset_rc = -1;
+	unsigned long flags;
+
+	if (count > sizeof(val_string) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+	if(sscanf(val_string,"%d", &reset_rc)!=1){
+		printk("usage: <RC reset Number> \n");
+		return count;
+	}
+
+	if(reset_rc != -1){
+		printk("reset and recover start RC %d\n",reset_rc);
+		spin_lock_irqsave(&pcie_esd_lock, flags);	
+		pcie_reset_handler(reset_rc);
+		spin_unlock_irqrestore(&pcie_esd_lock, flags);	
+		
+		ahb_status = 1;
+	}
+	
+	return count;
+}
+static int pcie_reset_con_read_proc(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "currect pcie_reset_con %d", pcie_reset_condiction);
+	len -= off;
+	*start = page + off;
+
+	if (len > count)
+		len = count;
+	else
+		*eof = 1;
+
+	if (len < 0)
+		len = 0;
+	
+	return len;
+}
+
+static int pcie_reset_con_write_proc(struct file *file, const char *buffer,
+	unsigned long count, void *data)
+{
+	char val_string[8];
+	int value;
+
+	if (count > sizeof(val_string) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+	if(sscanf(val_string,"%d", &value)!=1){
+		printk("usage: <pcie_reset_condiction 0:bustime out 1:pcie error> \n");
+		return count;
+	}
+	pcie_reset_condiction = (char)value;
+	return count;
+}
+static int pcie_reset_count_read_proc(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "pcie_reset_count %d\n", pcie_reset_count);
+	len -= off;
+	*start = page + off;
+
+	if (len > count)
+		len = count;
+	else
+		*eof = 1;
+
+	if (len < 0)
+		len = 0;
+	
+	return len;
+}
+static int aer_status_read_proc(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+	aer_status_dump();
+
+	return 0;
+}
+
+static int aer_status_write_proc(struct file *file, const char *buffer,
+	unsigned long count, void *data)
+{
+	char val_string[5];
+	int clear=0;
+
+	if (count > sizeof(val_string) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+	sscanf(val_string,"%d", &clear);
+
+	if(clear == 1){
+		aer_status_dump();
+		aer_status_clear();
+	}
+
+	return count;
+}
+
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+/*______________________________________________________________________________
+**function name:pcie_error_detect_count_read_proc
+**
+**description:
+*   get error detect count 
+**parameters:
+*   char *page
+*   char **start
+*	off_t off
+*	int count
+*	int *eof
+*	void *data
+**global:
+*    pcie_error_detect_count
+**return:
+*    len
+**call:
+*    
+**revision:
+*     Brian.shi
+**____________________________________________________________________________*/
+
+static int pcie_error_detect_count_read_proc(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "currect pcie_error_detect_count %d", pcie_error_detect_count);
+	len -= off;
+	*start = page + off;
+
+	if (len > count)
+		len = count;
+	else
+		*eof = 1;
+
+	if (len < 0)
+		len = 0;
+	
+	return len;
+}
+/*______________________________________________________________________________
+**function name:pcie_error_detect_count_write_proc
+**
+**description:
+*   set error detect count 
+**parameters:
+*   char *page
+*   char **start
+*	off_t off
+*	int count
+*	int *eof
+*	void *data
+**global:
+*    pcie_error_detect_count
+**return:
+*    len
+**call:
+*    
+**revision:
+*     Brian.shi
+**____________________________________________________________________________*/
+
+static int pcie_error_detect_count_write_proc(struct file *file, const char *buffer,
+	unsigned long count, void *data)
+{
+	char val_string[8];
+	int value;
+
+	if (count > sizeof(val_string) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+	if(sscanf(val_string,"%d", &value)!=1){
+		printk("usage: <count:overflow will do pcie reset> \n");
+		return count;
+	}
+	pcie_error_detect_count = (char)value;
+	return count;
+}
+
+/*______________________________________________________________________________
+**function name:ahb_status_value_count_read_proc
+**
+**description:
+*   get ahb status 
+**parameters:
+*   char *page
+*   char **start
+*	off_t off
+*	int count
+*	int *eof
+*	void *data
+**global:
+*    ahb_status
+**return:
+*    len
+**call:
+*    
+**revision:
+*     Brian.shi
+**____________________________________________________________________________*/
+
+static int ahb_status_value_count_read_proc(char *page, char **start, off_t off,
+	int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "currect pcie_error_detect_count %d", ahb_status);
+	len -= off;
+	*start = page + off;
+
+	if (len > count)
+		len = count;
+	else
+		*eof = 1;
+
+	if (len < 0)
+		len = 0;
+	
+	return len;
+}
+
+/*______________________________________________________________________________
+**function name:ahb_status_value_count_write_proc
+**
+**description:
+*   set ahb status 
+**parameters:
+*   char *page
+*   char **start
+*	off_t off
+*	int count
+*	int *eof
+*	void *data
+**global:
+*    ahb_status
+**return:
+*    len
+**call:
+*    
+**revision:
+*     Brian.shi
+**____________________________________________________________________________*/
+
+static int ahb_status_value_count_write_proc(struct file *file, const char *buffer,
+	unsigned long count, void *data)
+{
+	char val_string[8];
+	int value;
+
+	if (count > sizeof(val_string) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+	if(sscanf(val_string,"%d", &value)!=1){
+		printk("usage: <count:overflow will do pcie reset> \n");
+		return count;
+	}
+	ahb_status = (char)value;
+	return count;
+}
+#endif
+
+
+#if defined(TCSUPPORT_BONDING)
+static void reset_slave_chip(void){
+	uint32 tmp;
+
+	tmp = regRead32(CR_GPIO_CTRL);
+	tmp &= ~(0x3 << (6<<1));
+	tmp |=  (0x1 << (6<<1));
+	regWrite32(CR_GPIO_CTRL, tmp);
+	tmp = regRead32(CR_GPIO_ODRAIN);
+	regWrite32(CR_GPIO_ODRAIN, (tmp | (1<<6)));
+	tmp = regRead32(CR_GPIO_DATA);
+	regWrite32(CR_GPIO_DATA, (tmp | (1<<6)));
+	udelay(1);
+	regWrite32(CR_GPIO_DATA, (tmp & (~(1<<6))));
+	udelay(1);
+	regWrite32(CR_GPIO_DATA, (tmp | (1<<6)));
+	udelay(1);
+
+}
+#endif
+int pcie_api_init(void);
+
+static __init int tc3162_pcie_init(void)
+{
+	struct proc_dir_entry *ahb_status_proc;
+	struct proc_dir_entry *aer_status_proc;
+	int i;
+	uint32 tmp;
+
+
+#ifdef TCSUPPORT_DMT_CO
+	return 0;
+#endif
+
+	if(isMT7505 || isEN751221){	
+		/*before reset host,need to pull device low*/
+		tmp = regRead32(0xbfb00088);
+		regWrite32(0xbfb00088, (tmp & (~((1<<29) | (1<<26)))));
+		mdelay(1);
+	}
+#ifdef TCSUPPORT_MT7510_E1	
+	if(isMT751020){
+		#ifndef TCSUPPORT_MT7520_PCIE
+		if (!isFPGA)
+			return -1;
+		#endif
+		/* enabled PCIe port 0,1 */
+		tmp = regRead32(0xbfb00088);
+		regWrite32(0xbfb00088, (tmp | (0x1<<22)));
+		mdelay(1);
+	}
+#endif
+	if (!isFPGA){
+#if defined(TCSUPPORT_BONDING)
+		printk("slave chip reset\n");
+		reset_slave_chip();
+#endif
+		pciePhyInit();
+	}
+	if (isEN751221){   
+
+		printk("MT7512_pcie_init\n");
+
+		tc3162_pcie_mem_resource.start = 0x20000000;
+		tc3162_pcie_mem_resource.end   = 0x2FFFFFFF;
+
+		mt7512_pcie_reset();
+		
+		printk("check pcie link up status: \n");
+		printk("isRC0_LINKUP=%d \n",isRC0_LINKUP);
+		printk("isRC1_LINKUP=%d \n",isRC1_LINKUP);
+		if((!isRC0_LINKUP) && (!isRC1_LINKUP)){
+			printk("PCI-E RC0 & RC1 can not link up\n");
+			return -1;
+		}
+		mt7512_pcie_set_mac();
+
+	}else	if(isRT63365 || isMT751020 || isMT7505){
+		if(isMT751020){
+			dual_band_support = 1;
+			printk("MT7510_pcie_init\n");
+		}
+		else if(isRT63368){
+#if defined(TCSUPPORT_DUAL_WLAN)
+			//rt63368 enable pci-e port1 and port1 do not have power will cause hang. shnwind.
+			dual_band_support = 1;
+#else
+			dual_band_support = 0;
+#endif			
+			printk("RT63368_pcie_init:%d\n",dual_band_support);
+		} else if(isMT7505){
+			printk("MT7505_pcie_init\n");
+		} else{	
+			printk("RT63365_pcie_init\n");
+		}	
+
+		//change memory mapping affress.
+		tc3162_pcie_mem_resource.start = 0x20000000;
+		tc3162_pcie_mem_resource.end   = 0x2FFFFFFF;
+
+		//change pcie addr and data window.
+		pcie_config_addr = 0x1fb80020;
+		pcie_config_data = 0x1fb80024;
+
+		//PCI-E reset
+		if(isMT751020 || isMT7505){
+			/* enabled PCIe port 1 */
+			tmp = regRead32(0xbfb00088);
+			regWrite32(0xbfb00088, (tmp | (1<<22)));
+			mdelay(1);
+#if !defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_MT7505)
+#if !defined(TCSUPPORT_XPON_HAL_API_EXT) 
+			if (!isFPGA)
+#endif
+			{
+				//set GPIO share scheme reg for PERST output
+				tmp = regRead32(0xbfb00860);
+				regWrite32(0xbfb00860, (tmp | ((1<<19) | (1<<20))));
+			}
+#endif
+			/*first reset to default*/
+			tmp = regRead32(0xbfb00834);
+			regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<27) | (1<<29)))));
+			mdelay(1);
+			tmp = regRead32(0xbfb00834);
+			regWrite32(0xbfb00834, (tmp | ((1<<26) | (1<<27) | (1<<29))));
+			#ifdef MT7592
+			mdelay(100);
+			#else
+			mdelay(1);
+			#endif
+			tmp = regRead32(0xbfb00834);
+			regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<27) | (1<<29)))));
+			mdelay(1);
+		}else{
+			if (isFPGA) {
+				//FPGA mode
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp & ~(1<<26)));
+				mdelay(1);
+				tmp = regRead32(0xbfb00834);
+				regWrite32(0xbfb00834, (tmp | (1<<26)));
+				mdelay(1);
+			}else{
+				if(dual_band_support){
+					/* enabled PCIe port 1 */
+					tmp = regRead32(0xbfb00088);
+					regWrite32(0xbfb00088, (tmp | (1<<22)));
+					mdelay(1);
+					tmp = regRead32(0xbfb00834);
+					regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<27) | (1<<29)))));
+					mdelay(1);
+					tmp = regRead32(0xbfb00834);
+					regWrite32(0xbfb00834, (tmp | ((1<<26) | (1<<27) | (1<<29))));
+					#ifdef MT7592
+					mdelay(100);
+					#else
+					mdelay(1);
+					#endif
+					tmp = regRead32(0xbfb00834);
+					regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<27) | (1<<29)))));
+					mdelay(1);
+				}else{
+					/* disabled PCIe port 1 */
+					tmp = regRead32(0xbfb00088);
+					regWrite32(0xbfb00088, (tmp & ~(1<<22)));
+					mdelay(1);
+					tmp = regRead32(0xbfb00834);
+					regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<29)))));
+					mdelay(1);
+					tmp = regRead32(0xbfb00834);
+					regWrite32(0xbfb00834, (tmp | ((1<<26) | (1<<29))));
+					#ifdef MT7592
+					mdelay(100);
+					#else
+					mdelay(1);
+					#endif
+					tmp = regRead32(0xbfb00834);
+					regWrite32(0xbfb00834, (tmp & (~((1<<26) | (1<<29)))));
+					mdelay(1);
+				}
+			}
+		}
+		if(isMT751020 || isMT7505){
+			//relese pcie device reset
+#ifndef TCSUPPORT_CPU_MT7505
+			tmp = regRead32(0xbfb80000);
+			regWrite32(0xbfb80000, (tmp & (~((1<<1) | (1<<2)))));
+			mdelay(1);
+#else
+			tmp = regRead32(0xbfb00088);
+			regWrite32(0xbfb00088, (tmp | ((1<<29) | (1<<26))));
+			mdelay(1);
+#endif
+		}else{
+			tmp = regRead32(0xbfb80000);
+			regWrite32(0xbfb80000, (tmp | (1<<1)));
+			mdelay(1);
+			tmp = regRead32(0xbfb80000);
+			regWrite32(0xbfb80000, (tmp & ~(1<<1)));
+			mdelay(1);
+		}
+
+		if (isRT63365 && (isFPGA)) {
+			//FPGA mode
+			tmp = regRead32(0xbfbc0028);
+			regWrite32(0xbfbc0028, 0x60068880);
+			regWrite32(0xbfbc0004, 0x08000002);
+			regWrite32(0xbfbc0008, 0x00000700);
+			regWrite32(0xbfbc0000, 0x00160106);
+			regWrite32(0xbfbc0028, tmp);
+		}
+
+		//wait device link up
+		mdelay(250);
+		printk("check pcie link up status: \n");
+		printk("isRC0_LINKUP=%d \n",isRC0_LINKUP);
+		if(isMT751020){
+			printk("isRC1_LINKUP=%d \n",isRC1_LINKUP);
+                        
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+			printk("isSLAVERC_LINKUP=%d \n",isSLAVERC_LINKUP);
+#endif
+			if((!isRC0_LINKUP) && (!isRC1_LINKUP)){
+				printk("PCI-E RC0 & RC1 can not link up\n");
+				return -1;
+			}
+		}else{
+			if(dual_band_support){
+				printk("isRC1_LINKUP=%d \n",isRC1_LINKUP);
+				if((!isRC0_LINKUP) && (!isRC1_LINKUP)){
+					printk("PCI-E RC can not link up\n");
+					return -1;
+				}
+			}else{
+				if(!isRC0_LINKUP){
+					printk("PCI-E RC can not link up\n");
+					return -1;
+				}
+			}
+		}
+
+
+		if(isMT751020 || isMT7505){
+			pcie_soft_patch = DISABLE; //Enable after temp all config
+			if(isRC0_LINKUP){
+				//config PCI-E RC
+				regWrite32(0xbfb82010, 0xffff0001); //disable support BAR0
+
+				//change class PCI-PCI Bridge
+				regWrite32(0xbfb82034, 0x06040001);
+
+				//Enable CRC count .
+				regWrite32(KSEG1ADDR(pcie_config_addr), 0x118);
+				tmp = regRead32(KSEG1ADDR(pcie_config_data));
+				regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+				pcie_phy_force_mode_en(ENABLE, 0);
+				rc0_is_exist = 1;
+			}else{
+				//disable port 0
+				tmp = regRead32(0xbfb00088);
+				regWrite32(0xbfb00088, (tmp & ~(1<<23)));
+				mdelay(1);
+			}
+
+			if(isRC1_LINKUP){
+				//config PCI-E RC
+				regWrite32(0xbfb83010, 0xffff0001); //disable support BAR0
+
+				//change class PCI-PCI Bridge
+				regWrite32(0xbfb83034, 0x06040001);
+
+				//Enable RC1 ECRC count . //bus0, dev1
+				regWrite32(KSEG1ADDR(pcie_config_addr), 0x80118);
+				tmp = regRead32(KSEG1ADDR(pcie_config_data));
+				regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+				pcie_phy_force_mode_en(ENABLE, 1);
+				rc1_is_exist = 1;
+			}else{
+				//disable port 1
+				tmp = regRead32(0xbfb00088);
+				regWrite32(0xbfb00088, (tmp & ~(1<<22)));
+				mdelay(1);
+			}
+
+#if defined(TCSUPPORT_BONDING) && !defined(TCSUPPORT_CPU_EN7512)
+			if(isSLAVERC_LINKUP){
+				pcie_phy_force_mode_en(ENABLE, 2);
+			}else{
+				//disable slave RC
+				tmp = regRead32(0xbfb00088);
+				regWrite32(0xbfb00088, (tmp & ~(1<<24)));
+				mdelay(1);
+			}
+#endif
+		}else{
+			if(dual_band_support){
+				if(isRC0_LINKUP){
+					//config PCI-E RC
+					regWrite32(0xbfb82010, 0xffff0001); //disable support BAR0
+
+					//change class PCI-PCI Bridge
+					regWrite32(0xbfb82034, 0x06040001);
+
+					//Enable CRC count .
+					regWrite32(KSEG1ADDR(pcie_config_addr), 0x118);
+					tmp = regRead32(KSEG1ADDR(pcie_config_data));
+					regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+				}else{
+					//disable port 0
+					tmp = regRead32(0xbfb00088);
+					regWrite32(0xbfb00088, (tmp & ~(1<<23)));
+					mdelay(1);
+				}
+
+				if(isRC1_LINKUP){
+					//config PCI-E RC
+					regWrite32(0xbfb83010, 0xffff0001); //disable support BAR0
+
+					//change class PCI-PCI Bridge
+					regWrite32(0xbfb83034, 0x06040001);
+
+					//Enable RC1 ECRC count . //bus0, dev1
+					regWrite32(KSEG1ADDR(pcie_config_addr), 0x80118);
+					tmp = regRead32(KSEG1ADDR(pcie_config_data));
+					regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+				}else{
+					//disable port 1
+					tmp = regRead32(0xbfb00088);
+					regWrite32(0xbfb00088, (tmp & ~(1<<22)));
+					mdelay(1);
+				}
+			}else{
+				//config PCI-E RC
+				regWrite32(0xbfb82010, 0xffff0001); //disable support BAR0
+
+				//change class PCI-PCI Bridge
+				regWrite32(0xbfb82034, 0x06040001);
+
+				//Enable CRC count .
+				regWrite32(KSEG1ADDR(pcie_config_addr), 0x118);
+				tmp = regRead32(KSEG1ADDR(pcie_config_data));
+				regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+			}
+		}
+#if defined(TCSUPPORT_CPU_RT63368) ||defined(TCSUPPORT_CPU_MT7520) || defined(TCSUPPORT_CPU_MT7510)|| defined(TCSUPPORT_CPU_MT7505)
+#ifdef TCSUPPORT_WLAN_MT7592_PCIE
+	preConfigLDO();
+#endif
+#endif
+	}
+	else if(isRT63165){
+		
+		printk("RT63165_pcie_init\n");
+		tmp = regRead32(CR_AHB_PCIC);
+		regWrite32(CR_AHB_PCIC, (tmp | (1<<29)));
+		mdelay(1);
+		tmp = regRead32(CR_AHB_PCIC);
+		regWrite32(CR_AHB_PCIC, (tmp | (1<<30)));
+		mdelay(1);
+		//wait device link up
+		for(i=0 ; i<1000 ; i++){
+			mdelay(1);
+			if((regRead32(0xbfb81050) & 0x1) != 0){
+				break;
+			}	
+		}
+		if(i == 1000){
+			printk("PCI-E RC can not link up\n");
+			return -1;
+		}
+		regWrite32(0xbfb81cf8, 0x0);
+		if((regRead32(0xbfb81cfc) & 0xffff) == 0xffff){
+			printk("No PCI-E device found\n");
+			return -1;
+		}
+
+		//config PCI-E RC
+		regWrite32(0xbfb81010, 0xffff0001); //not support BAR0
+		//check has device or not 
+		regWrite32(0xbfb81034, 0x06040001); //change class PCI-PCI Bridge
+		//set pci-e burst size
+		//regWrite32(0xbfb81060, 0x3);
+		//Enable CRC count .
+		regWrite32(KSEG1ADDR(pcie_config_addr), 0x118);
+		tmp = regRead32(KSEG1ADDR(pcie_config_data));
+		regWrite32(KSEG1ADDR(pcie_config_data), (tmp | (1<<8)));
+	}else{
+	printk("tc3162_pcie_init\n");
+#ifdef CONFIG_MIPS_TC3262
+	regWrite32(0xbfb000b8, 0x00000001);
+#endif 
+
+#if defined(CONFIG_MIPS_TC3162U) || defined(CONFIG_MIPS_TC3262)
+	/*pcie relate clock setting*/
+	tmp = regRead32(CR_AHB_SSR);
+	//tmp &= ~(1<<0 | 1<<2 | 1<<3 | 1<<4);
+	//tmp |= (1<<0 | 1<<2 | 1<<3 | 1<<4);
+	/*use internal clock,*/
+	tmp &= ~(1<<0 | 1<<2 | 1<<3);
+	tmp |= (1<<0 | 1<<2 | 1<<3);
+	regWrite32(CR_AHB_SSR, tmp);
+	mdelay(1);
+#endif
+
+	//tmp = regRead32(CR_AHB_PCIC);
+	//regWrite32(CR_AHB_PCIC), (tmp & ~(1<<29)));
+	//mdelay(5);
+	//tmp = regRead32(CR_AHB_PCIC);
+	//regWrite32(CR_AHB_PCIC), (tmp & ~(1<<30)));
+	//mdelay(5);
+
+	tmp = regRead32(CR_AHB_PCIC);
+	regWrite32(CR_AHB_PCIC, (tmp | (1<<29)));
+	mdelay(5);
+	tmp = regRead32(CR_AHB_PCIC);
+	regWrite32(CR_AHB_PCIC, (tmp | (1<<30)));
+	mdelay(5);
+
+#ifdef CONFIG_MIPS_TC3162U
+	/*work arround for pcie link up*/
+	regWrite32(PCIE_CONFIG_ADDR, 0x40);
+	regWrite32(PCIE_CONFIG_DATA, 0x20);
+#endif	
+	/* PCI memory byte swap enable */
+	/*
+	tmp = regRead32(CR_AHB_PCIC);
+	regWrite32(CR_AHB_PCIC, (tmp | ((1<<24) | (1<<25))));
+	*/
+	}
+
+	/* Set I/O resource limits.  */
+	ioport_resource.end = 0x1fffffff;
+	iomem_resource.end = 0xffffffff;
+
+	if (isEN751221)
+	{
+		register_pci_controller(&mt7512_pcie_controller);
+		pcie_api_init();
+
+	}
+	else
+		register_pci_controller(&tc3162_pcie_controller);
+	
+#ifdef CONFIG_MIPS_TC3162U
+	/*Add AHB error monitor check*/
+	if(request_irq(ARBITER_ERR_INT, ahbErrIsr, 0, "AHB ERR", ahbErrIsr) != 0) {
+		printk("request ARBITER err isr error.\n");
+	}
+#endif
+	/*create a proc to check wifi dead or not*/
+	ahb_status_proc = create_proc_entry("tc3162/ahb_status", 0, NULL);
+	ahb_status_proc->read_proc = ahb_status_read_proc;
+	ahb_status_proc->write_proc = ahb_status_write_proc;
+
+#ifdef TCSUPPORT_RT63368_PCIE_RECOVER
+/*add two proc file,ahb_status_value only for test*/
+if(isRT63368){
+		/*create a proc to check AER*/
+		aer_status_proc = create_proc_entry("tc3162/pcie_error_detect_count", 0, NULL);
+		if(aer_status_proc != NULL){
+			aer_status_proc->read_proc = pcie_error_detect_count_read_proc;
+			aer_status_proc->write_proc = pcie_error_detect_count_write_proc;
+		}	
+		//for test
+		/*create a proc to check AER*/
+		aer_status_proc = create_proc_entry("tc3162/ahb_status_value", 0, NULL);
+		if(aer_status_proc != NULL){
+			aer_status_proc->read_proc = ahb_status_value_count_read_proc;
+			aer_status_proc->write_proc = ahb_status_value_count_write_proc;
+		}
+	}
+#endif
+	if(isMT751020 || isMT7505 || isEN751221){
+
+		/*create a proc to check AER*/
+		aer_status_proc = create_proc_entry("tc3162/aer_status", 0, NULL);
+		if(aer_status_proc != NULL){
+			aer_status_proc->read_proc = aer_status_read_proc;
+			aer_status_proc->write_proc = aer_status_write_proc;
+		}	
+		aer_status_proc = create_proc_entry("tc3162/pcie_reset", 0, NULL);
+		if(aer_status_proc != NULL){
+			aer_status_proc->read_proc = pcie_rcnum_read_proc;
+			aer_status_proc->write_proc = pcie_rcnum_write_proc;
+		}
+		aer_status_proc = create_proc_entry("tc3162/pcie_reset_cond", 0, NULL);
+		if(aer_status_proc != NULL){
+			aer_status_proc->read_proc = pcie_reset_con_read_proc;
+			aer_status_proc->write_proc = pcie_reset_con_write_proc;
+		}
+		create_proc_read_entry("tc3162/pcie_reset_count", 0, NULL, pcie_reset_count_read_proc, NULL);
+		
+	}
+	return 0;
+}
+
+arch_initcall(tc3162_pcie_init);
