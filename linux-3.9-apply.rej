--- arch/mips/include/asm/irqflags.h	2010-10-20 23:30:22.000000000 +0300
+++ mtk/linux-2.6.36/arch/mips/include/asm/irqflags.h	2019-03-07 03:40:17.000000000 +0200
@@ -195,11 +195,15 @@ __asm__(
 	"	.set	pop						\n"
 	"	.endm							\n");
 
-
+#ifdef TCSUPPORT_XPON_HAL_API_EXT
+extern void resetWatch(void);
+#endif
 static inline void raw_local_irq_restore(unsigned long flags)
 {
 	unsigned long __tmp1;
-
+	#ifdef TCSUPPORT_XPON_HAL_API_EXT
+	resetWatch();
+	#endif
 #ifdef CONFIG_MIPS_MT_SMTC
 	/*
 	 * SMTC kernel needs to do a software replay of queued
--- arch/mips/include/asm/mipsregs.h	2010-10-20 23:30:22.000000000 +0300
+++ mtk/linux-2.6.36/arch/mips/include/asm/mipsregs.h	2019-03-07 03:40:17.000000000 +0200
@@ -1062,12 +1087,18 @@ do {									\
 #define read_c0_taglo()		__read_32bit_c0_register($28, 0)
 #define write_c0_taglo(val)	__write_32bit_c0_register($28, 0, val)
 
+#define read_c0_idatalo()		__read_32bit_c0_register($28, 1)
+#define write_c0_idatalo(val)	__write_32bit_c0_register($28, 1, val)
+
 #define read_c0_dtaglo()	__read_32bit_c0_register($28, 2)
 #define write_c0_dtaglo(val)	__write_32bit_c0_register($28, 2, val)
 
 #define read_c0_taghi()		__read_32bit_c0_register($29, 0)
 #define write_c0_taghi(val)	__write_32bit_c0_register($29, 0, val)
 
+#define read_c0_idatahi()		__read_32bit_c0_register($29, 1)
+#define write_c0_idatahi(val)	__write_32bit_c0_register($29, 1, val)
+
 #define read_c0_errorepc()	__read_ulong_c0_register($30, 0)
 #define write_c0_errorepc(val)	__write_ulong_c0_register($30, 0, val)
 
--- arch/mips/include/asm/thread_info.h	2010-10-20 23:30:22.000000000 +0300
+++ mtk/linux-2.6.36/arch/mips/include/asm/thread_info.h	2019-03-07 03:40:17.000000000 +0200
@@ -92,8 +96,12 @@ register struct thread_info *__current_t
 #ifdef CONFIG_DEBUG_STACK_USAGE
 #define alloc_thread_info(tsk) kzalloc(THREAD_SIZE, GFP_KERNEL)
 #else
+#if defined(CONFIG_CPU_TC3162) || defined(CONFIG_MIPS_TC3262)
+#define alloc_thread_info(tsk) kzalloc(THREAD_SIZE, GFP_KERNEL)
+#else
 #define alloc_thread_info(tsk) kmalloc(THREAD_SIZE, GFP_KERNEL)
 #endif
+#endif
 
 #define free_thread_info(info) kfree(info)
 
--- arch/mips/Kbuild.platforms	2010-10-20 23:30:22.000000000 +0300
+++ mtk/linux-2.6.36/arch/mips/Kbuild.platforms	2019-03-07 03:40:18.000000000 +0200
@@ -18,6 +18,7 @@ platforms += pmc-sierra
 platforms += pnx833x
 platforms += pnx8550
 platforms += powertv
+platforms += ralink
 platforms += rb532
 platforms += sgi-ip22
 platforms += sgi-ip27
--- arch/mips/Kconfig	2010-10-20 23:30:22.000000000 +0300
+++ mtk/linux-2.6.36/arch/mips/Kconfig	2019-03-07 03:40:18.000000000 +0200
@@ -252,6 +252,65 @@ config MIPS_MALTA
 	  This enables support for the MIPS Technologies Malta evaluation
 	  board.
 
+config MIPS_TC3262
+	bool "TrendChip's TC3262 Board"
+	select CPU_MIPSR2_IRQ_VI
+	select CPU_MIPSR2_IRQ_EI
+	select NO_EXCEPT_FILL
+	select BOOT_RAW
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select HW_HAS_PCI
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_CPU_MIPS64_R1
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_MULTITHREADING
+	select TC3162_ADSL
+	select TC3162_IMEM
+	select TC3162_DMEM
+	help
+	  This enables support for TrendChip's TC3262 based board.  
+	  board.
+
+config MIPS_TC3182
+	bool "TrendChip's TC3182 Board"
+	depends on MIPS_TC3262
+	help
+	  This enables support for TrendChip's TC3182 based board.  
+	  board.
+
+config MIPS_RT63165
+	bool "Ralink's RT63165 Board"
+	depends on MIPS_TC3262
+	help
+	  This enables support for Ralink's RT63165 based board.  
+
+config MIPS_RT65168
+	bool "Ralink's RT65168 Board"
+	depends on MIPS_TC3262
+	select RALINK_VDSL
+	help
+	  This enables support for Ralink's RT65168 based board.  
+
+config MIPS_RT63365
+	bool "Ralink's RT63365 Board"
+	depends on MIPS_TC3262
+	help
+	  This enables support for Ralink's RT63365 based board.  
+config MIPS_MT7510
+	bool "MediaTek's MT7510 Board"
+	depends on MIPS_TC3262
+	select RALINK_VDSL
+	help
+	  This enables support for MediaTek's MT7510 based board.  
+	  
 config MIPS_SIM
 	bool 'MIPS simulator (MIPSsim)'
 	select CEVT_R4K
--- arch/mips/kernel/cevt-r4k.c	2010-10-20 23:30:22.000000000 +0300
+++ mtk/linux-2.6.36/arch/mips/kernel/cevt-r4k.c	2019-03-07 03:40:15.000000000 +0200
@@ -14,6 +14,7 @@
 #include <asm/smtc_ipi.h>
 #include <asm/time.h>
 #include <asm/cevt-r4k.h>
+#include <asm/tc3162/tc3162.h>
 
 /*
  * The SMTC Kernel for the 34K, 1004K, et. al. replaces several
--- arch/mips/kernel/cpu-probe.c	2010-10-20 23:30:22.000000000 +0300
+++ mtk/linux-2.6.36/arch/mips/kernel/cpu-probe.c	2019-03-07 03:40:15.000000000 +0200
@@ -25,6 +25,9 @@
 #include <asm/system.h>
 #include <asm/watch.h>
 #include <asm/spram.h>
+#ifdef TCSUPPORT_CPU_EN7512
+#include <asm/tc3162/tc3162.h>
+#endif
 /*
  * Not all of the MIPS CPUs have the "wait" instruction available. Moreover,
  * the implementation of the "wait" feature differs between CPU families. This
--- arch/mips/kernel/irq.c	2010-10-20 23:30:22.000000000 +0300
+++ mtk/linux-2.6.36/arch/mips/kernel/irq.c	2019-03-07 03:40:15.000000000 +0200
@@ -156,13 +156,14 @@ void __init init_IRQ(void)
  * SMP cross-CPU interrupts have their own specific
  * handlers).
  */
-void __irq_entry do_IRQ(unsigned int irq)
+__IMEM void __irq_entry do_IRQ(int irq)//xflu 20120522
 {
 	irq_enter();
 	__DO_IRQ_SMTC_HOOK(irq);
 	generic_handle_irq(irq);
 	irq_exit();
 }
+EXPORT_SYMBOL(do_IRQ);
 
 #ifdef CONFIG_MIPS_MT_SMTC_IRQAFF
 /*
--- arch/mips/kernel/Makefile	2010-10-20 23:30:22.000000000 +0300
+++ mtk/linux-2.6.36/arch/mips/kernel/Makefile	2019-03-07 03:40:15.000000000 +0200
@@ -36,6 +36,7 @@ obj-$(CONFIG_CPU_LOONGSON2)	+= r4k_fpu.o
 obj-$(CONFIG_CPU_MIPS32)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_MIPS64)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R3000)		+= r2300_fpu.o r2300_switch.o
+obj-$(CONFIG_CPU_TC3162)	+= r2300_fpu.o r2300_switch.o
 obj-$(CONFIG_CPU_R4300)		+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R4X00)		+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R5000)		+= r4k_fpu.o r4k_switch.o
--- arch/mips/kernel/smp-mt.c	2010-10-20 23:30:22.000000000 +0300
+++ mtk/linux-2.6.36/arch/mips/kernel/smp-mt.c	2019-03-07 03:40:15.000000000 +0200
@@ -151,6 +151,10 @@ static void vsmp_send_ipi_mask(const str
 
 static void __cpuinit vsmp_init_secondary(void)
 {
+#ifdef CONFIG_MIPS_TC3262
+	write_c0_status((read_c0_status() & ~ST0_IM ) |
+	                (STATUSF_IP0 | STATUSF_IP1)); 
+#else
 	extern int gic_present;
 
 	/* This is Malta specific: IPI,performance and timer inetrrupts */
--- arch/mips/kernel/smtc.c	2010-10-20 23:30:22.000000000 +0300
+++ mtk/linux-2.6.36/arch/mips/kernel/smtc.c	2019-03-07 03:40:15.000000000 +0200
@@ -42,6 +42,9 @@
 #include <asm/addrspace.h>
 #include <asm/smtc.h>
 #include <asm/smtc_proc.h>
+#ifdef CONFIG_MIPS_TC3262
+#include <asm/tc3162/tc3162.h>
+#endif
 
 /*
  * SMTC Kernel needs to manipulate low-level CPU interrupt mask
--- arch/mips/kernel/spram.c	2010-10-20 23:30:22.000000000 +0300
+++ mtk/linux-2.6.36/arch/mips/kernel/spram.c	2019-03-07 03:40:15.000000000 +0200
@@ -12,12 +12,84 @@
 #include <linux/kernel.h>
 #include <linux/ptrace.h>
 #include <linux/stddef.h>
+#include <linux/module.h>
 
+#include <asm/cpu.h>
 #include <asm/fpu.h>
 #include <asm/mipsregs.h>
 #include <asm/system.h>
 #include <asm/r4kcache.h>
 #include <asm/hazards.h>
+#ifdef CONFIG_MIPS_TC3262
+#include <asm/tc3162/tc3162.h>
+
+extern int __imem, __dmem;
+#endif
+static char *sram_allocp = NULL;
+static int sram_size = 0;
+static int sram_free = 0;
+
+static char *dspram_p = NULL;
+static int dspram_used_size = 0;
+static int dspram_max_size = 0x1000;	//4K
+int is_sram_addr(void *p)
+{
+	if ((CKSEG1ADDR(p) & 0xffffc000) == (CKSEG1ADDR(DSPRAM_BASE) & 0xffffc000))
+		return 1;
+	else 
+		return 0;
+}
+EXPORT_SYMBOL(is_sram_addr);
+
+void *alloc_sram(int n)
+{
+	if (sram_allocp == NULL)
+		return NULL;
+
+	if (sram_free >= n) {
+		sram_free -= n;
+		sram_allocp += n;
+		printk("alloc_sram p=%p free=%04x\n", sram_allocp, sram_free);
+		return sram_allocp - n;
+	} else 
+		return NULL;
+}
+EXPORT_SYMBOL(alloc_sram);
+
+void free_sram(void *p, int n)
+{
+	if (sram_allocp == (p+n)) {
+		sram_free += n;
+		sram_allocp -= n;
+	}
+	printk("free_sram p=%p free=%04x\n", sram_allocp, sram_free);
+}
+EXPORT_SYMBOL(free_sram);
+
+void write_to_dspram(long  data)
+{
+	if(dspram_p == NULL || dspram_max_size == 0)
+		return;
+
+	
+	*(long *)dspram_p = data;
+	dspram_p += sizeof(long);
+
+	dspram_used_size += sizeof(long);
+
+	if(dspram_used_size >= dspram_max_size){
+		dspram_p = (char *)(DSPRAM_BASE);
+		dspram_used_size = 0;
+	}
+}
+
+unsigned int dspram_base_addr()
+{
+	return DSPRAM_BASE;
+}
+
+
+#define MIPS34K_Index_Store_Data_I	0x0c
 
 /*
  * These definitions are correct for the 24K/34K/74K SPRAM sample
--- arch/mips/kernel/vpe.c	2010-10-20 23:30:22.000000000 +0300
+++ mtk/linux-2.6.36/arch/mips/kernel/vpe.c	2019-03-07 03:40:15.000000000 +0200
@@ -148,9 +148,9 @@ struct {
 	spinlock_t tc_list_lock;
 	struct list_head tc_list;	/* Thread contexts */
 } vpecontrol = {
-	.vpe_list_lock	= SPIN_LOCK_UNLOCKED,
+	.vpe_list_lock	= __SPIN_LOCK_UNLOCKED(vpecontrol.vpe_list_lock),
 	.vpe_list	= LIST_HEAD_INIT(vpecontrol.vpe_list),
-	.tc_list_lock	= SPIN_LOCK_UNLOCKED,
+	.tc_list_lock	= __SPIN_LOCK_UNLOCKED(vpecontrol.tc_list_lock),
 	.tc_list	= LIST_HEAD_INIT(vpecontrol.tc_list)
 };
 
@@ -192,7 +192,7 @@ static struct tc *get_tc(int index)
 	}
 	spin_unlock(&vpecontrol.tc_list_lock);
 
-	return NULL;
+	return res;//modify by xfu seams like a bug
 }
 
 /* allocate a vpe and associate it with this minor (or index) */
--- arch/mips/mm/Makefile	2010-10-20 23:30:22.000000000 +0300
+++ mtk/linux-2.6.36/arch/mips/mm/Makefile	2019-03-07 03:40:15.000000000 +0200
@@ -16,6 +16,7 @@ obj-$(CONFIG_CPU_MIPS64)	+= c-r4k.o cex-
 obj-$(CONFIG_CPU_NEVADA)	+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R10000)	+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R3000)		+= c-r3k.o tlb-r3k.o
+obj-$(CONFIG_CPU_TC3162)	+= c-tc3162.o tlb-r3k.o pg-r4k.o
 obj-$(CONFIG_CPU_R4300)		+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R4X00)		+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R5000)		+= c-r4k.o cex-gen.o tlb-r4k.o
