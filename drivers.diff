diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/char/random.c tplink-vr300/mtk/linux-2.6.36/drivers/char/random.c
--- linux-2.6.36/drivers/char/random.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/char/random.c	2019-03-07 03:39:43.000000000 +0200
@@ -1638,6 +1638,9 @@
 	return ret;
 }
 
+#if defined(CONFIG_USB_EN7512_XHCI_HCD) || defined(CONFIG_USB_EN7512_XHCI_HCD_MODULE)
+EXPORT_SYMBOL_GPL (get_random_int);
+#endif
 /*
  * randomize_range() returns a start address such that
  *
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/input/input.c tplink-vr300/mtk/linux-2.6.36/drivers/input/input.c
--- linux-2.6.36/drivers/input/input.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/input/input.c	2019-03-07 03:39:20.000000000 +0200
@@ -917,7 +917,7 @@
 union input_seq_state {
 	struct {
 		unsigned short pos;
-		bool mutex_acquired;
+		bool short mutex_acquired;
 	};
 	void *p;
 };
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/mtd/chips/Kconfig tplink-vr300/mtk/linux-2.6.36/drivers/mtd/chips/Kconfig
--- linux-2.6.36/drivers/mtd/chips/Kconfig	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/mtd/chips/Kconfig	2019-03-07 03:39:44.000000000 +0200
@@ -208,6 +208,12 @@
 config MTD_CFI_UTIL
 	tristate
 
+config MTD_SPIFLASH
+	tristate "Support for SPIFLASH on TC3162/TC3262"
+	depends on (MIPS_TC3162 || MIPS_TC3162U || MIPS_TC3262)
+	help
+	  This option enables basic support for SPIFLASH on TC3162 chip.
+
 config MTD_RAM
 	tristate "Support for RAM chips in bus mapping"
 	help
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/mtd/chips/Makefile tplink-vr300/mtk/linux-2.6.36/drivers/mtd/chips/Makefile
--- linux-2.6.36/drivers/mtd/chips/Makefile	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/mtd/chips/Makefile	2019-03-07 03:39:44.000000000 +0200
@@ -2,6 +2,9 @@
 # linux/drivers/chips/Makefile
 #
 
+ifneq ($(findstring DINCLUDE_DUAL_CONFIG,$(DF_FLAGS)),)
+EXTRA_CFLAGS += -DINCLUDE_DUAL_CONFIG
+endif
 obj-$(CONFIG_MTD)		+= chipreg.o
 obj-$(CONFIG_MTD_CFI)		+= cfi_probe.o
 obj-$(CONFIG_MTD_CFI_UTIL)	+= cfi_util.o
@@ -10,6 +13,15 @@
 obj-$(CONFIG_MTD_CFI_INTELEXT)	+= cfi_cmdset_0001.o
 obj-$(CONFIG_MTD_GEN_PROBE)	+= gen_probe.o
 obj-$(CONFIG_MTD_JEDECPROBE)	+= jedec_probe.o
+ifneq ($(TCSUPPORT_NEW_SPIFLASH),)
+obj-$(CONFIG_MTD_SPIFLASH)	+= newspiflash.o 
+else
+obj-$(CONFIG_MTD_SPIFLASH)	+= spiflash_tc3162.o
+endif
+ifneq ($(strip $(TCSUPPORT_CPU_EN7512) $(TCSUPPORT_CPU_EN7521)),)
+obj-$(CONFIG_MTD_NAND) += spi_nand_flash.o
+obj-y += spi_controller.o
+endif
 obj-$(CONFIG_MTD_RAM)		+= map_ram.o
 obj-$(CONFIG_MTD_ROM)		+= map_rom.o
 obj-$(CONFIG_MTD_ABSENT)	+= map_absent.o
Only in tplink-vr300/mtk/linux-2.6.36/drivers/mtd/chips: newspiflash.c
Only in tplink-vr300/mtk/linux-2.6.36/drivers/mtd/chips: newspiflash.h
Only in tplink-vr300/mtk/linux-2.6.36/drivers/mtd/chips: spi_controller.c
Only in tplink-vr300/mtk/linux-2.6.36/drivers/mtd/chips: spi_controller.h
Only in tplink-vr300/mtk/linux-2.6.36/drivers/mtd/chips: spiflash_tc3162.c
Only in tplink-vr300/mtk/linux-2.6.36/drivers/mtd/chips: spiflash_tc3162.h
Only in tplink-vr300/mtk/linux-2.6.36/drivers/mtd/chips: spi_nand_flash.c
Only in tplink-vr300/mtk/linux-2.6.36/drivers/mtd/chips: spi_nand_flash.h
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/mtd/Kconfig tplink-vr300/mtk/linux-2.6.36/drivers/mtd/Kconfig
--- linux-2.6.36/drivers/mtd/Kconfig	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/mtd/Kconfig	2019-03-07 03:39:44.000000000 +0200
@@ -344,4 +344,7 @@
 
 source "drivers/mtd/ubi/Kconfig"
 
+source "drivers/mtd/ralink/Kconfig"
+
+source "drivers/mtd/mtk/Kconfig"
 endif # MTD
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/mtd/Makefile tplink-vr300/mtk/linux-2.6.36/drivers/mtd/Makefile
--- linux-2.6.36/drivers/mtd/Makefile	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/mtd/Makefile	2019-03-07 03:39:44.000000000 +0200
@@ -29,7 +29,7 @@
 
 nftl-objs		:= nftlcore.o nftlmount.o
 inftl-objs		:= inftlcore.o inftlmount.o
-
-obj-y		+= chips/ lpddr/ maps/ devices/ nand/ onenand/ tests/
+# frankliao modify 20101216
+obj-y		+= chips/ mtk/ ralink/ lpddr/ maps/ devices/ nand/ onenand/ tests/
 
 obj-$(CONFIG_MTD_UBI)		+= ubi/
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/mtd/maps/Kconfig tplink-vr300/mtk/linux-2.6.36/drivers/mtd/maps/Kconfig
--- linux-2.6.36/drivers/mtd/maps/Kconfig	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/mtd/maps/Kconfig	2019-03-07 03:39:44.000000000 +0200
@@ -251,6 +251,13 @@
 	help
 	  Support for flash chips on NETtel/SecureEdge/SnapGear boards.
 
+config MTD_TC3162
+	tristate "TrendChip TC3162/TC3262 MTD support"
+	#depends on MIPS_TC3162 && MTD_PARTITIONS && MTD_CFI
+	depends on (MIPS_TC3162 || MIPS_TC3162U || MIPS_TC3262) && MTD_PARTITIONS
+	help
+	  Flash memory access on TrendChip TC3162 Boards
+
 config MTD_DILNETPC
 	tristate "CFI Flash device mapped on DIL/Net PC"
 	depends on X86 && MTD_CONCAT && MTD_PARTITIONS && MTD_CFI_INTELEXT && BROKEN
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/mtd/maps/Makefile tplink-vr300/mtk/linux-2.6.36/drivers/mtd/maps/Makefile
--- linux-2.6.36/drivers/mtd/maps/Makefile	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/mtd/maps/Makefile	2019-03-07 03:39:44.000000000 +0200
@@ -40,6 +40,7 @@
 obj-$(CONFIG_MTD_DBOX2)		+= dbox2-flash.o
 obj-$(CONFIG_MTD_SOLUTIONENGINE)+= solutionengine.o
 obj-$(CONFIG_MTD_PCI)		+= pci.o
+obj-$(CONFIG_MTD_TC3162)       	+= tc3162-flash.o
 obj-$(CONFIG_MTD_AUTCPU12)	+= autcpu12-nvram.o
 obj-$(CONFIG_MTD_EDB7312)	+= edb7312.o
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
Only in tplink-vr300/mtk/linux-2.6.36/drivers/mtd/maps: tc3162-flash.c
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/mtd/mtdchar.c tplink-vr300/mtk/linux-2.6.36/drivers/mtd/mtdchar.c
--- linux-2.6.36/drivers/mtd/mtdchar.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/mtd/mtdchar.c	2019-03-07 03:39:44.000000000 +0200
@@ -396,31 +396,36 @@
 	uint32_t retlen;
 	int ret = 0;
 
-	if (!(file->f_mode & FMODE_WRITE))
+	if (!(file->f_mode & FMODE_WRITE)){
 		return -EPERM;
+	}
 
-	if (length > 4096)
+	if (length > 4096){
 		return -EINVAL;
+	}
 
 	if (!mtd->write_oob)
 		ret = -EOPNOTSUPP;
 	else
 		ret = access_ok(VERIFY_READ, ptr, length) ? 0 : -EFAULT;
 
-	if (ret)
+	if (ret){
 		return ret;
+	}
 
 	ops.ooblen = length;
 	ops.ooboffs = start & (mtd->oobsize - 1);
 	ops.datbuf = NULL;
 	ops.mode = MTD_OOB_PLACE;
 
-	if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))
+	if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs)){
 		return -EINVAL;
+	}
 
 	ops.oobbuf = memdup_user(ptr, length);
-	if (IS_ERR(ops.oobbuf))
+	if (IS_ERR(ops.oobbuf)){
 		return PTR_ERR(ops.oobbuf);
+	}
 
 	start &= ~((uint64_t)mtd->oobsize - 1);
 	ret = mtd->write_oob(mtd, start, &ops);
@@ -428,11 +433,12 @@
 	if (ops.oobretlen > 0xFFFFFFFFU)
 		ret = -EOVERFLOW;
 	retlen = ops.oobretlen;
-	if (copy_to_user(retp, &retlen, sizeof(length)))
+	if (copy_to_user(retp, &retlen, sizeof(length))){
 		ret = -EFAULT;
 
 	kfree(ops.oobbuf);
 	return ret;
+	}
 }
 
 static int mtd_do_readoob(struct mtd_info *mtd, uint64_t start,
@@ -541,9 +547,9 @@
 	case MEMERASE64:
 	{
 		struct erase_info *erase;
-
-		if(!(file->f_mode & FMODE_WRITE))
+		if(!(file->f_mode & FMODE_WRITE)){
 			return -EPERM;
+		}
 
 		erase=kzalloc(sizeof(struct erase_info),GFP_KERNEL);
 		if (!erase)
@@ -609,10 +615,10 @@
 	{
 		struct mtd_oob_buf buf;
 		struct mtd_oob_buf __user *buf_user = argp;
-
 		/* NOTE: writes return length to buf_user->length */
-		if (copy_from_user(&buf, argp, sizeof(buf)))
+		if (copy_from_user(&buf, argp, sizeof(buf))){
 			ret = -EFAULT;
+		}
 		else
 			ret = mtd_do_writeoob(file, mtd, buf.start, buf.length,
 				buf.ptr, &buf_user->length);
@@ -1109,6 +1115,7 @@
 module_init(init_mtdchar);
 module_exit(cleanup_mtdchar);
 
+
 MODULE_ALIAS_CHARDEV_MAJOR(MTD_CHAR_MAJOR);
 
 MODULE_LICENSE("GPL");
Only in tplink-vr300/mtk/linux-2.6.36/drivers/mtd: mtk
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/mtd/nand/nand_base.c tplink-vr300/mtk/linux-2.6.36/drivers/mtd/nand/nand_base.c
--- linux-2.6.36/drivers/mtd/nand/nand_base.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/mtd/nand/nand_base.c	2019-03-07 03:39:44.000000000 +0200
@@ -778,7 +778,7 @@
  *
  * Get the device and lock it for exclusive access
  */
-static int
+int
 nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
 {
 	spinlock_t *lock = &chip->controller->lock;
@@ -2139,6 +2139,23 @@
 
 #define NOTALIGNED(x)	(x & (chip->subpagesize - 1)) != 0
 
+#ifdef TCSUPPORT_CT_PON_CN
+static void nand_write_alarm_print(unsigned char* partition,loff_t to,uint32_t writelen)
+{
+	printk("*\n");
+	printk("**\n");
+	printk("***\n");
+	printk("****\n");
+	printk("*****\n");
+	printk("ERROR!write %s fail,to = 0x%llx,writelen = 0x%x\n",partition,to,writelen);
+	printk("*****\n");
+	printk("****\n");
+	printk("***\n");
+	printk("**\n");
+	printk("*\n");
+}
+#endif
+
 /**
  * nand_do_write_ops - [Internal] NAND write with ECC
  * @mtd:	MTD device structure
@@ -2167,7 +2184,10 @@
 		return 0;
 
 	/* reject writes, which are not page aligned */
+	#if 0
 	if (NOTALIGNED(to) || NOTALIGNED(ops->len)) {
+	#endif
+	if (NOTALIGNED(to)) {
 		printk(KERN_NOTICE "%s: Attempt to write not "
 				"page aligned data\n", __func__);
 		return -EINVAL;
@@ -2209,7 +2229,7 @@
 		uint8_t *wbuf = buf;
 
 		/* Partial page write ? */
-		if (unlikely(column || writelen < (mtd->writesize - 1))) {
+		if (unlikely(column || writelen < (mtd->writesize))) {
 			cached = 0;
 			bytes = min_t(int, bytes - column, (int) writelen);
 			chip->pagebuf = -1;
@@ -2230,7 +2250,7 @@
 			break;
 
 		writelen -= bytes;
-		if (!writelen)
+		if (writelen<=0)
 			break;
 
 		column = 0;
Only in tplink-vr300/mtk/linux-2.6.36/drivers/mtd: ralink
Only in tplink-vr300/mtk/linux-2.6.36/drivers/net: imq.c
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/net/Kconfig tplink-vr300/mtk/linux-2.6.36/drivers/net/Kconfig
--- linux-2.6.36/drivers/net/Kconfig	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/net/Kconfig	2019-03-07 03:39:32.000000000 +0200
@@ -75,6 +75,9 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called bonding.
 
+config X_TP_VLAN
+	tristate "X_TP_VLAN support"
+
 config MACVLAN
 	tristate "MAC-VLAN support (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
@@ -121,6 +124,129 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called eql.  If unsure, say N.
 
+config IMQ
+	tristate "IMQ (intermediate queueing device) support"
+	depends on NETDEVICES && NETFILTER
+	---help---
+	  The IMQ device(s) is used as placeholder for QoS queueing
+	  disciplines. Every packet entering/leaving the IP stack can be
+	  directed through the IMQ device where it's enqueued/dequeued to the
+	  attached qdisc. This allows you to treat network devices as classes
+	  and distribute bandwidth among them. Iptables is used to specify
+	  through which IMQ device, if any, packets travel.
+
+	  More information at: http://www.linuximq.net/
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called imq.  If unsure, say N.
+
+choice
+	prompt "IMQ behavior (PRE/POSTROUTING)"
+	depends on IMQ
+	default IMQ_BEHAVIOR_AB
+	help
+
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		IMQ can work in any of the following ways:
+
+		    PREROUTING   |      POSTROUTING
+		-----------------|-------------------
+		#1  After NAT    |      After NAT
+		#2  After NAT    |      Before NAT
+		#3  Before NAT   |      After NAT
+		#4  Before NAT   |      Before NAT
+
+		The default behavior is to hook before NAT on PREROUTING
+		and after NAT on POSTROUTING (#3).
+
+		This settings are specially usefull when trying to use IMQ
+		to shape NATed clients.
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+config IMQ_BEHAVIOR_AA
+	bool "IMQ AA"
+	help
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		Choosing this option will make IMQ hook like this:
+
+		PREROUTING:   After NAT
+		POSTROUTING:  After NAT
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+config IMQ_BEHAVIOR_AB
+	bool "IMQ AB"
+	help
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		Choosing this option will make IMQ hook like this:
+
+		PREROUTING:   After NAT
+		POSTROUTING:  Before NAT
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+config IMQ_BEHAVIOR_BA
+	bool "IMQ BA"
+	help
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		Choosing this option will make IMQ hook like this:
+
+		PREROUTING:   Before NAT
+		POSTROUTING:  After NAT
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+config IMQ_BEHAVIOR_BB
+	bool "IMQ BB"
+	help
+		This settings defines how IMQ behaves in respect to its
+		hooking in PREROUTING and POSTROUTING.
+
+		Choosing this option will make IMQ hook like this:
+
+		PREROUTING:   Before NAT
+		POSTROUTING:  Before NAT
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
+endchoice
+
+config IMQ_NUM_DEVS
+
+	int "Number of IMQ devices"
+	range 2 16
+	depends on IMQ
+	default "16"
+	help
+
+		This settings defines how many IMQ devices will be
+		created.
+
+		The default value is 16.
+
+		More information can be found at: www.linuximq.net
+
+		If not sure leave the default settings alone.
+
 config TUN
 	tristate "Universal TUN/TAP device driver support"
 	select CRC32
@@ -2439,6 +2565,13 @@
 	  Some boards that use the Discovery chipset are the Momenco
 	  Ocelot C and Jaguar ATX and Pegasos II.
 
+config TITAN_GE
+	bool "PMC-Sierra TITAN Gigabit Ethernet Support"
+	depends on PMC_YOSEMITE
+	help
+	  This enables support for the the integrated ethernet of
+	  PMC-Sierra's Titan SoC.
+
 config XILINX_LL_TEMAC
 	tristate "Xilinx LL TEMAC (LocalLink Tri-mode Ethernet MAC) driver"
 	depends on PPC || MICROBLAZE
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/net/macvlan.c tplink-vr300/mtk/linux-2.6.36/drivers/net/macvlan.c
--- linux-2.6.36/drivers/net/macvlan.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/net/macvlan.c	2019-03-07 03:39:32.000000000 +0200
@@ -30,6 +30,11 @@
 #include <linux/if_macvlan.h>
 #include <net/rtnetlink.h>
 #include <net/xfrm.h>
+#ifdef CONFIG_X_TP_VLAN
+/*add for single-VID-multi-connection by wanghao*/
+#include "../../net/bridge/br_private.h"
+/*add end*/
+#endif
 
 #define MACVLAN_HASH_SIZE	(1 << BITS_PER_BYTE)
 
@@ -161,6 +166,14 @@
 	unsigned int len = 0;
 	int ret = NET_RX_DROP;
 
+#ifdef CONFIG_X_TP_VLAN
+/*add for single-VID-multi-connection by wanghao*/
+	struct hlist_node *n;
+	struct sk_buff *skb2;
+	int i;
+/*add end*/
+#endif
+
 	port = macvlan_port_get_rcu(skb->dev);
 	if (is_multicast_ether_addr(eth->h_dest)) {
 		src = macvlan_hash_lookup(port, eth->h_source);
@@ -186,9 +199,15 @@
 	}
 
 	vlan = macvlan_hash_lookup(port, eth->h_dest);
+
+#ifndef CONFIG_X_TP_VLAN
 	if (vlan == NULL)
 		return skb;
-
+#else
+	/*modified for single-VID-multi-connection by wanghao*/
+	if (vlan != NULL)
+	{
+#endif
 	dev = vlan->dev;
 	if (unlikely(!(dev->flags & IFF_UP))) {
 		kfree_skb(skb);
@@ -207,6 +226,53 @@
 out:
 	macvlan_count_rx(vlan, len, ret == NET_RX_SUCCESS, 0);
 	return NULL;
+#ifdef CONFIG_X_TP_VLAN
+	}
+	/*
+	 * brief	add for single-VID-multi-connection
+	 * By	wangwenhao, 20May13
+	 */
+	else 
+	{
+		for (i = 0; i < MACVLAN_HASH_SIZE; i++) {
+			hlist_for_each_entry_rcu(vlan, n, &port->vlan_hash[i], hlist) {
+				dev = vlan->dev;
+				
+				if (br_fdb_test_addr_hook != NULL && br_fdb_test_addr_hook(dev, (unsigned char *)eth->h_dest))
+				{
+					dev->stats.rx_bytes += skb->len + ETH_HLEN;
+					dev->stats.rx_packets++;
+
+					skb->pkt_type = PACKET_HOST;
+					skb->dev = dev;
+					netif_rx(skb);
+					return NULL;
+				}
+			}
+		}
+	}
+	
+	for (i = 0; i < MACVLAN_HASH_SIZE; i++) {
+		hlist_for_each_entry_rcu(vlan, n, &port->vlan_hash[i], hlist) {
+			dev = vlan->dev;
+
+			skb2 = skb_copy(skb, GFP_ATOMIC);
+			if (NULL == skb2)
+			{
+				continue;
+			}
+			dev->stats.rx_bytes += skb->len + ETH_HLEN;
+			dev->stats.rx_packets++;
+
+			skb2->pkt_type = PACKET_HOST;
+			skb2->dev = dev;
+			netif_rx(skb2);
+		}
+	}
+
+	kfree_skb(skb);
+	return NULL;
+#endif
 }
 
 static int macvlan_queue_xmit(struct sk_buff *skb, struct net_device *dev)
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/net/Makefile tplink-vr300/mtk/linux-2.6.36/drivers/net/Makefile
--- linux-2.6.36/drivers/net/Makefile	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/net/Makefile	2019-03-07 03:39:32.000000000 +0200
@@ -154,6 +154,8 @@
 obj-$(CONFIG_QLCNIC) += qlcnic/
 obj-$(CONFIG_QLGE) += qlge/
 
+obj-$(CONFIG_TITAN_GE) += titan_mdio.o titan_ge.o
+
 obj-$(CONFIG_PPP) += ppp_generic.o
 obj-$(CONFIG_PPP_ASYNC) += ppp_async.o
 obj-$(CONFIG_PPP_SYNC_TTY) += ppp_synctty.o
@@ -169,6 +171,7 @@
 obj-$(CONFIG_XEN_NETDEV_FRONTEND) += xen-netfront.o
 
 obj-$(CONFIG_DUMMY) += dummy.o
+obj-$(CONFIG_IMQ) += imq.o
 obj-$(CONFIG_IFB) += ifb.o
 obj-$(CONFIG_MACVLAN) += macvlan.o
 obj-$(CONFIG_MACVTAP) += macvtap.o
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/net/ppp_async.c tplink-vr300/mtk/linux-2.6.36/drivers/net/ppp_async.c
--- linux-2.6.36/drivers/net/ppp_async.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/net/ppp_async.c	2019-03-07 03:39:32.000000000 +0200
@@ -300,7 +300,6 @@
 			break;
 		err = 0;
 		break;
-
 	case PPPIOCGUNIT:
 		err = -EFAULT;
 		if (put_user(ppp_unit_number(&ap->chan), p))
@@ -811,6 +810,8 @@
 
 	/* queue the frame to be processed */
 	skb->cb[0] = ap->state;
+
+
 	skb_queue_tail(&ap->rqueue, skb);
 	ap->rpkt = NULL;
 	ap->state = 0;
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/net/ppp_generic.c tplink-vr300/mtk/linux-2.6.36/drivers/net/ppp_generic.c
--- linux-2.6.36/drivers/net/ppp_generic.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/net/ppp_generic.c	2019-03-07 03:39:33.000000000 +0200
@@ -465,6 +465,7 @@
 	struct ppp_file *pf = file->private_data;
 	struct sk_buff *skb;
 	ssize_t ret;
+	//unsigned int proto = 0;
 
 	if (!pf)
 		return -ENXIO;
@@ -479,6 +480,13 @@
 		goto out;
 	}
 
+#if 0 /* 影响了新西兰拨号，去掉 */
+	proto = (skb->data[0] << 8) + skb->data[1];
+
+	if (proto == PPP_LCP)
+		skb->mark |= 0x100;	//TC_ROUTE_MARK
+#endif 
+	
 	skb_queue_tail(&pf->xq, skb);
 
 	switch (pf->kind) {
@@ -1036,6 +1044,12 @@
 	dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
 	dev->features |= NETIF_F_NETNS_LOCAL;
 	dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;
+	
+/* added by yangxv for QoS */
+	dev->priv_flags |= IFF_WAN_DEV;
+/* end added */
+//for vlan tag 0
+	dev->priv_flags |= IFF_802_1Q_DUAL_VLAN;
 }
 
 /*
@@ -1585,6 +1599,17 @@
 
 	proto = PPP_PROTO(skb);
 	if (!pch->ppp || proto >= 0xc000 || proto == PPP_CCPFRAG) {
+		/* yuanshang ,record lcp reply to rx ,2010-07-19 */
+		/* merge from trunk:rev6126, fix the heartbeat statistic num invalid */
+		/* CM 2014-04-29 */
+		if( (proto == 0xc021) && ((skb->data[2] == 10)
+			|| (skb->data[2] == 9)) )/*lcp echo reply*/
+		{			
+			++((pch->ppp)->dev->stats.rx_packets);
+			(pch->ppp)->dev->stats.rx_bytes += skb->len - 2;
+		}
+		/* end added */
+		
 		/* put it on the channel queue */
 		skb_queue_tail(&pch->file.rq, skb);
 		/* drop old frames if queue too long */
Only in tplink-vr300/mtk/linux-2.6.36/drivers/net: ppp_mppe.ko
Only in tplink-vr300/mtk/linux-2.6.36/drivers/net: ppp_mppe.mod.c
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/net/pppoe.c tplink-vr300/mtk/linux-2.6.36/drivers/net/pppoe.c
--- linux-2.6.36/drivers/net/pppoe.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/net/pppoe.c	2019-03-07 03:39:32.000000000 +0200
@@ -317,7 +317,7 @@
 			lock_sock(sk);
 
 			if (po->pppoe_dev == dev &&
-			    sk->sk_state & (PPPOX_CONNECTED | PPPOX_BOUND)) {
+			    sk->sk_state & (PPPOX_CONNECTED | PPPOX_BOUND | PPPOX_ZOMBIE)) {/*OSBNB00028443:add PPPOX_ZOMBIE to avoid dead loop*/
 				pppox_unbind_sock(sk);
 				sk->sk_state = PPPOX_ZOMBIE;
 				sk->sk_state_change(sk);
@@ -529,7 +529,11 @@
 	.owner	  = THIS_MODULE,
 	.obj_size = sizeof(struct pppox_sock),
 };
-
+#ifdef TCSUPPORT_CPU_PERFORMANCE_TEST
+#define PVC_NUM 8
+struct sock *sk_ppp[PVC_NUM]={NULL};
+EXPORT_SYMBOL(sk_ppp);
+#endif
 /***********************************************************************
  *
  * Initialize a new struct sock.
@@ -615,7 +619,9 @@
 	struct pppoe_net *pn;
 	struct net *net = NULL;
 	int error;
-
+#if defined(TCSUPPORT_CPU_PERFORMANCE_TEST)
+	int pvcIndex = 0;
+#endif
 	lock_sock(sk);
 
 	error = -EINVAL;
@@ -666,7 +672,14 @@
 		if (!(dev->flags & IFF_UP)) {
 			goto err_put;
 		}
-
+#if defined(TCSUPPORT_CPU_PERFORMANCE_TEST)
+//		printk("\r\n:---pppoe_connect:---dev->name = %s", dev->name);
+		if(strncmp(dev->name, "nas", 3)==0)
+		{
+			sscanf(dev->name, "nas%d", &pvcIndex);
+			sk_ppp[pvcIndex] = sk;
+		}
+#endif	
 		memcpy(&po->pppoe_pa,
 		       &sp->sa_addr.pppoe,
 		       sizeof(struct pppoe_addr));
@@ -868,6 +881,12 @@
 
 	skb->dev = dev;
 
+#ifdef CONFIG_QOS
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+		skb->mark |= QOS_DEFAULT_MARK;
+#endif
+#endif
+
 	skb->priority = sk->sk_priority;
 	skb->protocol = cpu_to_be16(ETH_P_PPP_SES);
 
@@ -943,12 +962,18 @@
 	dev_hard_header(skb, dev, ETH_P_PPP_SES,
 			po->pppoe_pa.remote, NULL, data_len);
 
+#ifdef CONFIG_QOS
+#if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
+		skb->mark |= QOS_DEFAULT_MARK;
+#endif
+#endif
+
 	dev_queue_xmit(skb);
 	return 1;
 
 abort:
 	kfree_skb(skb);
-	return 0;
+	return 1;
 }
 
 /************************************************************************
Only in tplink-vr300/mtk/linux-2.6.36/drivers/net: titan_ge.c
Only in tplink-vr300/mtk/linux-2.6.36/drivers/net: titan_ge.h
Only in tplink-vr300/mtk/linux-2.6.36/drivers/net: titan_mdio.c
Only in tplink-vr300/mtk/linux-2.6.36/drivers/net: titan_mdio.h
Only in tplink-vr300/mtk/linux-2.6.36/drivers/net: tun.ko
Only in tplink-vr300/mtk/linux-2.6.36/drivers/net: tun.mod.c
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/net/wireless/Kconfig tplink-vr300/mtk/linux-2.6.36/drivers/net/wireless/Kconfig
--- linux-2.6.36/drivers/net/wireless/Kconfig	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/net/wireless/Kconfig	2019-03-07 03:39:32.000000000 +0200
@@ -17,6 +17,16 @@
 
 if WLAN
 
+config RALINK_WIRELESS
+      tristate "Ralink wireless support"
+      depends on PCI
+      select WIRELESS_EXT
+      select WEXT_PRIV
+      select CRC_CCITT
+      select FW_LOADER
+       ---help---
+        Ralink wireless driver support
+
 config PCMCIA_RAYCS
 	tristate "Aviator/Raytheon 2.4GHz wireless support"
 	depends on PCMCIA
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/pci/pci.c tplink-vr300/mtk/linux-2.6.36/drivers/pci/pci.c
--- linux-2.6.36/drivers/pci/pci.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/pci/pci.c	2019-03-07 03:39:49.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/pm_runtime.h>
 #include <asm/setup.h>
 #include "pci.h"
+#include <asm/tc3162/tc3162.h>
 
 const char *pci_power_names[] = {
 	"error", "D0", "D1", "D2", "D3hot", "D3cold", "unknown",
@@ -179,6 +180,11 @@
 	u16 status;
 
 	pci_bus_read_config_word(bus, devfn, PCI_STATUS, &status);
+
+	/* workaround for fixing the the bug (the value of configuration reg 0x100 is wrong)
+			& bonding mode problem (it doesn't to scan bus1/dev1,2.....) on MT7510 */
+	if(isMT751020 || isMT7505 || isEN751221)
+		return 0;
 	if (!(status & PCI_STATUS_CAP_LIST))
 		return 0;
 
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/scsi/sd.c tplink-vr300/mtk/linux-2.6.36/drivers/scsi/sd.c
--- linux-2.6.36/drivers/scsi/sd.c	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/scsi/sd.c	2019-03-07 03:39:49.000000000 +0200
@@ -66,6 +66,18 @@
 
 #include "sd.h"
 #include "scsi_logging.h"
+#ifdef USB_AUTOMOUNT
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+struct mutex signal_mutex;
+struct task_struct *mount_task_p;
+#endif
+#ifdef TCSUPPORT_USB_HOST_LED
+#if !defined(TCSUPPORT_CPU_MT7510) && !defined(TCSUPPORT_CPU_MT7520) && !defined(TCSUPPORT_CPU_MT7505)
+extern unsigned int usb_dev_connected ; //usb led support
+#endif
+#endif
+
 
 MODULE_AUTHOR("Eric Youngdale");
 MODULE_DESCRIPTION("SCSI disk (sd) driver");
@@ -127,6 +139,61 @@
 	"write back, no read (daft)"
 };
 
+#ifdef USB_AUTOMOUNT
+/*---------------------------------------------------------------------
+ ** function mame: automount_pid_write_proc
+ *
+ ** description:
+ *      1. receives AutoMount's PID from user space and turns it into
+ *         a task_struct pointer which will be used to send signals to
+ *         AutoMount later. 
+ *
+ ** parameters:
+ *      1. buffer: the pointer pointing to the string received from user
+ *      2. count: the length of the string in buffer
+ *
+ ** global:
+ *      1. mount_task_p: the pointer pointing to the task_struct structure
+ *          that is going to be used to send signals to AutoMount
+ *
+ ** return: int
+ *
+ ** call: none
+ *
+ ** revision:
+ *      1. Trey 2010/08/16
+ *---------------------------------------------------------------------*/
+static int automount_pid_write_proc(struct file *file, const char *buffer,
+    unsigned long count, void *data)
+{
+    char str_pid[16];
+    pid_t mount_pid = 0;
+    char *cp;
+     
+    if (copy_from_user(str_pid, buffer, count)){
+        printk("automount_pid_write_proc failed\n");
+        return -EFAULT;
+    }
+     
+    str_pid[count] = '\0';
+     
+     //atoi func
+    for (cp = str_pid; *cp != '\0'; cp++) {
+        switch (*cp) {
+        case '0' ... '9':
+            mount_pid = 10*mount_pid+(*cp-'0');
+            break;
+        default:
+            break;
+        }
+    }
+    
+    mount_task_p = find_task_by_vpid(mount_pid);
+
+    return 0;
+}
+#endif
+
 static ssize_t
 sd_store_cache_type(struct device *dev, struct device_attribute *attr,
 		    const char *buf, size_t count)
@@ -2285,11 +2352,24 @@
 	sd_dif_config_host(sdkp);
 
 	sd_revalidate_disk(gd);
-
 	sd_printk(KERN_NOTICE, sdkp, "Attached SCSI %sdisk\n",
 		  sdp->removable ? "removable " : "");
 	scsi_autopm_put_device(sdp);
 	put_device(&sdkp->dev);
+#ifdef USB_AUTOMOUNT   
+    if(mount_task_p != NULL)
+    {
+        mutex_lock(&signal_mutex);
+        send_sig(SIGUSR1, mount_task_p, 0);
+        mutex_unlock(&signal_mutex);
+    }
+#endif 
+#ifdef TCSUPPORT_USB_HOST_LED
+#if !defined(TCSUPPORT_CPU_MT7510) && !defined(TCSUPPORT_CPU_MT7520) && !defined(TCSUPPORT_CPU_MT7505)
+	usb_dev_connected ++; //usb led support
+#endif
+#endif
+
 }
 
 /**
@@ -2310,6 +2390,8 @@
  *	Assume sd_attach is not re-entrant (for time being)
  *	Also think about sd_attach() and sd_remove() running coincidentally.
  **/
+
+
 static int sd_probe(struct device *dev)
 {
 	struct scsi_device *sdp = to_scsi_device(dev);
@@ -2422,7 +2504,21 @@
 	dev_set_drvdata(dev, NULL);
 	put_device(&sdkp->dev);
 	mutex_unlock(&sd_ref_mutex);
-
+#ifdef USB_AUTOMOUNT
+    if(mount_task_p != NULL)
+    {
+        mutex_lock(&signal_mutex);
+        send_sig(SIGUSR2, mount_task_p, 0);
+        mutex_unlock(&signal_mutex);
+        //msleep(500); /* let AutoMount can deal with umount right after SIGUSR2 is sent*/
+    } 
+#endif
+#ifdef TCSUPPORT_USB_HOST_LED
+#if !defined(TCSUPPORT_CPU_MT7510) && !defined(TCSUPPORT_CPU_MT7520) && !defined(TCSUPPORT_CPU_MT7505)
+    if(usb_dev_connected > 0)
+        usb_dev_connected --;    //usb led support
+#endif
+#endif
 	return 0;
 }
 
@@ -2554,7 +2650,25 @@
 static int __init init_sd(void)
 {
 	int majors = 0, i, err;
+#ifdef USB_AUTOMOUNT
+    struct proc_dir_entry *automount_proc;
 
+/* 1. mount_task_p: a pointer which will (later) point to the task_struct 
+ *      structure that stands for AutoMount's PID. The pointer will be used
+ *      by send_sig() to send SIGUSR1 or SIGUSR2 to AutoMount.
+ * 2. signal_mutex: a mutex used to prevent more than one signals are sent
+ *      at the same time.
+ * 3. automount_proc: used when AutoMount write its PID to
+ *      "tc3162/automount_pid", automount_pid_write_proc() will be
+ *      triggered to transform the PID to the task_struct structure which
+ *      is pointed by mount_task_p. Then, mount_task_p can be used to send
+ *      signals to AutoMount.  --Trey 2010/08/17
+ */
+    mount_task_p = NULL;
+    mutex_init(&signal_mutex);
+    automount_proc = create_proc_entry("tc3162/automount_pid", 0, NULL);
+    automount_proc->write_proc = automount_pid_write_proc;
+#endif
 	SCSI_LOG_HLQUEUE(3, printk("init_sd: sd driver entry point\n"));
 
 	for (i = 0; i < SD_MAJORS; i++)
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/serial/Kconfig tplink-vr300/mtk/linux-2.6.36/drivers/serial/Kconfig
--- linux-2.6.36/drivers/serial/Kconfig	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/serial/Kconfig	2019-03-07 03:39:26.000000000 +0200
@@ -1611,4 +1611,9 @@
 	help
 	  Enable a Altera UART port to be the system console.
 
+config SERIAL_TC3162
+	bool "TC3162/TC3262 serial port support"
+	select SERIAL_CORE
+	depends on (MIPS_TC3162 || MIPS_TC3162U || MIPS_TC3262)
+
 endmenu
diff -r -I '$Id:' -I '$Header' -I '$Revision' -I printk -I VERSION -I '\*' -x '*.lds' -x '*.order' -x '*.builtin' -x '*.a' -x '*.d' -x '*.o' -x '*.cmd' -x '*usb*' -x .gitignore -u linux-2.6.36/drivers/serial/Makefile tplink-vr300/mtk/linux-2.6.36/drivers/serial/Makefile
--- linux-2.6.36/drivers/serial/Makefile	2010-10-20 23:30:22.000000000 +0300
+++ tplink-vr300/mtk/linux-2.6.36/drivers/serial/Makefile	2019-03-07 03:39:26.000000000 +0200
@@ -88,3 +88,7 @@
 obj-$(CONFIG_SERIAL_ALTERA_UART) += altera_uart.o
 obj-$(CONFIG_SERIAL_MRST_MAX3110)	+= mrst_max3110.o
 obj-$(CONFIG_SERIAL_MFD_HSU)	+= mfd.o
+obj-$(CONFIG_SERIAL_TC3162) += tc3162_uart.o
+ifeq ($(TCSUPPORT_UART2),1)
+obj-y += tc3162_uart2.o
+endif
Only in tplink-vr300/mtk/linux-2.6.36/drivers/serial: tc3162_uart2.c
Only in tplink-vr300/mtk/linux-2.6.36/drivers/serial: tc3162_uart.c
