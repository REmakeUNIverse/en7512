diff --exclude '*~' -ur vr300-linux-orig/arch/mips/include/asm/irqflags.h vr300-linux/arch/mips/include/asm/irqflags.h
--- vr300-linux-orig/arch/mips/include/asm/irqflags.h	2021-12-05 22:52:39.507294472 +0200
+++ vr300-linux/arch/mips/include/asm/irqflags.h	2021-12-06 00:15:04.174747602 +0200
@@ -195,15 +195,11 @@
 	"	.set	pop						\n"
 	"	.endm							\n");
 
-#ifdef TCSUPPORT_XPON_HAL_API_EXT
-extern void resetWatch(void);
-#endif
+
 static inline void raw_local_irq_restore(unsigned long flags)
 {
 	unsigned long __tmp1;
-	#ifdef TCSUPPORT_XPON_HAL_API_EXT
-	resetWatch();
-	#endif
+
 #ifdef CONFIG_MIPS_MT_SMTC
 	/*
 	 * SMTC kernel needs to do a software replay of queued
diff --exclude '*~' -ur vr300-linux-orig/arch/mips/include/asm/processor.h vr300-linux/arch/mips/include/asm/processor.h
--- vr300-linux-orig/arch/mips/include/asm/processor.h	2021-12-05 22:52:39.499294585 +0200
+++ vr300-linux/arch/mips/include/asm/processor.h	2021-12-06 00:16:59.441158020 +0200
@@ -118,15 +118,11 @@
 	dspreg_t        dspr[NUM_DSP_REGS];
 	unsigned int    dspcontrol;
 };
-#ifdef TCSUPPORT_XPON_HAL_API_EXT
-#define INIT_CPUMASK { \
-	{7,} \
-}
-#else
+
 #define INIT_CPUMASK { \
 	{0,} \
 }
-#endif
+
 struct mips3264_watch_reg_state {
 	/* The width of watchlo is 32 in a 32 bit kernel and 64 in a
 	   64 bit kernel.  We use unsigned long as it has the same
diff --exclude '*~' -ur vr300-linux-orig/arch/mips/include/asm/time.h vr300-linux/arch/mips/include/asm/time.h
--- vr300-linux-orig/arch/mips/include/asm/time.h	2021-12-05 22:52:39.507294472 +0200
+++ vr300-linux/arch/mips/include/asm/time.h	2021-12-06 01:02:15.468057203 +0200
@@ -22,14 +22,6 @@
 extern spinlock_t rtc_lock;
 
 /*
- * Timer interrupt functions.
- * mips_timer_state is needed for high precision timer calibration.
- * mips_timer_ack may be NULL if the interrupt is self-recoverable.
- */
-extern void (*board_time_init)(void);
-extern void (*mips_timer_ack)(void);
-
-/*
  * RTC ops.  By default, they point to weak no-op RTC functions.
  *	rtc_mips_set_time - reverse the above translation and set time to RTC.
  *	rtc_mips_set_mmss - similar to rtc_set_time, but only min and sec need
diff --exclude '*~' -ur vr300-linux-orig/arch/mips/kernel/cevt-smtc.c vr300-linux/arch/mips/kernel/cevt-smtc.c
--- vr300-linux-orig/arch/mips/kernel/cevt-smtc.c	2021-12-05 22:52:39.543293963 +0200
+++ vr300-linux/arch/mips/kernel/cevt-smtc.c	2021-12-06 00:49:32.287182876 +0200
@@ -230,20 +230,15 @@
 				goto repeat;
 	}
 }
-#ifdef TCSUPPORT_XPON_HAL_API_EXT
-extern void resetWatchAlways(void);
-#endif
+
+
 irqreturn_t c0_compare_interrupt(int irq, void *dev_id)
 {
 	int cpu = smp_processor_id();
 
-	if (isRT63165 || isRT63365 || isMT751020 || isMT7505 || isEN751221) {				
+	if (isRT63165 || isRT63365 || isMT751020 || isMT7505 || isEN751221) {
 		mips_timer_ack();
 	}
-#ifdef TCSUPPORT_XPON_HAL_API_EXT
-	resetWatchAlways();
-#endif
-
 	/* If we're running SMTC, we've got MIPS MT and therefore MIPS32R2 */
 	handle_perf_irq(1);
 
@@ -252,76 +247,11 @@
 		write_c0_compare(read_c0_compare());
 		smtc_distribute_timer(cpu_data[cpu].vpe_id);
 	}
- 
 	return IRQ_HANDLED;
 }
 
 #ifdef CONFIG_MIPS_TC3262
 unsigned int mips_hpt_frequency_true;
-unsigned long loops_per_jiffy_true = 0;
-extern unsigned long loops_per_jiffy;
-unsigned long udelay_val_true[NR_CPUS];
-static unsigned long cycles_per_jiffy __read_mostly;
-extern struct clocksource clocksource_mips;
-
-int reset_time_value(int time_shift){
-	u64 temp=0;
-	u32 shift=0;
-	int i=0;
-	unsigned int cpu = smp_processor_id();
-		
-#ifdef DBG
-	printk("cycles_per_jiffy %x\n",cycles_per_jiffy);
-	printk("true mips_hpt_frequency  %x shift %d\n",mips_hpt_frequency_true,time_shift);
-#endif	
-	if(loops_per_jiffy_true == 0){
-		//save correct value
-		if(loops_per_jiffy == (1<<12)){
-			printk("init not over\n");	
-			return -1;
-		}else{
-			loops_per_jiffy_true = loops_per_jiffy;
-			for(i=0;i<NR_CPUS;i++){
-				udelay_val_true[i] = cpu_data[i].udelay_val;
-			}
-		}
-	} 
-#ifdef DBG	
-	printk("true loops_per_jiffie  %x loops_per_jiffie %x\n", loops_per_jiffy_true, loops_per_jiffy);
-#endif
-	local_irq_disable();
-	mips_hpt_frequency = (mips_hpt_frequency_true>>(time_shift));
-#ifdef DBG	
-	printk("After mips_hpt_frequency %x \n",mips_hpt_frequency);
-#endif
-	/* Calculate cache parameters.	*/
-	cycles_per_jiffy = (mips_hpt_frequency + HZ / 2) / HZ;
-#ifdef DBG	
-	printk("cycles_per_jiffy %x\n",cycles_per_jiffy);
-#endif	
-	/* Calclate a somewhat reasonable rating value */
-	clocksource_mips.rating = 200 + mips_hpt_frequency / 10000000;
-	clocksource_set_clock(&clocksource_mips, mips_hpt_frequency);
-
-	//about date
-	clocksource_change_rating(&clocksource_mips, clocksource_mips.rating);
-#ifdef DBG	
-	printk("clocksource_mips.rate %x shift %x mult %x cycle_interval null\n",clocksource_mips.rating,clocksource_mips.shift,clocksource_mips.mult/*,clocksource_mips.cycle_interval*/);
-#endif
-	//about delay
-	for(i=0;i<NR_CPUS;i++){
-		cpu_data[i].udelay_val = (udelay_val_true[i] >> (time_shift));
-	}
-	loops_per_jiffy = loops_per_jiffy_true >> (time_shift) ;
-#ifdef DBG	
-	printk("loops_per_jiffy %x\n",loops_per_jiffy);
-#endif
-	
-	local_irq_enable();
-	
-	return 0;
-}
-EXPORT_SYMBOL(reset_time_value);
 #endif
 
 int __cpuinit smtc_clockevent_init(void)
@@ -336,9 +266,9 @@
 	if (!cpu_has_counter || !mips_hpt_frequency)
 		return -ENXIO;
 	cycles_per_jiffy =(mips_hpt_frequency + HZ / 2) / HZ;
-#ifdef CONFIG_MIPS_TC3262 
+#ifdef CONFIG_MIPS_TC3262
 	mips_hpt_frequency_true = mips_hpt_frequency;
-#endif	
+#endif
 	if (cpu == 0) {
 		for (i = 0; i < num_possible_cpus(); i++) {
 			smtc_nextinvpe[i] = 0;
diff --exclude '*~' -ur vr300-linux-orig/arch/mips/kernel/irq.c vr300-linux/arch/mips/kernel/irq.c
--- vr300-linux-orig/arch/mips/kernel/irq.c	2021-12-05 22:52:39.543293963 +0200
+++ vr300-linux/arch/mips/kernel/irq.c	2021-12-05 23:52:32.146028924 +0200
@@ -156,14 +156,13 @@
  * SMP cross-CPU interrupts have their own specific
  * handlers).
  */
-__IMEM void __irq_entry do_IRQ(int irq)//xflu 20120522
+void __irq_entry do_IRQ(unsigned int irq)
 {
 	irq_enter();
 	__DO_IRQ_SMTC_HOOK(irq);
 	generic_handle_irq(irq);
 	irq_exit();
 }
-EXPORT_SYMBOL(do_IRQ);
 
 #ifdef CONFIG_MIPS_MT_SMTC_IRQAFF
 /*
@@ -171,7 +170,7 @@
  * IRQ affinity, we have this variant that skips the affinity check.
  */
 
-__IMEM void __irq_entry do_IRQ_no_affinity(unsigned int irq)
+void __irq_entry do_IRQ_no_affinity(unsigned int irq)
 {
 	irq_enter();
 	__NO_AFFINITY_IRQ_SMTC_HOOK(irq);
diff --exclude '*~' -ur vr300-linux-orig/arch/mips/kernel/time.c vr300-linux/arch/mips/kernel/time.c
--- vr300-linux-orig/arch/mips/kernel/time.c	2021-12-05 22:52:39.543293963 +0200
+++ vr300-linux/arch/mips/kernel/time.c	2021-12-06 01:01:36.476453901 +0200
@@ -116,78 +116,10 @@
 
 	return 0;
 }
-#if 0 //def CONFIG_MIPS_TC3262
-int reset_time_value(int time_shift){
-	u64 temp;
-	u32 shift;
-	int i;
-	unsigned int cpu;
-	
-#ifdef DBG
-	printk("cycles_per_jiffy %x\n",cycles_per_jiffy);
-	printk("true mips_hpt_frequency  %x shift %d\n",mips_hpt_frequency_true,time_shift);
-#endif	
-	if(loops_per_jiffy_true == 0){
-		//save correct value
-		if(loops_per_jiffy == (1<<12)){
-			printk("init not over\n");	
-			return -1;
-		}else{
-			loops_per_jiffy_true = loops_per_jiffy;
-			for(i=0;i<NR_CPUS;i++){
-				udelay_val_true[i] = cpu_data[i].udelay_val;
-			}
-		}
-	} 
-#ifdef DBG	
-	printk("true loops_per_jiffie  %x loops_per_jiffie %x\n", loops_per_jiffy_true, loops_per_jiffy);
-#endif
-	local_irq_disable();
-	mips_hpt_frequency = (mips_hpt_frequency_true>>(time_shift));
-#ifdef DBG	
-	printk("After mips_hpt_frequency %x \n",mips_hpt_frequency);
-#endif
-	/* Calculate cache parameters.  */
-	cycles_per_jiffy = (mips_hpt_frequency + HZ / 2) / HZ;
-#ifdef DBG	
-	printk("cycles_per_jiffy %x\n",cycles_per_jiffy);
-#endif	
-	/* Calclate a somewhat reasonable rating value */
-	clocksource_mips.rating = 200 + mips_hpt_frequency / 10000000;	
-	/* Find a shift value */
-	for (shift = 32; shift > 0; shift--) {
-		temp = (u64) NSEC_PER_SEC << shift;
-		do_div(temp, mips_hpt_frequency);
-		if ((temp >> 32) == 0)
-			break;
-	}
-	clocksource_mips.shift = shift;
-	clocksource_mips.mult = (u32)temp;
-	//about date
-	clocksource_calculate_interval(&clocksource_mips, NTP_INTERVAL_LENGTH);
-	clocksource_change_rating(&clocksource_mips, clocksource_mips.rating);
-#ifdef DBG	
-	printk("clocksource_mips.rate %x shift %x mult %x cycle_interval %x\n",clocksource_mips.rating,clocksource_mips.shift,clocksource_mips.mult,clocksource_mips.cycle_interval);
-#endif
-	//about delay
-	for(i=0;i<NR_CPUS;i++){
-		cpu_data[i].udelay_val = (udelay_val_true[i] >> (time_shift));
-	}
-	loops_per_jiffy = loops_per_jiffy_true >> (time_shift) ;
-
-	local_irq_enable();
-
-	return 0;
-}
-EXPORT_SYMBOL(reset_time_value);
-#endif
 
 void (*board_time_init)(void);
 void __init time_init(void)
 {
-	if(board_time_init)
-		board_time_init();
-
 	plat_time_init();
 
 	if (!mips_clockevent_init() || !cpu_has_mfc0_count_bug())
