--- vr300-linux/arch/mips/kernel/traps.c	2021-12-06 11:55:45.033880616 +0200
+++ linux-2.6.36/arch/mips/kernel/traps.c	2010-10-20 23:30:22.000000000 +0300
@@ -53,9 +53,6 @@
 #include <asm/stacktrace.h>
 #include <asm/irq.h>
 #include <asm/uasm.h>
-#ifdef TCSUPPORT_XPON_HAL_API_EXT
-#include <linux/kallsyms.h>
-#endif
 
 extern void check_wait(void);
 extern asmlinkage void r4k_wait(void);
@@ -116,76 +113,6 @@
 	printk("\n");
 }
 
-#define NMI_STACK_LEN	80
-#define NMI_STACK_MAGIC_NUM	0x5abc2312
-
-
-void show_raw_backtrace_nmi(unsigned long sp_start, unsigned long stack_len)
-{
-	unsigned long *sp = (unsigned long *)(sp_start & ~3);
-	unsigned long addr, i = 0;
-
-	printk("Call Trace NMI:");
-#ifdef CONFIG_KALLSYMS
-	printk("\n");
-#endif
-	while (i < stack_len) {
-		unsigned long __user *p =
-			(unsigned long __user *)(unsigned long)sp++;
-		if (__get_user(addr, p)) {
-			printk(" (Bad stack address)");
-			break;
-		}
-		if (__kernel_text_address(addr))
-			print_ip_sym(addr);
-
-		i++;
-	}
-	printk("\n");
-}
-
-void show_stack_nmi()
-{
-	unsigned int dspram_addr = dspram_base_addr();
-	int i, dspram_data_len=NMI_STACK_LEN;
-	unsigned int *p = (unsigned int *)dspram_addr;
-
-	printk("dspram_addr=0x%x\n", dspram_addr);
-
-	if(*p != NMI_STACK_MAGIC_NUM){
-		printk("No NMI Happen!\n");
-		return;
-	}
-	
-	p++;
-	printk("epc   : %08lx %pS\n", *p,
-	       (void *) (*p));
-	p++;
-	printk("ra    : %08lx %pS\n",*p,
-	       (void *) (*p));
-
-	p++;
-	printk("Status: %08x    ", (uint32_t) (*p));
-	p++;
-	printk("Cause : %08x\n", (*p));
-
-	p++;
-
-	while(dspram_data_len){
-		if(dspram_data_len % 8 == 0)
-			printk("\n       ");
-		printk(" %08lx", *p);
-
-		p++;
-		dspram_data_len--;
-	}
-	printk("\n       ");
-
-	show_raw_backtrace_nmi(dspram_base_addr(),NMI_STACK_LEN);
-	
-	
-}
-
 #ifdef CONFIG_KALLSYMS
 int raw_show_trace;
 static int __init set_raw_show_trace(char *str)
@@ -248,36 +175,6 @@
 	show_backtrace(task, regs);
 }
 
-static void show_stacktrace_nmi(struct task_struct *task,
-	const struct pt_regs *regs)
-{
-	const int field = 2 * sizeof(unsigned long);
-	long stackdata;
-	int i;
-	unsigned long __user *sp = (unsigned long __user *)regs->regs[29];
-
-	printk("Stack :");
-	i = 0;
-	while ((unsigned long) sp & (PAGE_SIZE - 1)) {
-		if (i && ((i % (64 / field)) == 0))
-			printk("\n       ");
-		if (i > NMI_STACK_LEN-1) {
-			printk(" ...");
-			break;
-		}
-
-		if (__get_user(stackdata, sp++)) {
-			printk(" (Bad stack address)");
-			break;
-		}
-
-		printk(" %0*lx", field, stackdata);
-		i++;
-	}
-	printk("\n");
-	//show_backtrace(task, regs);
-}
-
 void show_stack(struct task_struct *task, unsigned long *sp)
 {
 	struct pt_regs regs;
@@ -430,105 +327,6 @@
 	       cpu_name_string());
 }
 
-static void __show_regs_nmi(const struct pt_regs *regs)
-{
-	const int field = 2 * sizeof(unsigned long);
-	unsigned int cause = regs->cp0_cause;
-	int i;
-
-	printk("Cpu %d\n", smp_processor_id());
-
-	/*
-	 * Saved main processor registers
-	 */
-	for (i = 0; i < 32; ) {
-		if ((i % 4) == 0)
-			printk("$%2d   :", i);
-		if (i == 0)
-			printk(" %0*lx", field, 0UL);
-		else if (i == 26 || i == 27)
-			printk(" %*s", field, "");
-		else
-			printk(" %0*lx", field, regs->regs[i]);
-
-		i++;
-		if ((i % 4) == 0)
-			printk("\n");
-	}
-
-#ifdef CONFIG_CPU_HAS_SMARTMIPS
-	printk("Acx    : %0*lx\n", field, regs->acx);
-#endif
-	printk("Hi    : %0*lx\n", field, regs->hi);
-	printk("Lo    : %0*lx\n", field, regs->lo);
-
-	/*
-	 * Saved cp0 registers
-	 */
-	//printk("epc   : %0*lx %pS\n", field, regs->cp0_epc,
-	//       (void *) regs->cp0_epc);
-	printk("epc   : %0*lx\n", field, regs->cp0_epc);
-	printk("    %s\n", print_tainted());
-	//printk("ra    : %0*lx %pS\n", field, regs->regs[31],
-	//       (void *) regs->regs[31]);
-	printk("ra    : %0*lx\n", field, regs->regs[31]);
-
-	printk("Status: %08x    ", (uint32_t) regs->cp0_status);
-
-	if (current_cpu_data.isa_level == MIPS_CPU_ISA_I) {
-		if (regs->cp0_status & ST0_KUO)
-			printk("KUo ");
-		if (regs->cp0_status & ST0_IEO)
-			printk("IEo ");
-		if (regs->cp0_status & ST0_KUP)
-			printk("KUp ");
-		if (regs->cp0_status & ST0_IEP)
-			printk("IEp ");
-		if (regs->cp0_status & ST0_KUC)
-			printk("KUc ");
-		if (regs->cp0_status & ST0_IEC)
-			printk("IEc ");
-	} else {
-		if (regs->cp0_status & ST0_KX)
-			printk("KX ");
-		if (regs->cp0_status & ST0_SX)
-			printk("SX ");
-		if (regs->cp0_status & ST0_UX)
-			printk("UX ");
-		switch (regs->cp0_status & ST0_KSU) {
-		case KSU_USER:
-			printk("USER ");
-			break;
-		case KSU_SUPERVISOR:
-			printk("SUPERVISOR ");
-			break;
-		case KSU_KERNEL:
-			printk("KERNEL ");
-			break;
-		default:
-			printk("BAD_MODE ");
-			break;
-		}
-		if (regs->cp0_status & ST0_ERL)
-			printk("ERL ");
-		if (regs->cp0_status & ST0_EXL)
-			printk("EXL ");
-		if (regs->cp0_status & ST0_IE)
-			printk("IE ");
-	}
-	printk("\n");
-
-	printk("Cause : %08x\n", cause);
-
-	cause = (cause & CAUSEF_EXCCODE) >> CAUSEB_EXCCODE;
-	if (1 <= cause && cause <= 5)
-		printk("BadVA : %0*lx\n", field, regs->cp0_badvaddr);
-
-	printk("PrId  : %08x (%s)\n", read_c0_prid(),
-	       cpu_name_string());
-}
-
-
 /*
  * FIXME: really the generic show_regs should take a const pointer argument.
  */
@@ -559,29 +357,6 @@
 	printk("\n");
 }
 
-void show_registers_nmi(struct pt_regs *regs)
-{
-	const int field = 2 * sizeof(unsigned long);
-
-	__show_regs_nmi(regs);
-	//print_modules();
-	printk("Process %s (pid: %d, threadinfo=%p, task=%p, tls=%0*lx)\n",
-	       current->comm, current->pid, current_thread_info(), current,
-	      field, current_thread_info()->tp_value);
-	if (cpu_has_userlocal) {
-		unsigned long tls;
-
-		tls = read_c0_userlocal();
-		if (tls != current_thread_info()->tp_value)
-			printk("*HwTLS: %0*lx\n", field, tls);
-	}
-
-	show_stacktrace_nmi(current, regs);
-	//show_code((unsigned int __user *) regs->cp0_epc);
-	printk("\n");
-}
-
-
 static int regs_to_trapnr(struct pt_regs *regs)
 {
 	return (regs->cp0_cause >> 2) & 0x1f;
@@ -626,84 +401,6 @@
 	do_exit(sig);
 }
 
-void nmi_info_store( struct pt_regs *regs)
-{
-	const int field = 2 * sizeof(unsigned long);
-	unsigned int cause = regs->cp0_cause;
-	long stackdata;
-	int i;
-	unsigned long __user *sp = (unsigned long __user *)regs->regs[29];
-	
-	/*Store Magic Number*/
-	write_to_dspram(NMI_STACK_MAGIC_NUM);
-
-	/*Store register value*/
-	write_to_dspram(regs->cp0_epc);
-	write_to_dspram(regs->regs[31]); //ra
-	write_to_dspram((uint32_t) regs->cp0_status);
-	write_to_dspram(cause);
-	
-	/*Store stack data*/
-	i = 0;
-	while ((unsigned long) sp & (PAGE_SIZE - 1)) {
-		if (i > NMI_STACK_LEN-1) {
-			break;
-		}
-
-		if (__get_user(stackdata, sp++)) {
-			//printk(" (Bad stack address)");
-			break;
-		}
-
-		//printk(" %0*lx", field, stackdata);
-		write_to_dspram(stackdata);
-		i++;
-	}
-}
-
-void __noreturn die_nmi(const char *str, struct pt_regs *regs)
-{
-	static int die_counter;
-	int sig = SIGSEGV;
-#ifdef CONFIG_MIPS_MT_SMTC
-	unsigned long dvpret = dvpe();
-#endif /* CONFIG_MIPS_MT_SMTC */
-
-	notify_die(DIE_OOPS, str, regs, 0, regs_to_trapnr(regs), SIGSEGV);
-
-	console_verbose();
-	spin_lock_irq(&die_lock);
-	bust_spinlocks(1);
-#ifdef CONFIG_MIPS_MT_SMTC
-	mips_mt_regdump_nmi(dvpret);
-#endif /* CONFIG_MIPS_MT_SMTC */
-	
-
-	if (notify_die(DIE_OOPS, str, regs, 0, regs_to_trapnr(regs), SIGSEGV) == NOTIFY_STOP)
-		sig = 0;
-
-	printk("%s[#%d]:\n", str, ++die_counter);
-	show_registers_nmi(regs);
-
-	while(1); //waiting for watchdog reboot
-	#if 0
-	add_taint(TAINT_DIE);
-	spin_unlock_irq(&die_lock);
-
-	if (in_interrupt())
-		panic("Fatal exception in interrupt");
-
-	if (panic_on_oops) {
-		printk(KERN_EMERG "Fatal exception: panic in 5 seconds\n");
-		ssleep(5);
-		panic("Fatal exception");
-	}
-
-	do_exit(sig);
-	#endif
-}
-
-
 extern struct exception_table_entry __start___dbe_table[];
 extern struct exception_table_entry __stop___dbe_table[];
 
@@ -1316,152 +1013,6 @@
 /*
  * Called with interrupts disabled.
  */
-int watchFlag=0;
-EXPORT_SYMBOL(watchFlag);
-#ifdef TCSUPPORT_XPON_HAL_API_EXT
-volatile int watchOccured = 0;
-volatile int watchLo2Val = 0;
-u32 kmem_cache_alloc_addr = 0;
-u32 kmem_cache_free_addr = 0;
-u32 __slab_alloc_addr = 0;
-u32 __slab_alloc_addr2 = 0;
-u32 deactivate_slab_addr = 0;
-u32 kfree_addr = 0;
-
-void resetWatch(void)
-{
-	if(watchOccured)
-	{
-		u32 val_Hi;
-		u32 val_Lo;
-		u32 *ptr;
-
-		val_Hi = read_c0_watchhi2();
-
-		val_Hi = 0x4000000b;
-		write_c0_watchhi2(val_Hi);
-		write_c0_watchlo2(watchLo2Val);
-		//printk("Reset WATCH exception: write val_Lo %08x val_Hi %08x\r\n", val_Lo, val_Hi);
-
-
-		val_Hi = read_c0_watchhi2();
-		val_Lo = read_c0_watchlo2();
-			
-		//printk("Caught WATCH exception: reread val_Lo %08x val_Hi %08x\r\n", val_Lo, val_Hi);
-		ptr = watchLo2Val & 0xFFFFFFF8;
-		
-		watchOccured = 0;
-		//prom_printf("resetWatch: Caught WATCH exception: resetWatch val_Lo %08x val_Hi %08x ptr %08x, val is %08x\\r\n", 
-		//			val_Lo, val_Hi, ptr, *ptr);
-
-	}
-}
-EXPORT_SYMBOL(resetWatch);
-
-void resetWatchAlways(void)
-{
-	if(watchFlag) {
-	u32 val_Lo;
-	val_Lo = read_c0_watchlo2();
-	if(watchLo2Val && ((val_Lo & 0x7) == 0))
-	{
-		prom_printf("Reset Watch: watchLo2Val %08x\r\n", watchLo2Val);
-		write_c0_watchhi2(0x4000000b);
-		write_c0_watchlo2(watchLo2Val);
-	}
-	}
-}
-
-
-void checkWatch(struct pt_regs *regs)
-{
-	u32 val_Hi;
-	u32 val_Lo;
-	u32 *ptr;
-	u32 findsymbol = 0;
-
-	//val_Hi = read_c0_watchhi2();
-	val_Lo = read_c0_watchlo2();
-
-	watchLo2Val = val_Lo;
-	//ptr = val_Lo & 0xFFFFFFF8;
-
-	//printk("\r\nCaught WATCH exception: val_Lo %08x val_Hi %08x ptr %08x, val is %08x\r\n", val_Lo, val_Hi, ptr, *ptr);
-	if((kmem_cache_alloc_addr != 0) && (regs->cp0_epc == kmem_cache_alloc_addr))
-	{
-		findsymbol = 1;
-	}
-
-	if((kmem_cache_free_addr != 0) && (regs->cp0_epc == kmem_cache_free_addr))
-	{
-		findsymbol = 1;
-	}
-
-	if((__slab_alloc_addr != 0) && (regs->cp0_epc == __slab_alloc_addr))
-	{
-		findsymbol = 1;
-	}
-
-	if((__slab_alloc_addr2 != 0) && (regs->cp0_epc == __slab_alloc_addr2))
-	{
-		findsymbol = 1;
-	}
-	
-	if((deactivate_slab_addr != 0) && (regs->cp0_epc == deactivate_slab_addr))
-	{
-		findsymbol = 1;
-	}
-
-	if((kfree_addr != 0) && (regs->cp0_epc == kfree_addr))
-	{
-		findsymbol = 1;
-	}
-
-	if(findsymbol == 0)
-	{
-		char buffer[KSYM_SYMBOL_LEN] = {0};
-		memset(buffer, 0, KSYM_SYMBOL_LEN);
-		sprint_symbol(buffer, regs->cp0_epc);
-		printk("epc %08x, func %s\r\n", regs->cp0_epc, buffer);
-		if((kmem_cache_alloc_addr == 0) && strstr(buffer, "kmem_cache_alloc+"))
-		{
-			kmem_cache_alloc_addr = regs->cp0_epc;
-			printk("kmem_cache_alloc_addr is %08x\r\n", kmem_cache_alloc_addr);
-		}
-		else if((kmem_cache_free_addr == 0) && strstr(buffer, "kmem_cache_free+"))
-		{
-			kmem_cache_free_addr = regs->cp0_epc;
-			printk("kmem_cache_free_addr is %08x\r\n", kmem_cache_free_addr);
-		}
-		else if((__slab_alloc_addr == 0) && strstr(buffer, "__slab_alloc+"))
-		{
-			__slab_alloc_addr = regs->cp0_epc;
-			printk("__slab_alloc_addr is %08x\r\n", __slab_alloc_addr);
-		}
-		else if((__slab_alloc_addr2 == 0) && strstr(buffer, "__slab_alloc+"))
-		{
-			__slab_alloc_addr2 = regs->cp0_epc;
-			printk("__slab_alloc_addr2 is %08x\r\n", __slab_alloc_addr2);
-		}
-		else if((deactivate_slab_addr == 0) && strstr(buffer, "deactivate_slab+"))
-		{
-			deactivate_slab_addr = regs->cp0_epc;
-			printk("deactivate_slab_addr is %08x\r\n", deactivate_slab_addr);
-		}
-		else if((kfree_addr == 0) && strstr(buffer, "kfree+"))
-		{
-			kfree_addr = regs->cp0_epc;
-			printk("kfree_addr is %08x\r\n", kfree_addr);
-		}
-		else
-		{
-			show_registers(regs);
-		}
-
-	}
-
-}
-#endif
 asmlinkage void do_watch(struct pt_regs *regs)
 {
 	u32 cause;
@@ -1470,25 +1021,10 @@
 	 * Clear WP (bit 22) bit of cause register so we don't loop
 	 * forever.
 	 */
-	 #ifdef TCSUPPORT_XPON_HAL_API_EXT
-	 if(0){
-	 #else
-	 if(watchFlag){
-	 #endif
-	 dump_tlb_all();
-	 show_registers(regs);	 	 
-	 //show_regs(regs);
-	//compute_return_epc(regs);
-	panic("Caught WATCH exception - probably caused by stack overflow\n");
-		return;
-	}
-	else{
 	cause = read_c0_cause();
 	cause &= ~(1 << 22);
 	write_c0_cause(cause);
-	#ifdef TCSUPPORT_XPON_HAL_API_EXT
-		checkWatch(regs);
-	#endif
+
 	/*
 	 * If the current thread has the watch registers loaded, save
 	 * their values and send SIGTRAP.  Otherwise another thread
@@ -1502,10 +1038,6 @@
 		mips_clear_watch_registers();
 		local_irq_enable();
 	}
-	#ifdef TCSUPPORT_XPON_HAL_API_EXT
-		watchOccured = 1;
-	#endif
-	}
 }
 
 asmlinkage void do_mcheck(struct pt_regs *regs)
@@ -1768,10 +1300,8 @@
 NORET_TYPE void ATTRIB_NORET nmi_exception_handler(struct pt_regs *regs)
 {
 	bust_spinlocks(1);
-	nmi_info_store(regs);
 	printk("NMI taken!!!!\n");
-	//die("NMI", regs);
-	die_nmi("NMI", regs);
+	die("NMI", regs);
 }
 
 #define VECTORSPACING 0x100	/* for EI/VI mode */
@@ -1874,15 +1404,10 @@
 
 		memcpy(b, vec_start, handler_len);
 #ifdef CONFIG_MIPS_MT_SMTC
-		if (!cpu_has_veic) 
 		BUG_ON(n > 7);	/* Vector index %d exceeds SMTC maximum. */
 
 		w = (u32 *)(b + mori_offset);
-#ifdef CONFIG_MIPS_TC3262
-		*w = (*w & 0xffff0000) | (n);
-#else
 		*w = (*w & 0xffff0000) | (0x100 << n);
-#endif
 #endif /* CONFIG_MIPS_MT_SMTC */
 		w = (u32 *)(b + lui_offset);
 		*w = (*w & 0xffff0000) | (((u32)handler >> 16) & 0xffff);
@@ -1912,7 +1437,6 @@
 {
 	return set_vi_srs_handler(n, addr, 0);
 }
-EXPORT_SYMBOL(set_vi_handler);
 
 extern void cpu_cache_init(void);
 extern void tlb_init(void);
